<%!
/*
* 
* This source-code is licensed under GPL v2.
* See ../../LICENSE for details
* 
* Originally written for http://vdr-m7x0.foroactivo.com.es by:
* atinar <atinar1@hotmail.com>
* 
* You will need the KLONE web application development framework
* from www.koanlogic.com Version 2.
* 
*/

#include <errno.h>
#include <fcntl.h>
#include <klone/utils.h>
#include <signal.h>
#include <stdio.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>

#include "recording.h"
#include "recordings.h"

#ifdef DEBUG
static void dbg_streamrec_kl1(void) { 
	dbg("streamrec.kl1");
}
#endif

%><%

#ifdef DEBUG
	dbg_streamrec_kl1();
#endif
	wcontext_t vwctx;
	wcontext_t *wctx=&vwctx;
	if (initCtx(wctx,PN_STREAM_REC,session,request,response,out,1024)){
		vars_t *args = request_get_args(request);
		//wctx->currentAction=(vars_countn(args,"a")>0) ? vars_get_value_i(args,"a") : PA_PLAY;
		//TODO int hostId=(vars_countn(args, "hostId")>0)?vars_get_value_i(args,"hostId"):0;
		if (vars_countn(args, "path")==0){
			warn("No hay ruta");
			returnHttpNoContent(response);
		} else {
			uint64_t range_start=0;
			uint64_t range_end=0;
			bool use_range=false;

			readWebifConf();
			fragmentList_t fragments;
			initFL(&fragments);
			{
				bool isACopy;
				char *path=wctxGetRequestParam(wctx,args,"path",&isACopy);
				getFragmentList(&fragments,path);
				//dbg("length[%d],fragNum[%d],totalSize[%lld]",fragments.length,fragments.fragNum,fragments.totalSize);
				if (isACopy) free(path);
			}
			if (fragments.length>0 && fragments.totalSize>0) {
				field_t * range = request_get_field(request,"Range");
				if (range){
					dbg("Rango solicitado \"%s\"",range->value);
					if (strncmp(range->value,"bytes=",6)==0){
						char *r = range->value+6;
						use_range=true;
						errno=0;
						range_start=(uint64_t)strtoll(r,&r,10);
						if (errno || range_start>fragments.totalSize){
							warn("Invalid range start %s, range_start=%lld, total_size=%lld, errno=%d",r,range_start,fragments.totalSize,errno);
							use_range=false;
						}
						else {
							r+=strspn(r,"- ");
							if (strlen(r)>0) {
								errno=0;
								range_end=(uint64_t)strtoll((const char *)r,&r,10);
								if (errno){
									warn("Invalid range end %s, range_end=%lld, total_size=%lld, errno=%d",r,range_end,fragments.totalSize,errno);
									range_end=0;
								}
							}
						}
					}
					else {
						warn("Invalid range %s",range->value);
						use_range=0;
					}
				}
				//debugFragmentList("streamrec.kl1",&fragments);
				if (!seekFragment(&fragments,range_start)){
					warn("No fragment found for range_start=%lld",range_start);
					returnHttpNoContent(response);
				} else {
					response_set_field(response, "Accept-Ranges", "bytes");
					if (use_range){
						if (!range_end){
							range_end=fragments.totalSize-1;
						}
						response_set_status(response,HTTP_PARTIAL_CONTENT); //=206 requires klone-core patched
						char *content_range;		
						if (asprintf(&content_range,"bytes %lld-%lld/%lld",range_start,range_end,fragments.totalSize)!=-1) {
							response_set_field(response, "Content-Range", content_range);
							free(content_range);
						}
					}
					else {
						response_set_status(response,HTTP_STATUS_OK);
						range_end=fragments.totalSize-1;
					}
					uint64_t remaining=(range_end-range_start+1);
					response_set_content_length(response,remaining);
					response_set_content_type(response,"video/mpeg");

					io_codecs_remove(response_io(rs)); //avoids extra buffering
					response_print_header(response);
					io_flush(out); //TODO ¿necesario?
					
					// Start of streaming

					// catch SIGPIPE signals
					struct sigaction sa;
					struct sigaction oldsa;
					sa.sa_handler=SIG_IGN;		
					sigemptyset(&sa.sa_mask);
					sigaction(SIGPIPE,&sa,&oldsa);

					bool cancel=false;
					int len,br,bw;
					enum { BUFSZ = 4096 };
					char buffer[BUFSZ];
					while (fragments.fragNum<fragments.length && remaining>0 && !cancel){
						fragmentEntry_t *f=&fragments.entry[fragments.fragNum];
						if (f->path!=NULL && f->size>0){
							FILE *fi = fopen(f->path,"rb");
							if (fi) {
								errno=0;
								if (fseek(fi,fragments.fragPos,SEEK_SET)!=0) {
									warn("Wrong position %lld in fragment[&d].Error:%d",fragments.fragPos,fragments.fragNum,errno);
								}
								while(remaining>0 && !cancel && !feof(fi) && !ferror(fi)) {
									len=(remaining>BUFSZ)?BUFSZ:(int)remaining;
									br=fread(buffer,1,len,fi);
									while (br>0 && !cancel) {
										bw=io_write(out,buffer,br);
										if (bw<0) {
											cancel=true;
#ifdef DEBUG
											dbg("socket cerrado. br[%d] bw[%d]",br,bw);
											{	
												// volcar paquete rechazado
												// aparentemente VLC interpreta secuencia de 0 como EOF
												io_t *dump=NULL;
												dbg_ifb(u_file_open("/var/tmp/streamrecdump", O_CREAT | O_TRUNC | O_WRONLY, &dump)){
													dbg_if(io_write(dump, (const char*)buffer, br)<0);
												}
												io_free(dump);
											}
#endif
										} else {
											br-=bw;
											remaining-=bw;
										}
									}
								}
								if (errno) {
									if (errno!=ECONNRESET) warn("%d %s",errno,strerror(errno));
									errno=0;
								}
								fclose(fi);
							}
						}
						fragments.fragNum++;
						fragments.fragPos=0;
					}

					// End of streaming 

					sigaction(SIGPIPE,&oldsa,NULL);
				}
			} else {
				returnHttpNoContent(response);
			}
			freeFL(&fragments);
		}
	}
	freeCtx(wctx);
%>
