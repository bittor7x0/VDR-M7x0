<%!
/*
* 
* This source-code is licensed under GPL v2.
* See ../../LICENSE for details
* 
* Originally written for http://vdr-m7x0.foroactivo.com.es by:
* atinar <atinar1@hotmail.com>
* 
* You will need the KLONE web application development framework
* from www.koanlogic.com Version 2.
* 
*/

#include <errno.h>
#include <fcntl.h>
#include <klone/utils.h>
#include <signal.h>
#include <stdio.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>

#include "recording.h"
#include "recordings.h"

#ifdef DEBUG
static void dbg_streamrec_kl1(void) { 
	dbg("streamrec.kl1");
}
#endif

%><%

#ifdef DEBUG
	dbg_streamrec_kl1();
#endif
	wcontext_t vwctx;
	wcontext_t *wctx=&vwctx;
	if (initCtx(wctx,PN_STREAM_REC,session,request,response,out,1024)){
		vars_t *args = request_get_args(request);
		rec_t rec;
		initRecFromArgs(wctx,&rec,args);
		if (!rec.path){
			warn("Invalid parameters");
			returnHttpNoContent(response);
		} else {
			uint64_t range_start=0;
			uint64_t range_end=0;
			bool use_range=false;

			readWebifConf();
			fragmentList_t list;
			if (!getFragmentList(&list,&rec)) {
				returnHttpNoContent(response);
			} else {
				field_t * range = request_get_field(request,"Range");
				if (range){
					dbg("Rango solicitado \"%s\"",range->value);
					if (strncmp(range->value,"bytes=",6)==0){
						char *r = range->value+6;
						use_range=true;
						errno=0;
						range_start=(uint64_t)strtoll(r,&r,10);
						if (errno || range_start>list.totalSize){
							warn("Invalid range start %s, range_start=%lld, total_size=%lld, errno=%d",r,range_start,list.totalSize,errno);
							use_range=false;
						}
						else {
							r+=strspn(r,"- ");
							if (strlen(r)>0) {
								errno=0;
								range_end=(uint64_t)strtoll((const char *)r,&r,10);
								if (errno){
									warn("Invalid range end %s, range_end=%lld, total_size=%lld, errno=%d",r,range_end,list.totalSize,errno);
									range_end=0;
								}
							}
						}
					}
					else {
						warn("Invalid range %s",range->value);
						use_range=0;
					}
				}
				if (!seekFragment(&list,range_start)){
					warn("No fragment found for range_start=%lld",range_start);
					returnHttpNoContent(response);
				} else {
					response_set_field(response, "Accept-Ranges", "bytes");
					if (use_range){
						if (!range_end){
							range_end=list.totalSize-1;
						}
						response_set_status(response,HTTP_PARTIAL_CONTENT); //=206 requires klone-core patched
						char *content_range;		
						if (asprintf(&content_range,"bytes %lld-%lld/%lld",range_start,range_end,list.totalSize)!=-1) {
							response_set_field(response, "Content-Range", content_range);
							free(content_range);
						}
					}
					else {
						response_set_status(response,HTTP_STATUS_OK);
						range_end=list.totalSize-1;
					}
					uint64_t remaining=(range_end-range_start+1);
					response_set_content_length(response,remaining);
					response_set_content_type(response,"video/mpeg");

					io_codecs_remove(response_io(rs)); //avoids extra buffering
					response_print_header(response);
					io_flush(out); //TODO ¿necesario?
					
					// Start of streaming

					// catch SIGPIPE signals
					struct sigaction sa;
					struct sigaction oldsa;
					sa.sa_handler=SIG_IGN;		
					sigemptyset(&sa.sa_mask);
					sigaction(SIGPIPE,&sa,&oldsa);

					bool cancel=false;
					int len,br,bw;
					enum { BUFSZ = 4096 };
					char buffer[BUFSZ];
					while (list.fragNum<list.length && remaining>0 && !cancel){
						fragmentEntry_t *f=&list.entry[list.fragNum];
						if (f->path!=NULL && f->size>0){
							FILE *fi = fopen(f->path,"rb");
							if (fi) {
								errno=0;
								if (fseek(fi,list.fragPos,SEEK_SET)!=0) {
									warn("Wrong position %lld in fragment[&d].Error:%d",list.fragPos,list.fragNum,errno);
								}
								while(remaining>0 && !cancel && !feof(fi) && !ferror(fi)) {
									len=(remaining>BUFSZ)?BUFSZ:(int)remaining;
									br=fread(buffer,1,len,fi);
									if (br>0) {
										bw=io_write(out,buffer,br);
										if (bw<0) {
											info("socket cerrado");
											cancel=true;
										}
										else {
											remaining-=bw;
										}
									}
								}
								if (errno) {
									if (errno!=ECONNRESET) warn("%d %s",errno,strerror(errno));
									errno=0;
								}
								fclose(fi);
							}
						}
						list.fragNum++;
						list.fragPos=0;
					}

					// End of streaming 

					sigaction(SIGPIPE,&oldsa,NULL);
				}
			}
			freeFL(&list);
		}
		freeRec(&rec);
	}
	freeCtx(wctx);
%>
