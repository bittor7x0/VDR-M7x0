<%!
/*
* 
* This source-code is licensed under GPL v2.
* See ../../LICENSE for details
* 
* Originally written for http://vdr-m7x0.foroactivo.com.es by:
* atinar <atinar1@hotmail.com>
* 
* You will need the KLONE web application development framework
* from www.koanlogic.com Version 2.
* 
*/

#include <fcntl.h>
#include <klapp_conf.h>
#include <time.h>
#include <sys/types.h>
#include <sys/stat.h>

#include "i18n.h"
#include "misc.h"
#include "conf.h"

#ifdef DEBUG
void dbg_commands_kl1(){ dbg("commands.kl1"); }
#endif

static void printHtmlHeadExtra(wcontext_t *wctx){
	if (wctx->currentAction==PA_COMMANDS_SHOW){
		wctx_printf0(wctx,"<link rel=\"stylesheet\" type=\"text/css\" href=\"%s/css/commands.css\" media=\"screen\" />\n",webifConf.www);
		wctx_printf0(wctx,"<script type=\"text/javascript\" src=\"%s/js/commands.js\"></script>\n",webifConf.www);
		wctx_printfn(wctx,"<script type=\"text/javascript\">\n",0,1);
		wctx_printf0(wctx,"$(function(){webif.commandsPageInit();});\n");
		wctx_printfn(wctx,"$.extend(webif.messages,{\n",0,1);
		wctx_printf0(wctx,"commandConfirm:'%s',\n",tr("command.execute.confirm"));
		wctx_printfn(wctx,"});\n",-1,0);
		wctx_printfn(wctx,"$.extend(webif.actions,{\n",0,1);
		wctx_printf0(wctx,"getRecInfo:%d,\n",PA_GET_REC_INFO);
		wctx_printfn(wctx,"});\n",-1,0);
		wctx_printfn(wctx,"</script>\n",-1,0);
	}
}

static int cgi_set_blocking(int fd){
	int flags;
	warn_err_sif((flags = fcntl(fd, F_GETFL)) < 0);
	nop_err_if(fcntl(fd, F_SETFL, flags & (~O_NONBLOCK)) < 0);
	return 0;
err:
	return ~0;
}


//adapted from cgi_sup.c:
static void command_exec(wcontext_t *wctx,const char *command){
	enum {RD_END,WR_END};
	int ipc[2] = { -1, -1 };
	pid_t pid;

	response_disable_caching(wctx->response);
	io_codecs_remove(response_io(wctx->response));
	crit_err_if(pipe(ipc) < 0);
	crit_err_if((pid = fork()) < 0);
	if (pid==0) { 	/* child */
		close(ipc[RD_END]);
		crit_err_if(dup2(ipc[WR_END], STDOUT_FILENO) < 0);
		//crit_err_if(dup2(ipc[WR_END], STDERR_FILENO) < 0);
		info("comando: [%s]",command);
		cgi_set_blocking(STDOUT_FILENO);
		crit_err_sif(execl("/bin/sh","/bin/sh","-c", command, (char*)NULL));
	} else if(pid > 0) {	/* parent */
		int status;
		int cont;
		enum {BUFSZ=256};
		char buffer[BUFSZ];

		// establecer un sighandler para poder matar el proceso hijo si el cliente web cierra la conexion
		struct sigaction sa;
		struct sigaction oldsa;
		sa.sa_handler=SIG_IGN;
		sigfillset(&sa.sa_mask);
		sigaction(SIGPIPE,&sa,&oldsa);
		info("sigpipe handler establecido");

		close(ipc[WR_END]);
		bool cancel=false;
		while(!cancel && (cont=read(ipc[RD_END],buffer,BUFSZ))>0){
			if(wctx_printf(wctx,"%s",CTX_HTML_ENCODE(buffer,cont))!=0){
				cancel=true;
				break;
			}
			if(io_flush(wctx->out)!=0){
				cancel=true;
				break;
			}
		}
		if (cancel) { 
			//el cliente web ha cerrado el socket
			//tenemos que indicar al proceso hijo que termine
			info("Enviando SIGTERM a pid[%d]",pid);
			kill(pid,SIGTERM);
		}
		waitpid(pid, &status, 0);
		if(WIFEXITED(status) && WEXITSTATUS(status)){
			warn("proceso hijo terminado con estado [%d]", WEXITSTATUS(status));
		}

		// restore SIGPIPE handler
		sigaction(SIGPIPE,&oldsa,NULL);
		info("sigpipe handler restaurado");
	} else {
		warn_err("fork error");
	}
err:
	if(pid == 0){ /*child*/
		_exit(1);
	}
	if(ipc[0] != -1) close(ipc[0]);
	if(ipc[1] != -1) close(ipc[1]);
}

%><%
	#ifdef DEBUG
	dbg_commands_kl1();
	#endif

	wcontext_t vwctx;
	wcontext_t *wctx=&vwctx;
	if (initCtx(wctx,PN_COMMANDS,session,request,response,out,1024)){
		vars_t *args = request_get_args(request);
		wctx->currentAction=(vars_countn(args,"a")>0)?vars_get_value_i(args,"a"):PA_COMMANDS_SHOW;
		const int argCommandNum=vars_get_value_i(args,"n");
		const char *argCommandTitle=vars_get_value(args,"title");
		char * execCommand=NULL;
		if (wctx->currentAction==PA_COMMANDS_EXECUTE){
			wctx->decoratePage=false;
		}
		initHtmlPage(wctx,tr("commands"),printHtmlHeadExtra);
		if (fileExists(commandsFile) 
			&& ( wctx->currentAction==PA_COMMANDS_SHOW
			|| ( wctx->currentAction==PA_COMMANDS_EXECUTE && argCommandNum>0 && argCommandTitle) )
		) {
			if (wctx->currentAction==PA_COMMANDS_SHOW){
				wctx_printfn(wctx,"<div class=\"level2-div ui-widget\">\n",0,1);
				wctx_printf0(wctx,"<h2 class=\"level2-top ui-widget-header\">%s</h2>\n",tr("commands"));
				wctx_printfn(wctx,"<div class=\"level2 ui-widget-content\">\n",0,1);
			}

			FILE *f = fopen(commandsFile,"r");
			if (f) {
				if (wctx->currentAction==PA_COMMANDS_SHOW){
					wctx_printfn(wctx,"<table id=\"commands\" class=\"layout\" cellspacing=\"5\">\n",0,1);
					wctx_printf0(wctx,"<col class=\"menu\"/>\n");
					wctx_printf0(wctx,"<col class=\"result\"/>\n");
					wctx_printfn(wctx,"<tbody>\n",0,1);
					wctx_printfn(wctx,"<tr>\n",0,1);
					wctx_printfn(wctx,"<td>\n",0,1);
				} else {
					wctx_printfn(wctx,"<pre>\n",0,1);
				}
				enum {BUFSZ=4096};
				char buffer[BUFSZ];
				int level=0;
				int levelant=-1;
				char *sep;
				char *title;
				char *command;
				int n=0;
				bool confirm;
				while(fgets(buffer,BUFSZ-1,f)!=NULL) {
					sep=strchr(buffer,':');
					if (sep){
						*sep=0;
						title=buffer;
						command=sep+1;
						for(sep--;sep>buffer && *sep==' ';sep--){
							*sep=0;
						}
						if (*sep=='?'){
							confirm=true;
							*sep=0;
						} else {
							confirm=false;
						} 
						for(level=0;*title=='-';title++)	level++;
						while(*command==' ') command++;
						if (strlen(title)>0 && strlen(command)>0){
							n++;
							if (wctx->currentAction==PA_COMMANDS_SHOW){
								if(level>levelant){
									wctx_printfn(wctx,"<ul class=\"commands\">\n",0,1);
								}
								if (level<levelant){
									wctx_printfn(wctx,"</ul>\n",-1,0);
									wctx_printfn(wctx,"</li>\n",-1,0);
								}
								wctx_printfn(wctx,"<li class=\"command\" title=\"%s\">\n",0,1,CTX_HTML_ENCODE(command,-1));
								wctx_printf0(wctx,"<a class=\"command%s\" href=\"commands.kl1?a=%d&amp;n=%d&amp;title=%s\">%s</a>\n"
									,(confirm)?" confirm":"",PA_COMMANDS_EXECUTE,n,CTX_URL_ENCODE(title,-1,NULL),title);
							} else if (wctx->currentAction==PA_COMMANDS_EXECUTE){
								if (n==argCommandNum){
									if (strcmp(argCommandTitle,title)==0){
										execCommand=strdup(command);
									} else {
										printMessage(wctx,"alert",tr("commands.err.titleMismatch"),NULL, false);
									}
									break;
								}
							}

						}
						levelant=level;
					}
				}
				if (wctx->currentAction==PA_COMMANDS_SHOW && n>0){
					wctx_printfn(wctx,"</li>\n",-1,0);
					wctx_printfn(wctx,"</ul>\n",-1,0);
				}
				fclose(f);
				if (wctx->currentAction==PA_COMMANDS_SHOW){
					wctx_printfn(wctx,"</td>\n",-1,0);
					wctx_printfn(wctx,"<td id=\"resultContainer\">\n",0,1);
					wctx_printfn(wctx,"</td>\n",-1,0);
					wctx_printfn(wctx,"</tr>\n",-1,0);
					wctx_printfn(wctx,"</tbody>\n",-1,0);
					wctx_printfn(wctx,"</table>\n",-1,0);
				}
			}
			if (wctx->currentAction==PA_COMMANDS_SHOW){
				wctx_printfn(wctx,"</div>\n",-1,0); //level2
				wctx_printfn(wctx,"</div>\n",-1,0); //level2-div
			} else if (wctx->currentAction==PA_COMMANDS_EXECUTE && execCommand){
				command_exec(wctx,execCommand);
				free(execCommand);
				wctx_printfn(wctx,"</pre>\n",-1,0);
				wctx_printf0(wctx,"<p>-------------FIN--------------</p>");
			}
		}
		finishHtmlPage(wctx);
	}
	freeCtx(wctx);
%>
