diff -Naur usbautomounter-orig/display.c usbautomounter/display.c
--- usbautomounter-orig/display.c	2009-05-01 16:08:50.000000000 +0200
+++ usbautomounter/display.c	2009-05-01 16:53:43.000000000 +0200
@@ -25,6 +25,12 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <ctype.h>
+#include <errno.h>
+#include <netdb.h>
+#include <netinet/in.h>
+#include <sys/socket.h>
+#include <string.h>
+#include <unistd.h>
 #include "display.h"
 #include "tools.h"
 
@@ -35,6 +41,11 @@
 #define BAR_WIDTH (OSD_WIDTH - (2 * (OSD_HKEEPOUT + 20)))
 #define BAR_HEIGHT 30
 #define BAR_XPOS ((OSD_WIDTH - BAR_WIDTH) / 2)
+#define SVDRADDRESS "localhost"
+#define SVDRPORT 2001
+#define SVDRPBarStep 10
+#define SVDRPBarMinTime 30
+#define SVDRPBarMaxTime 60
 
 /* Texts for flasher */
 static const i18n_text_t mounter_texts[] = {
@@ -177,6 +188,9 @@
 	int init;
 	struct osd_progress_bar bar;
 } display_ctx;
+extern int useSVDRP;
+int SendSVDRPMessage(const char* Message);
+void CloseSVDRP();
 
 static void get_vdr_config(void)
 {
@@ -256,6 +270,15 @@
 
 int display_init(int autoboot)
 {
+	if(useSVDRP>0)
+	{
+		get_vdr_config();
+		i18n_init(-1);
+		if(i18n_register(mounter_texts))
+			SYSLOG_ERR("Cannot init translation");
+		SendSVDRPMessage(tr("Filesystem Check"));
+		return 0;
+	}
 	int text_height;
 	int y;
 
@@ -321,12 +344,36 @@
 
 void display_deinit(void)
 {
+	if(useSVDRP>0)
+	{
+		void CloseSVDRP();		
+		i18n_deinit();
+		return;
+	}
 	if (display_ctx.init)
 		libosd_deinit(display_ctx.autoboot,1);
 }
 
+#define MAXBUF 512
+int LastBar=0;
+int LastBarTime=0;
 int display_update_bar(int value)
 {
+	if(useSVDRP>0)
+	{
+		time_t Now=time(NULL);
+		if(Now-LastBarTime<SVDRPBarMinTime)
+			return;
+		if((value>LastBar)&&(value-LastBar<SVDRPBarStep)&&(Now-LastBarTime<SVDRPBarMaxTime))
+			return;
+		LastBar=(value/SVDRPBarStep)*SVDRPBarStep;
+		LastBarTime=Now;
+		char Buffer[MAXBUF];
+		snprintf(Buffer,MAXBUF,"%s (%d%%)",tr("Filesystem Check"),LastBar);
+		Buffer[MAXBUF-1]=0;
+		SendSVDRPMessage(Buffer);
+		return;
+	}
 	int r;
 	r = osd_progress_update(&display_ctx.bar, 1, value);
 	osd_flush();
@@ -335,6 +382,12 @@
 
 void display_msg(const char *txt)
 {
+	if(useSVDRP>0)
+	{
+		LastBarTime=0;
+		SendSVDRPMessage(txt);
+		return;
+	}
 	int text_height;
 	text_height = font_get_line_height();
 	osd_draw_text_line(0, display_ctx.y_msg, OSD_WIDTH , text_height, txt,
@@ -342,3 +395,146 @@
 		TEXT_ALIGN_CENTER | TEXT_ALIGN_TOP);
 	osd_flush();
 }
+
+int svdrprecv (int sd) {
+
+  char buf1[MAXBUF] = "";
+  char buf2[MAXBUF + 6] = "";
+  char tmp[6] = "\n";
+  int l = 3;
+
+  struct timeval tv;
+  fd_set rfds;
+
+  tv.tv_sec = 1;
+  tv.tv_usec = 50000;
+
+  FD_ZERO (&rfds);
+  FD_SET (sd, &rfds);
+
+  select (sd + 1, &rfds, NULL, NULL, &tv);
+
+  while (l) {
+
+    if ((recv (sd, buf1, MAXBUF - 1, 4)) < 1) {
+      perror ("recv faild");
+      return (0);
+
+    } else {
+
+      buf1[strlen (buf1)] = '\0';
+      printf ("%s", buf1);
+
+      if ((select (sd + 1, &rfds, NULL, NULL, &tv)) < 1) {
+	if (errno != 0) {
+	  perror ("select faild");
+	  return (0);
+	}
+      }
+     
+      /*
+       * wow, this is stupid to send "Access Denied!" outside
+       * their own format spec. deal with it anyway....
+       */
+
+      if (l == 3) {
+	if (strncmp (buf1, "Access denied!\n", sizeof (buf1)) == 0) {
+	 return 0;
+	}
+	l = 2;
+      }
+
+      strncat (buf2, tmp, sizeof (tmp));
+      bzero (tmp, sizeof (tmp));
+      strncat (buf2, buf1, sizeof (buf1));
+
+      if (l == 2) {
+	int i, j = 0;
+	for (i = 0; i < strlen (buf2); i++) {
+	  if (buf2[i] == '\n' && isdigit (buf2[1 + i]) && isdigit (buf2[2 + i])
+	      && isdigit (buf2[3 + i]) && buf2[4 + i] == ' ') {
+		l = 1;
+	  }
+	  if (i > (strlen (buf2) - 6))
+	    tmp[j++] = buf2[i];
+	}
+      }
+
+      if (l == 1) {
+	if (buf1[strlen (buf1) - 1] == '\n' && buf1[strlen (buf1)] == '\0') {
+	  //printf("DEBUG MATCH EOT\n");
+	  l = 0;
+	}
+      }
+
+      bzero (buf1, sizeof (buf1));
+      bzero (buf2, sizeof (buf2));
+    }
+  }
+  return (1);
+}
+
+int sd=-1;
+int OpenSVDRP()
+{
+  if(sd!=-1)
+	return 1;
+  struct hostent *hostaddr=gethostbyname(SVDRADDRESS);
+  if(!hostaddr)
+    return 0;
+
+  sd=socket(PF_INET,SOCK_STREAM,6);
+  if(sd==-1)
+    return 0;
+
+  struct sockaddr_in socketaddr;
+  memset(&socketaddr,0,sizeof(socketaddr));
+  socketaddr.sin_family=AF_INET;
+  socketaddr.sin_port=htons(SVDRPORT);
+
+  memcpy(&socketaddr.sin_addr,hostaddr->h_addr,hostaddr->h_length);
+
+  if(connect(sd,(struct sockaddr *)&socketaddr,sizeof(socketaddr))==-1)
+  {
+	close(sd);
+	sd=-1;
+	return 0;
+  }
+  return 1;
+}
+int SendSVDRP(const char *msg)
+{
+	if(!OpenSVDRP())
+		return 0;
+	if(send(sd,msg,strlen(msg),0)!=strlen(msg))
+	{
+		close(sd);
+		sd=-1;
+		return 0;	
+	}
+	if(!svdrprecv(sd))
+	{
+		close(sd);
+		sd=-1;
+		return 0;	
+	}
+	return 1;
+}
+
+void CloseSVDRP()
+{
+	if(sd==-1)
+		return;
+	if(SendSVDRP("QUIT\n\r"))
+	{
+		close(sd);
+		sd=-1;
+	}
+}
+int SendSVDRPMessage(const char* Message)
+{
+	char Buffer[MAXBUF];
+	snprintf(Buffer,MAXBUF,"MESG %s\n\r",Message);
+	Buffer[MAXBUF-1]=0;
+	return SendSVDRP(Buffer);
+}
diff -Naur usbautomounter-orig/setup.c usbautomounter/setup.c
--- usbautomounter-orig/setup.c	2009-04-21 20:17:00.000000000 +0200
+++ usbautomounter/setup.c	2009-05-01 17:07:35.000000000 +0200
@@ -296,6 +296,7 @@
 	free(conf->action_volume_lost);
 }
 
+extern int useSVDRP;
 int read_config_file(struct usbautomounter_config *conf)
 {
 	FILE *conf_file;
@@ -343,6 +344,12 @@
 		} else if (!strcasecmp(key, "FsckAsHotplug")) {
 			conf->fsck_as_hotplug = atoi(value);
          free(value);
+		}
+		else if(!strcasecmp(key,"SVDRP"))
+		{
+			if(useSVDRP==0)
+				useSVDRP=atoi(value);
+			free(value);
 		} else {
 			SYSLOG_WARN("Unknown config file Entry '%s = %s'", key, value);
 			free(value);
diff -Naur usbautomounter-orig/usbautomounter.c usbautomounter/usbautomounter.c
--- usbautomounter-orig/usbautomounter.c	2009-05-01 16:03:42.000000000 +0200
+++ usbautomounter/usbautomounter.c	2009-05-01 16:46:15.000000000 +0200
@@ -37,6 +37,7 @@
 #include "config.h"
 #include "display.h"
 
+int useSVDRP=0;
 struct usbmounter_context {
 	int ashotplug;
 	int autoboot;
@@ -805,11 +806,13 @@
 
 static void print_usage() {
 	fprintf(stderr, "usbautomounter " USB_MOUNTER_VERSION_STR "\n\n");
-	fprintf(stderr, "usbautomounter <command> [fsck|nofsck]\n");
+	fprintf(stderr, "usbautomounter <command> [fsck|nofsck] [SVDRP|noSVDRP]\n");
 	fprintf(stderr, "\t<command> := usb | mount | remount | umount\n");
 	fprintf(stderr, "\tusb | mount | remount\tmounts/remounts all usb storage devices\n");
 	fprintf(stderr, "\tumount\tumounts all mounted usb storage devices\n");
 	fprintf(stderr, "\tfsck|nofsck\toptional, force or disable fsck check\n");
+	fprintf(stderr, "\tSVDRP|noSVDRP\tuse or disable SVDRP\n");
+	fprintf(stderr, "\t\toptional, must be the last parameter\n");
 }
 
 int main(int argc, char **argv)
@@ -819,6 +822,14 @@
 		return 1;
 	}
 
+	if (argc>=3 && !strcasecmp(argv[2],"SVDRP"))
+		useSVDRP=1;
+	if (argc>=4 && !strcasecmp(argv[3],"SVDRP"))
+		useSVDRP=1;
+	if (argc>=3 && !strcasecmp(argv[2],"noSVDRP"))
+		useSVDRP=-1;
+	if (argc>=4 && !strcasecmp(argv[3],"noSVDRP"))
+		useSVDRP=-1;
 	int force_fsck = 0;
 	if (argc >= 3 && !strcasecmp(argv[2],"fsck"))
 		force_fsck = 1;
