diff -Naur VDR-NG-EM-orig/dvbosd.c VDR-NG-EM/dvbosd.c
--- VDR-NG-EM-orig/dvbosd.c	Tue Jun 12 12:57:36 2007
+++ VDR-NG-EM/dvbosd.c	Tue Feb 26 20:27:52 2008
@@ -11,7 +11,7 @@
 //M7X0 BEGIN AK
 // Nearly the complete File is changed.
 // OSD is done via Linux Framebuffer-Device
-// At the moment runs 720x576@32-Bit or 720x576@8-Bit Indexed Interlaced
+// At the moment runs 720x576@8-Bit Indexed Interlaced
 
 
 #include <signal.h>
@@ -23,160 +23,39 @@
 #include <errno.h>
 
 // --- cDvbOsd ---------------------------------------------------------------
-#ifdef USE_32BPP_FRAMEBUFFER
-class cDvbOsd : public cOsd {
-private:
-	uint32_t *fbMem;
-	int fbWidth;
-	int fbHeight;
-	int fbBpp;
-	bool fbInterlaced;
-	bool shown;
-
-public:
-	cDvbOsd(int Left, int Top, uint32_t *FbMem ,
-			int FbWidth, int FbHeight, int FbBpp,bool FbInterlaced);
-	virtual ~cDvbOsd();
-	virtual void Flush(void);
-  };
-
-cDvbOsd::cDvbOsd(int Left, int Top, uint32_t *FbMem,int FbWidth,
-	int FbHeight,int FbBpp, bool FbInterlaced)
-:cOsd(Left, Top)
-{
-	shown = false;
-
-	fbMem = FbMem;
-	fbWidth=FbWidth;
-	fbHeight=FbHeight;
-	fbBpp=FbBpp;
-	fbInterlaced=FbInterlaced;
-
-}
-
-cDvbOsd::~cDvbOsd()
-{
-	if (shown) {
-		for (int i=0, i2= (fbHeight>>1) * fbWidth;
-				i2 < fbWidth*fbHeight ; i+=fbWidth, i2+=fbWidth){
-			memset(fbMem+i,0,fbWidth*(fbBpp>>3));
-			memset(fbMem+i2,0,fbWidth*(fbBpp>>3));
-		}
-		msync(fbMem,fbWidth*fbHeight*(fbBpp>>3),MS_ASYNC);
-	}
-}
-
-void cDvbOsd::Flush(void)
-{
-	cBitmap *Bitmap;
-	int x1, y1, y1Field1, y1Field2;
-	// Used for the Dirty-Rectangle in the Bitmap.
-	int x1BitmapDirty, x2BitmapDirty, y1BitmapDirty, y2BitmapDirty;
-	int i,j,k;
-	int NumColors;
-	int bitmapWidth;
-	const tColor *Colors;
-	const tIndex *bitmapData;
-
-	shown = true;
-
-	for (i=0; (Bitmap = GetBitmap(i)) != NULL; i++) {
-		if(!Bitmap->Dirty(x1BitmapDirty, y1BitmapDirty,
-				x2BitmapDirty , y2BitmapDirty))
-			continue;
-
-		// Clear Dirty-Area
-		Bitmap->Clean();
-
-		Colors = Bitmap->Colors(NumColors);
-		bitmapData = Bitmap->Data(0,0);
-
-		if(!Colors || !bitmapData)
-			continue;
-
-		bitmapWidth= Bitmap->Width();
-
-		x1 = Bitmap->X0() + Left();
-		y1 = y1BitmapDirty + Bitmap->Y0() + Top();
-
-		if((y1&1)==0) {
-			// Bitmaps First Dirty Line is in the first Field
-			y1Field1= (y1 >> 1)*fbWidth;
-			y1Field2= ((fbHeight>>1)+(y1>>1))*fbWidth;
-		} else {
-			// Bitmaps First Dirty Line is in the second Field
-			y1Field1= ((fbHeight>>1)+(y1>>1))*fbWidth;
-			y1Field2= ((y1 >> 1)+1)*fbWidth;
-		}
-
-		y1Field1+=x1;
-		y1Field2+=x1;
-
-    	for (j = y1BitmapDirty*bitmapWidth ;
-				y1BitmapDirty < y2BitmapDirty;
-				y1BitmapDirty+=2, j += bitmapWidth<<1,
-				y1Field1 += fbWidth , y1Field2 += fbWidth) {
-			// Maybe this loop is faster if splited up in two (for each field)
-			// This can happen due to caching of the CPU
-			for (k=x1BitmapDirty ; k <= x2BitmapDirty; k++){
-				fbMem[y1Field1+k]=Colors[bitmapData[j+k]];
-				fbMem[y1Field2+k]=Colors[bitmapData[j+k+bitmapWidth]];
-			}
-		}
-
-		if ( y1BitmapDirty == y2BitmapDirty ){
-			// Copy last Dirty-Line of Bitmap
-			for (k=x1BitmapDirty ; k <= x2BitmapDirty; k++){
-				fbMem[y1Field1+k]=Colors[bitmapData[j+k]];
-			}
-		}
-
-
-	}
-
-	msync(fbMem,fbWidth*fbHeight*(fbBpp>>3),MS_ASYNC);
-
-}
-#else
-
 class cDvbOsd : public cOsd {
 private:
   int fb_fd;
   uint8_t *fbMem;
   bool shown;
-  struct fb_cmap *palette;
-  int *paletteUses;
-  bool clearOnStop;
-  bool overlay;
   void SetFbPalette(const tColor *Colors, int NumColors);
 public:
-  cDvbOsd(int Left, int Top, int Fb_fd, uint8_t *FbMem,
-          struct fb_cmap *Palette, int *PaletteUses, bool ClearOnStop, bool Overlay);
+  cDvbOsd(int Left, int Top, int Fb_fd, uint8_t *FbMem);
   virtual ~cDvbOsd();
   virtual eOsdError CanHandleAreas(const tArea *Areas, int NumAreas);
-  virtual eOsdError SetAreas(const tArea *Areas, int NumAreas);
   virtual void Flush(void);
   };
 
-cDvbOsd::cDvbOsd(int Left, int Top, int Fb_fd, uint8_t *FbMem,
- struct fb_cmap *Palette, int *PaletteUses, bool ClearOnStop, bool Overlay)
+cDvbOsd::cDvbOsd(int Left, int Top, int Fb_fd, uint8_t *FbMem)
  : cOsd(Left, Top)
 {
   shown = false;
   fb_fd = Fb_fd;
   fbMem = FbMem;
-  palette = Palette;
-  paletteUses = PaletteUses;
-  clearOnStop = ClearOnStop;
-  overlay = Overlay;
 }
 
 cDvbOsd::~cDvbOsd()
 {
-  if (shown && clearOnStop) {
-     for (int i=0; i < (720 * 576) / 2; i += 720) {
-         memset(fbMem + i, 0xFF, 720);
-         memset(fbMem + i + ((720 * 576) / 2), 0xFF, 720);
+  if (shown) {
+     uint8_t *f1;
+     uint8_t *f2;
+     f1 = f2 = fbMem;
+     f2 += (576 / 2) * 720;
+     const uint8_t *const f1end = f2;
+     while (f1 < f1end) {
+         memset(f1, 0xFF, 720);
+         memset(f2, 0xFF, 720);
+         f1 += 720; f2 +=720;
          }
      msync(fbMem,720 * 576, MS_ASYNC);
      }
@@ -188,65 +67,34 @@
   return ( (NumAreas <= 1) ? cOsd::CanHandleAreas(Areas,NumAreas) : oeTooManyAreas );
 }
 
-eOsdError cDvbOsd::SetAreas(const tArea *Areas, int NumAreas)
-{
-  eOsdError r = cOsd::SetAreas(Areas, NumAreas);
-  if (r != oeOk || !*paletteUses || NumAreas < 1)
-     return r;
-
-  cBitmap *Bitmap = GetBitmap(0); // Only one area allowed.
-  for (int i = 0; i < *paletteUses; i++) {
-      const tColor color = ((palette->blue[i]  & 0xFF00) >> 8) |
-                           ((palette->green[i] & 0xFF00)     ) |
-                           ((palette->red[i]   & 0xFF00) << 8) |
-            ((0xFF - ((palette->transp[i] >> 8) & 0xFF)) << 24);
-      Bitmap->SetColor(i, color);
-      }
-  Bitmap->PaletteModified();
-  if (overlay) {
-     tIndex *bitmapBuf = Bitmap->GetBuffer();
-     const int bitmapWidth = Bitmap->Width();
-     const int bitmapHeight = Bitmap->Height();
-     const int x = Left() + Bitmap->X0();
-     const int y = Top() + Bitmap->Y0();
-
-     const tIndex *const end = bitmapBuf + bitmapHeight * bitmapWidth;
-
-     uint8_t *fbp = fbMem + ((y + 1) >> 1) * 720 + x;
-     tIndex *start = bitmapBuf + (y & 1) * bitmapWidth;
-     while (start < end) {
-           memcpy(start, fbp, bitmapWidth);
-           fbp += 720;
-           start += (bitmapWidth << 1);
-           }
-
-     fbp = fbMem + 720 * (576 / 2) + (y >> 1) * 720 + x;
-     start = bitmapBuf + ((y + 1) & 1) * bitmapWidth;
-     while (start < end) {
-           memcpy(start, fbp, bitmapWidth);
-           fbp += 720;
-           start += (bitmapWidth << 1);
-           }
-
-     }
-  return r;
-}
-
 void cDvbOsd::SetFbPalette(const tColor *Colors, int NumColors)
 {
   // This is wired ,driver seems to expect little endian format
   // for palette. Only 8 bits are used.
+  uint16_t red[256];
+  uint16_t green[256];
+  uint16_t blue[256];
+  uint16_t trans[256];
+
   for (int i = 0; i < NumColors; i++) {
-      palette->blue[i] = (Colors[i] & 0xFF) << 8;
-      palette->green[i] = (Colors[i] & 0xFF00);
-      palette->red[i] = (Colors[i] >> 8) & 0xFF00;
-      palette->transp[i] = (0xFF - (Colors[i] >> 24)) << 8;
+      blue[i] = (Colors[i] & 0xFF) << 8;
+      green[i] = (Colors[i] & 0xFF00);
+      red[i] = (Colors[i] >> 8) & 0xFF00;
+      trans[i] = (0xFF - (Colors[i] >> 24)) << 8;
       }
-  *paletteUses = NumColors;
+  blue[255] = green[255] = red[255] = 0;
+  trans[255] = 0xFF00;
 
   // Works only correct if we set the full palette
   // otherwise you get a pink osd (don't know why may be the box likes pink ;))
-  CHECK(ioctl(fb_fd, FBIOPUTCMAP, palette));
+  struct fb_cmap palette;
+  palette.start = 0;
+  palette.len = 256;
+  palette.red = red;
+  palette.green = green;
+  palette.blue = blue;
+  palette.transp = trans;
+  CHECK(ioctl(fb_fd, FBIOPUTCMAP, &palette));
 }
 
 void cDvbOsd::Flush(void)
@@ -262,8 +110,6 @@
 
   Bitmap->Clean();
 
-
-
   if (Bitmap->PaletteModified()) {
      int NumColors;
      const tColor *Colors = Bitmap->Colors(NumColors);
@@ -283,16 +129,17 @@
   const int x1 = x1BitmapDirty + Bitmap->X0() + Left();
   const int y1 = y1BitmapDirty + Bitmap->Y0() + Top();
 
-  int y1Field1, y1Field2;
-  if ((y1 & 1) == 0) {
+  uint8_t *y1Field1;
+  uint8_t *y1Field2;
+  y1Field2 = y1Field1 = fbMem + (y1 >> 1) * 720;
+  if (!(y1 & 1)) {
      // Bitmaps First Dirty Line is in the first Field
-     y1Field1 = (y1 >> 1) * 720;
-     y1Field2 = ((y1 >> 1) + (576 / 2)) * 720;
+     y1Field2 += (576 / 2) * 720;
      }
   else {
      // Bitmaps First Dirty Line is in the second Field
-     y1Field1 = ((y1 >> 1) + (576 / 2)) * 720;
-     y1Field2 = ((y1 >> 1) + 1) * 720;
+     y1Field1 += (576 / 2) * 720;
+     y1Field2 += 720;
      }
 
   y1Field1 += x1;
@@ -303,32 +150,29 @@
   y2BitmapDirty -= y1BitmapDirty;
   const tIndex *const bitmapDataLimit = bitmapData + y2BitmapDirty * bitmapWidth;
 
-  for (;bitmapData < bitmapDataLimit; y1Field1 += 720, y1Field2 += 720,
-                                             bitmapData += bitmapWidth) {
-      memcpy(fbMem + y1Field1, bitmapData, x2BitmapDirty);
-      bitmapData += bitmapWidth;
-      memcpy(fbMem + y1Field2, bitmapData, x2BitmapDirty);
+  while (bitmapData < bitmapDataLimit) {
+        memcpy(y1Field1, bitmapData, x2BitmapDirty);
+        bitmapData += bitmapWidth;
+        memcpy(y1Field2, bitmapData, x2BitmapDirty);
+        bitmapData += bitmapWidth;
 
-      }
+        y1Field1 += 720;
+        y1Field2 += 720;
+        }
 
   // Copy last dirty line
   if (bitmapData == bitmapDataLimit)
-     memcpy(fbMem + y1Field1, bitmapData, x2BitmapDirty);
+     memcpy(y1Field1, bitmapData, x2BitmapDirty);
 
   msync(fbMem, 720 * 576, MS_ASYNC);
   //dsyslog("OSD FLUSHED!");
 }
-#endif
 // --- cDvbOsdProvider -------------------------------------------------------
 
-cDvbOsdProvider::cDvbOsdProvider(int OsdDev, bool ClearOnStart,
-                                bool ClearOnStop, bool Overlay)
+cDvbOsdProvider::cDvbOsdProvider(int OsdDev)
 {
   osdDev = OsdDev;
   fbMem=NULL;
-  clearOnStart = ClearOnStart;
-  clearOnStop = ClearOnStop;
-  overlay = Overlay && !ClearOnStart;
   if (osdDev < 0) {
      esyslog("ERROR: illegal OSD device handle (%d)!", osdDev);
      return;
@@ -341,15 +185,9 @@
      }
 
   fbBppSaved=scrInf.bits_per_pixel;
-  if (clearOnStart ||
-#ifdef USE_32BPP_FRAMEBUFFER
-      fbBppSaved != 32) {
-     scrInf.bits_per_pixel=32;
-#else
-      fbBppSaved != 8) {
+  if (fbBppSaved != 8) {
      scrInf.bits_per_pixel=8;
-#endif
-     clearOnStart = true;
+
      if (ioctl(osdDev,FBIOPUT_VSCREENINFO,&scrInf) < 0) {
         esyslog("ERROR: cannot get Framebuffer-Settings !");
         return;
@@ -365,136 +203,98 @@
   fbWidth=scrInf.xres;
   fbHeight=scrInf.yres;
   fbBpp=scrInf.bits_per_pixel;
-  fbInterlaced=scrInf.vmode&FB_VMODE_INTERLACED;
-#ifdef USE_32BPP_FRAMEBUFFER
-  fbMem= (uint32_t *) mmap(0, fbWidth * fbHeight * (fbBpp>>3),
+  fbInterlaced=(scrInf.vmode&FB_VMODE_INTERLACED) == FB_VMODE_INTERLACED;
+  fbMem= (uint8_t *) mmap(0, fbWidth * fbHeight,
                                        PROT_READ | PROT_WRITE,
                                        MAP_SHARED, osdDev, 0);
-#else
-  fbMem= (uint8_t *) mmap(0, fbWidth * fbHeight * (fbBpp>>3),
-                                       PROT_READ | PROT_WRITE,
-                                       MAP_SHARED, osdDev, 0);
-#endif
 
   if (fbMem == MAP_FAILED) {
-      esyslog("ERROR: cannot mmap Framebuffer (%d)!",errno);
-      fbMem=NULL;
-      }
+     esyslog("ERROR: cannot mmap Framebuffer (%d)!",errno);
+     fbMem=NULL;
+     return;
+     }
 
-#ifdef USE_32BPP_FRAMEBUFFER
-  if (!fbMem || fbWidth != 720 || fbHeight != 576 || fbBpp != 32 || !fbInterlaced) {
-#else
-  if (!fbMem || fbWidth != 720 || fbHeight != 576 || fbBpp != 8 || !fbInterlaced) {
-#endif
+  if (fbWidth != 720 | fbHeight != 576 | fbBpp != 8 | !fbInterlaced) {
      esyslog("ERROR: illegal or unsupported framebuffer: %u x %u x %u !",
                                                    fbWidth,fbHeight,fbBpp);
-     if (fbMem) {
-        munmap(fbMem, fbWidth * fbHeight * (fbBpp>>3));
-        }
+     munmap(fbMem, fbWidth * fbHeight * (fbBpp>>3));
      return;
      }
 
-#ifdef USE_32BPP_FRAMEBUFFER
-  if (clearOnStart) {
-     memset(fbMem, 0, fbWidth * fbHeight * 4);
-     msync(fbMem, fbWidth * fbHeight * 4, MS_ASYNC);
-     }
-#else
+  uint16_t zeros[256];
+  uint16_t trans[256];
+
+  memset(zeros,0,256 * sizeof(uint16_t));
+  memset(trans,0xFF,256 * sizeof(uint16_t));
+
+  struct fb_cmap palette;
   palette.start = 0;
   palette.len = 256;
-  palette.red = red;
-  palette.green = green;
-  palette.blue = blue;
+  palette.red = zeros;
+  palette.green = zeros;
+  palette.blue = zeros;
   palette.transp = trans;
-  if (clearOnStart) {
-     memset(fbMem, 0xFF, fbWidth * fbHeight);
-     memset(red,0,256 * sizeof(uint16_t));
-     memset(green,0,256 * sizeof(uint16_t));
-     memset(blue,0,256 * sizeof(uint16_t));
-     memset(trans,0xFF,256 * sizeof(uint16_t));
-     paletteUses = 0;
-     if (ioctl(osdDev, FBIOPUTCMAP, &palette) < 0) {
-          esyslog("ERROR: cannot set framebuffer palette");
-        }
-     msync(fbMem, fbWidth * fbHeight, MS_ASYNC);
+  if (ioctl(osdDev, FBIOPUTCMAP, &palette) < 0) {
+     esyslog("ERROR: cannot set framebuffer palette");
      }
-  else {
-     if (ioctl(osdDev, FBIOGETCMAP, &palette) < 0) {
-          esyslog("ERROR: cannot get framebuffer palette");
-        }
-     // Driver has differnet format for getting and setting palettes
-     // Yet another bug
-     paletteUses = 0;
-     for (int i = 0; i < 256; i++) {
-         trans[i] = 0xFF - (trans[i] >> 8);
-         if (trans[i] < 0xFF)
-            paletteUses = i + 1;
-         trans[i] = trans[i] << 8;
-         }
-     trans[255] = 255 << 8;
-     red[255] = green[255] = blue[255] = 0;
-     }
-#endif
-
+  memset(fbMem, 0xFF, fbWidth * fbHeight);
+  msync(fbMem, fbWidth * fbHeight, MS_ASYNC);
 }
 
 cDvbOsdProvider::~cDvbOsdProvider(){
-  struct fb_var_screeninfo scrInf;
-  if (ioctl(osdDev,FBIOGET_VSCREENINFO,&scrInf) < 0) {
-     esyslog("ERROR: cannot get Framebuffer-Settings !");
-     return;
-     }
 
   if (fbMem){
-     munmap(fbMem, fbWidth * fbHeight * (fbBpp>>3));
+     munmap(fbMem, fbWidth * fbHeight);
      }
 
-  if (clearOnStop) {
-     const int startSize = fbWidth * fbHeight * (fbBppSaved>>3);
-     uint8_t buf[startSize];
-     memset(buf, 0, startSize);
-     write(osdDev, buf, startSize);
+  if (fbBpp != fbBppSaved) {
+     struct fb_var_screeninfo scrInf;
+     if (ioctl(osdDev,FBIOGET_VSCREENINFO,&scrInf) < 0) {
+        esyslog("ERROR: cannot get Framebuffer-Settings !");
+        return;
+        }
      scrInf.bits_per_pixel = fbBppSaved;
      if (ioctl(osdDev,FBIOPUT_VSCREENINFO,&scrInf) < 0) {
         esyslog("ERROR: cannot get Framebuffer-Settings !");
         return;
         }
-#ifndef USE_32BPP_FRAMEBUFFER
-     if (fbBppSaved == 8) {
-        memset(red,0,256 * sizeof(uint16_t));
-        memset(green,0,256 * sizeof(uint16_t));
-        memset(blue,0,256 * sizeof(uint16_t));
-        memset(trans,0xFF,256 * sizeof(uint16_t));
-
-        if (ioctl(osdDev, FBIOPUTCMAP, &palette) < 0) {
-           esyslog("ERROR: cannot set framebuffer palette");
-           }
-        }
-#endif
-
-     // memset(fbMem, 0, fbWidth * fbHeight * (fbBpp>>3));
      }
 
+  if (fbBppSaved == 8) {
+     uint16_t zeros[256];
+     uint16_t trans[256];
+
+     memset(zeros,0,256 * sizeof(uint16_t));
+     memset(trans,0xFF,256 * sizeof(uint16_t));
+
+     struct fb_cmap palette;
+     palette.start = 0;
+     palette.len = 256;
+     palette.red = zeros;
+     palette.green = zeros;
+     palette.blue = zeros;
+     palette.transp = trans;
+
+     if (ioctl(osdDev, FBIOPUTCMAP, &palette) < 0) {
+        esyslog("ERROR: cannot set framebuffer palette");
+        }
+     }
 
+  const int startSize = fbWidth * fbHeight * (fbBppSaved>>3);
+  uint8_t buf[startSize];
+  memset(buf, 0, startSize);
+  write(osdDev, buf, startSize);
 }
 
 cOsd *cDvbOsdProvider::CreateOsd(int Left, int Top)
 {
-#ifdef USE_32BPP_FRAMEBUFFER
-  return new cDvbOsd(Left, Top, fbMem, fbWidth, fbHeight, fbBpp, fbInterlaced);
-#else
-  if (fbMem && fbWidth == 720 && fbHeight == 576 && fbBpp == 8 && fbInterlaced) {
-     if (clearOnStart)
-        paletteUses = 0;
-     return new cDvbOsd(Left, Top, osdDev, fbMem, &palette, &paletteUses, clearOnStop, overlay);
+  if (fbMem != NULL & fbWidth == 720 & fbHeight == 576 & fbBpp == 8 & fbInterlaced) {
+     return new cDvbOsd(Left, Top, osdDev, fbMem);
      }
 
   esyslog("ERROR: illegal or unsupported framebuffer: %u x %u x %u !",
                                                fbWidth,fbHeight,fbBpp);
   return new cOsd(Left, Top);
-
-#endif
-
 }
 
 //M7X0 END AK
diff -Naur VDR-NG-EM-orig/dvbosd.h VDR-NG-EM/dvbosd.h
--- VDR-NG-EM-orig/dvbosd.h	Tue Jun 12 12:57:36 2007
+++ VDR-NG-EM/dvbosd.h	Tue Feb 26 17:51:52 2008
@@ -20,27 +20,14 @@
 //M7X0 BEGIN AK
 // OSD is done via framebuffer-device so mmap can be used.
 // Save settings in here.
-#ifdef USE_32BPP_FRAMEBUFFER
-  uint32_t *fbMem;
-#else
   uint8_t *fbMem;
-  uint16_t red[256];
-  uint16_t green[256];
-  uint16_t blue[256];
-  uint16_t trans[256];
-  struct fb_cmap palette;
-  int paletteUses;
-#endif
   bool fbInterlaced;
   int fbWidth;
   int fbHeight;
   int fbBpp;
   int fbBppSaved;
-  bool clearOnStart;
-  bool clearOnStop;
-  bool overlay;
 public:
-  cDvbOsdProvider(int OsdDev, bool ClearOnStart = true, bool ClearOnStop = true, bool Overlay = false);
+  cDvbOsdProvider(int OsdDev);
   virtual ~cDvbOsdProvider();
 //M7X0 END AK
   virtual cOsd *CreateOsd(int Left, int Top);
diff -Naur VDR-NG-EM-orig/font.c VDR-NG-EM/font.c
--- VDR-NG-EM-orig/font.c	Wed Mar 12 10:43:30 2008
+++ VDR-NG-EM/font.c	Wed Mar 12 18:13:10 2008
@@ -6,16 +6,14 @@
  *
  * $Id$
  */
-//M7X0 BEGIN AK
-#ifndef OSDPAINTER
+
 #include "config.h"
-#endif
 
 #include <ctype.h>
 #include "font.h"
 #include "tools.h"
 
-#ifndef OSDPAINTER
+
 #include "fontfix-iso8859-1.c"
 #include "fontosd-iso8859-1.c"
 #include "fontsml-iso8859-1.c"
@@ -36,7 +34,7 @@
 #include "fontfix-iso8859-13.c"
 #include "fontosd-iso8859-13.c"
 #include "fontsml-iso8859-13.c"
-#endif
+
 #include "fontfix-iso8859-15.c"
 #include "fontosd-iso8859-15.c"
 #include "fontsml-iso8859-15.c"
@@ -46,33 +44,25 @@
 // --- cFont -----------------------------------------------------------------
 
 static const void *const FontData[eDvbCodeSize][eDvbFontSize] = {
-#ifndef OSDPAINTER
   { FontOsd_iso8859_1,  FontFix_iso8859_1,  FontSml_iso8859_1,  FontSym },
-
   { FontOsd_iso8859_2,  FontFix_iso8859_2,  FontSml_iso8859_2,  FontSym },
   { FontOsd_iso8859_5,  FontFix_iso8859_5,  FontSml_iso8859_5,  FontSym },
   { FontOsd_iso8859_7,  FontFix_iso8859_7,  FontSml_iso8859_7,  FontSym },
   { FontOsd_iso8859_13, FontFix_iso8859_13, FontSml_iso8859_13, FontSym },
-#endif
   { FontOsd_iso8859_15, FontFix_iso8859_15, FontSml_iso8859_15, FontSym },
   };
 
 static const char *FontCode[eDvbCodeSize] = {
-#ifndef OSDPAINTER
   "iso8859-1",
   "iso8859-2",
   "iso8859-5",
   "iso8859-7",
   "iso8859-13",
-#endif
   "iso8859-15",
   };
-#ifndef OSDPAINTER
+
 eDvbCode cFont::code = code_iso8859_1;
-#else
-eDvbCode cFont::code = code_iso8859_15;
-#endif
-//M7X0 END AK
+
 cFont *cFont::fonts[eDvbFontSize] = { NULL };
 
 cFont::cFont(const void *Data)
@@ -134,20 +124,18 @@
   delete fonts[Font];
   fonts[Font] = new cFont(Data ? Data : FontData[code][Font]);
 }
-//M7X0 BEGIN AK
+
 const cFont *cFont::GetFont(eDvbFont Font)
 {
-#ifndef OSDPAINTER
   if (Setup.UseSmallFont == 0 && Font == fontSml)
      Font = fontOsd;
   else if (Setup.UseSmallFont == 2)
      Font = fontSml;
-#endif
   if (!fonts[Font])
      SetFont(Font);
   return fonts[Font];
 }
-//M7X0 END AK
+
 // --- cTextWrapper ----------------------------------------------------------
 
 cTextWrapper::cTextWrapper(void)
diff -Naur VDR-NG-EM-orig/font.h VDR-NG-EM/font.h
--- VDR-NG-EM-orig/font.h	Wed Mar 12 10:43:30 2008
+++ VDR-NG-EM/font.h	Wed Mar 12 18:14:55 2008
@@ -25,19 +25,17 @@
 #define eDvbFontSize (fontSym + 1)
   };
 
-//M7X0 BEGIN AK
+
 enum eDvbCode {
-#ifndef OSDPAINTER
   code_iso8859_1,
   code_iso8859_2,
   code_iso8859_5,
   code_iso8859_7,
   code_iso8859_13,
-#endif
   code_iso8859_15,
 #define eDvbCodeSize (code_iso8859_15 + 1)
   };
-//M7X0 END AK
+
 
 class cFont {
 public:
diff -Naur VDR-NG-EM-orig/Makefile VDR-NG-EM/Makefile
--- VDR-NG-EM-orig/Makefile	Wed Mar 12 10:43:49 2008
+++ VDR-NG-EM/Makefile	Wed Mar 12 18:09:38 2008
@@ -263,17 +263,3 @@
 fontclean:
 	-rm -f fontfix*.c fontosd*.c fontsml*.c
 CLEAN: clean fontclean
-
-osdpainter.o: osdpainter.c
-	$(CXX) $(CXXFLAGS) -c $(DEFINES) -DOSDPAINTER $(INCLUDES) -o $@ osdpainter.c
-
-font-osdpainter.o: font.c
-	$(CXX) $(CXXFLAGS) -c $(DEFINES) -DOSDPAINTER $(INCLUDES) -o $@ font.c
-
-tools-osdpainter.o: tools.c
-	$(CXX) $(CXXFLAGS) -c $(DEFINES) -DOSDPAINTER $(INCLUDES) -o $@ tools.c
-OBJS_OSDPAINTER = osdpainter.o dvbosd.o osd.o font-osdpainter.o tools-osdpainter.o
-
-
-osdpainter: $(OBJS_OSDPAINTER)
-	$(CXX) $(CXXFLAGS) $(LDFLAGS) $(OBJS_OSDPAINTER) -o osdpainter
diff -Naur VDR-NG-EM-orig/osdpainter.c VDR-NG-EM/osdpainter.c
--- VDR-NG-EM-orig/osdpainter.c	Tue Jun 12 12:57:36 2007
+++ VDR-NG-EM/osdpainter.c	Thu Jan 01 01:00:00 1970
@@ -1,1052 +0,0 @@
-/*
- * osdpainter.c: A tool for drawing on osd using vdr osd parts
- *
- * Copyright (C) 2007 Andreas Koch - the open7x0.org group
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- * Or, point your browser to http://www.gnu.org/copyleft/gpl.html
- *
- * The author can be reached at andreas@open7x0.org
- *
- * The project's page is at http://www.open7x0.org
- *
- * Some parts are taken from vdr main sources.
- *
- */
-
-#include "dvbosd.h"
-#include <getopt.h>
-#include <stdlib.h>
-#include <stdio.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <fcntl.h>
-#include <unistd.h>
-#define FB_DEVICE "/dev/fb0"
-#define HELPSHORTOPTION "h::"
-#define HELPLONGOPTION "help"
-#define HELPCHAR 'h'
-#define ERROR(a...) void( void ( (fprintf(stderr,"ERROR: "), fprintf(stderr,a), fprintf(stderr,"\n")) ))
-#define VERSIONSTRING "0.0.1"
-#define PROGRAMNAME "osdpainter "
-#define TITLESTR PROGRAMNAME "V. " VERSIONSTRING "\n"
-#define HELPINDENT "   "
-#define USAGESTR "usage: " PROGRAMNAME "[<common options>] <command> <command parameters>\n"
-
-// --- cCommonGraphic --------------------------------------------------------
-class cCommonGraphic {
-private:
-  static const char *optstring;
-  static const struct option longopts[];
-  int fd_fb;
-protected:
-  bool clearOnStart;
-  bool clearOnStop;
-  bool overlay;
-  int width;
-  int height;
-  int x;
-  int y;
-  tColor bgColor;
-  tColor fgColor;
-  cOsd *osd;
-  bool Init(void);
-public:
-  cCommonGraphic() {
-    clearOnStart = false;
-    clearOnStop = false;
-    overlay = false;
-    width = 720;
-    height = 576;
-    bgColor = 0x00000000;
-    fgColor = 0xFFFFFFFF;
-    x = 0;
-    y = 0;
-    osd = NULL;
-    fd_fb = -1;
-    }
-  cCommonGraphic(cCommonGraphic &common) {
-    clearOnStart = common.clearOnStart;
-    clearOnStop = common.clearOnStop;
-    overlay = common.overlay;
-    x = common.x;
-    y = common.y;
-    width = common.width;
-    height = common.height;
-    bgColor = common.bgColor;
-    fgColor = common.fgColor;
-    osd = NULL;
-    fd_fb = -1;
-    }
-  virtual ~cCommonGraphic() {
-    delete osd;
-    cOsdProvider::Shutdown();
-    if (fd_fb >= 0) {
-       close(fd_fb);
-       }
-    }
-  virtual int ParseArg(int val, const char *arg);
-  virtual const char *OptionString(void) const {
-    return optstring;
-    }
-  virtual const struct option *LongOption(void) const {
-    return longopts;
-    }
-  virtual const char *Help(void) const;
-  virtual bool CheckParameter(void) {
-    if (width + x > 720) {
-       width = 720 - x;
-       }
-    if (height + y > 576) {
-       height = 576 - y;
-       }
-    overlay = overlay && !clearOnStart;
-    return true;
-    };
-  virtual bool Paint(void) { return false;}
-  };
-
-const char *cCommonGraphic::optstring = "-c:b:f:w:H:x:y:o" HELPSHORTOPTION;
-const struct option cCommonGraphic::longopts[] = {
-  { "clear", 1, NULL, 'c'},
-  { "background-color", 1, NULL, 'b' },
-  { "foreground-color", 1, NULL, 'f' },
-  { "width", 1, NULL, 'w'},
-  { "height", 1, NULL, 'H'},
-  { "xoffset", 1, NULL, 'x'},
-  { "yoffset", 1, NULL, 'y'},
-  { "overlay", 0, NULL, 'o'},
-  { HELPLONGOPTION, 2, NULL, HELPCHAR},
-  { NULL, 0, NULL, 0}
-};
-
-const char *cCommonGraphic::Help(void) const
-{
-  return "common options:\n"
-         HELPINDENT "-b|--background-color <x>:\n"
-         HELPINDENT HELPINDENT "x := 32 Bit background-color ARGB (default 0)\n\n"
-         HELPINDENT "-c|--clear <n>:\n"
-         HELPINDENT HELPINDENT "n := Clear Osd on\n"
-         HELPINDENT HELPINDENT "0   Never (Default)\n"
-         HELPINDENT HELPINDENT "1   On startup only\n"
-         HELPINDENT HELPINDENT "2   On shutdown only\n"
-         HELPINDENT HELPINDENT "3   On startup and shutdown\n\n"
-         HELPINDENT "-f|--foreground-color <x>:\n"
-         HELPINDENT HELPINDENT "x := 32 Bit foreground-color ARGB (default 0xFFFFFFFF)\n\n"
-         HELPINDENT "-H|--height <x>:\n"
-         HELPINDENT HELPINDENT "x := Height of osd bounding box (default 576)\n\n"
-         HELPINDENT "-o|--overlay:\n"
-         HELPINDENT HELPINDENT "Enable overlay mode\n\n"
-         HELPINDENT "-w|--width <x>:\n"
-         HELPINDENT HELPINDENT "x := Width of osd bounding box (default 720)\n\n"
-         HELPINDENT "-x|--xoffset <x>:\n"
-         HELPINDENT HELPINDENT "x := x offset of osd bound box. All other coordinates"
-         "a relative\n"
-         HELPINDENT HELPINDENT "     to this value (default 0)\n\n"
-         HELPINDENT "-y|--yoffset <x>:\n"
-         HELPINDENT HELPINDENT "x := y offset of osd bound box. All other coordinates"
-         "a relative\n"
-         HELPINDENT HELPINDENT "     to this value (default 0)\n\n";
-}
-
-int cCommonGraphic::ParseArg(int val, const char *arg)
-{
-  int r = 0;
-  switch (val) {
-    case 'c':
-         if (isnumber(arg)) {
-            switch (atoi(arg)) {
-              case 0:
-                   break;
-              case 1:
-                   clearOnStart = true;
-                   break;
-              case 2:
-                   clearOnStop = true;
-                   break;
-              case 3:
-                   clearOnStart = true;
-                   clearOnStop = true;
-                   break;
-              default:
-                  r = -1;
-              }
-            }
-         else
-            r = -1;
-         break;
-    case 'w':
-         if (isnumber(arg)) {
-            const int newwidth = atoi(arg);
-            if (newwidth > 0 && newwidth <= 720)
-               width = newwidth;
-            else
-               r = -1;
-            }
-         else
-            r = -1;
-         break;
-    case 'H':
-         if (isnumber(arg)) {
-            const int newheight = atoi(arg);
-            if (newheight > 0 && newheight <= 576)
-               height = newheight;
-            else
-               r = -1;
-            }
-         else
-            r = -1;
-         break;
-    case 'x':
-         if (isnumber(arg)) {
-            const int newx = atoi(arg);
-            if (newx > 0 && newx <= 720)
-               x = newx;
-            else
-               r = -1;
-            }
-         else
-            r = -1;
-         break;
-    case 'y':
-         if (isnumber(arg)) {
-            const int newy = atoi(arg);
-            if (newy > 0 && newy <= 576)
-               y = newy;
-            else
-               r = -1;
-            }
-         else
-            r = -1;
-         break;
-    case 'b': {
-         char *endp;
-         tColor newbgColor  = strtoul(arg, &endp, 0);
-         if (arg != endp) {
-            bgColor = newbgColor;
-            }
-         else
-            r = -1;
-         }
-         break;
-    case 'f': {
-         char *endp;
-         tColor newfgColor  = strtoul(arg, &endp, 0);
-         if (arg != endp) {
-            fgColor = newfgColor;
-            }
-         else
-            r = -1;
-         }
-         break;
-    case 'o':
-         overlay = true;
-         break;
-    default:
-         r = -1;
-    }
-  return r;
-}
-
-bool cCommonGraphic::Init(void)
-{
-  fd_fb = open(FB_DEVICE,O_RDWR);
-  if (fd_fb < 0) {
-     ERROR("Cannot open framebuffer!");
-     return false;
-     }
-  new cDvbOsdProvider(fd_fb, clearOnStart, clearOnStop, overlay);
-  osd = cOsdProvider::NewOsd(x, y);
-  tArea area;
-  area.x1 = 0;
-  area.y1 = 0;
-  area.x2 = width - 1;
-  area.y2 = height - 1;
-  area.bpp = 8;
-
-  if (osd->SetAreas(&area, 1) != oeOk) {
-     ERROR("Invalid bounding box!");
-     return false;
-     }
-
-  return true;
-}
-
-// --- cTextGraphic ----------------------------------------------------------
-
-class cTextGraphic : public cCommonGraphic {
-private:
-  static const char *optstring;
-  static const struct option longopts[];
-  char *text;
-  int twidth;
-  int theight;
-  int tx;
-  int ty;
-  int alignment;
-  bool multiline;
-  eDvbFont fontType;
-  eDvbCode encoding;
-public:
-  static cCommonGraphic *New(cCommonGraphic &common) { return new cTextGraphic(common); }
-  cTextGraphic(cCommonGraphic &common) : cCommonGraphic(common) {
-    text = NULL;
-    twidth = 0;
-    theight = 0;
-    tx = 0;
-    ty = 0;
-    alignment = taDefault;
-    fontType = fontOsd;
-    encoding = code_iso8859_15;
-    multiline = false;
-    }
-  virtual ~cTextGraphic() { free(text); }
-  virtual const char *OptionString(void) const {
-    return optstring;
-    }
-  virtual const struct option *LongOption(void) const {
-    return longopts;
-    }
-  virtual int ParseArg(int val, const char *arg);
-  virtual const char *Help(void) const;
-  virtual bool CheckParameter(void) {
-    if (!text) {
-       ERROR("No text given!");
-       return false;
-       }
-    return true;
-    }
-  virtual bool Paint(void);
-  };
-
-const char *cTextGraphic::optstring = "-a:f:e:w:H:x:y:m" HELPSHORTOPTION;
-const struct option cTextGraphic::longopts[] = {
-  { "alignment", 1, NULL, 'a'},
-  { "font", 1, NULL, 'f' },
-  { "encoding", 1, NULL, 'e' },
-  { "width", 1, NULL, 'w'},
-  { "height", 1, NULL, 'H'},
-  { "xoffset", 1, NULL, 'x'},
-  { "yoffset", 1, NULL, 'y'},
-  { "multiline", 0, NULL, 'm'},
-  { HELPLONGOPTION, 2, NULL, HELPCHAR},
-  { NULL, 0, NULL, 0}
-};
-
-const char *cTextGraphic::Help(void) const
-{
-  return "command usage: drawtext [<drawtext options>] <text>\n\n"
-         "Draws <text> on osd with foreground color (specified in common options).\n"
-         "If background color is specified in common options and its not fully transparent\n"
-         "The whole osd-bounding box gets filled with it before drawing text.\n\n"
-         "drawtext options:\n"
-         HELPINDENT "-a|--alignment <x>:\n"
-         HELPINDENT HELPINDENT "x := Alignment of text in drawing area. Bitwise or'd of flags:\n"
-         HELPINDENT HELPINDENT "0   centered (in both directions)\n"
-         HELPINDENT HELPINDENT "1   left (default)\n"
-         HELPINDENT HELPINDENT "2   right\n"
-         HELPINDENT HELPINDENT "4   top (defautl)\n"
-         HELPINDENT HELPINDENT "8   bottom\n\n"
-         HELPINDENT "-e|--encoding <n>:\n"
-         HELPINDENT HELPINDENT "Font encoding <n>:n"
-         HELPINDENT HELPINDENT "0   ISO-8859-15 (default)\n\n"
-         HELPINDENT "-f|--font <n>:\n"
-         HELPINDENT HELPINDENT "Font <n>:\n"
-         HELPINDENT HELPINDENT "0   normal font (default)\n"
-         HELPINDENT HELPINDENT "1   fixed size font\n"
-         HELPINDENT HELPINDENT "2   small font\n\n"
-         HELPINDENT "-H|--height <x>:\n"
-         HELPINDENT HELPINDENT "x := Height of text drawing area (default 0 )\n"
-         HELPINDENT HELPINDENT "     0 means unbound\n\n"
-         HELPINDENT "-m|--multiline:\n"
-         HELPINDENT HELPINDENT "Enable multiline mode. Text gets automaticly wrapped, if\n"
-         HELPINDENT HELPINDENT "exceeds width of text drawing area.\n\n"
-         HELPINDENT "-w|--width <x>:\n"
-         HELPINDENT HELPINDENT "x := Width of text drawing area(default 0 )\n"
-         HELPINDENT HELPINDENT "     0 means unbound\n\n"
-         HELPINDENT "-x|--xoffset <x>:\n"
-         HELPINDENT HELPINDENT "x := x position of text area.\n\n"
-         HELPINDENT "-y|--yoffset <x>:\n"
-         HELPINDENT HELPINDENT "x := y position of text area.\n\n";
-}
-
-int cTextGraphic::ParseArg(int val, const char *arg)
-{
-  int r = 0;
-  switch (val) {
-    case 1:
-         text = strdup(arg);
-         break;
-    case 'a': {
-         char *endp;
-         int newalign  = strtol(arg, &endp, 0);
-         if (arg != endp) {
-            alignment = newalign;
-            }
-         else {
-            r = -1;
-            }
-         }
-         break;
-    case 'f':
-         if (isnumber(arg)) {
-            int newfont = atoi(arg);
-            if (newfont >= 0 && newfont < eDvbFontSize)
-               fontType = (eDvbFont) newfont;
-            else
-                 r = -1;
-            }
-         else
-            r = -1;
-         break;
-    case 'e':
-         if (isnumber(arg)) {
-            int newenc = atoi(arg);
-            if (newenc >= 0 && newenc < eDvbCodeSize)
-               encoding = (eDvbCode) newenc;
-            else
-                 r = -1;
-            }
-         else
-            r = -1;
-         break;
-    case 'w':
-         if (isnumber(arg)) {
-            const int newwidth = atoi(arg);
-            if (newwidth > 0 && newwidth <= 720)
-               twidth = newwidth;
-            else
-               r = -1;
-            }
-         else
-            r = -1;
-         break;
-    case 'H':
-         if (isnumber(arg)) {
-            const int newheight = atoi(arg);
-            if (newheight > 0 && newheight <= 576)
-               theight = newheight;
-            else
-               r = -1;
-            }
-         else
-            r = -1;
-         break;
-    case 'x':
-         if (isnumber(arg)) {
-            const int newx = atoi(arg);
-            if (newx > 0 && newx <= 720)
-               tx = newx;
-            else
-               r = -1;
-            }
-         else
-            r = -1;
-         break;
-    case 'y':
-         if (isnumber(arg)) {
-            const int newy = atoi(arg);
-            if (newy > 0 && newy <= 576)
-               ty = newy;
-            else
-               r = -1;
-            }
-         else
-            r = -1;
-         break;
-    case 'm':
-         multiline = true;
-         break;
-    default:
-         r = -1;
-    }
-  return r;
-}
-
-bool cTextGraphic::Paint(void) {
-  overlay = overlay && !(bgColor & 0xFF000000);
-  if (!Init())
-     return false;
-
-  if (!overlay) {
-     tIndex bgIndex = osd->GetBitmap(0)->Index(bgColor);
-     if (bgIndex)
-        memset(osd->GetBitmap(0)->GetBuffer(), bgIndex, width *height);
-     }
-  if (!(bgColor & 0xFF000000) || overlay) {
-     osd->GetBitmap(0)->Clean();
-     }
-
-  cFont::SetCode(encoding);
-  const cFont *font = cFont::GetFont(fontType);
-  if (!font) {
-     ERROR("Cannot get font!");
-     return false;
-     }
-
-  if (multiline) {
-     int area_width = width - tx;
-     int area_height = height - ty;
-     if (twidth && twidth < area_width)
-        area_width = twidth;
-     if (theight && theight < area_height)
-        area_height = theight;
-     cTextWrapper textWrap(text, font, area_width);
-     const int lineHeight = font->Height();
-     const int lineCount = (lineHeight * textWrap.Lines() > area_height ?
-                            area_height / lineHeight : textWrap.Lines());
-     int y_pos;
-     if (alignment & taTop) {
-        y_pos = ty;
-        }
-     else if (alignment & taBottom) {
-        y_pos = area_height - (lineCount * lineHeight);
-        }
-     else { // centered
-        y_pos = (area_height - (lineCount * lineHeight)) >> 1;
-        }
-     for (int i = 0; i < lineCount; i++) {
-         osd->DrawText(tx, y_pos, textWrap.GetLine(i), fgColor, clrTransparent,
-                                               font, area_width, 0, alignment);
-         y_pos += lineHeight;
-         }
-     }
-  else {
-     osd->DrawText(tx, ty, text, fgColor, clrTransparent, font, twidth,
-                                                   theight, alignment);
-     }
-  osd->Flush();
-  return true;
-}
-
-// --- cBitmapGraphic --------------------------------------------------------
-
-class cBitmapGraphic : public cCommonGraphic {
-private:
-  static const char *optstring;
-  static const struct option longopts[];
-  char *filename;
-  int bx;
-  int by;
-public:
-  static cCommonGraphic *New(cCommonGraphic &common) { return new cBitmapGraphic(common); }
-  cBitmapGraphic(cCommonGraphic &common) : cCommonGraphic(common) {
-    filename = NULL;
-    bx = 0;
-    by = 0;
-    }
-  virtual ~cBitmapGraphic() { free(filename); }
-  virtual const char *OptionString(void) const {
-    return optstring;
-    }
-  virtual const struct option *LongOption(void) const {
-    return longopts;
-    }
-  virtual int ParseArg(int val, const char *arg);
-  virtual const char *Help(void) const;
-  virtual bool CheckParameter(void) {
-    if (!filename) {
-       ERROR("No xpm file name given!");
-       return false;
-       }
-    return true;
-    }
-  virtual bool Paint(void);
-  };
-
-const char *cBitmapGraphic::optstring = "-x:y:" HELPSHORTOPTION;
-const struct option cBitmapGraphic::longopts[] = {
-  { "xoffset", 1, NULL, 'x'},
-  { "yoffset", 1, NULL, 'y'},
-  { HELPLONGOPTION, 2, NULL, HELPCHAR},
-  { NULL, 0, NULL, 0}
-};
-
-const char *cBitmapGraphic::Help(void) const
-{
-  return "command usage: drawbitmap [<drawbitmap options>] <xpm filename>\n\n"
-         "Draws XPM bitmap in <xpm filename>  on osd.\n"
-         "If background color is specified in common options and its not fully transparent\n"
-         "The whole osd-bounding box gets filled with it before drawing.\n\n"
-         "drawbitmap options:\n"
-         HELPINDENT "-x|--xoffset <x>:\n"
-         HELPINDENT HELPINDENT "x := x position of bitmap.\n\n"
-         HELPINDENT "-y|--yoffset <x>:\n"
-         HELPINDENT HELPINDENT "x := y position of bitmap.\n\n";
-}
-
-int cBitmapGraphic::ParseArg(int val, const char *arg)
-{
-  int r = 0;
-  switch (val) {
-    case 1:
-         filename = strdup(arg);
-         break;
-    case 'x':
-         if (isnumber(arg)) {
-            const int newx = atoi(arg);
-            if (newx > 0 && newx <= 720)
-               bx = newx;
-            else
-               r = -1;
-            }
-         else
-            r = -1;
-         break;
-    case 'y':
-         if (isnumber(arg)) {
-            const int newy = atoi(arg);
-            if (newy > 0 && newy <= 576)
-               by = newy;
-            else
-               r = -1;
-            }
-         else
-            r = -1;
-         break;
-    default:
-         r = -1;
-    }
-  return r;
-}
-
-bool cBitmapGraphic::Paint(void) {
-  if (clearOnStart  && !(bgColor & 0xFF000000)) {
-     dsyslog("DEBUG: cBitmapGraphic::Paint(): using direct draw");
-     x += bx;
-     y += by;
-     width -= bx;
-     height -= by;
-     if (!Init())
-        return false;
-     int saved_width = width;
-     int saved_height = height;
-     cBitmap *bitmap = osd->GetBitmap(0);
-     if (!bitmap->LoadXpm(filename)){
-        ERROR("Cannot load bitmap %s",filename);
-        return false;
-        }
-     saved_width = min(bitmap->Width() , saved_width) - 1;
-     saved_height = min(bitmap->Height(), saved_height) - 1;
-     bitmap->Clean();
-     tIndex saved = *bitmap->Data(0,0);
-     bitmap->SetIndex(0,0, 0xFF);
-     bitmap->SetIndex(0,0, saved);
-     saved = *bitmap->Data(saved_width,saved_height);
-     bitmap->SetIndex(saved_width,saved_height, 0xFF);
-     bitmap->SetIndex(saved_width,saved_height, saved);
-     osd->Flush();
-     return true;
-     }
-
-  overlay = overlay && !(bgColor & 0xFF000000);
-  if (!Init())
-     return false;
-
-  if (!overlay) {
-     tIndex bgIndex = osd->GetBitmap(0)->Index(bgColor);
-     if (bgIndex)
-        memset(osd->GetBitmap(0)->GetBuffer(), bgIndex, width *height);
-     }
-
-  if (!(bgColor & 0xFF000000) || overlay) {
-     osd->GetBitmap(0)->Clean();
-     }
-
-  cBitmap bitmap(1,1,8);
-
-  if (!bitmap.LoadXpm(filename)){
-     ERROR("Cannot load bitmap %s",filename);
-     return false;
-     }
-
-
-
-  osd->DrawBitmap(bx, by, bitmap, 0, 0, false, !(bitmap.Color(0) && 0xFF000000));
-  osd->Flush();
-  return true;
-}
-
-// --- cRectangle ------------------------------------------------------------
-class cRectangleGraphic : public cCommonGraphic {
-private:
-  static const char *optstring;
-  static const struct option longopts[];
-public:
-  static cCommonGraphic *New(cCommonGraphic &common) { return new cRectangleGraphic(common); }
-  cRectangleGraphic(cCommonGraphic &common) : cCommonGraphic(common) {  }
-  virtual const char *OptionString(void) const {
-    return optstring;
-    }
-  virtual const struct option *LongOption(void) const {
-    return longopts;
-    }
-  virtual int ParseArg(int val, const char *arg) { return -1; }
-  virtual const char *Help(void) const;
-  virtual bool CheckParameter(void) {  return true; }
-  virtual bool Paint(void);
-  };
-
-const char *cRectangleGraphic::optstring = "-" HELPSHORTOPTION;
-const struct option cRectangleGraphic::longopts[] = {
-  { HELPLONGOPTION, 2, NULL, HELPCHAR},
-  { NULL, 0, NULL, 0}
-};
-
-const char *cRectangleGraphic::Help(void) const
-{
-  return "command usage: drawrectangle\n\n"
-         "Draws rectangle with foreground color on the whole osd-bound box as\n"
-         "specified in common options\n\n";
-}
-
-
-
-bool cRectangleGraphic::Paint(void) {
-  overlay = false;
-  if (!Init())
-     return false;
-
-  tIndex fgIndex = osd->GetBitmap(0)->Index(fgColor);
-  if (fgIndex)
-     memset(osd->GetBitmap(0)->GetBuffer(), fgIndex, width *height);
-
-  osd->Flush();
-  return true;
-}
-
-// --- cSlopeGraphic --------------------------------------------------------
-
-class cSlopeGraphic : public cCommonGraphic {
-private:
-  static const char *optstring;
-  static const struct option longopts[];
-  int type;
-
-public:
-  static cCommonGraphic *New(cCommonGraphic &common) { return new cSlopeGraphic(common); }
-  cSlopeGraphic(cCommonGraphic &common) : cCommonGraphic(common) {
-    type = 0;
-    }
-  virtual const char *OptionString(void) const {
-    return optstring;
-    }
-  virtual const struct option *LongOption(void) const {
-    return longopts;
-    }
-  virtual int ParseArg(int val, const char *arg);
-  virtual const char *Help(void) const;
-  virtual bool CheckParameter(void) { return true; }
-  virtual bool Paint(void);
-  };
-
-const char *cSlopeGraphic::optstring = "-t:" HELPSHORTOPTION;
-const struct option cSlopeGraphic::longopts[] = {
-  { "type", 1, NULL, 't'},
-  { HELPLONGOPTION, 2, NULL, HELPCHAR},
-  { NULL, 0, NULL, 0}
-};
-
-const char *cSlopeGraphic::Help(void) const
-{
-  return "command usage: drawslope [<drawslope options>]\n\n"
-         "Draws a slope with foreground color in the osd bounding box.\n"
-         "If background color is specified in common options and its not fully transparent\n"
-         "The whole osd-bounding box gets filled with it before drawing.\n\n"
-         "drawslope options:\n"
-         HELPINDENT "-t|--type <n>:\n"
-         HELPINDENT HELPINDENT "n :=  Slope Direction\n"
-         HELPINDENT HELPINDENT "0   horizontal, rising,  lower (default)\n"
-         HELPINDENT HELPINDENT "1   horizontal, rising,  upper\n"
-         HELPINDENT HELPINDENT "2   horizontal, falling, lower\n"
-         HELPINDENT HELPINDENT "3   horizontal, falling, upper\n"
-         HELPINDENT HELPINDENT "4   vertical,   rising,  lower\n"
-         HELPINDENT HELPINDENT "5   vertical,   rising,  upper\n"
-         HELPINDENT HELPINDENT "6   vertical,   falling, lower\n"
-         HELPINDENT HELPINDENT "7   vertical,   falling, upper\n\n";
-}
-
-int cSlopeGraphic::ParseArg(int val, const char *arg)
-{
-  int r = 0;
-  switch (val) {
-    case 't':
-         if (isnumber(arg)) {
-            const int newtype = atoi(arg);
-            if (newtype >= 0 && newtype <= 7)
-               type = newtype;
-            else
-               r = -1;
-            }
-         else
-            r = -1;
-         break;
-    default:
-         r = -1;
-    }
-  return r;
-}
-
-bool cSlopeGraphic::Paint(void) {
-  overlay = overlay && !(bgColor & 0xFF000000);
-  if (!Init())
-     return false;
-
-  if (!overlay) {
-     tIndex bgIndex = osd->GetBitmap(0)->Index(bgColor);
-     if (bgIndex)
-        memset(osd->GetBitmap(0)->GetBuffer(), bgIndex, width * height);
-     }
-
-  if (!(bgColor & 0xFF000000) || overlay) {
-     osd->GetBitmap(0)->Clean();
-     }
-
-  osd->DrawSlope(0, 0, width, height, fgColor, type);
-  osd->Flush();
-  return true;
-}
-
-// --- cEllipseGraphic --------------------------------------------------------
-
-class cEllipseGraphic : public cCommonGraphic {
-private:
-  static const char *optstring;
-  static const struct option longopts[];
-  int type;
-
-public:
-  static cCommonGraphic *New(cCommonGraphic &common) { return new cEllipseGraphic(common); }
-  cEllipseGraphic(cCommonGraphic &common) : cCommonGraphic(common) {
-    type = 0;
-    }
-  virtual const char *OptionString(void) const {
-    return optstring;
-    }
-  virtual const struct option *LongOption(void) const {
-    return longopts;
-    }
-  virtual int ParseArg(int val, const char *arg);
-  virtual const char *Help(void) const;
-  virtual bool CheckParameter(void) { return true; }
-  virtual bool Paint(void);
-  };
-
-const char *cEllipseGraphic::optstring = "-t:" HELPSHORTOPTION;
-const struct option cEllipseGraphic::longopts[] = {
-  { "type", 1, NULL, 't'},
-  { HELPLONGOPTION, 2, NULL, HELPCHAR},
-  { NULL, 0, NULL, 0}
-};
-
-const char *cEllipseGraphic::Help(void) const
-{
-  return "command usage: drawellipse [<drawellipse options>]\n\n"
-         "Draws a ellipse with foreground color in the osd bounding box.\n"
-         "If background color is specified in common options and its not fully transparent\n"
-         "The whole osd-bounding box gets filled with it before drawing.\n\n"
-         "drawellipse options:\n"
-         HELPINDENT "-t|--type <n>:\n"
-         HELPINDENT HELPINDENT "n :=  Ellipse drawing type (negative value draws inverted)\n"
-         HELPINDENT HELPINDENT "0   draws entire ellipse (default)\n"
-         HELPINDENT HELPINDENT "1   draws only the first quadrant\n"
-         HELPINDENT HELPINDENT "2   draws only the second quadrant\n"
-         HELPINDENT HELPINDENT "3   draws only the third quadrant\n"
-         HELPINDENT HELPINDENT "4   draws only the fourth quadrant\n"
-         HELPINDENT HELPINDENT "5   draws the right half\n"
-         HELPINDENT HELPINDENT "6   draws the top half\n"
-         HELPINDENT HELPINDENT "7   draws the left half\n"
-         HELPINDENT HELPINDENT "8   draws the bottom half\n\n";
-}
-
-int cEllipseGraphic::ParseArg(int val, const char *arg)
-{
-  int r = 0;
-  switch (val) {
-    case 't':
-         if (isnumber(arg) || (*arg == '-' && isnumber(arg +1))) {
-            const int newtype = atoi(arg);
-            if (newtype >= -4 && newtype <= 8)
-               type = newtype;
-            else
-               r = -1;
-            }
-         else
-            r = -1;
-         break;
-    default:
-         r = -1;
-    }
-  return r;
-}
-
-bool cEllipseGraphic::Paint(void) {
-  overlay = overlay && !(bgColor & 0xFF000000);
-  if (!Init())
-     return false;
-
-  if (!overlay) {
-     tIndex bgIndex = osd->GetBitmap(0)->Index(bgColor);
-     if (bgIndex)
-        memset(osd->GetBitmap(0)->GetBuffer(), bgIndex, width * height);
-     }
-
-  if (!(bgColor & 0xFF000000) || overlay) {
-     osd->GetBitmap(0)->Clean();
-     }
-
-  osd->DrawEllipse(0, 0, width, height, fgColor, type);
-  osd->Flush();
-  return true;
-}
-
-// --- Main Part -------------------------------------------------------------
-struct sCommands {
- const char *name;
- cCommonGraphic* (*init) (cCommonGraphic&);
-};
-
-static sCommands commands[] = {
-  { "drawtext", cTextGraphic::New },
-  { "drawbitmap", cBitmapGraphic::New },
-  { "drawrectangle", cRectangleGraphic::New },
-  { "drawslope", cSlopeGraphic::New },
-  { "drawellipse", cEllipseGraphic::New },
-  { NULL, NULL}
-};
-
-
-static void printHelp(cCommonGraphic *com, cCommonGraphic *gra, const char *arg)
-{
-  printf(TITLESTR);
-  printf(USAGESTR);
-  if (!arg) {
-     if (!gra) {
-        printf(com->Help());
-        printf("Commands are: ");
-        for (int i = 0; commands[i].name; i++) {
-            printf("%s ", commands[i].name);
-            }
-        printf("\n\nUse --help all for help on all commands or --help <command> for help on <command>.\n");
-        }
-     else {
-        printf(gra->Help());
-        }
-     return;
-     }
-
-  if (!strcasecmp("all",arg)) {
-     printf(com->Help());
-     for (int i = 0; commands[i].name; i++) {
-         cCommonGraphic *cur = commands[i].init(*com);
-         printf(cur->Help());
-         delete cur;
-         }
-     return;
-     }
-
-  for (int i = 0; commands[i].name; i++) {
-      if (!strcasecmp(commands[i].name,arg)) {
-         cCommonGraphic *cur = commands[i].init(*com);;
-         printf(cur->Help());
-         delete cur;
-         return;
-         }
-      }
-
-  ERROR("Command %s unknown", arg);
-
-}
-
-int main (int argc, char **argv) {
-  cCommonGraphic common;
-  int val;
-  while ((val = getopt_long(argc, argv, common.OptionString(),
-                              common.LongOption(), NULL)) > 1) {
-        switch (val) {
-          case 'h':
-               printHelp(&common,NULL,(!optarg && optind < argc &&
-                 argv[optind][0] != '-' ? argv[optind] : optarg) );
-               return 0;
-          case '?':
-               ERROR("Illegal option");
-               return -1;
-          case ':':
-               ERROR("Missing parameter");
-               return -1;
-          default:
-               if (common.ParseArg(val,optarg) < 0) {
-                  ERROR("Invalid parameter");
-                  return -1;
-                  }
-          }
-        }
-
-  if (!common.CheckParameter())
-     return -1;
-
-  if (val != 1) {
-     ERROR("No command given!");
-     return -1;
-     }
-
-  int cmd = -1;
-  for (int i = 0; commands[i].name; i++)
-      if (!strcasecmp(commands[i].name,optarg)) {
-         cmd = i;
-         break;
-         }
-
-  if (cmd == -1) {
-     ERROR("Unknown command %s", optarg);
-     return -1;
-     }
-
-
-  cCommonGraphic *commandGraphic = commands[cmd].init(common);
-  while ((val = getopt_long(argc, argv, commandGraphic->OptionString(),
-                              commandGraphic->LongOption(), NULL)) > 0) {
-        switch (val) {
-          case 'h':
-               printHelp(&common,commandGraphic,(!optarg && optind < argc &&
-                 argv[optind][0] != '-' ? argv[optind] : optarg));
-               delete commandGraphic;
-               return 0;
-          case '?':
-               ERROR("Illegal option");
-               delete commandGraphic;
-               return -1;
-          case ':':
-               ERROR("Missing parameter");
-               delete commandGraphic;
-               return -1;
-          default:
-               if (commandGraphic->ParseArg(val,optarg) < 0) {
-                  ERROR("Invalid parameter");
-                  delete commandGraphic;
-                  return -1;
-                  }
-          }
-        }
-
-  if (!commandGraphic->CheckParameter()) {
-     delete commandGraphic;
-     return -1;
-     }
-
-  commandGraphic->Paint();
-  delete commandGraphic;
-  return 0;
-}
diff -Naur VDR-NG-EM-orig/tools.c VDR-NG-EM/tools.c
--- VDR-NG-EM-orig/tools.c	Mon Oct 01 11:36:10 2007
+++ VDR-NG-EM/tools.c	Wed Mar 12 18:19:41 2008
@@ -48,8 +48,7 @@
 
 
 #define MAXSYSLOGBUF 256
-//M7X0 BEGIN AK
-#ifndef OSDPAINTER
+
 void syslog_with_tid(int priority, const char *format, ...)
 {
   va_list ap;
@@ -59,8 +58,6 @@
   vsyslog(priority, fmt, ap);
   va_end(ap);
 }
-#endif
-//M7X0 END AK
 int BCD2INT(int x)
 {
   return ((1000000 * BCDCHARTOINT((x >> 24) & 0xFF)) +
@@ -634,8 +631,7 @@
   vasprintf(&buffer, fmt, ap);
   return cString(buffer, true);
 }
-//M7X0 BEGIN AK
-#ifndef OSDPAINTER
+
 cString WeekDayName(int WeekDay)
 {
   char buffer[4];
@@ -695,8 +691,6 @@
   strftime(buf, sizeof(buf), "%R", localtime_r(&t, &tm_r));
   return buf;
 }
-#endif
-//M7X0 END AK
 // --- RgbToJpeg -------------------------------------------------------------
 //M7X0 BEGIN AK
 #ifdef WITH_LIBJPEG
diff -Naur VDR-NG-EM-orig/tools.h VDR-NG-EM/tools.h
--- VDR-NG-EM-orig/tools.h	Mon Oct 01 11:36:10 2007
+++ VDR-NG-EM/tools.h	Wed Mar 12 18:20:44 2008
@@ -105,9 +105,8 @@
 template<class T> inline void swap(T &a, T &b) { T t = a; a = b; b = t; }
 #endif
 
-#ifndef OSDPAINTER
 void syslog_with_tid(int priority, const char *format, ...) __attribute__ ((format (printf, 2, 3)));
-#endif
+
 //M7X0 END AK
 
 #define BCDCHARTOINT(x) (10 * ((x & 0xF0) >> 4) + (x & 0xF))
@@ -173,16 +172,12 @@
 bool SpinUpDisk(const char *FileName);
 void TouchFile(const char *FileName);
 time_t LastModifiedTime(const char *FileName);
-//M7X0 BEGIN AK
-#ifndef OSDPAINTER
 cString WeekDayName(int WeekDay);
 cString WeekDayName(time_t t);
 cString DayDateTime(time_t t = 0);
 cString TimeToString(time_t t);
 cString DateString(time_t t);
 cString TimeString(time_t t);
-#endif
-//M7X0 END
 uchar *RgbToJpeg(uchar *Mem, int Width, int Height, int &Size, int Quality = 100);
     ///< Converts the given Memory to a JPEG image and returns a pointer
     ///< to the resulting image. Mem must point to a data block of exactly
