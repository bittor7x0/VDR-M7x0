Speed-ups from VDR-Extensions-Patch-72 for VDR 1.7.7 (http://www.zulu-entertainment.de).

VDR 1.7.14 backports applied in this patch:
* Implemented handling the "Content Descriptor" (based on a patch from Rolf
  Ahrenberg). The 'classic' and 'sttng' skins display the textual
  representation of the content descriptors as "genre". The epg.data file stores
  the genre using the tag character 'G'.
* Implemented handling the "Parental Rating Descriptor" (based on a patch from Rolf
  Ahrenberg). The 'classic' and 'sttng' skins display the parental
  rating (if given) in their event displays. The epg.data file stores
  the parental rating using the tag character 'R'.
  IMPORTANT NOTE: if VDR doesn't display a parental rating, this does not
  necessarily mean that the given programme is suitable for all audiences!
* The new Setup parameter "Channel entry timeout" can be used to customize the time
  since the last keypress until a numerically entered channel number is considered
  complete, and the channel is switched (suggested by Helmut Auer). Setting this
  parameter to 0 turns off the automatic channel switching, and the user will
  have to confirm the entry by pressing the "Ok" key.
* The "Source" item in the "Edit channel" menu now wraps around the list of sources
  (suggested by Halim Sahin).
* The new setup option "Recording/Pause key handling" can be used to define
  what happens if the Pause key on the remote control is pressed during
  live tv (thanks to Timo Eskola).
* The new setup option "Recording/Delete timeshift recording" controls whether a timeshift
  recording is automatically deleted after viewing it.
  This obsoletes the DELTIMESHIFTREC patch.
  Note that the meaning of the values for this option is different from the DELTIMESHIFTREC
  patch: 0 means timeshift recordings are not automatically deleted (the default behavior
  as in previous versions), while 1 means to ask the user whether the recording shall be
  deleted.
* Removed the compile time option VFAT to allow users of precompiled binary
  distributions to have full control over whether or not to use the --vfat option
  at runtime (suggested by Michael Nork).
* Modified handling invalid characters in VFAT mode.
* Made MAXFRAMESIZE a multiple of TS_SIZE to avoid breaking up TS packets.
* Improved logging system time changes to avoid problems on slow systems under
  heavy load (suggested by Helmut Auer).
* Running the thread that removes deleted recordings at a low priority to (maybe)
  avoid stuttering replay in case the thread is run during replay.
* Reduced the number of time(NULL) calls in vdr.c's main loop to a single call
  (thanks to Tobias Bratfisch).
* Improved numdigits(), isnumber() and strreplace() (thanks to Tobias Bratfisch).
* Made skipspace() an inline function (suggested by Tobias Bratfisch) and changed
  it to handle the most common case of 'no leading space' very fast, and avoid
  calling isspace(), which made the whole function a lot faster.
* Fixed a problem with characters >0x7F in the modified version of skipspace()
  (thanks to Marco Schlüßler).
* Changed the EIT filter setup to save a few handles on devices that do hardware
  filtering.
* Changed the EVCONTENTMASK_* macros to enums and changed "mask" to "group".
* Ignoring "repeat" and "release" keys in the time search entry mode during replay,
  to avoid inadvertently leaving it in case a key is pressed too long (suggested
  by Andreas Brugger).
* Improved cControl::Launch() to keep 'control' from pointing to uninitialized
  memory (thanks to Rolf Ahrenberg).
* Removed unneeded include files <linux/dvb/dmx.h> and <time.h> from remux.h
  (reported by Tobias Grimm).
* Stripping control codes 0x86 and 0x87 from SI strings.
* Optimized cNitFilter::Process() (thanks to Tobias Bratfisch).
* Optimized cMenuEditChrItem::Set() (thanks to Tobias Bratfisch).
* Improved performance of the SVDRP commands LSTC and CHAN when used with a
  channel name.
* The SVDRP command LSTC can now list the channels with group separators if the
  option ':groups' is given (thanks to Andreas Mair).
* The SVDRP command PUTE now supports reading the EPG data from a given file
  (thanks to Helmut Auer).
* Added a debug error message to cReceiver::~cReceiver() in case it is still
  attached to a device (thanks to Reinhard Nissl).
* cBitmap::SetXpm() now checks whether the given Xpm pointer is not NULL, to
  avoid a crash with files that only contain "/* XPM */" (suggested by Andreas
  Mair).
* Resetting a timer's 'pending' flag when it has ended.
* Added some missing 'const' keywords (thanks to Sascha Volkenandt).
* Added some missing 'const' keywords to avoid compilation errors with gcc 4.4
  (thanks to Ville Skyttä and Ludwig Nussel).
* Added the backslash ('\') to the list of characters that need to be escaped
  when executing external commands (thanks to Peter Bieringer for reporting this one).
* The section handler is now stopped before the device is destroyed, to avoid
  accessing file handles after they have become invalid (thanks to Reinhard
  Nissl for reporting an invalid access when ending VDR, and to Deti Fliegl for
  a patch that was used to implement StopSectionHandler()).
* Fixed the format in cRemote::Put() to use "%016llX" instead of "%016LX" (thanks
  to Ludwig Nussel for pointing this out).
* Fixed variable types in cIndexFile (reported by Udo Richter).
* Fixed cOsdMenu::Display() in case the menu size has changed (thanks to
  Reinhard Nissl).
* Added plain text error messages to log entries from cOsd::SetAreas() (suggested
  by Rolf Ahrenberg).
* Added a missing Channels.SetModified(true) call when deleting or moving a
  channel in the Channels menu (reported by Halim Sahin).
* Added a missing SetVolumeDevice() call in cDevice::SetPrimaryDevice() (reported
  by Reinhard Nissl).
* Fixed a problem with calling isyslog() from within the SignalHandler() (thanks
  to Udo Richter).
* Fixed handling kLeft in the calls to cStatus::MsgOsdTextItem() (thanks to
  Alexander Rieger).
* Fixed a possible integer overflow in GetAbsTime() (thanks to Alexander Rieger).
* Fixed wrong value for TableIdBAT in libsi/si.h (thanks to Winfried Köhler).
* Fixed initializing the timer's flags in the cTimer copy constructor (thanks to
  Andreas Mair).
* Fixed the MEGABYTE() macro to make it correctly handle parameters resulting in
  values larger than 2GB.
* Added a missing 'P' to vdr.c's SHUTDOWNCANCELROMPT macro (reported by Marco
  Schlüßler).
* Fixed checking for ttDolbyLast in cDevice::SetCurrentAudioTrack() (thanks
  to Marco Schlüßler).
* Fixed handling address masks in SVDRP host settings (thanks to Frank Schmirler).
* If svdrphosts.conf contains only the address of the local host, the SVDRP port
  is opened only for the local host (thanks to Manuel Reimer).
* Added a missing reset of maxNumber in cChannels::Renumber() (reported by Sundararaj
  Reel).
* Fixed tuning to a live channel after a recording has been stopped using the
  'Back' key.
* Added a missing '.' to the date returned by DayDateTime() (thanks to Lauri Nurmi).
* Fixed decoding filename characters in case there are not two hex digits after
  the '#' (reported by Helmut Auer).
* Fixed selecting the audio track when pressing Ok in the Audio menu (thanks
  to Marco Schlüßler).
* Fixed a missing '-' at the next to last line of SVDRP help texts (reported by
  Denis Knauf).
* Fixed a crash when pressing Left while at the first character of a cMenuEditStrItem
  (thanks to Christian Wieninger).
* Channel names containing commas are now handled correctly in channels.conf.
  If a channel's short name contains a comma, it is replaced with a '.'.
* Removed the workaround for short channel names of "Kabel Deutschland", because
  apparently they now have their data according to the DVB standard (thanks to
  Johann Friedrichs).
* cDevice now logs the device number when a new device is created.
* Improved SPU handling on devices with limited OSD capabilities (thanks to
  Matthieu Castet).
* Improved cDvbSpuBitmap::getMinBpp() (thanks to Matthieu Castet and Johann
  Friedrichs).
* Some fixes to dvbspu.[hc] (thanks to Johann Friedrichs).
* Fixed plugin arguments corruption with glibc 2.11 on x86_64 (thanks to
  Anssi Hannula).
* cPatFilter::Process() now only stores CA descriptors for video and audio pids
  (thanks to Francesco Saverio Schiavarelli for reporting a problem with channels
  that have some encrypted components that VDR doesn't use).
* Several code modifications to avoid compiler warnings (thanks to Winfried Köhler).
* Fixed compiler warnings "format not a string literal and no format arguments"
  in some syslog calls (thanks to Rolf Ahrenberg).
* Fixed not logging changes for channels that have no number
  (reported by Timothy D. Lenz).
* Fixed saving terminal settings when running in background (thanks to Manuel
  Reimer).
* The new command line option --edit can be used to edit a recording without
  actually starting the entire VDR (based on a patch from Helmut Auer).
* Rearranged cEvent members to minimize memory waste.
* After a CLRE command, no further EPG processing is now done for 10 seconds,
  so that data sent with subsequent PUTE commands doesn't interfere with data
  from the broadcasters (suggested by Helmut Auer).
* Fixed adding new transponders in case there is only a single channel in the
  channel list (reported by Halim Sahin).
* The new setup option "Folders in timer menu" controls whether the file names in
  the timer menu are shown with their full folder path.
* The full timer file name is now displayed if it ends with "TITLE" or "EPISODE"
  (pointed out by Udo Richter).
* cSafeFile::Close() now flushes the file (suggested by Stephan Austermühle).


diff -Naur VDR-NG-orig/channels.c VDR-NG/channels.c
--- VDR-NG-orig/channels.c	2010-02-10 16:57:06.000000000 +0100
+++ VDR-NG/channels.c	2010-02-10 16:58:58.000000000 +0100
@@ -26,7 +26,7 @@
   {   0, INVERSION_OFF },
   {   1, INVERSION_ON },
   { 999, INVERSION_AUTO },
-  { -1 }
+  {  -1, 0 }
   };
 
 const tChannelParameterMap BandwidthValues[] = {
@@ -34,7 +34,7 @@
   {   7, BANDWIDTH_7_MHZ },
   {   8, BANDWIDTH_8_MHZ },
   { 999, BANDWIDTH_AUTO },
-  { -1 }
+  {  -1, 0 }
   };
 
 const tChannelParameterMap CoderateValues[] = {
@@ -48,7 +48,7 @@
   {  78, FEC_7_8 },
   {  89, FEC_8_9 },
   { 999, FEC_AUTO },
-  { -1 }
+  {  -1, 0 }
   };
 
 const tChannelParameterMap ModulationValues[] = {
@@ -59,14 +59,14 @@
   { 128, QAM_128 },
   { 256, QAM_256 },
   { 999, QAM_AUTO },
-  { -1 }
+  {  -1, 0 }
   };
 
 const tChannelParameterMap TransmissionValues[] = {
   {   2, TRANSMISSION_MODE_2K },
   {   8, TRANSMISSION_MODE_8K },
   { 999, TRANSMISSION_MODE_AUTO },
-  { -1 }
+  {  -1, 0 }
   };
 
 const tChannelParameterMap GuardValues[] = {
@@ -75,7 +75,7 @@
   {  16, GUARD_INTERVAL_1_16 },
   {  32, GUARD_INTERVAL_1_32 },
   { 999, GUARD_INTERVAL_AUTO },
-  { -1 }
+  {  -1, 0 }
   };
 
 const tChannelParameterMap HierarchyValues[] = {
@@ -84,7 +84,7 @@
   {   2, HIERARCHY_2 },
   {   4, HIERARCHY_4 },
   { 999, HIERARCHY_AUTO },
-  { -1 }
+  {  -1, 0 }
   };
 
 int UserIndex(int Value, const tChannelParameterMap *Map)
@@ -180,7 +180,7 @@
   modification = CHANNELMOD_NONE;
   schedule     = NULL;
   linkChannels = NULL;
-  refChannel   = NULL;
+  refChannels  = NULL;
 }
 
 cChannel::cChannel(const cChannel &Channel)
@@ -191,28 +191,26 @@
   portalName = NULL;
   schedule     = NULL;
   linkChannels = NULL;
-  refChannel   = NULL;
+  refChannels  = NULL;
   *this = Channel;
 }
 
 cChannel::~cChannel()
 {
-  delete linkChannels;
-  linkChannels = NULL; // more than one channel can link to this one, so we need the following loop
-  for (cChannel *Channel = Channels.First(); Channel; Channel = Channels.Next(Channel)) {
-      if (Channel->linkChannels) {
-         for (cLinkChannel *lc = Channel->linkChannels->First(); lc; lc = Channel->linkChannels->Next(lc)) {
-             if (lc->Channel() == this) {
-                Channel->linkChannels->Del(lc);
-                break;
-                }
-             }
-         if (Channel->linkChannels->Count() == 0) {
-            delete Channel->linkChannels;
-            Channel->linkChannels = NULL;
-            }
-         }
-      }
+  if (linkChannels) {
+     // in all channels which we link to remove the reference to us
+     for (cLinkChannel *lc = linkChannels->First(); lc; lc = linkChannels->Next(lc))
+         lc->Channel()->DelRefChannel(this);
+     delete linkChannels;
+     linkChannels = NULL;
+     }
+  if (refChannels) {
+     // in all channels which reference us remove their link to us
+     for (cLinkChannel *lc = refChannels->First(); lc; lc = refChannels->Next(lc))
+         lc->Channel()->DelLinkChannel(this);
+     delete refChannels;
+     refChannels = NULL;
+     }
   free(name);
   free(shortName);
   free(provider);
@@ -237,6 +235,7 @@
     case 'v': Frequency += 200000; break;
     case 'l': Frequency += 300000; break;
     case 'r': Frequency += 400000; break;
+    default: esyslog("ERROR: invalid value for Polarization '%c'", Polarization);
     }
   return Frequency;
 }
@@ -470,7 +469,8 @@
         q += IntArrayToString(q, Dpids, 10, DLangs);
         }
      *q = 0;
-     dsyslog("changing pids of channel %d from %d+%d:%s:%d to %d+%d:%s:%d", Number(), vpid, ppid, OldApidsBuf, tpid, Vpid, Ppid, NewApidsBuf, Tpid);
+     if (Number())
+         dsyslog("changing pids of channel %d from %d+%d:%s:%d to %d+%d:%s:%d", Number(), vpid, ppid, OldApidsBuf, tpid, Vpid, Ppid, NewApidsBuf, Tpid);
      vpid = Vpid;
      ppid = Ppid;
      for (int i = 0; i < MAXAPIDS; i++) {
@@ -491,14 +491,15 @@
 
 void cChannel::SetCaIds(const int *CaIds)
 {
-  if (caids[0] && caids[0] <= 0x00FF)
+  if (caids[0] && caids[0] <= CA_USER_MAX)
      return; // special values will not be overwritten
   if (IntArraysDiffer(caids, CaIds)) {
      char OldCaIdsBuf[MAXCAIDS * 5 + 10]; // 5: 4 digits plus delimiting ',', 10: paranoia
      char NewCaIdsBuf[MAXCAIDS * 5 + 10];
      IntArrayToString(OldCaIdsBuf, caids, 16);
      IntArrayToString(NewCaIdsBuf, CaIds, 16);
-     dsyslog("changing caids of channel %d from %s to %s", Number(), OldCaIdsBuf, NewCaIdsBuf);
+     if (Number())
+         dsyslog("changing caids of channel %d from %s to %s", Number(), OldCaIdsBuf, NewCaIdsBuf);
      for (int i = 0; i <= MAXCAIDS; i++) { // <= to copy the terminating 0
          caids[i] = CaIds[i];
          if (!CaIds[i])
@@ -514,7 +515,7 @@
   if (Level > 0) {
      modification |= CHANNELMOD_CA;
      Channels.SetModified();
-     if (Level > 1)
+     if (Number() && Level > 1)
         dsyslog("changing ca descriptors of channel %d", Number());
      }
 }
@@ -544,7 +545,7 @@
   q += sprintf(q, "linking channel %d from", Number());
   if (linkChannels) {
      for (cLinkChannel *lc = linkChannels->First(); lc; lc = linkChannels->Next(lc)) {
-         lc->Channel()->SetRefChannel(NULL);
+         lc->Channel()->DelRefChannel(this);
          q += sprintf(q, " %d", lc->Channel()->Number());
          }
      delete linkChannels;
@@ -555,19 +556,50 @@
   linkChannels = LinkChannels;
   if (linkChannels) {
      for (cLinkChannel *lc = linkChannels->First(); lc; lc = linkChannels->Next(lc)) {
-         lc->Channel()->SetRefChannel(this);
+         lc->Channel()->AddRefChannel(this);
          q += sprintf(q, " %d", lc->Channel()->Number());
          //dsyslog("link %4d -> %4d: %s", Number(), lc->Channel()->Number(), lc->Channel()->Name());
          }
      }
   else
      q += sprintf(q, " none");
-  dsyslog(buffer);
+  if (Number())
+     dsyslog("%s", buffer);
 }
 
-void cChannel::SetRefChannel(cChannel *RefChannel)
+void cChannel::AddRefChannel(cChannel *RefChannel)
 {
-  refChannel = RefChannel;
+  if (!refChannels)
+     refChannels = new cLinkChannels;
+  refChannels->Add(new cLinkChannel(RefChannel));
+}
+
+void cChannel::DelRefChannel(cChannel *RefChannel)
+{
+  for (cLinkChannel *lc = refChannels->First(); lc; lc = refChannels->Next(lc)) {
+      if (lc->Channel() == RefChannel) {
+         refChannels->Del(lc);
+         if (refChannels->Count() <= 0) {
+            delete refChannels;
+            refChannels = NULL;
+            }
+         return;
+         }
+      }
+}
+
+void cChannel::DelLinkChannel(cChannel *LinkChannel)
+{
+  for (cLinkChannel *lc = linkChannels->First(); lc; lc = linkChannels->Next(lc)) {
+      if (lc->Channel() == LinkChannel) {
+         linkChannels->Del(lc);
+         if (linkChannels->Count() <= 0) {
+            delete linkChannels;
+            linkChannels = NULL;
+            }
+         return;
+         }
+      }
 }
 
 static int PrintParameter(char *p, char Name, int Value)
@@ -649,6 +681,8 @@
   q += sprintf(q, "%s", Channel->name);
   if (!isempty(Channel->shortName))
      q += sprintf(q, ",%s", Channel->shortName);
+  else if (strchr(Channel->name, ','))
+     q += sprintf(q, ",");
   if (!isempty(Channel->provider))
      q += sprintf(q, ";%s", Channel->provider);
   *q = 0;
@@ -799,7 +833,7 @@
               while ((q = strtok_r(p, ",", &strtok_next)) != NULL) {
                     if (NumCaIds < MAXCAIDS) {
                        caids[NumCaIds++] = strtol(q, NULL, 16) & 0xFFFF;
-                       if (NumCaIds == 1 && caids[0] <= 0x00FF)
+                       if (NumCaIds == 1 && caids[0] <= CA_USER_MAX)
                           break;
                        }
                     else
@@ -816,7 +850,7 @@
            *p++ = 0;
            provider = strcpyrealloc(provider, p);
            }
-        p = strchr(namebuf, ',');
+        p = strrchr(namebuf, ','); // long name might contain a ',', so search for the rightmost one
         if (p) {
            *p++ = 0;
            shortName = strcpyrealloc(shortName, p);
@@ -910,14 +944,72 @@
   return false;
 }
 
+void cChannels::ClearChannelHashes(void)
+{
+  channelsHashSid.Clear();
+  channelsHashNidTid.Clear();
+}
+
 void cChannels::HashChannel(cChannel *Channel)
 {
   channelsHashSid.Add(Channel, Channel->Sid());
+  channelsHashNidTid.Add(Channel, HashKeyNidTid(Channel->Nid(), Channel->Tid()));
 }
 
 void cChannels::UnhashChannel(cChannel *Channel)
 {
   channelsHashSid.Del(Channel, Channel->Sid());
+  channelsHashNidTid.Del(Channel, HashKeyNidTid(Channel->Nid(), Channel->Tid()));
+}
+
+unsigned int cChannels::HashKeyNidTid(unsigned short Nid, unsigned short Tid)
+{
+  return Nid << 16 | Tid;
+}
+
+cIterator<cChannel> cChannels::GetChannelsBySourceNidTid(int Source, unsigned short Nid, unsigned short Tid)
+{
+  class cIteratorImplSourceNidTid : public cIteratorImpl {
+  private:
+    cList<cHashObject> *hashList;
+    cHashObject *current;
+    int source;
+    unsigned short nid;
+    unsigned short tid;
+    cChannel *FindMatchingChannel(bool reverse, bool reset = false) {
+      if (!hashList || (!current && !reset))
+         return NULL;
+      while (true) {
+            if (reset) {
+               reset = false;
+               current = reverse ? hashList->Last() : hashList->First();
+               }
+            else
+               current = reverse ? hashList->Prev(current) : hashList->Next(current);
+            if (!current)
+               break;
+            cChannel *Channel = (cChannel *)current->Object();
+            if (Channel->Source() == source && Channel->Nid() == nid && Channel->Tid() == tid)
+               return Channel;
+            }
+      return NULL;
+      }
+  public:
+    cIteratorImplSourceNidTid(cList<cHashObject> *HashList, int Source, unsigned short Nid, unsigned short Tid) {
+       hashList = HashList;
+       source = Source;
+       nid = Nid;
+       tid = Tid;
+       current = NULL;
+       }
+    virtual void *First(void) { return FindMatchingChannel(false, true); }
+    virtual void *Last(void)  { return FindMatchingChannel(true,  true); }
+    virtual void *Prev(void)  { return FindMatchingChannel(true);  }
+    virtual void *Next(void)  { return FindMatchingChannel(false); }
+    virtual void *Current(void) const  { return current ? (cChannel *)current->Object() : NULL; }
+    };
+
+  return cIterator<cChannel>(new cIteratorImplSourceNidTid(channelsHashNidTid.GetList(HashKeyNidTid(Nid, Tid)), Source, Nid, Tid));
 }
 
 int cChannels::GetNextGroup(int Idx)
@@ -952,9 +1044,10 @@
   return channel ? Idx : -1;
 }
 
-void cChannels::ReNumber( void )
+void cChannels::ReNumber(void)
 {
-  channelsHashSid.Clear();
+  ClearChannelHashes();
+  maxNumber = 0;
   int Number = 1;
   for (cChannel *channel = First(); channel; channel = Next(channel)) {
       if (channel->GroupSep()) {
diff -Naur VDR-NG-orig/channels.h VDR-NG/channels.h
--- VDR-NG-orig/channels.h	2010-02-10 16:57:08.000000000 +0100
+++ VDR-NG/channels.h	2010-02-10 16:58:58.000000000 +0100
@@ -147,9 +147,12 @@
   int modification;
   mutable const cSchedule *schedule;
   cLinkChannels *linkChannels;
-  cChannel *refChannel;
+  cLinkChannels *refChannels;
   cString ParametersToString(void) const;
   bool StringToParameters(const char *s);
+  void AddRefChannel(cChannel *RefChannel);
+  void DelRefChannel(cChannel *RefChannel);
+  void DelLinkChannel(cChannel *RefChannel);
 public:
   cChannel(void);
   cChannel(const cChannel &Channel);
@@ -199,7 +202,8 @@
   int Guard(void) const { return guard; }
   int Hierarchy(void) const { return hierarchy; }
   const cLinkChannels* LinkChannels(void) const { return linkChannels; }
-  const cChannel *RefChannel(void) const { return refChannel; }
+  const cChannel *RefChannel(void) const { return refChannels ? refChannels->Last()->Channel() : 0; }
+  const cLinkChannels* RefChannels(void) const { return refChannels; }
   bool IsCable(void) const { return cSource::IsCable(source); }
   bool IsSat(void) const { return cSource::IsSat(source); }
   bool IsTerr(void) const { return cSource::IsTerr(source); }
@@ -217,17 +221,52 @@
   void SetCaIds(const int *CaIds); // list must be zero-terminated
   void SetCaDescriptors(int Level);
   void SetLinkChannels(cLinkChannels *LinkChannels);
-  void SetRefChannel(cChannel *RefChannel);
   bool Filtered(void);
   };
 
+class cIteratorImpl {
+private:
+  int refCount;
+  cIteratorImpl(const cIteratorImpl &);
+  const cIteratorImpl &operator =(const cIteratorImpl &);
+public:
+  cIteratorImpl(void) { refCount = 0; }
+  virtual ~cIteratorImpl() {}
+  virtual int AddRef(void) { return ++refCount; }
+  virtual int DelRef(void) { int RefCount = --refCount; if (RefCount <= 0) delete this; return RefCount; }
+  virtual void *First(void) = 0;
+  virtual void *Last(void)  = 0;
+  virtual void *Prev(void)  = 0;
+  virtual void *Next(void)  = 0;
+  virtual void *Current(void) const = 0;
+  };
+
+template <class T> class cIterator
+{
+private:
+  cIteratorImpl *impl;
+public:
+  cIterator(cIteratorImpl *Impl) { impl = Impl; impl->AddRef(); }
+  cIterator(const cIterator &rhs) { impl = rhs.impl; impl->AddRef(); }
+  ~cIterator() { impl->DelRef(); }
+  const cIterator &operator =(const cIterator &rhs) { rhs.impl->AddRef(); impl->DelRef(); impl = rhs.impl; return *this; }
+  T *First(void) const   { return (T *)impl->First(); }
+  T *Last(void) const    { return (T *)impl->Last(); }
+  T *Prev(void) const    { return (T *)impl->Prev(); }
+  T *Next(void) const    { return (T *)impl->Next(); }
+  T *Current(void) const { return (T *)impl->Current(); }
+  };
+
 class cChannels : public cRwLock, public cConfig<cChannel> {
 private:
   int maxNumber;
   int modified;
   int beingEdited;
   cHash<cChannel> channelsHashSid;
+  cHash<cChannel> channelsHashNidTid;
   void DeleteDuplicateChannels(void);
+  void ClearChannelHashes(void);
+  static unsigned int HashKeyNidTid(unsigned short Nid, unsigned short Tid);
 public:
   cChannels(void);
   bool Load(const char *FileName, bool AllowComments = false, bool MustExist = false);
@@ -241,6 +280,7 @@
   cChannel *GetByNumber(int Number, int SkipGap = 0);
   cChannel *GetByServiceID(int Source, int Transponder, unsigned short ServiceID);
   cChannel *GetByChannelID(tChannelID ChannelID, bool TryWithoutRid = false, bool TryWithoutPolarization = false);
+  cIterator<cChannel> GetChannelsBySourceNidTid(int Source, unsigned short Nid, unsigned short Tid);
   int BeingEdited(void) { return beingEdited; }
   void IncBeingEdited(void) { beingEdited++; }
   void DecBeingEdited(void) { beingEdited--; }
diff -Naur VDR-NG-orig/config.c VDR-NG/config.c
--- VDR-NG-orig/config.c	2010-02-10 16:57:34.000000000 +0100
+++ VDR-NG/config.c	2010-02-10 17:16:10.000000000 +0100
@@ -82,7 +82,7 @@
      while ((c = fgetc(p)) != EOF) {
            if (l % 20 == 0)
               result = (char *)realloc(result, l + 21);
-           result[l++] = c;
+           result[l++] = char(c);
            }
      if (result)
         result[l] = 0;
@@ -137,9 +137,14 @@
   return result != 0 && (mask != 0 || addr.s_addr == 0);
 }
 
+bool cSVDRPhost::IsLocalhost(void)
+{
+  return addr.s_addr == htonl(INADDR_LOOPBACK);
+}
+
 bool cSVDRPhost::Accepts(in_addr_t Address)
 {
-  return (Address & mask) == addr.s_addr;
+  return (Address & mask) == (addr.s_addr & mask);
 }
 
 // -- cCommands --------------------------------------------------------------
@@ -167,6 +172,17 @@
 
 cSVDRPhosts SVDRPhosts;
 
+bool cSVDRPhosts::LocalhostOnly(void)
+{
+  cSVDRPhost *h = First();
+  while (h) {
+        if (!h->IsLocalhost())
+           return false;
+        h = (cSVDRPhost *)h->Next();
+        }
+  return true;
+}
+
 bool cSVDRPhosts::Acceptable(in_addr_t Address)
 {
   cSVDRPhost *h = First();
@@ -284,15 +300,18 @@
 //M7X0 END AK
   SVDRPTimeout = 300;
   ZapTimeout = 3;
+  ChannelEntryTimeout = 1000;
   PrimaryLimit = 0;
   DefaultPriority = 50;
   DefaultLifetime = 99;
+  PauseKeyHandling = 2;
   PausePriority = 10;
   PauseLifetime = 1;
   UseSubtitle = 1;
   UseVps = 0;
   VpsMargin = 120;
   RecordingDirs = 1;
+  FoldersInTimerMenu = 1;
   RecordingsSortMode = 0;
   RecordingsSortDirsFirst = 0;
   CutterAutoDelete = 1;
@@ -317,6 +336,7 @@
   MaxVideoFileSize = MAXVIDEOFILESIZE;
   MaxRecordingSize = DEFAULTRECORDINGSIZE;
   SplitEditedFiles = 0;
+  DelTimeshiftRec = 0;
   HardLinkCutter = 0;
   MinEventTimeout = 30;
   MinUserInactivity = 300;
@@ -482,15 +502,18 @@
 //M7X0 END AK
   else if (!strcasecmp(Name, "SVDRPTimeout"))        SVDRPTimeout       = atoi(Value);
   else if (!strcasecmp(Name, "ZapTimeout"))          ZapTimeout         = atoi(Value);
+  else if (!strcasecmp(Name, "ChannelEntryTimeout")) ChannelEntryTimeout= atoi(Value);
   else if (!strcasecmp(Name, "PrimaryLimit"))        PrimaryLimit       = atoi(Value);
   else if (!strcasecmp(Name, "DefaultPriority"))     DefaultPriority    = atoi(Value);
   else if (!strcasecmp(Name, "DefaultLifetime"))     DefaultLifetime    = atoi(Value);
+  else if (!strcasecmp(Name, "PauseKeyHandling"))    PauseKeyHandling   = atoi(Value);
   else if (!strcasecmp(Name, "PausePriority"))       PausePriority      = atoi(Value);
   else if (!strcasecmp(Name, "PauseLifetime"))       PauseLifetime      = atoi(Value);
   else if (!strcasecmp(Name, "UseSubtitle"))         UseSubtitle        = atoi(Value);
   else if (!strcasecmp(Name, "UseVps"))              UseVps             = atoi(Value);
   else if (!strcasecmp(Name, "VpsMargin"))           VpsMargin          = atoi(Value);
   else if (!strcasecmp(Name, "RecordingDirs"))       RecordingDirs      = atoi(Value);
+  else if (!strcasecmp(Name, "FoldersInTimerMenu"))  FoldersInTimerMenu = atoi(Value);
   else if (!strcasecmp(Name, "RecordingsSortMode"))  RecordingsSortMode = atoi(Value);
   else if (!strcasecmp(Name, "RecordingsSortDirsFirst")) RecordingsSortDirsFirst = atoi(Value);
   else if (!strcasecmp(Name, "CutterAutoDelete"))    CutterAutoDelete   = atoi(Value);
@@ -515,6 +538,7 @@
   else if (!strcasecmp(Name, "MaxVideoFileSize"))    MaxVideoFileSize   = atoi(Value);
   else if (!strcasecmp(Name, "MaxRecordingSize"))    MaxRecordingSize   = atoi(Value);
   else if (!strcasecmp(Name, "SplitEditedFiles"))    SplitEditedFiles   = atoi(Value);
+  else if (!strcasecmp(Name, "DelTimeshiftRec"))     DelTimeshiftRec    = atoi(Value);
   else if (!strcasecmp(Name, "HardLinkCutter"))      HardLinkCutter     = atoi(Value);
   else if (!strcasecmp(Name, "MinEventTimeout"))     MinEventTimeout    = atoi(Value);
   else if (!strcasecmp(Name, "MinUserInactivity"))   MinUserInactivity  = atoi(Value);
@@ -587,15 +611,18 @@
 //M7X0 END AK
   Store("SVDRPTimeout",       SVDRPTimeout);
   Store("ZapTimeout",         ZapTimeout);
+  Store("ChannelEntryTimeout",ChannelEntryTimeout);
   Store("PrimaryLimit",       PrimaryLimit);
   Store("DefaultPriority",    DefaultPriority);
   Store("DefaultLifetime",    DefaultLifetime);
+  Store("PauseKeyHandling",   PauseKeyHandling);
   Store("PausePriority",      PausePriority);
   Store("PauseLifetime",      PauseLifetime);
   Store("UseSubtitle",        UseSubtitle);
   Store("UseVps",             UseVps);
   Store("VpsMargin",          VpsMargin);
   Store("RecordingDirs",      RecordingDirs);
+  Store("FoldersInTimerMenu", FoldersInTimerMenu);
   Store("RecordingsSortMode", RecordingsSortMode);
   Store("RecordingsSortDirsFirst", RecordingsSortDirsFirst);
   Store("CutterAutoDelete",   CutterAutoDelete);
@@ -620,6 +647,7 @@
   Store("MaxVideoFileSize",   MaxVideoFileSize);
   Store("MaxRecordingSize",   MaxRecordingSize);
   Store("SplitEditedFiles",   SplitEditedFiles);
+  Store("DelTimeshiftRec",    DelTimeshiftRec);
   Store("HardLinkCutter",     HardLinkCutter);
   Store("MinEventTimeout",    MinEventTimeout);
   Store("MinUserInactivity",  MinUserInactivity);
diff -Naur VDR-NG-orig/config.h VDR-NG/config.h
--- VDR-NG-orig/config.h	2010-02-10 16:57:34.000000000 +0100
+++ VDR-NG/config.h	2010-02-10 17:17:06.000000000 +0100
@@ -88,6 +88,7 @@
 public:
   cSVDRPhost(void);
   bool Parse(const char *s);
+  bool IsLocalhost(void);
   bool Accepts(in_addr_t Address);
   };
 
@@ -183,6 +184,7 @@
 
 class cSVDRPhosts : public cConfig<cSVDRPhost> {
 public:
+  bool LocalhostOnly(void);
   bool Acceptable(in_addr_t Address);
   };
 
@@ -253,13 +255,16 @@
 //M7X0 END AK
   int SVDRPTimeout;
   int ZapTimeout;
+  int ChannelEntryTimeout;
   int PrimaryLimit;
   int DefaultPriority, DefaultLifetime;
   int PausePriority, PauseLifetime;
+  int PauseKeyHandling;
   int UseSubtitle;
   int UseVps;
   int VpsMargin;
   int RecordingDirs;
+  int FoldersInTimerMenu;
   int HotStandby;
   int TvMode;
   int VCRMode;
@@ -276,6 +281,7 @@
   int MaxVideoFileSize;
   int MaxRecordingSize;
   int SplitEditedFiles;
+  int DelTimeshiftRec;
   int HardLinkCutter;
   int MinEventTimeout, MinUserInactivity;
   int MultiSpeedMode;
diff -Naur VDR-NG-orig/cutter.c VDR-NG/cutter.c
--- VDR-NG-orig/cutter.c	2010-02-10 16:57:18.000000000 +0100
+++ VDR-NG/cutter.c	2010-02-10 16:58:58.000000000 +0100
@@ -484,3 +484,31 @@
   ended = false;
   return result;
 }
+
+#define CUTTINGCHECKINTERVAL 500 // ms between checks for the active cutting process
+
+bool CutRecording(const char *FileName)
+{
+  if (DirectoryOk(FileName)) {
+     cRecording Recording(FileName);
+     if (Recording.Name()) {
+        cMarks Marks;
+        if (Marks.Load(FileName) && Marks.Count()) {
+           if (cCutter::Start(FileName)) {
+              while (cCutter::Active())
+                    cCondWait::SleepMs(CUTTINGCHECKINTERVAL);
+              return true;
+              }
+           else
+              fprintf(stderr, "can't start editing process\n");
+           }
+        else
+           fprintf(stderr, "'%s' has no editing marks\n", FileName);
+        }
+     else
+        fprintf(stderr, "'%s' is not a recording\n", FileName);
+     }
+  else
+     fprintf(stderr, "'%s' is not a directory\n", FileName);
+  return false;
+}
diff -Naur VDR-NG-orig/cutter.h VDR-NG/cutter.h
--- VDR-NG-orig/cutter.h	2010-02-10 16:57:12.000000000 +0100
+++ VDR-NG/cutter.h	2010-02-10 16:58:58.000000000 +0100
@@ -28,4 +28,6 @@
   static bool Ended(void);
   };
 
+bool CutRecording(const char *FileName);
+
 #endif //__CUTTER_H
diff -Naur VDR-NG-orig/device.c VDR-NG/device.c
--- VDR-NG-orig/device.c	2010-02-10 16:57:32.000000000 +0100
+++ VDR-NG/device.c	2010-02-10 16:58:58.000000000 +0100
@@ -220,6 +220,7 @@
 cDevice::cDevice(void)
 {
   cardIndex = nextCardIndex++;
+  dsyslog("new device number %d", CardIndex() + 1);
 
   SetDescription("receiver on device %d", CardIndex() + 1);
 
@@ -330,6 +331,7 @@
      primaryDevice->MakePrimaryDevice(true);
      primaryDevice->SetTvMode(Setup.TvMode);
      primaryDevice->SetVideoFormat(eVideoFormat(Setup.VideoFormat));
+     primaryDevice->SetVolumeDevice(Setup.CurrentVolume);
      return true;
      }
   esyslog("ERROR: invalid primary device number: %d", n + 1);
@@ -468,6 +470,7 @@
                case vdfLetterBox:
                     spuDecoder->setScaleMode(cSpuDecoder::eSpuLetterBox);
                     break;
+               default: esyslog("ERROR: invalid value for VideoDisplayFormat '%d'", VideoDisplayFormat);
                }
         }
      }
@@ -483,7 +486,7 @@
   return vsPAL;
 }
 
-//#define PRINTPIDS(s) { char b[500]; char *q = b; q += sprintf(q, "%d %s ", CardIndex(), s); for (int i = 0; i < MAXPIDHANDLES; i++) q += sprintf(q, " %s%4d %d", i == ptOther ? "* " : "", pidHandles[i].pid, pidHandles[i].used); dsyslog(b); }
+//#define PRINTPIDS(s) { char b[500]; char *q = b; q += sprintf(q, "%d %s ", CardIndex(), s); for (int i = 0; i < MAXPIDHANDLES; i++) q += sprintf(q, " %s%4d %d", i == ptOther ? "* " : "", pidHandles[i].pid, pidHandles[i].used); dsyslog("%s", b); }
 #define PRINTPIDS(s)
 
 bool cDevice::HasPid(int Pid) const
@@ -808,6 +811,22 @@
      }
 }
 
+void cDevice::StopSectionHandler(void)
+{
+  if (sectionHandler) {
+     delete nitFilter;
+     delete sdtFilter;
+     delete patFilter;
+     delete eitFilter;
+     delete sectionHandler;
+     nitFilter = NULL;
+     sdtFilter = NULL;
+     patFilter = NULL;
+     eitFilter = NULL;
+     sectionHandler = NULL;
+     }
+}
+
 int cDevice::OpenFilter(u_short Pid, u_char Tid, u_char Mask)
 {
   return -1;
@@ -871,6 +890,7 @@
         case scrNoTransfer:   Skins.Message(mtError, tr("Can't start Transfer Mode!"));
                               return false;
         case scrFailed:       break; // loop will retry
+        default:              esyslog("ERROR: invalid return value from SetChannel");
         }
       esyslog("retrying");
       }
@@ -1183,7 +1203,7 @@
 
 bool cDevice::SetCurrentAudioTrack(eTrackType Type)
 {
-  if (ttNone < Type && Type < ttDolbyLast) {
+  if (ttNone < Type && Type <= ttDolbyLast) {
      cMutexLock MutexLock(&mutexCurrentAudioTrack);
      if (IS_DOLBY_TRACK(Type))
         SetDigitalAudioDevice(true);
diff -Naur VDR-NG-orig/device.h VDR-NG/device.h
--- VDR-NG-orig/device.h	2009-09-24 17:21:12.000000000 +0200
+++ VDR-NG/device.h	2010-02-10 16:58:58.000000000 +0100
@@ -328,7 +328,12 @@
 protected:
   void StartSectionHandler(void);
        ///< A derived device that provides section data must call
-       ///< this function to actually set up the section handler.
+       ///< this function (typically in its constructor) to actually set
+       ///< up the section handler.
+  void StopSectionHandler(void);
+       ///< A device that has called StartSectionHandler() must call this
+       ///< function (typically in its destructor) to stop the section
+       ///< handler.
 public:
   virtual int OpenFilter(u_short Pid, u_char Tid, u_char Mask);
        ///< Opens a file handle for the given filter data.
diff -Naur VDR-NG-orig/dvbdevice.c VDR-NG/dvbdevice.c
--- VDR-NG-orig/dvbdevice.c	2010-02-10 16:57:32.000000000 +0100
+++ VDR-NG/dvbdevice.c	2010-02-10 16:58:58.000000000 +0100
@@ -291,6 +291,7 @@
                           }
                        }
                        break;
+                  default: esyslog("ERROR: unknown diseqc command %d", da);
                   }
                 }
             frequency -= diseqc->Lof();
@@ -409,6 +410,8 @@
                   lastTimeoutReport = 0;
                   continue;
                   }
+               break;
+          default: esyslog("ERROR: unknown tuner status %d", tunerStatus);
           }
 
         if (ciHandler)
@@ -2389,6 +2392,7 @@
   if (tsreplayer != NULL)
      delete tsreplayer;
 //M7X0 END AK
+  StopSectionHandler();
   delete spuDecoder;
   delete dvbTuner;
   // We're not explicitly closing any device files here, since this sometimes
@@ -2398,7 +2402,6 @@
 bool cDvbDevice::Probe(const char *FileName)
 {
   if (access(FileName, F_OK) == 0) {
-     dsyslog("probing %s", FileName);
      int f = open(FileName, O_RDONLY);
      if (f >= 0) {
         close(f);
@@ -2607,6 +2610,7 @@
              CHECK(ioctl(fd_video_v4l, M7X0_SET_TV_ASPECT_MODE, M7X0_VIDEO_LETTER_BOX));
              dsyslog("DEBUG: set mode -> letterbox");
              break;
+        default: esyslog("ERROR: unknown video display format %d", VideoDisplayFormat);
         }
       //}
    }
@@ -2636,16 +2640,17 @@
         	dsyslog("DEBUG: set 16/9");
         	CHECK(ioctl(fd_video_v4l, M7X0_SET_TV_ASPECT_RATIO, M7X0_VIDEO_FORMAT_16_9));
         	CHECK(ioctl(avs, AVSWCMD_MODE_16_9, 0));
-		break;
-    	    case vf4_3:
+        	break;
+	    case vf4_3:
         	dsyslog("DEBUG: set 4/3");
         	CHECK(ioctl(fd_video_v4l, M7X0_SET_TV_ASPECT_RATIO, M7X0_VIDEO_FORMAT_4_3));
         	CHECK(ioctl(avs, AVSWCMD_MODE_4_3, 0));
-		break;
+        	break;
 	    case vfauto:
-		dsyslog("DEBUG: m7x0 auto aspect");
-		CheckStreamAspect(1);
-		break;
+        	dsyslog("DEBUG: m7x0 auto aspect");
+        	CheckStreamAspect(1);
+        	break;
+		default: esyslog("ERROR: unknown video format %d", VideoFormat);
       }
       close(avs);
       SetVideoDisplayFormat(eVideoDisplayFormat(Setup.VideoDisplayFormat));
@@ -3396,6 +3401,7 @@
     case pmTransfererAudioOnly:
          TurnOffLiveMode(true,pidHandles[cDevice::ptVideo].pid);
          break;
+    default: esyslog("ERROR: unknown play mode %d", PlayMode);
     }
   playMode = PlayMode;
   return true;
diff -Naur VDR-NG-orig/dvbplayer.c VDR-NG/dvbplayer.c
--- VDR-NG-orig/dvbplayer.c	2010-02-10 16:57:22.000000000 +0100
+++ VDR-NG/dvbplayer.c	2010-02-10 16:58:58.000000000 +0100
@@ -820,6 +820,7 @@
             FasterUnlockOther();
             }
             break;
+       default: esyslog("ERROR: unknown playMode %d (%s)", playMode, __FUNCTION__);
        }
      }
 }
@@ -873,6 +874,7 @@
             FasterUnlockOther();
             }
             break;
+       default: esyslog("ERROR: unknown playMode %d (%s)", playMode, __FUNCTION__);
        }
      }
 }
diff -Naur VDR-NG-orig/dvbspu.c VDR-NG/dvbspu.c
--- VDR-NG-orig/dvbspu.c	2009-09-24 17:21:12.000000000 +0200
+++ VDR-NG/dvbspu.c	2010-02-10 17:11:00.000000000 +0100
@@ -64,9 +64,10 @@
                              uint8_t * fodd, uint8_t * eodd,
                              uint8_t * feven, uint8_t * eeven)
 {
-    if (size.x1 < 0 || size.y1 < 0 || size.x2 >= spuXres
-        || size.y2 >= spuYres)
-        throw;
+    size.x1 = max(size.x1, 0);
+    size.y1 = max(size.y1, 0);
+    size.x2 = min(size.x2, spuXres - 1);
+    size.y2 = min(size.y2, spuYres - 1);
 
     bmpsize = size;
     revRect(minsize[0], size);
@@ -74,10 +75,11 @@
     revRect(minsize[2], size);
     revRect(minsize[3], size);
 
-    if (!(bmp = new uint8_t[spuXres * spuYres * sizeof(uint8_t)]))
-        throw;
+    int MemSize = spuXres * spuYres * sizeof(uint8_t);
+    bmp = new uint8_t[MemSize];
 
-    memset(bmp, 0, spuXres * spuYres * sizeof(uint8_t));
+    if (bmp)
+       memset(bmp, 0, MemSize);
     putFieldData(0, fodd, eodd);
     putFieldData(1, feven, eeven);
 }
@@ -112,11 +114,13 @@
     }
 
     // set the content
-    for (int yp = 0; yp < h; yp++) {
-        for (int xp = 0; xp < w; xp++) {
-            uint8_t idx = bmp[(size.y1 + yp) * spuXres + size.x1 + xp];
-            ret->SetIndex(xp, yp, idx);
-        }
+    if (bmp) {
+       for (int yp = 0; yp < h; yp++) {
+           for (int xp = 0; xp < w; xp++) {
+               uint8_t idx = bmp[(size.y1 + yp) * spuXres + size.x1 + xp];
+               ret->SetIndex(xp, yp, idx);
+           }
+       }
     }
     return ret;
 }
@@ -143,14 +147,15 @@
         DEBUG("MinSize: (%d, %d) x (%d, %d)\n",
               size.x1, size.y1, size.x2, size.y2);
     if (size.x1 > size.x2 || size.y1 > size.y2)
-       return false;
+        return false;
 
     return ret;
 }
 
 void cDvbSpuBitmap::putPixel(int xp, int yp, int len, uint8_t colorid)
 {
-    memset(bmp + spuXres * yp + xp, colorid, len);
+    if (bmp)
+       memset(bmp + spuXres * yp + xp, colorid, len);
     setMin(minsize[colorid].x1, xp);
     setMin(minsize[colorid].y1, yp);
     setMax(minsize[colorid].x2, xp + len - 1);
@@ -335,6 +340,35 @@
     return size;
 }
 
+int cDvbSpuBitmap::getMinBpp(const aDvbSpuPalDescr paldescr)
+{
+    int col = 1;
+    for (int i = 0; i < 4; i++) {
+        if (paldescr[i].trans != 0) {
+                col++;
+        }
+    }
+    return col > 2 ? 2 : 1;
+}
+
+int cDvbSpuDecoder::CalcAreaBpp(cBitmap *fgbmp, cBitmap *bgbmp)
+{
+        int fgbpp = 0;
+        int bgbpp = 0;
+        int ret;
+    if (fgbmp) {
+            fgbpp = spubmp->getMinBpp(hlpDescr);
+    }
+    if (bgbmp) {
+            bgbpp = spubmp->getMinBpp(palDescr);
+    }
+    ret = fgbpp + bgbpp;
+    if (ret > 2)
+            ret = 4;
+    return ret;
+}
+
+
 void cDvbSpuDecoder::Draw(void)
 {
     cMutexLock MutexLock(&mutex);
@@ -342,43 +376,92 @@
         Hide();
         return;
     }
-
+    sDvbSpuRect bgsize;
     cBitmap *fg = NULL;
     cBitmap *bg = NULL;
-    sDvbSpuRect bgsize;
-    sDvbSpuRect hlsize;
-
-    hlsize.x1 = hlpsize.x1;
-    hlsize.y1 = hlpsize.y1;
-    hlsize.x2 = hlpsize.x2;
-    hlsize.y2 = hlpsize.y2;
 
     if (highlight)
-        fg = spubmp->getBitmap(hlpDescr, palette, hlsize);
+        fg = spubmp->getBitmap(hlpDescr, palette, hlpsize);
 
     if (spubmp->getMinSize(palDescr, bgsize))
         bg = spubmp->getBitmap(palDescr, palette, bgsize);
 
-    sDvbSpuRect areaSize = CalcAreaSize(hlsize, fg, bgsize, bg);
+    if (!fg || !bg || !osd)
+        Hide();
 
-    if (!fg || !bg || !osd) {
-       Hide();
-       }
+    if (osd == NULL) {
+            restricted_osd = false;
+            osd = cOsdProvider::NewOsd(0, 0);
+
+            tArea Area = { size.x1, size.y1, size.x2, size.y2, 4};
+            if (osd->CanHandleAreas(&Area, 1) != oeOk)
+                    restricted_osd = true;
+            else
+                osd->SetAreas(&Area, 1);
+    }
+    if (restricted_osd) {
+            sDvbSpuRect hlsize;
+            bool setarea = false;
+            /* reduce fg area (only valid if there is no bg below) */
+            if (fg) {
+                    spubmp->getMinSize(hlpDescr,hlsize);
+                    /* clip to the highligh area */
+                    setMax(hlsize.x1, hlpsize.x1);
+                    setMax(hlsize.y1, hlpsize.y1);
+                    setMin(hlsize.x2, hlpsize.x2);
+                    setMin(hlsize.y2, hlpsize.y2);
+                    if (hlsize.x1 > hlsize.x2 || hlsize.y1 > hlsize.y2) {
+                            hlsize.x1 = hlsize.x2 = hlsize.y1 = hlsize.y2 = 0;
+                    }
+            }
+            sDvbSpuRect areaSize = CalcAreaSize((fg && bg) ? hlpsize : hlsize, fg, bgsize, bg);
 
-    if (bg || fg) {
-        if (osd == NULL) {
-           osd = cOsdProvider::NewOsd(0, 0);
-           if ((areaSize.width() & 3) != 0)
-              areaSize.x2 += 4 - (areaSize.width() & 3);
-           tArea Area = { areaSize.x1, areaSize.y1, areaSize.x2, areaSize.y2, (fg && bg) ? 4 : 2 };
-           if (osd->SetAreas(&Area, 1) != oeOk)
+#define DIV(a, b) (a/b)?:1
+            for (int d = 1; !setarea && d <= 2; d++) {
+
+                    /* first try old behaviour */
+                    tArea Area = { areaSize.x1, areaSize.y1, areaSize.x2, areaSize.y2, DIV(CalcAreaBpp(fg, bg), d) };
+
+                    if ((Area.Width() & 7) != 0)
+                            Area.x2 += 8 - (Area.Width() & 7);
+
+                    if (osd->CanHandleAreas(&Area, 1) == oeOk &&
+                        osd->SetAreas(&Area, 1) == oeOk)
+                            setarea = true;
+
+                    /* second try to split area if there is both area */
+                    if (!setarea && fg && bg) {
+                            tArea Area_Both [2] = {
+                                    {bgsize.x1, bgsize.y1, bgsize.x2, bgsize.y2, DIV(CalcAreaBpp(0, bg), d)},
+                                    {hlpsize.x1, hlpsize.y1, hlpsize.x2, hlpsize.y2, DIV(CalcAreaBpp(fg, 0), d)}
+                            };
+                            if (!Area_Both[0].Intersects(Area_Both[1])) {
+                                    /* there is no intersection. We can reduce hl */
+                                    Area_Both[1].x1 = hlsize.x1;
+                                    Area_Both[1].y1 = hlsize.y1;
+                                    Area_Both[1].x2 = hlsize.x2;
+                                    Area_Both[1].y2 = hlsize.y2;
+
+                                    if ((Area_Both[0].Width() & 7) != 0)
+                                            Area_Both[0].x2 += 8 - (Area_Both[0].Width() & 7);
+                                    if ((Area_Both[1].Width() & 7) != 0)
+                                            Area_Both[1].x2 += 8 - (Area_Both[1].Width() & 7);
+                                    if (osd->CanHandleAreas(Area_Both, 2) == oeOk &&
+                                        osd->SetAreas(Area_Both, 2) == oeOk)
+                                            setarea = true;
+                            }
+                    }
+            }
+            if (!setarea)
               dsyslog("dvbspu: AreaSize (%d, %d) (%d, %d) Bpp %d", areaSize.x1, areaSize.y1, areaSize.x2, areaSize.y2, (fg && bg) ? 4 : 2 );
-           }
+    }
 
+    /* we could draw use DrawPixel on osd */
+    if (bg || fg) {
         if (bg)
            osd->DrawBitmap(bgsize.x1, bgsize.y1, *bg);
         if (fg)
-           osd->DrawBitmap(hlsize.x1, hlsize.y1, *fg);
+           osd->DrawBitmap(hlpsize.x1, hlpsize.y1, *fg);
         delete fg;
         delete bg;
 
@@ -509,6 +592,7 @@
                 }
             }
             if (fodd != 0 && feven != 0) {
+                Hide();
                 delete spubmp;
                 spubmp = new cDvbSpuBitmap(size, spu + fodd, spu + feven,
                                            spu + feven, spu + cmdOffs());
diff -Naur VDR-NG-orig/dvbspu.h VDR-NG/dvbspu.h
--- VDR-NG-orig/dvbspu.h	2009-09-24 17:21:12.000000000 +0200
+++ VDR-NG/dvbspu.h	2010-02-10 16:58:58.000000000 +0100
@@ -32,10 +32,10 @@
     int x1, y1;
     int x2, y2;
 
-    int width() {
+    int width() const {
         return x2 - x1 + 1;
     };
-    int height() {
+    int height() const {
         return y2 - y1 + 1;
     };
 
@@ -63,8 +63,6 @@
 // --- cDvbSpuBitmap----------------------------------------------------------
 
 class cDvbSpuBitmap {
-
-  public:
   private:
     sDvbSpuRect bmpsize;
     sDvbSpuRect minsize[4];
@@ -82,6 +80,7 @@
 
     bool getMinSize(const aDvbSpuPalDescr paldescr,
                     sDvbSpuRect & size) const;
+    int getMinBpp(const aDvbSpuPalDescr paldescr);
     cBitmap *getBitmap(const aDvbSpuPalDescr paldescr,
                        const cDvbSpuPalette & pal,
                        sDvbSpuRect & size) const;
@@ -99,6 +98,7 @@
     uint32_t spupts;
     bool clean;
     bool ready;
+    bool restricted_osd;
 
     enum spFlag { spNONE, spHIDE, spSHOW, spMENU };
     spFlag state;
@@ -131,6 +131,7 @@
     };
 
     sDvbSpuRect CalcAreaSize(sDvbSpuRect fgsize, cBitmap *fgbmp, sDvbSpuRect bgsize, cBitmap *bgbmp);
+    int CalcAreaBpp(cBitmap *fgbmp, cBitmap *bgbmp);
 
   public:
     cDvbSpuDecoder();
@@ -196,8 +197,7 @@
 
 inline uint32_t cDvbSpuPalette::getColor(uint8_t idx, uint8_t trans) const
 {
-    uint8_t t = trans == 0x0f ? 0xff : trans << 4;
-    return palette[idx] | (t << 24);
+    return palette[idx] | ((trans == 0x0f) ? 0xff000000 : (trans << 28));
 }
 
 #endif                          // __DVBSPU_H
diff -Naur VDR-NG-orig/eit.c VDR-NG/eit.c
--- VDR-NG-orig/eit.c	2010-02-10 16:57:32.000000000 +0100
+++ VDR-NG/eit.c	2010-02-10 17:11:00.000000000 +0100
@@ -159,9 +159,40 @@
                     }
                  }
                  break;
-            case SI::ContentDescriptorTag:
+            case SI::ContentDescriptorTag: {
+                 SI::ContentDescriptor *cd = (SI::ContentDescriptor *)d;
+                 SI::ContentDescriptor::Nibble Nibble;
+                 int NumContents = 0;
+                 uchar Contents[MaxEventContents] = { 0 };
+                 for (SI::Loop::Iterator it3; cd->nibbleLoop.getNext(Nibble, it3); ) {
+                     if (NumContents < MaxEventContents) {
+                        Contents[NumContents] = ((Nibble.getContentNibbleLevel1() & 0xF) << 4) | (Nibble.getContentNibbleLevel2() & 0xF);
+                        NumContents++;
+                        }
+                     }
+                 pEvent->SetContents(Contents);
+                 }
                  break;
-            case SI::ParentalRatingDescriptorTag:
+            case SI::ParentalRatingDescriptorTag: {
+                 int LanguagePreferenceRating = -1;
+                 SI::ParentalRatingDescriptor *prd = (SI::ParentalRatingDescriptor *)d;
+                 SI::ParentalRatingDescriptor::Rating Rating;
+                 for (SI::Loop::Iterator it3; prd->ratingLoop.getNext(Rating, it3); ) {
+                     if (I18nIsPreferredLanguage(Setup.EPGLanguages, Rating.languageCode, LanguagePreferenceRating)) {
+                        int ParentalRating = (Rating.getRating() & 0xFF);
+                        switch (ParentalRating) {
+                          // values defined by the DVB standard (minimum age = rating + 3 years):
+                          case 0x01 ... 0x0F: ParentalRating += 3; break;
+                          // values defined by broadcaster CSAT (now why didn't they just use 0x07, 0x09 and 0x0D?):
+                          case 0x11:          ParentalRating = 10; break;
+                          case 0x12:          ParentalRating = 12; break;
+                          case 0x13:          ParentalRating = 16; break;
+                          default:            ParentalRating = 0;
+                          }
+                        pEvent->SetParentalRating(ParentalRating);
+                        }
+                     }
+                 }
                  break;
             case SI::PDCDescriptorTag: {
                  SI::PDCDescriptor *pd = (SI::PDCDescriptor *)d;
@@ -312,9 +343,9 @@
   if (diff > 5) {
      mutex.Lock();
      if (abs(diff - lastDiff) < 3) {
-        isyslog("System Time = %s (%ld)", *TimeToString(loctim), loctim);
-        isyslog("Local Time  = %s (%ld)", *TimeToString(sattim), sattim);
-        if (stime(&sattim) < 0){
+        if (stime(&sattim) == 0)
+           isyslog("system time changed from %s (%ld) to %s (%ld)", *TimeToString(loctim), loctim, *TimeToString(sattim), sattim);
+        else {
 				char __errorstr[256];
 				strerror_r(errno,__errorstr,256);
 				__errorstr[255]=0;
@@ -328,36 +359,45 @@
 
 // --- cEitFilter ------------------------------------------------------------
 
+time_t cEitFilter::disableUntil = 0;
+
 cEitFilter::cEitFilter(void)
 {
-//M7X0 BEGIN AK
-// m7x0 can only handle one filter per pid
-// Lets only filter 0x40-0x5f m7x0 seems not to like too many filters
-// Is 0x6x really used? (hopefully not)
-  Set(0x12, 0x40, 0xE0, 5);   // event info, actual(0x4E)/other(0x4F) TS, present/following
- 									// event info, actual TS, schedule(0x50)/schedule for future days(0x5X)
-									// event info, other  TS, schedule(0x60)/schedule for future days(0x6X)
-//M7X0 END AK
-  Set(0x14, 0x70);        // TDT
+  Set(0x12, 0x40, 0xC0);  // event info now&next actual/other TS (0x4E/0x4F), future actual/other TS (0x5X/0x6X)
+  if (Setup.SetSystemTime && Setup.TimeTransponder)
+     Set(0x14, 0x70);     // TDT
+}
+
+void cEitFilter::SetDisableUntil(time_t Time)
+{
+  disableUntil = Time;
 }
 
 void cEitFilter::Process(u_short Pid, u_char Tid, const u_char *Data, int Length)
 {
+  if (disableUntil) {
+     if (time(NULL) > disableUntil)
+        disableUntil = 0;
+     else
+        return;
+     }
   switch (Pid) {
     case 0x12: {
-         cSchedulesLock SchedulesLock(true, 10);
-         cSchedules *Schedules = (cSchedules *)cSchedules::Schedules(SchedulesLock);
-         if (Schedules)
-            cEIT EIT(Schedules, Source(), Tid, Data);
-         else {
-            // If we don't get a write lock, let's at least get a read lock, so
-            // that we can set the running status and 'seen' timestamp (well, actually
-            // with a read lock we shouldn't be doing that, but it's only integers that
-            // get changed, so it should be ok)
-            cSchedulesLock SchedulesLock(false, 50);
+         if (Tid >= 0x4E && Tid <= 0x6F) {
+            cSchedulesLock SchedulesLock(true, 10);
             cSchedules *Schedules = (cSchedules *)cSchedules::Schedules(SchedulesLock);
             if (Schedules)
-               cEIT EIT(Schedules, Source(), Tid, Data, true);
+               cEIT EIT(Schedules, Source(), Tid, Data);
+            else {
+               // If we don't get a write lock, let's at least get a read lock, so
+               // that we can set the running status and 'seen' timestamp (well, actually
+               // with a read lock we shouldn't be doing that, but it's only integers that
+               // get changed, so it should be ok)
+               cSchedulesLock SchedulesLock(false, 50);
+               cSchedules *Schedules = (cSchedules *)cSchedules::Schedules(SchedulesLock);
+               if (Schedules)
+                  cEIT EIT(Schedules, Source(), Tid, Data, true);
+               }
             }
          }
          break;
@@ -366,5 +406,6 @@
             cTDT TDT(Data);
          }
          break;
+    default: ;
     }
 }
diff -Naur VDR-NG-orig/eit.h VDR-NG/eit.h
--- VDR-NG-orig/eit.h	2009-09-24 17:21:02.000000000 +0200
+++ VDR-NG/eit.h	2010-02-10 16:58:58.000000000 +0100
@@ -13,10 +13,13 @@
 #include "filter.h"
 
 class cEitFilter : public cFilter {
+private:
+  static time_t disableUntil;
 protected:
   virtual void Process(u_short Pid, u_char Tid, const u_char *Data, int Length);
 public:
   cEitFilter(void);
+  static void SetDisableUntil(time_t Time);
   };
 
 #endif //__EIT_H
diff -Naur VDR-NG-orig/eitscan.c VDR-NG/eitscan.c
--- VDR-NG-orig/eitscan.c	2009-09-24 17:21:00.000000000 +0200
+++ VDR-NG/eitscan.c	2010-03-04 11:47:14.000000000 +0100
@@ -141,7 +141,7 @@
 
 void cEITScanner::Process(void)
 {
-  if ((Setup.EPGScanTimeout || !lastActivity) && Channels.MaxNumber() > 1) { // !lastActivity means a scan was forced
+  if (Setup.EPGScanTimeout || !lastActivity) { // !lastActivity means a scan was forced
      time_t now = time(NULL);
      if (now - lastScan > ScanTimeout && now - lastActivity > ActivityTimeout) {
         if (Channels.Lock(false, 10)) {
diff -Naur VDR-NG-orig/epg.c VDR-NG/epg.c
--- VDR-NG-orig/epg.c	2010-02-10 16:57:22.000000000 +0100
+++ VDR-NG/epg.c	2010-02-10 17:11:00.000000000 +0100
@@ -112,6 +112,8 @@
   shortText = NULL;
   description = NULL;
   components = NULL;
+  memset(contents, 0, sizeof(contents));
+  parentalRating = 0;
   startTime = 0;
   duration = 0;
   vps = 0;
@@ -193,6 +195,17 @@
   components = Components;
 }
 
+void cEvent::SetContents(uchar *Contents)
+{
+  for (int i = 0; i < MaxEventContents; i++)
+      contents[i] = Contents[i];
+}
+
+void cEvent::SetParentalRating(int ParentalRating)
+{
+  parentalRating = ParentalRating;
+}
+
 void cEvent::SetStartTime(time_t StartTime)
 {
   if (startTime != StartTime) {
@@ -237,6 +250,155 @@
   return runningStatus >= (OrAboutToStart ? SI::RunningStatusStartsInAFewSeconds : SI::RunningStatusPausing);
 }
 
+const char *cEvent::ContentToString(uchar Content)
+{
+  switch (Content & 0xF0) {
+    case ecgMovieDrama:
+         switch (Content & 0x0F) {
+           default:
+           case 0x00: return tr("Content$Movie/Drama");
+           case 0x01: return tr("Content$Detective/Thriller");
+           case 0x02: return tr("Content$Adventure/Western/War");
+           case 0x03: return tr("Content$Science Fiction/Fantasy/Horror");
+           case 0x04: return tr("Content$Comedy");
+           case 0x05: return tr("Content$Soap/Melodrama/Folkloric");
+           case 0x06: return tr("Content$Romance");
+           case 0x07: return tr("Content$Serious/Classical/Religious/Historical Movie/Drama");
+           case 0x08: return tr("Content$Adult Movie/Drama");
+           }
+         break;
+    case ecgNewsCurrentAffairs:
+         switch (Content & 0x0F) {
+           default:
+           case 0x00: return tr("Content$News/Current Affairs");
+           case 0x01: return tr("Content$News/Weather Report");
+           case 0x02: return tr("Content$News Magazine");
+           case 0x03: return tr("Content$Documentary");
+           case 0x04: return tr("Content$Discussion/Inverview/Debate");
+           }
+         break;
+    case ecgShow:
+         switch (Content & 0x0F) {
+           default:
+           case 0x00: return tr("Content$Show/Game Show");
+           case 0x01: return tr("Content$Game Show/Quiz/Contest");
+           case 0x02: return tr("Content$Variety Show");
+           case 0x03: return tr("Content$Talk Show");
+           }
+         break;
+    case ecgSports:
+         switch (Content & 0x0F) {
+           default:
+           case 0x00: return tr("Content$Sports");
+           case 0x01: return tr("Content$Special Event");
+           case 0x02: return tr("Content$Sport Magazine");
+           case 0x03: return tr("Content$Football/Soccer");
+           case 0x04: return tr("Content$Tennis/Squash");
+           case 0x05: return tr("Content$Team Sports");
+           case 0x06: return tr("Content$Athletics");
+           case 0x07: return tr("Content$Motor Sport");
+           case 0x08: return tr("Content$Water Sport");
+           case 0x09: return tr("Content$Winter Sports");
+           case 0x0A: return tr("Content$Equestrian");
+           case 0x0B: return tr("Content$Martial Sports");
+           }
+         break;
+    case ecgChildrenYouth:
+         switch (Content & 0x0F) {
+           default:
+           case 0x00: return tr("Content$Children's/Youth Programme");
+           case 0x01: return tr("Content$Pre-school Children's Programme");
+           case 0x02: return tr("Content$Entertainment Programme for 6 to 14");
+           case 0x03: return tr("Content$Entertainment Programme for 10 to 16");
+           case 0x04: return tr("Content$Informational/Educational/School Programme");
+           case 0x05: return tr("Content$Cartoons/Puppets");
+           }
+         break;
+    case ecgMusicBalletDance:
+         switch (Content & 0x0F) {
+           default:
+           case 0x00: return tr("Content$Music/Ballet/Dance");
+           case 0x01: return tr("Content$Rock/Pop");
+           case 0x02: return tr("Content$Serious/Classical Music");
+           case 0x03: return tr("Content$Folk/Tradional Music");
+           case 0x04: return tr("Content$Jazz");
+           case 0x05: return tr("Content$Musical/Opera");
+           case 0x06: return tr("Content$Ballet");
+           }
+         break;
+    case ecgArtsCulture:
+         switch (Content & 0x0F) {
+           default:
+           case 0x00: return tr("Content$Arts/Culture");
+           case 0x01: return tr("Content$Performing Arts");
+           case 0x02: return tr("Content$Fine Arts");
+           case 0x03: return tr("Content$Religion");
+           case 0x04: return tr("Content$Popular Culture/Traditional Arts");
+           case 0x05: return tr("Content$Literature");
+           case 0x06: return tr("Content$Film/Cinema");
+           case 0x07: return tr("Content$Experimental Film/Video");
+           case 0x08: return tr("Content$Broadcasting/Press");
+           case 0x09: return tr("Content$New Media");
+           case 0x0A: return tr("Content$Arts/Culture Magazine");
+           case 0x0B: return tr("Content$Fashion");
+           }
+         break;
+    case ecgSocialPoliticalEconomics:
+         switch (Content & 0x0F) {
+           default:
+           case 0x00: return tr("Content$Social/Political/Economics");
+           case 0x01: return tr("Content$Magazine/Report/Documentary");
+           case 0x02: return tr("Content$Economics/Social Advisory");
+           case 0x03: return tr("Content$Remarkable People");
+           }
+         break;
+    case ecgEducationalScience:
+         switch (Content & 0x0F) {
+           default:
+           case 0x00: return tr("Content$Education/Science/Factual");
+           case 0x01: return tr("Content$Nature/Animals/Environment");
+           case 0x02: return tr("Content$Technology/Natural Sciences");
+           case 0x03: return tr("Content$Medicine/Physiology/Psychology");
+           case 0x04: return tr("Content$Foreign Countries/Expeditions");
+           case 0x05: return tr("Content$Social/Spiritual Sciences");
+           case 0x06: return tr("Content$Further Education");
+           case 0x07: return tr("Content$Languages");
+           }
+         break;
+    case ecgLeisureHobbies:
+         switch (Content & 0x0F) {
+           default:
+           case 0x00: return tr("Content$Leisure/Hobbies");
+           case 0x01: return tr("Content$Tourism/Travel");
+           case 0x02: return tr("Content$Handicraft");
+           case 0x03: return tr("Content$Motoring");
+           case 0x04: return tr("Content$Fitness & Health");
+           case 0x05: return tr("Content$Cooking");
+           case 0x06: return tr("Content$Advertisement/Shopping");
+           case 0x07: return tr("Content$Gardening");
+           }
+         break;
+    case ecgSpecial:
+         switch (Content & 0x0F) {
+           case 0x00: return tr("Content$Original Language");
+           case 0x01: return tr("Content$Black & White");
+           case 0x02: return tr("Content$Unpublished");
+           case 0x03: return tr("Content$Live Broadcast");
+           default: ;
+           }
+         break;
+    default: ;
+    }
+  return "";
+}
+
+cString cEvent::GetParentalRatingString(void) const
+{
+  if (parentalRating)
+     return cString::sprintf(tr("ParentalRating$from %d"), parentalRating);
+  return NULL;
+}
+
 cString cEvent::GetDateString(void) const
 {
 //M7X0 BEGIN AK
@@ -281,6 +443,14 @@
         fprintf(f, "%sD %s\n", Prefix, description);
         strreplace(description, '|', '\n');
         }
+     if (contents[0]) {
+        fprintf(f, "%sG", Prefix);
+        for (int i = 0; Contents(i); i++)
+            fprintf(f, " %02X", Contents(i));
+        fprintf(f, "\n");
+        }
+     if (parentalRating)
+        fprintf(f, "%sR %d\n", Prefix, parentalRating);
      if (components) {
         for (int i = 0; i < components->NumComponents(); i++) {
             tComponent *p = components->Component(i);
@@ -307,6 +477,22 @@
     case 'D': strreplace(t, '|', '\n');
               SetDescription(t);
               break;
+    case 'G': {
+                memset(contents, 0, sizeof(contents));
+                for (int i = 0; i < MaxEventContents; i++) {
+                    char *tail = NULL;
+                    int c = strtol(t, &tail, 16);
+                    if (0x00 < c && c <= 0xFF) {
+                       contents[i] = c;
+                       t = tail;
+                       }
+                    else
+                       break;
+                    }
+              }
+              break;
+    case 'R': SetParentalRating(atoi(t));
+              break;
     case 'X': if (!components)
                  components = new cComponents;
               components->SetComponent(components->NumComponents(), t);
@@ -624,6 +810,7 @@
                      case 0x0F: p->description = strdup("HD 16:9"); break;
                      case 0x0C:
                      case 0x10: p->description = strdup("HD >16:9"); break;
+                     default: ;
                      }
                    EpgBugFixStat(9, ChannelID());
                    }
@@ -642,12 +829,13 @@
                 if (!p->description) {
                    switch (p->type) {
                      case 0x05: p->description = strdup("Dolby Digital"); break;
-                     // all others will just display the language
+                     default: ; // all others will just display the language
                      }
                    EpgBugFixStat(11, ChannelID());
                    }
                 }
                 break;
+           default: ;
            }
          }
      }
@@ -917,6 +1105,7 @@
                }
             }
             break;
+       default: esyslog("ERROR: unknown DumpMode %d (%s %d)", DumpMode, __FUNCTION__, __LINE__);
        }
      fprintf(f, "%sc\n", Prefix);
      }
@@ -1125,6 +1314,7 @@
   if (!p) {
      p = new cSchedule(ChannelID);
      Add(p);
+     HashSchedule(p);
      cChannel *channel = Channels.GetByChannelID(ChannelID);
      if (channel)
         channel->schedule = p;
@@ -1135,10 +1325,14 @@
 const cSchedule *cSchedules::GetSchedule(tChannelID ChannelID) const
 {
   ChannelID.ClrRid();
-  for (cSchedule *p = First(); p; p = Next(p)) {
-      if (p->ChannelID() == ChannelID)
-         return p;
-      }
+  cList<cHashObject> *list = schedulesHash.GetList(HashKey(ChannelID));
+  if (list) {
+     for (cHashObject *hobj = list->First(); hobj; hobj = list->Next(hobj)) {
+         cSchedule *p = (cSchedule *)hobj->Object();
+         if (p->ChannelID() == ChannelID)
+            return p;
+         }
+     }
   return NULL;
 }
 
@@ -1154,11 +1348,27 @@
   if (Channel->schedule == &DummySchedule && AddIfMissing) {
      cSchedule *Schedule = new cSchedule(Channel->GetChannelID());
      ((cSchedules *)this)->Add(Schedule);
+     ((cSchedules *)this)->HashSchedule(Schedule);
      Channel->schedule = Schedule;
      }
   return Channel->schedule != &DummySchedule? Channel->schedule : NULL;
 }
 
+void cSchedules::HashSchedule(cSchedule *Schedule)
+{
+  schedulesHash.Add(Schedule, HashKey(Schedule->ChannelID().ClrRid()));
+}
+
+void cSchedules::UnhashSchedule(cSchedule *Schedule)
+{
+  schedulesHash.Del(Schedule, HashKey(Schedule->ChannelID().ClrRid()));
+}
+
+unsigned int cSchedules::HashKey(tChannelID ChannelID)
+{
+  return (unsigned int)((ChannelID.Nid() << 16 | ChannelID.Source()) ^ (ChannelID.Tid() << 16 | ChannelID.Sid()) ^ ChannelID.Rid());
+}
+
 // --- cSchedulesReaderThread ------------------------------------------------------------
 cSchedulesReaderThread cSchedulesReaderThread::readerThread;
 
diff -Naur VDR-NG-orig/epg.h VDR-NG/epg.h
--- VDR-NG-orig/epg.h	2010-02-10 16:57:22.000000000 +0100
+++ VDR-NG/epg.h	2010-02-10 17:11:00.000000000 +0100
@@ -19,6 +19,23 @@
 
 #define MAXEPGBUGFIXLEVEL 3
 
+enum { MaxEventContents = 4 };
+
+enum eEventContentGroup {
+  ecgMovieDrama               = 0x10,
+  ecgNewsCurrentAffairs       = 0x20,
+  ecgShow                     = 0x30,
+  ecgSports                   = 0x40,
+  ecgChildrenYouth            = 0x50,
+  ecgMusicBalletDance         = 0x60,
+  ecgArtsCulture              = 0x70,
+  ecgSocialPoliticalEconomics = 0x80,
+  ecgEducationalScience       = 0x90,
+  ecgLeisureHobbies           = 0xA0,
+  ecgSpecial                  = 0xB0,
+  ecgUserDefined              = 0xF0
+  };
+
 enum eDumpMode { dmAll, dmPresent, dmFollowing, dmPresentAndFollowing, dmAtTime, dmBetween, dmWithID };
 
 struct tComponent {
@@ -53,15 +70,18 @@
 class cEvent : public cListObject {
   friend class cSchedule;
 private:
+  // The sequence of these parameters is optimized for minimal memory waste!
   cSchedule *schedule;     // The Schedule this event belongs to
   tEventID eventID;        // Event ID of this event
   uchar tableID;           // Table ID this event came from
   uchar version;           // Version number of section this event came from
-  int runningStatus;       // 0=undefined, 1=not running, 2=starts in a few seconds, 3=pausing, 4=running
+  uchar runningStatus;     // 0=undefined, 1=not running, 2=starts in a few seconds, 3=pausing, 4=running
+  uchar parentalRating;    // Parental rating of this event
   char *title;             // Title of this event
   char *shortText;         // Short description of this event (typically the episode name in case of a series)
   char *description;       // Description of this event
   cComponents *components; // The stream components of this event
+  uchar contents[MaxEventContents]; // Contents of this event
   time_t startTime;        // Start time of this event
   int duration;            // Duration of this event in seconds
   time_t vps;              // Video Programming Service timestamp (VPS, aka "Programme Identification Label", PIL)
@@ -86,6 +106,8 @@
   const char *ShortText(void) const { return shortText; }
   const char *Description(void) const { return description; }
   const cComponents *Components(void) const { return components; }
+  uchar Contents(int i = 0) const { return (0 <= i && i < MaxEventContents) ? contents[i] : 0; }
+  int ParentalRating(void) const { return parentalRating; }
   time_t StartTime(void) const { return startTime; }
   time_t EndTime(void) const { return startTime + duration; }
   int Duration(void) const { return duration; }
@@ -96,6 +118,8 @@
   void IncTimerUse(void) const { usedByTimers++; }
   void DecTimerUse(void) const { usedByTimers--; }
   bool IsRunning(bool OrAboutToStart = false) const;
+  static const char *ContentToString(uchar Content);
+  cString GetParentalRatingString(void) const;
   cString GetDateString(void) const;
   cString GetTimeString(void) const;
   cString GetEndTimeString(void) const;
@@ -108,6 +132,8 @@
   void SetShortText(const char *ShortText);
   void SetDescription(const char *Description);
   void SetComponents(cComponents *Components); // Will take ownership of Components!
+  void SetContents(uchar *Contents);
+  void SetParentalRating(int ParentalRating);
   void SetStartTime(time_t StartTime);
   void SetDuration(int Duration);
   void SetVps(time_t Vps);
@@ -172,11 +198,15 @@
   friend class cSchedulesLock;
 private:
   cRwLock rwlock;
+  cHash<cSchedule> schedulesHash;
   static cSchedules schedules;
   static const char *epgDataFileName;
   static time_t lastCleanup;
   static time_t lastDump;
   static time_t modified;
+  void HashSchedule(cSchedule *Schedule);
+  void UnhashSchedule(cSchedule *Schedule);
+  static unsigned int HashKey(tChannelID ChannelID);
 public:
   static void SetEpgDataFileName(const char *FileName);
   static const cSchedules *Schedules(cSchedulesLock &SchedulesLock);
diff -Naur VDR-NG-orig/i18n.c VDR-NG/i18n.c
--- VDR-NG-orig/i18n.c	2010-02-10 16:57:34.000000000 +0100
+++ VDR-NG/i18n.c	2010-02-10 16:59:00.000000000 +0100
@@ -3926,6 +3926,28 @@
     "Optagelser i foldere",
     "Seznam nahrávek",
   },
+  { "Setup.OSD$Folders in timer menu",
+    "Verzeichnisse im Timer-Menü",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Mostrar directorios en programaciones",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
   { "Setup.EPG$EPG scan timeout (h)",
     "Zeit bis zur EPG-Aktualisierung (h)",
     "Èas do EPG pregleda (h)",
@@ -4718,6 +4740,116 @@
     "Standard levetid (d)",
     "Výchozí ¾ivotnost",
   },
+  { "Setup.Recording$Pause key handling",
+    "Funktion der Pause-Taste",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Función del botón Pausa",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "do not pause live video",
+    "Live-Signal nicht anhalten",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "no pausar directo",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "confirm pause live video",
+    "Anhalten des Live-Signals bestätigen",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "confirmar pausar directo",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "pause live video",
+    "Live-Signal anhalten",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "pausar directo",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Pause live video?",
+    "Live-Signal anhalten?",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "¿Pausar vídeo en directo?",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
   { "Setup.Recording$Pause priority",
     "Pause-Priorität",
     "Prioriteta pavze",
@@ -4784,6 +4916,50 @@
     "Anvend udsendelsesnavn",
     "Pou¾ívat název epizody",
   },
+  { "Setup.Recording$Delete timeshift recording",
+    "Zeitversetzte Aufnahme löschen",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Borrar grabación timeshift",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Delete timeshift recording?",
+    "Zeitversetzte Aufnahme löschen?",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "¿Borrar grabación timeshift?",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
   { "Setup.Recording$Use VPS",
     "VPS benutzen",
     "Uporabi VPS",
@@ -5136,6 +5312,28 @@
     "Zap timeout (s)",
     "Èasový limit Zap (s)",
   },
+  { "Setup.Miscellaneous$Channel entry timeout (ms)",
+    "Zeitlimit für Kanaleingabe (ms)",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Tiempo introducción canal (ms)",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
   { "Setup.Miscellaneous$Initial channel",
     "Kanal beim Einschalten",
     "Privzeti kanal",
@@ -6491,6 +6689,28 @@
     "Zvuk",
   },
   // Miscellaneous:
+  { "confirm",
+    "bestätigen",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "confirmar",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
   { "yes",
     "ja",
     "da",
@@ -6975,6 +7195,1766 @@
     "Starter EPG skanning",
     "Zaèíná prohledávání EPG",
   },
+  { "Content$Movie/Drama",
+    "Film/Drama",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Película/Drama",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Detective/Thriller",
+    "Detektiv/Thriller",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Policíaca/Suspense",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Adventure/Western/War",
+    "Abenteuer/Western/Krieg",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Aventura/Oeste/Guerra",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Science Fiction/Fantasy/Horror",
+    "Science-Fiction/Fantasy/Horror",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Ciencia Ficción/Fantasía/Terror",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Comedy",
+    "Komödie",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Comedia",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Soap/Melodrama/Folkloric",
+    "Seife/Melodram/Folklore",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Telenovela/Melodrama/Folclore",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Romance",
+    "Romanze",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Romántico",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Serious/Classical/Religious/Historical Movie/Drama",
+    "Ernst/Klassik/Religion/Historischer Film/Drama",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Solemne/Clásico/Religioso/Película histórica/Drama",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Adult Movie/Drama",
+    "Erwachsenen-Film/Drama",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Película para adultos/Drama",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$News/Current Affairs",
+    "Aktuelle Angelegenheiten",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Noticias/Actualidad",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$News/Weather Report",
+    "Wetterbericht",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Noticias/Informe meteorológico",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$News Magazine",
+    "Nachrichtenmagazin",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Magazín informativo",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Documentary",
+    "Dokumentation",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Documental",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Discussion/Inverview/Debate",
+    "Diskussion/Interview/Debatte",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Discusión/Entrevista/Debate",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Show/Game Show",
+    "Show/Spielshow",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Programa/Programa concurso",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Game Show/Quiz/Contest",
+    "Spielshow/Quiz/Wettbewerb",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Programa concurso/Acertijo/Cuestionario",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Variety Show",
+    "Variete-Show",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Programa de variedades",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Talk Show",
+    "Talkshow",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Programa de entrevistas",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Sports",
+    "Sport",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Deporte",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Special Event",
+    "Besonderes Ereignis",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Acontecimiento especial",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Sport Magazine",
+    "Sportmagazin",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Magazín deportivo",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Football/Soccer",
+    "Football/Fußball",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Fútbol/Rugby",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Tennis/Squash",
+    "Tennis/Squash",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Tenis/Squash",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Team Sports",
+    "Mannschaftssport",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Deporte de equipo",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Athletics",
+    "Athletik",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Atletismo",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Motor Sport",
+    "Motorsport",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Deporte motorizado",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Water Sport",
+    "Wassersport",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Deporte acuático",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Winter Sports",
+    "Wintersport",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Deporte de invierno",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Equestrian",
+    "Reitsport",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Hípica",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Martial Sports",
+    "Kampfsport",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Deporte marcial",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Children's/Youth Programme",
+    "Kinder/Jugendprogramm",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Infantil/Programa juvenil",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Pre-school Children's Programme",
+    "Programm für Vorschulkinder",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Programa para niños en preescolar",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Entertainment Programme for 6 to 14",
+    "Unterhaltungsprogramm für 6 bis 14",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Programa de entretenimiento de 6 a 14",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Entertainment Programme for 10 to 16",
+    "Unterhaltungsprogramm für 10 bis 16",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Programa de entretenimiento de 10 a 16",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Informational/Educational/School Programme",
+    "Informations/Lehr/Schul-Programm",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Informativo/Educacional/Programa escolar",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Cartoons/Puppets",
+    "Zeichentrick/Puppen",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Dibujos animados/Muñecos",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Music/Ballet/Dance",
+    "Musik/Ballett/Tanz",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Música/Ballet/Danza",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Rock/Pop",
+    "Rock/Pop",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Rock/Pop",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Serious/Classical Music",
+    "Ernste/Klassische Musik",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Solemne/Música clásica",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Folk/Tradional Music",
+    "Volks/Traditionelle Musik",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Folclore/Música tradicional",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Jazz",
+    "Jazz",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Jazz",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Musical/Opera",
+    "Musical/Oper",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Musical/Ópera",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Ballet",
+    "Ballett",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Ballet",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Arts/Culture",
+    "Kunst/Kultur",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Artes/Cultura",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Performing Arts",
+    "Darstellende Künste",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Artes escénicas",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Fine Arts",
+    "Bildende Künste",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Bellas Artes",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Religion",
+    "Religion",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Religión",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Popular Culture/Traditional Arts",
+    "Pop-Kultur/Traditionelle Künste",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Cultura popular/Artes tradicionales",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Literature",
+    "Literatur",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Literatura",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Film/Cinema",
+    "Film/Kino",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Película/Cine",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Experimental Film/Video",
+    "Experimentalfilm/Video",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Película experimental/Vídeo",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Broadcasting/Press",
+    "Rundfunk/Presse",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Radiodifusión/Prensa",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$New Media",
+    "Neue Medien",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Nuevos medios",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Arts/Culture Magazine",
+    "Kunst/Kulturmagazin",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Artes/Magazín cultural",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Fashion",
+    "Mode",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Moda",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Social/Political/Economics",
+    "Gesellschaft/Politik/Wirtschaft",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Sociedad/Política/Economía",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Magazine/Report/Documentary",
+    "Magazin/Bericht/Dokumentation",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Magazín/Reportaje/Documental",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Economics/Social Advisory",
+    "Wirtschafts/Gesellschaftsberatung",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Economía/Asesor social",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Remarkable People",
+    "Bemerkenswerte Leute",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Gente excepcional",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Education/Science/Factual",
+    "Ausbildung/Wissenschaft/Sachlich",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Educación/Ciencia/Práctico",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Nature/Animals/Environment",
+    "Natur/Tiere/Umwelt",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Naturaleza/Animales/Medio ambiente",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Technology/Natural Sciences",
+    "Technik/Naturwissenschaften",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Tecnología/Ciencias naturales",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Medicine/Physiology/Psychology",
+    "Medizin/Physiologie/Psychologie",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Medicina/Fisiología/Psicología",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Foreign Countries/Expeditions",
+    "Ausland/Expeditionen",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Países extranjeros/Expediciones",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Social/Spiritual Sciences",
+    "Sozial/Geisteswissenschaften",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Sociedad/Humanidades",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Further Education",
+    "Weiterbildung",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Formación continua",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Languages",
+    "Sprachen",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Idiomas",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Leisure/Hobbies",
+    "Freizeit/Hobbies",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Ocio y tiempo libre/Aficiones",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Tourism/Travel",
+    "Tourismus/Reisen",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Turismo/Viajes",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Handicraft",
+    "Handwerk",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Artesanía",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Motoring",
+    "Autofahren",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Automovilismo",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Fitness & Health",
+    "Fitness & Gesundheit",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Forma física y salud",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Cooking",
+    "Kochen",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Cocina",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Advertisement/Shopping",
+    "Werbung/Einkaufen",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Publicidad/Compras",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Gardening",
+    "Gartenbau",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Jardinería",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Original Language",
+    "Originalsprache",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Idioma original",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Black & White",
+    "Schwarz-weiß",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Blanco y negro",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Unpublished",
+    "Unveröffentlicht",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Inédito",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Content$Live Broadcast",
+    "Live-Sendung",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Programa en directo",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "ParentalRating$from %d",
+    "ab %d",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "a partir de %d",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
   { "This plugin has no setup parameters!",
     "Dieses Plugin hat keine Parameter!",
     "Ta vstavek nima nastavitvenih parametrov!",
diff -Naur VDR-NG-orig/INSTALL VDR-NG/INSTALL
--- VDR-NG-orig/INSTALL	2010-02-10 17:38:46.091269446 +0100
+++ VDR-NG/INSTALL	2010-02-10 17:38:39.903287937 +0100
@@ -67,13 +67,8 @@
 the defaults of which can be set via the RCU_DEVICE and LIRC_DEVICE macros,
 respectively.
 
-If your video directory will be on a VFAT partition, add the compile
-time switch
-
-  VFAT=1
-
-to the 'make' command. Alternatively, you can call VDR with the command
-line option '--vfat'.
+If your video directory will be on a VFAT partition, you can call VDR with
+the command line option '--vfat'.
 
 When running, the 'vdr' program writes status information into the
 system log file (/var/log/messages). You may want to watch these
diff -Naur VDR-NG-orig/libsi/si.c VDR-NG/libsi/si.c
--- VDR-NG-orig/libsi/si.c	2009-09-24 17:20:48.000000000 +0200
+++ VDR-NG/libsi/si.c	2010-02-10 16:59:00.000000000 +0100
@@ -280,7 +280,6 @@
       if (    ((' ' <= *from) && (*from <= '~'))
            || (*from == '\n')
            || (0xA0 <= *from)
-           || (*from == 0x86 || *from == 0x87)
          )
          *to++ = *from;
       else if (*from == 0x8A)
@@ -543,6 +542,7 @@
             break;
       }
       break;
+   default: ; // unknown domain, nothing to do
    }
    d->setData(da);
    return d;
diff -Naur VDR-NG-orig/libsi/si.h VDR-NG/libsi/si.h
--- VDR-NG-orig/libsi/si.h	2009-09-24 17:20:48.000000000 +0200
+++ VDR-NG/libsi/si.h	2010-02-10 16:59:00.000000000 +0100
@@ -28,7 +28,7 @@
                TableIdNIT_other  = 0x41, //network information section, other network
                TableIdSDT = 0x42, //service description section
                TableIdSDT_other  = 0x46,
-               TableIdBAT = 0x46, //bouquet association section
+               TableIdBAT = 0x4A, //bouquet association section
                TableIdEIT_presentFollowing = 0x4E, //event information section
                TableIdEIT_presentFollowing_other = 0x4F,
                //range from 0x50 to 0x5F
@@ -398,6 +398,8 @@
             return data.FourBytes(index);
          case 8:
             return (SixtyFourBit(data.FourBytes(index)) << 32) | data.FourBytes(index+4);
+         default:
+            return 0; // just to avoid a compiler warning
          }
          return 0; // just to avoid a compiler warning
       }
diff -Naur VDR-NG-orig/libsi/util.c VDR-NG/libsi/util.c
--- VDR-NG-orig/libsi/util.c	2009-09-24 17:20:48.000000000 +0200
+++ VDR-NG/libsi/util.c	2010-02-10 16:59:00.000000000 +0100
@@ -215,58 +215,73 @@
 
 //taken and adapted from libdtv, (c) Rolf Hakenes
 // CRC32 lookup table for polynomial 0x04c11db7
+// swapped bytes to avoid one shift operation in CRC loop (c) Reinhard Nissl
 u_int32_t CRC32::crc_table[256] = {
-   0x00000000, 0x04c11db7, 0x09823b6e, 0x0d4326d9, 0x130476dc, 0x17c56b6b,
-   0x1a864db2, 0x1e475005, 0x2608edb8, 0x22c9f00f, 0x2f8ad6d6, 0x2b4bcb61,
-   0x350c9b64, 0x31cd86d3, 0x3c8ea00a, 0x384fbdbd, 0x4c11db70, 0x48d0c6c7,
-   0x4593e01e, 0x4152fda9, 0x5f15adac, 0x5bd4b01b, 0x569796c2, 0x52568b75,
-   0x6a1936c8, 0x6ed82b7f, 0x639b0da6, 0x675a1011, 0x791d4014, 0x7ddc5da3,
-   0x709f7b7a, 0x745e66cd, 0x9823b6e0, 0x9ce2ab57, 0x91a18d8e, 0x95609039,
-   0x8b27c03c, 0x8fe6dd8b, 0x82a5fb52, 0x8664e6e5, 0xbe2b5b58, 0xbaea46ef,
-   0xb7a96036, 0xb3687d81, 0xad2f2d84, 0xa9ee3033, 0xa4ad16ea, 0xa06c0b5d,
-   0xd4326d90, 0xd0f37027, 0xddb056fe, 0xd9714b49, 0xc7361b4c, 0xc3f706fb,
-   0xceb42022, 0xca753d95, 0xf23a8028, 0xf6fb9d9f, 0xfbb8bb46, 0xff79a6f1,
-   0xe13ef6f4, 0xe5ffeb43, 0xe8bccd9a, 0xec7dd02d, 0x34867077, 0x30476dc0,
-   0x3d044b19, 0x39c556ae, 0x278206ab, 0x23431b1c, 0x2e003dc5, 0x2ac12072,
-   0x128e9dcf, 0x164f8078, 0x1b0ca6a1, 0x1fcdbb16, 0x018aeb13, 0x054bf6a4,
-   0x0808d07d, 0x0cc9cdca, 0x7897ab07, 0x7c56b6b0, 0x71159069, 0x75d48dde,
-   0x6b93dddb, 0x6f52c06c, 0x6211e6b5, 0x66d0fb02, 0x5e9f46bf, 0x5a5e5b08,
-   0x571d7dd1, 0x53dc6066, 0x4d9b3063, 0x495a2dd4, 0x44190b0d, 0x40d816ba,
-   0xaca5c697, 0xa864db20, 0xa527fdf9, 0xa1e6e04e, 0xbfa1b04b, 0xbb60adfc,
-   0xb6238b25, 0xb2e29692, 0x8aad2b2f, 0x8e6c3698, 0x832f1041, 0x87ee0df6,
-   0x99a95df3, 0x9d684044, 0x902b669d, 0x94ea7b2a, 0xe0b41de7, 0xe4750050,
-   0xe9362689, 0xedf73b3e, 0xf3b06b3b, 0xf771768c, 0xfa325055, 0xfef34de2,
-   0xc6bcf05f, 0xc27dede8, 0xcf3ecb31, 0xcbffd686, 0xd5b88683, 0xd1799b34,
-   0xdc3abded, 0xd8fba05a, 0x690ce0ee, 0x6dcdfd59, 0x608edb80, 0x644fc637,
-   0x7a089632, 0x7ec98b85, 0x738aad5c, 0x774bb0eb, 0x4f040d56, 0x4bc510e1,
-   0x46863638, 0x42472b8f, 0x5c007b8a, 0x58c1663d, 0x558240e4, 0x51435d53,
-   0x251d3b9e, 0x21dc2629, 0x2c9f00f0, 0x285e1d47, 0x36194d42, 0x32d850f5,
-   0x3f9b762c, 0x3b5a6b9b, 0x0315d626, 0x07d4cb91, 0x0a97ed48, 0x0e56f0ff,
-   0x1011a0fa, 0x14d0bd4d, 0x19939b94, 0x1d528623, 0xf12f560e, 0xf5ee4bb9,
-   0xf8ad6d60, 0xfc6c70d7, 0xe22b20d2, 0xe6ea3d65, 0xeba91bbc, 0xef68060b,
-   0xd727bbb6, 0xd3e6a601, 0xdea580d8, 0xda649d6f, 0xc423cd6a, 0xc0e2d0dd,
-   0xcda1f604, 0xc960ebb3, 0xbd3e8d7e, 0xb9ff90c9, 0xb4bcb610, 0xb07daba7,
-   0xae3afba2, 0xaafbe615, 0xa7b8c0cc, 0xa379dd7b, 0x9b3660c6, 0x9ff77d71,
-   0x92b45ba8, 0x9675461f, 0x8832161a, 0x8cf30bad, 0x81b02d74, 0x857130c3,
-   0x5d8a9099, 0x594b8d2e, 0x5408abf7, 0x50c9b640, 0x4e8ee645, 0x4a4ffbf2,
-   0x470cdd2b, 0x43cdc09c, 0x7b827d21, 0x7f436096, 0x7200464f, 0x76c15bf8,
-   0x68860bfd, 0x6c47164a, 0x61043093, 0x65c52d24, 0x119b4be9, 0x155a565e,
-   0x18197087, 0x1cd86d30, 0x029f3d35, 0x065e2082, 0x0b1d065b, 0x0fdc1bec,
-   0x3793a651, 0x3352bbe6, 0x3e119d3f, 0x3ad08088, 0x2497d08d, 0x2056cd3a,
-   0x2d15ebe3, 0x29d4f654, 0xc5a92679, 0xc1683bce, 0xcc2b1d17, 0xc8ea00a0,
-   0xd6ad50a5, 0xd26c4d12, 0xdf2f6bcb, 0xdbee767c, 0xe3a1cbc1, 0xe760d676,
-   0xea23f0af, 0xeee2ed18, 0xf0a5bd1d, 0xf464a0aa, 0xf9278673, 0xfde69bc4,
-   0x89b8fd09, 0x8d79e0be, 0x803ac667, 0x84fbdbd0, 0x9abc8bd5, 0x9e7d9662,
-   0x933eb0bb, 0x97ffad0c, 0xafb010b1, 0xab710d06, 0xa6322bdf, 0xa2f33668,
-   0xbcb4666d, 0xb8757bda, 0xb5365d03, 0xb1f740b4};
+   0x00000000, 0xb71dc104, 0x6e3b8209, 0xd926430d, 0xdc760413, 0x6b6bc517,
+   0xb24d861a, 0x0550471e, 0xb8ed0826, 0x0ff0c922, 0xd6d68a2f, 0x61cb4b2b,
+   0x649b0c35, 0xd386cd31, 0x0aa08e3c, 0xbdbd4f38, 0x70db114c, 0xc7c6d048,
+   0x1ee09345, 0xa9fd5241, 0xacad155f, 0x1bb0d45b, 0xc2969756, 0x758b5652,
+   0xc836196a, 0x7f2bd86e, 0xa60d9b63, 0x11105a67, 0x14401d79, 0xa35ddc7d,
+   0x7a7b9f70, 0xcd665e74, 0xe0b62398, 0x57abe29c, 0x8e8da191, 0x39906095,
+   0x3cc0278b, 0x8bdde68f, 0x52fba582, 0xe5e66486, 0x585b2bbe, 0xef46eaba,
+   0x3660a9b7, 0x817d68b3, 0x842d2fad, 0x3330eea9, 0xea16ada4, 0x5d0b6ca0,
+   0x906d32d4, 0x2770f3d0, 0xfe56b0dd, 0x494b71d9, 0x4c1b36c7, 0xfb06f7c3,
+   0x2220b4ce, 0x953d75ca, 0x28803af2, 0x9f9dfbf6, 0x46bbb8fb, 0xf1a679ff,
+   0xf4f63ee1, 0x43ebffe5, 0x9acdbce8, 0x2dd07dec, 0x77708634, 0xc06d4730,
+   0x194b043d, 0xae56c539, 0xab068227, 0x1c1b4323, 0xc53d002e, 0x7220c12a,
+   0xcf9d8e12, 0x78804f16, 0xa1a60c1b, 0x16bbcd1f, 0x13eb8a01, 0xa4f64b05,
+   0x7dd00808, 0xcacdc90c, 0x07ab9778, 0xb0b6567c, 0x69901571, 0xde8dd475,
+   0xdbdd936b, 0x6cc0526f, 0xb5e61162, 0x02fbd066, 0xbf469f5e, 0x085b5e5a,
+   0xd17d1d57, 0x6660dc53, 0x63309b4d, 0xd42d5a49, 0x0d0b1944, 0xba16d840,
+   0x97c6a5ac, 0x20db64a8, 0xf9fd27a5, 0x4ee0e6a1, 0x4bb0a1bf, 0xfcad60bb,
+   0x258b23b6, 0x9296e2b2, 0x2f2bad8a, 0x98366c8e, 0x41102f83, 0xf60dee87,
+   0xf35da999, 0x4440689d, 0x9d662b90, 0x2a7bea94, 0xe71db4e0, 0x500075e4,
+   0x892636e9, 0x3e3bf7ed, 0x3b6bb0f3, 0x8c7671f7, 0x555032fa, 0xe24df3fe,
+   0x5ff0bcc6, 0xe8ed7dc2, 0x31cb3ecf, 0x86d6ffcb, 0x8386b8d5, 0x349b79d1,
+   0xedbd3adc, 0x5aa0fbd8, 0xeee00c69, 0x59fdcd6d, 0x80db8e60, 0x37c64f64,
+   0x3296087a, 0x858bc97e, 0x5cad8a73, 0xebb04b77, 0x560d044f, 0xe110c54b,
+   0x38368646, 0x8f2b4742, 0x8a7b005c, 0x3d66c158, 0xe4408255, 0x535d4351,
+   0x9e3b1d25, 0x2926dc21, 0xf0009f2c, 0x471d5e28, 0x424d1936, 0xf550d832,
+   0x2c769b3f, 0x9b6b5a3b, 0x26d61503, 0x91cbd407, 0x48ed970a, 0xfff0560e,
+   0xfaa01110, 0x4dbdd014, 0x949b9319, 0x2386521d, 0x0e562ff1, 0xb94beef5,
+   0x606dadf8, 0xd7706cfc, 0xd2202be2, 0x653deae6, 0xbc1ba9eb, 0x0b0668ef,
+   0xb6bb27d7, 0x01a6e6d3, 0xd880a5de, 0x6f9d64da, 0x6acd23c4, 0xddd0e2c0,
+   0x04f6a1cd, 0xb3eb60c9, 0x7e8d3ebd, 0xc990ffb9, 0x10b6bcb4, 0xa7ab7db0,
+   0xa2fb3aae, 0x15e6fbaa, 0xccc0b8a7, 0x7bdd79a3, 0xc660369b, 0x717df79f,
+   0xa85bb492, 0x1f467596, 0x1a163288, 0xad0bf38c, 0x742db081, 0xc3307185,
+   0x99908a5d, 0x2e8d4b59, 0xf7ab0854, 0x40b6c950, 0x45e68e4e, 0xf2fb4f4a,
+   0x2bdd0c47, 0x9cc0cd43, 0x217d827b, 0x9660437f, 0x4f460072, 0xf85bc176,
+   0xfd0b8668, 0x4a16476c, 0x93300461, 0x242dc565, 0xe94b9b11, 0x5e565a15,
+   0x87701918, 0x306dd81c, 0x353d9f02, 0x82205e06, 0x5b061d0b, 0xec1bdc0f,
+   0x51a69337, 0xe6bb5233, 0x3f9d113e, 0x8880d03a, 0x8dd09724, 0x3acd5620,
+   0xe3eb152d, 0x54f6d429, 0x7926a9c5, 0xce3b68c1, 0x171d2bcc, 0xa000eac8,
+   0xa550add6, 0x124d6cd2, 0xcb6b2fdf, 0x7c76eedb, 0xc1cba1e3, 0x76d660e7,
+   0xaff023ea, 0x18ede2ee, 0x1dbda5f0, 0xaaa064f4, 0x738627f9, 0xc49be6fd,
+   0x09fdb889, 0xbee0798d, 0x67c63a80, 0xd0dbfb84, 0xd58bbc9a, 0x62967d9e,
+   0xbbb03e93, 0x0cadff97, 0xb110b0af, 0x060d71ab, 0xdf2b32a6, 0x6836f3a2,
+   0x6d66b4bc, 0xda7b75b8, 0x035d36b5, 0xb440f7b1};
+
+inline void swap_bytes(u_int32_t &crc)
+{
+  unsigned char a = crc >> 24;
+  unsigned char b = crc >> 16;
+  unsigned char c = crc >> 8;
+  unsigned char d = crc;
+
+  crc = ((d << 8 | c) << 8 | b) << 8 | a;
+}
 
 u_int32_t CRC32::crc32 (const char *d, int len, u_int32_t crc)
 {
    register int i;
    const unsigned char *u=(unsigned char*)d; // Saves '& 0xff'
 
+   swap_bytes(crc);
+
    for (i=0; i<len; i++)
-      crc = (crc << 8) ^ crc_table[((crc >> 24) ^ *u++)];
+      crc = (crc >> 8) ^ crc_table[(unsigned char)crc ^ *u++];
+
+   swap_bytes(crc);
 
    return crc;
 }
diff -Naur VDR-NG-orig/lirc.c VDR-NG/lirc.c
--- VDR-NG-orig/lirc.c	2010-02-10 16:57:28.000000000 +0100
+++ VDR-NG/lirc.c	2010-02-10 16:59:00.000000000 +0100
@@ -71,42 +71,28 @@
   char buf[LIRC_BUFFER_SIZE];
   char LastKeyName[LIRC_KEY_BUF] = "";
   bool repeat = false;
-//M7X0 BEGIN AK
-// This should fix broken shutdown
+  int ret, ch;
   int timeout = DEFAULTTIMEOUT;
-  int i,ret=0;
-  char *end=NULL;
-//M7X0 END AK
 
   while (Running() && f >= 0) {
-        int endcount = end ? end - buf + 1 : ret;
-        if (endcount < ret) {
-           memcpy (buf,buf + endcount, ret - endcount);
-           ret -= endcount;
-           end = NULL;
-           }
-        else if (ret < 0 || endcount == ret || ret >= LIRC_BUFFER_SIZE) {
-           ret = 0;
-           end = NULL;
-           }
         bool ready = cFile::FileReady(f, timeout);
-//M7X0 BEGIN AK
+        ret = -1;
         if (ready) {
-           //ret = 0;
-           do {
-              i = safe_read(f, buf + ret, LIRC_BUFFER_SIZE - ret);
-              if (i < 0) {
-                 ret = i;
-                 break;
-                 }
-              ret += i;
-              } while ((!ret || !(end = (char *)memchr(buf,'\n',ret))) && ret < LIRC_BUFFER_SIZE);
-           buf[ret<0 ? 0 : (ret<LIRC_BUFFER_SIZE?ret:LIRC_BUFFER_SIZE-1)]=0;
-          // dsyslog("LIRC Buffer '%s' read with %d Bytes",buf,ret);
+           // read one line of the line oriented lirc protocol
+           for (ret = 0; ret < (int)sizeof(buf); ret++) {
+               ch = readchar(f);
+               if (ch < 0) {
+                  ret = -1;
+                  break;
+                  }
+               if (ch == '\n') {
+                  buf[ret++] = '\0';
+                  break;
+                  }
+               buf[ret] = ch;
+               }
            }
-        //else
-        //   ret = -1;
-//M7X0 END AK
+
         if (ready && ret <= 0 ) {
            esyslog("ERROR: lircd connection broken, trying to reconnect every %.1f seconds", float(RECONNECTDELAY) / 1000);
            close(f);
diff -Naur VDR-NG-orig/Make.config VDR-NG/Make.config
--- VDR-NG-orig/Make.config	2009-09-24 17:21:12.000000000 +0200
+++ VDR-NG/Make.config	2010-02-10 16:59:00.000000000 +0100
@@ -28,7 +28,6 @@
 
 REMOTE=LIRC
 NO_KBD=1
-VFAT=1
 DEFINES+= -D_REENTRANT -D_GNU_SOURCE -DUSE_TUNER_AUTOVALUES
 # TESTING 
 # DEFINES += -DUSE_HW_VIDEO_FRAME_EVENTS # Use Hardware Frame Events
diff -Naur VDR-NG-orig/Makefile VDR-NG/Makefile
--- VDR-NG-orig/Makefile	2010-02-10 16:57:32.000000000 +0100
+++ VDR-NG/Makefile	2010-02-10 16:59:00.000000000 +0100
@@ -92,11 +92,6 @@
 VDRVERSION = $(shell sed -ne '/define VDRVERSION/s/^.*"\(.*\)".*$$/\1/p' config.h)
 APIVERSION = $(shell sed -ne '/define APIVERSION/s/^.*"\(.*\)".*$$/\1/p' config.h)
 
-ifdef VFAT
-# for people who want their video directory on a VFAT partition
-DEFINES += -DVFAT
-endif
-
 all: vdr
 font: genfontfile\
       fontfix-iso8859-1.c fontosd-iso8859-1.c fontsml-iso8859-1.c\
diff -Naur VDR-NG-orig/MANUAL VDR-NG/MANUAL
--- VDR-NG-orig/MANUAL	2010-02-10 17:40:08.391267647 +0100
+++ VDR-NG/MANUAL	2010-02-10 17:40:03.915267524 +0100
@@ -700,6 +700,13 @@
   Pause priority = 10    The Priority and Lifetime values used when pausing live
   Pause lifetime = 1     video.
 
+  Pause key handling = 2 Defines what happens if the Pause key on the remote control
+                         is pressed during live tv.
+                         0 = do not pause live video
+                         1 = confirm pause live video
+                         2 = pause live video
+                         The default is 2.
+
   Use episode name = yes Repeating timers use the EPG's 'Episode name' information
                          to create recording file names in a hierarchical structure
                          (for instance to gather all episodes of a series in a
@@ -787,6 +794,15 @@
   Zap Timeout = 3        The time (in seconds) until a channel counts as "previous"
                          for switching with '0'
 
+  Channel entry timeout = 1000
+                         The time (in milliseconds) after the last keypress until
+                         a numerically entered channel number is considered
+                         complete, and the channel is switched. Default is 1000,
+                         a value of 0 turns this off, so a numerically entered
+                         channel number then needs to be confirmed with the "Ok"
+                         key. Note that the total maximum is also limited by
+                         the "OSD/Channel info time" parameter.
+
   Initial channel = 0    The number of the channel that shall be tuned to when
                          VDR starts. Default is 0, which means that it will
                          tune to the channel that was on before VDR was stopped.
diff -Naur VDR-NG-orig/menu.c VDR-NG/menu.c
--- VDR-NG-orig/menu.c	2010-02-10 16:57:34.000000000 +0100
+++ VDR-NG/menu.c	2010-02-10 16:59:00.000000000 +0100
@@ -129,16 +129,23 @@
   eOSState state = cMenuEditItem::ProcessKey(Key);
 
   if (state == osUnknown) {
-     if (NORMALKEY(Key) == kLeft) { // TODO might want to increase the delta if repeated quickly?
-        if (source && source->Prev()) {
-           source = (cSource *)source->Prev();
+     bool IsRepeat = Key & k_Repeat;
+     Key = NORMALKEY(Key);
+     if (Key == kLeft) { // TODO might want to increase the delta if repeated quickly?
+        if (source) {
+           if (source->Prev())
+              source = (cSource *)source->Prev();
+           else if (!IsRepeat)
+              source = Sources.Last();
            *value = source->Code();
            }
         }
-     else if (NORMALKEY(Key) == kRight) {
+     else if (Key == kRight) {
         if (source) {
            if (source->Next())
               source = (cSource *)source->Next();
+           else if (!IsRepeat)
+              source = Sources.First();
            }
         else
            source = Sources.First();
@@ -566,6 +573,7 @@
         Channels.Del(channel);
         cOsdMenu::Del(Index);
         Propagate();
+        Channels.SetModified(true);
         isyslog("channel %d deleted", DeletedChannel);
         if (CurrentChannel && CurrentChannel->Number() != CurrentChannelNr) {
            if (!cDevice::PrimaryDevice()->Replaying() || cDevice::PrimaryDevice()->Transferring())
@@ -590,6 +598,7 @@
      Channels.Move(FromChannel, ToChannel);
      cOsdMenu::Move(From, To);
      Propagate();
+     Channels.SetModified(true);
      isyslog("channel %d moved to %d", FromNumber, ToNumber);
      if (CurrentChannel && CurrentChannel->Number() != CurrentChannelNr) {
         if (!cDevice::PrimaryDevice()->Replaying() || cDevice::PrimaryDevice()->Transferring())
@@ -692,7 +701,7 @@
     case kRight|k_Repeat:
     case kRight:
                   DisplayMenu()->Scroll(NORMALKEY(Key) == kUp || NORMALKEY(Key) == kLeft, NORMALKEY(Key) == kLeft || NORMALKEY(Key) == kRight);
-                  cStatus::MsgOsdTextItem(NULL, NORMALKEY(Key) == kUp);
+                  cStatus::MsgOsdTextItem(NULL, NORMALKEY(Key) == kUp || NORMALKEY(Key) == kLeft);
                   return osContinue;
     default: break;
     }
@@ -739,12 +748,12 @@
         free(buf);
         }
 
-     char* p = strrchr(data.file, '~');
+     char* p = strrchr(data.file, FOLDERDELIMCHAR);
      if (p) {
         p++;
         strn0cpy(name, p, sizeof(name));
         strn0cpy(path, data.file, sizeof(path));
-        p = strrchr(path, '~');
+        p = strrchr(path, FOLDERDELIMCHAR);
         if (p)
            p[0] = 0;
         }   
@@ -879,6 +888,11 @@
      strftime(buffer, sizeof(buffer), "%Y%m%d", &tm_r);
      day = buffer;
      }
+  const char *File = Setup.FoldersInTimerMenu ? NULL : strrchr(timer->File(), FOLDERDELIMCHAR);
+  if (File && strcmp(File + 1, TIMERMACRO_TITLE) && strcmp(File + 1, TIMERMACRO_EPISODE))
+     File++;
+  else
+     File = timer->File();
   char *buffer = NULL;
   asprintf(&buffer, "%c\t%d\t%s%s%s\t%02d:%02d\t%02d:%02d\t%s",
                     !(timer->HasFlags(tfActive)) ? ' ' : timer->FirstDay() ? Setup.WarEagleIcons ? ICON_PFEIL : '!' : timer->Recording() ? Setup.WarEagleIcons ? ICON_REC : '#' : Setup.WarEagleIcons ? ICON_UHR : '>',
@@ -890,7 +904,7 @@
                     timer->Start() % 100,
                     timer->Stop() / 100,
                     timer->Stop() % 100,
-                    timer->File());
+                    File);
   char *buffer2 = buffer;
   buffer = NULL;
   asprintf(&buffer, "%c%s", diskStatus, buffer2);
@@ -1259,7 +1273,7 @@
     case kRight|k_Repeat:
     case kRight:
                   DisplayMenu()->Scroll(NORMALKEY(Key) == kUp || NORMALKEY(Key) == kLeft, NORMALKEY(Key) == kLeft || NORMALKEY(Key) == kRight);
-                  cStatus::MsgOsdTextItem(NULL, NORMALKEY(Key) == kUp);
+                  cStatus::MsgOsdTextItem(NULL, NORMALKEY(Key) == kUp || NORMALKEY(Key) == kLeft);
                   return osContinue;
     default: break;
     }
@@ -1698,6 +1712,7 @@
     case cMenuScheduleItem::ssmThisThis: PrepareScheduleThisThis(Event, Channel); break;
     case cMenuScheduleItem::ssmThisAll:  PrepareScheduleThisAll(Event, Channel); break;
     case cMenuScheduleItem::ssmAllAll:   PrepareScheduleAllAll(Event, Channel); break;
+    default: esyslog("ERROR: unknown SortMode %d (%s %d)", cMenuScheduleItem::SortMode(), __FUNCTION__, __LINE__);
     }
   CurrentItem = (cMenuScheduleItem *)Get(Current());
   Sort();
@@ -2075,7 +2090,7 @@
     case kRight|k_Repeat:
     case kRight:
                   DisplayMenu()->Scroll(NORMALKEY(Key) == kUp || NORMALKEY(Key) == kLeft, NORMALKEY(Key) == kLeft || NORMALKEY(Key) == kRight);
-                  cStatus::MsgOsdTextItem(NULL, NORMALKEY(Key) == kUp);
+                  cStatus::MsgOsdTextItem(NULL, NORMALKEY(Key) == kUp || NORMALKEY(Key) == kLeft);
                   return osContinue;
     default: break;
     }
@@ -2179,12 +2194,12 @@
   priority = recording->priority;
   lifetime = recording->lifetime;
 
-  char* p = strrchr(recording->Name(), '~');
+  char* p = strrchr(recording->Name(), FOLDERDELIMCHAR);
   if (p) {
      p++;
      strn0cpy(name, p, sizeof(name));
      strn0cpy(path, recording->Name(), sizeof(path));
-     p = strrchr(path, '~');
+     p = strrchr(path, FOLDERDELIMCHAR);
      if (p)
         p[0] = 0;
      }
@@ -2344,6 +2359,7 @@
        case 1: SetHelp(tr("Button$Open")); break;
        case 2:
        case 3: SetHelp(RecordingCommands.Count() ? tr("Commands") : tr("Button$Play"), tr("Button$Rewind"), tr("Button$Delete"), NewHelpKeys == 3 ? tr("Button$Info") : NULL);
+       default: ;
        }
      helpKeys = NewHelpKeys;
      }
@@ -2366,7 +2382,7 @@
   Clear();
   Recordings.Sort();
   for (cRecording *recording = Recordings.First(); recording; recording = Recordings.Next(recording)) {
-      if (!base || (strstr(recording->Name(), base) == recording->Name() && recording->Name()[strlen(base)] == '~')) {
+      if (!base || (strstr(recording->Name(), base) == recording->Name() && recording->Name()[strlen(base)] == FOLDERDELIMCHAR)) {
          cMenuRecordingItem *Item = new cMenuRecordingItem(recording, level);
          if ((*Item->Text() && (!LastItem || strcmp(Item->Text(), LastItemText) != 0))
             && (!cStatus::MsgReplayProtected(GetRecording(Item), Item->Name(), base,
@@ -2528,7 +2544,7 @@
      cRecording *recording = GetRecording(ri);
      if (recording) {
         char *parameter = NULL;
-        asprintf(&parameter, "\"%s\"", *strescape(recording->FileName(), "\"$"));
+        asprintf(&parameter, "\"%s\"", *strescape(recording->FileName(), "\\\"$"));
         cMenuCommands *menu;
         eOSState state = AddSubMenu(menu = new cMenuCommands(tr("Recording commands"), &RecordingCommands, parameter));
         free(parameter);
@@ -2685,6 +2701,7 @@
   Add(new cMenuEditBoolItem(tr("Setup.OSD$Scroll wraps"),           &data.MenuScrollWrap));
   Add(new cMenuEditBoolItem(tr("Setup.OSD$Menu button closes"),     &data.MenuButtonCloses));
   Add(new cMenuEditBoolItem(tr("Setup.OSD$Recording directories"),  &data.RecordingDirs));
+  Add(new cMenuEditBoolItem(tr("Setup.OSD$Folders in timer menu"),  &data.FoldersInTimerMenu));
   Add(new cMenuEditBoolItem(tr("Setup.OSD$Main menu command position"), &data.MenuCmdPosition, tr("bottom"), tr("top")));
   SetCurrent(Get(current));
   Display();
@@ -3168,6 +3185,8 @@
 
 class cMenuSetupRecord : public cMenuSetupBase {
 private:
+  const char *pauseKeyHandlingTexts[3];
+  const char *delTimeshiftRecTexts[3];
   const char *RecordingsSortModeTexts[MAXSORTMODES];
 public:
   cMenuSetupRecord(void);
@@ -3175,6 +3194,12 @@
 
 cMenuSetupRecord::cMenuSetupRecord(void)
 {
+  pauseKeyHandlingTexts[0] = tr("do not pause live video");
+  pauseKeyHandlingTexts[1] = tr("confirm pause live video");
+  pauseKeyHandlingTexts[2] = tr("pause live video");
+  delTimeshiftRecTexts[0] = tr("no");
+  delTimeshiftRecTexts[1] = tr("confirm");
+  delTimeshiftRecTexts[2] = tr("yes");
   RecordingsSortModeTexts[0] = tr("main dir alphabetically, subdirs flexible");
   RecordingsSortModeTexts[1] = tr("main dir by date, subdirs flexible");
   RecordingsSortModeTexts[2] = tr("all alphabetically");
@@ -3186,9 +3211,11 @@
   Add(new cMenuEditIntItem( tr("Setup.Recording$Primary limit"),             &data.PrimaryLimit, 0, MAXPRIORITY));
   Add(new cMenuEditIntItem( tr("Setup.Recording$Default priority"),          &data.DefaultPriority, 0, MAXPRIORITY));
   Add(new cMenuEditIntItem( tr("Setup.Recording$Default lifetime (d)"),      &data.DefaultLifetime, 0, MAXLIFETIME));
+  Add(new cMenuEditStraItem(tr("Setup.Recording$Pause key handling"),        &data.PauseKeyHandling, 3, pauseKeyHandlingTexts));
   Add(new cMenuEditIntItem( tr("Setup.Recording$Pause priority"),            &data.PausePriority, 0, MAXPRIORITY));
   Add(new cMenuEditIntItem( tr("Setup.Recording$Pause lifetime (d)"),        &data.PauseLifetime, 0, MAXLIFETIME));
   Add(new cMenuEditBoolItem(tr("Setup.Recording$Use episode name"),          &data.UseSubtitle));
+  Add(new cMenuEditStraItem(tr("Setup.Recording$Delete timeshift recording"),&data.DelTimeshiftRec, 3, delTimeshiftRecTexts));
   Add(new cMenuEditBoolItem(tr("Setup.Recording$Use VPS"),                   &data.UseVps));
   Add(new cMenuEditIntItem( tr("Setup.Recording$VPS margin (s)"),            &data.VpsMargin, 0));
   Add(new cMenuEditBoolItem(tr("Setup.Recording$Record Dolby Digital"),      &data.UseDolbyInRecordings));
@@ -3278,6 +3305,7 @@
   Add(new cMenuEditIntItem( tr("Setup.Miscellaneous$Min. user inactivity (min)"), &data.MinUserInactivity));
   Add(new cMenuEditIntItem( tr("Setup.Miscellaneous$SVDRP timeout (s)"),          &data.SVDRPTimeout));
   Add(new cMenuEditIntItem( tr("Setup.Miscellaneous$Zap timeout (s)"),            &data.ZapTimeout));
+  Add(new cMenuEditIntItem( tr("Setup.Miscellaneous$Channel entry timeout (ms)"), &data.ChannelEntryTimeout, 0));
   Add(new cMenuEditStraItem(tr("Setup.Miscellaneous$Filter channels"),            &data.ChannelFilter, 3, channelFilterTexts));;    
   Add(new cMenuEditChanItem(tr("Setup.Miscellaneous$Initial channel"),            &data.InitialChannel, tr("Setup.Miscellaneous$as before")));
   Add(new cMenuEditIntItem( tr("Setup.Miscellaneous$Initial volume"),             &data.InitialVolume, -1, 255, tr("Setup.Miscellaneous$as before")));
@@ -3904,8 +3932,6 @@
 
 // --- cDisplayChannel -------------------------------------------------------
 
-#define DIRECTCHANNELTIMEOUT 1000 //ms
-
 cDisplayChannel *cDisplayChannel::currentDisplayChannel = NULL;
 
 cDisplayChannel::cDisplayChannel(int Number, bool Switched)
@@ -4141,7 +4167,7 @@
          Refresh();
          break;
     case kNone:
-         if (number && lastTime.Elapsed() > DIRECTCHANNELTIMEOUT) {
+         if (number && Setup.ChannelEntryTimeout && int(lastTime.Elapsed()) > Setup.ChannelEntryTimeout) {
             channel = Channels.GetByNumber(number);
             if (channel)
                NewChannel = channel;
@@ -4384,7 +4410,7 @@
          timeout.Set(TRACKTIMEOUT);
          break;
     case kOk:
-         if (track != cDevice::PrimaryDevice()->GetCurrentAudioTrack())
+         if (types[track] != cDevice::PrimaryDevice()->GetCurrentAudioTrack())
             oldTrack = -1; // make sure we explicitly switch to that track
          timeout.Set();
          break;
@@ -4512,22 +4538,26 @@
   return false;
 }
 
-void cRecordControl::Stop(void)
+void cRecordControl::Stop(bool ExecuteUserCommand)
 {
   if (timer) {
      DELETENULL(recorder);
      timer->SetRecording(false);
      timer = NULL;
      cStatus::MsgRecording(device, NULL, fileName, false);
-     cRecordingUserCommand::InvokeCommand(RUC_AFTERRECORDING, fileName);
+     if (ExecuteUserCommand)
+        cRecordingUserCommand::InvokeCommand(RUC_AFTERRECORDING, fileName);
      }
 }
 
 bool cRecordControl::Process(time_t t)
 {
 //M7X0 BEGIN AK
-  if (!recorder || !recorder->Activated() || !timer || !timer->Matches(t))
+  if (!recorder || !recorder->Activated() || !timer || !timer->Matches(t)) {
+     if (timer)
+        timer->SetPending(false);
      return false;
+     }
   AssertFreeDiskSpace(timer->Priority());
   return true;
 //M7X0 END AK
@@ -4662,10 +4692,12 @@
 
 cRecordControl *cRecordControls::GetRecordControl(const char *FileName)
 {
-  for (int i = 0; i < MAXRECORDCONTROLS; i++) {
-      if (RecordControls[i] && strcmp(RecordControls[i]->FileName(), FileName) == 0)
-         return RecordControls[i];
-      }
+  if (FileName) {
+     for (int i = 0; i < MAXRECORDCONTROLS; i++) {
+         if (RecordControls[i] && strcmp(RecordControls[i]->FileName(), FileName) == 0)
+            return RecordControls[i];
+         }
+     }
   return NULL;
 }
 
@@ -4754,6 +4786,38 @@
      currentReplayControl = NULL;
 }
 
+void cReplayControl::Stop(void)
+{
+  if (Setup.DelTimeshiftRec && fileName) {
+     cRecordControl* rc = cRecordControls::GetRecordControl(fileName);
+     if (rc && rc->InstantId()) {
+        if (Active()) {
+           if (Setup.DelTimeshiftRec == 2 || Interface->Confirm(tr("Delete timeshift recording?"))) {
+              cTimer *timer = rc->Timer();
+              rc->Stop(false); // don't execute user command
+              if (timer) {
+                 isyslog("deleting timer %s", *timer->ToDescr());
+                 Timers.Del(timer);
+                 Timers.SetModified();
+                 }
+              cDvbPlayerControl::Stop();
+              cRecording *recording = Recordings.GetByName(fileName);;
+              if (recording) {
+                 if (recording->Delete()) {
+                    Recordings.DelByName(fileName);
+                    ClearLastReplayed(fileName);
+                    }
+                 else
+                    Skins.Message(mtError, tr("Error while deleting recording!"));
+                 }
+              return;
+              }
+           }
+        }
+     }
+  cDvbPlayerControl::Stop();
+}
+
 void cReplayControl::SetRecording(const char *FileName, const char *Title)
 {
   free(fileName);
@@ -4921,7 +4985,8 @@
          timeSearchActive = false;
          break;
     default:
-         timeSearchActive = false;
+         if (!(Key & k_Flags)) // ignore repeat/release keys
+            timeSearchActive = false;
          break;
     }
 
@@ -5180,7 +5245,11 @@
                            else
                               Show();
                            break;
-            case kBack:    return osRecordings;
+            case kBack:    if (Setup.DelTimeshiftRec) { 
+                              cRecordControl* rc = cRecordControls::GetRecordControl(fileName);
+                              return rc && rc->InstantId() ? osEnd : osRecordings;
+                              }
+                           return osRecordings;
             default:       return osUnknown;
             }
           }
diff -Naur VDR-NG-orig/menu.h VDR-NG/menu.h
--- VDR-NG-orig/menu.h	2010-04-29 18:40:41.000000000 +0200
+++ VDR-NG/menu.h	2010-04-29 19:10:04.294971024 +0200
@@ -198,7 +198,7 @@
   virtual ~cRecordControl();
   bool Process(time_t t);
   cDevice *Device(void) { return device; }
-  void Stop(void);
+  void Stop(bool ExecuteUserCommand = true);
   const char *InstantId(void) { return instantId; }
   const char *FileName(void) { return fileName; }
   cTimer *Timer(void) { return timer; }
@@ -251,6 +251,7 @@
 public:
   cReplayControl(void);
   virtual ~cReplayControl();
+  void Stop(void);
   virtual cOsdObject *GetInfo(void);
   virtual eOSState ProcessKey(eKeys Key);
   virtual void Show(void);
diff -Naur VDR-NG-orig/menuitems.c VDR-NG/menuitems.c
--- VDR-NG-orig/menuitems.c	2010-02-10 16:56:56.000000000 +0100
+++ VDR-NG/menuitems.c	2010-02-10 16:59:02.000000000 +0100
@@ -103,7 +103,7 @@
             if (*value > max) { *value = max; Set(); }
             return state;
        }
-     if (newValue != *value && (!fresh || min <= newValue) && newValue <= max) {
+     if (!DoubleEqual(newValue, *value) && (!fresh || min <= newValue) && newValue <= max) {
         *value = newValue;
         Set();
         }
@@ -221,7 +221,8 @@
 void cMenuEditChrItem::Set(void)
 {
   char buf[2];
-  snprintf(buf, sizeof(buf), "%c", *value);
+  buf[0] = *value;
+  buf[1] = '\0';
   SetValue(buf);
 }
 
@@ -412,9 +413,7 @@
                  break;
     case kBlue|k_Repeat:
     case kBlue:  // consume the key only if in edit-mode
-                 if (InEditMode())
-                    ;
-                 else
+                 if (!InEditMode())
                     return osUnknown;
                  break;
     case kLeft|k_Repeat:
@@ -422,9 +421,9 @@
                     if (!insert || newchar)
                        pos--;
                     newchar = true;
+                    if (!insert && isalpha(value[pos]))
+                       uppercase = isupper(value[pos]);
                     }
-                 if (!insert && isalpha(value[pos]))
-                    uppercase = isupper(value[pos]);
                  break;
     case kRight|k_Repeat:
     case kRight: AdvancePos();
@@ -993,6 +992,7 @@
                      pos++;
                      }
                   break;
+          default: ;
           }
         }
      else if (NORMALKEY(Key) == kLeft) { // TODO might want to increase the delta if repeated quickly?
diff -Naur VDR-NG-orig/nit.c VDR-NG/nit.c
--- VDR-NG-orig/nit.c	2009-09-24 17:21:12.000000000 +0200
+++ VDR-NG/nit.c	2010-02-10 16:59:02.000000000 +0100
@@ -112,6 +112,7 @@
                   case 1: f = BCD2INT(f) / 100; break;
                   case 2: f = BCD2INT(f) / 10; break;
                   case 3: f = f * 10;  break;
+                  default: ;
                   }
                 Frequencies[n++] = f;
                 }
@@ -142,33 +143,33 @@
                         }
                     break;
                     }
-                 bool found = false;
-                 for (cChannel *Channel = Channels.First(); Channel; Channel = Channels.Next(Channel)) {
-                     if (!Channel->GroupSep() && Channel->Source() == Source && Channel->Nid() == ts.getOriginalNetworkId() && Channel->Tid() == ts.getTransportStreamId()) {
-                        if (Setup.UpdateChannels >= 5) {
-                           if (!ISTRANSPONDER(cChannel::Transponder(Frequency, Polarization), Channel->Transponder())) {
-                              for (int n = 0; n < NumFrequencies; n++) {
-                                  if (ISTRANSPONDER(cChannel::Transponder(Frequencies[n], Polarization), Channel->Transponder())) {
-                                     Frequency = Frequencies[n];
-                                     break;
-                                     }
+                 if (Setup.UpdateChannels >= 5) {
+                    bool found = false;
+                    cIterator<cChannel> ChannelIterator = Channels.GetChannelsBySourceNidTid(Source, ts.getOriginalNetworkId(), ts.getTransportStreamId());
+                    for (cChannel *Channel = ChannelIterator.First(); Channel; Channel = ChannelIterator.Next()) {
+                        int transponder = Channel->Transponder();
+                        found = true;
+                        if (!ISTRANSPONDER(cChannel::Transponder(Frequency, Polarization), transponder)) {
+                           for (int n = 0; n < NumFrequencies; n++) {
+                               if (ISTRANSPONDER(cChannel::Transponder(Frequencies[n], Polarization), transponder)) {
+                                  Frequency = Frequencies[n];
+                                  break;
                                   }
-                              }
-                           if (ISTRANSPONDER(cChannel::Transponder(Frequency, Polarization), Transponder())) // only modify channels if we're actually receiving this transponder
-                              Channel->SetSatTransponderData(Source, Frequency, Polarization, SymbolRate, CodeRate);
+                               }
                            }
-                        found = true;
-                        }
-                     }
-                 if (!found && Setup.UpdateChannels >= 5) {
-                    for (int n = 0; n < NumFrequencies; n++) {
-                        cChannel *Channel = new cChannel;
-                        Channel->SetId(ts.getOriginalNetworkId(), ts.getTransportStreamId(), 0, 0);
-                        if (Channel->SetSatTransponderData(Source, Frequencies[n], Polarization, SymbolRate, CodeRate))
-                           EITScanner.AddTransponder(Channel);
-                        else
-                           delete Channel;
+                        if (ISTRANSPONDER(cChannel::Transponder(Frequency, Polarization), Transponder())) // only modify channels if we're actually receiving this transponder
+                           Channel->SetSatTransponderData(Source, Frequency, Polarization, SymbolRate, CodeRate);
                         }
+                    if (!found) {
+                       for (int n = 0; n < NumFrequencies; n++) {
+                           cChannel *Channel = new cChannel;
+                           Channel->SetId(ts.getOriginalNetworkId(), ts.getTransportStreamId(), 0, 0);
+                           if (Channel->SetSatTransponderData(Source, Frequencies[n], Polarization, SymbolRate, CodeRate))
+                              EITScanner.AddTransponder(Channel);
+                           else
+                              delete Channel;
+                           }
+                       }
                     }
                  }
                  break;
@@ -192,33 +193,33 @@
                         }
                     break;
                     }
-                 bool found = false;
-                 for (cChannel *Channel = Channels.First(); Channel; Channel = Channels.Next(Channel)) {
-                     if (!Channel->GroupSep() && Channel->Source() == Source && Channel->Nid() == ts.getOriginalNetworkId() && Channel->Tid() == ts.getTransportStreamId()) {
-                        if (Setup.UpdateChannels >= 5) {
-                           if (!ISTRANSPONDER(Frequency / 1000, Channel->Transponder())) {
-                              for (int n = 0; n < NumFrequencies; n++) {
-                                  if (ISTRANSPONDER(Frequencies[n] / 1000, Channel->Transponder())) {
-                                     Frequency = Frequencies[n];
-                                     break;
-                                     }
+                 if (Setup.UpdateChannels >= 5) {
+                    bool found = false;
+                    cIterator<cChannel> ChannelIterator = Channels.GetChannelsBySourceNidTid(Source, ts.getOriginalNetworkId(), ts.getTransportStreamId());
+                    for (cChannel *Channel = ChannelIterator.First(); Channel; Channel = ChannelIterator.Next()) {
+                        int transponder = Channel->Transponder();
+                        found = true;
+                        if (!ISTRANSPONDER(Frequency / 1000, transponder)) {
+                           for (int n = 0; n < NumFrequencies; n++) {
+                               if (ISTRANSPONDER(Frequencies[n] / 1000, transponder)) {
+                                  Frequency = Frequencies[n];
+                                  break;
                                   }
-                              }
-                           if (ISTRANSPONDER(Frequency / 1000, Transponder())) // only modify channels if we're actually receiving this transponder
-                              Channel->SetCableTransponderData(Source, Frequency, Modulation, SymbolRate, CodeRate);
+                               }
                            }
-                        found = true;
-                        }
-                     }
-                 if (!found && Setup.UpdateChannels >= 5) {
-                    for (int n = 0; n < NumFrequencies; n++) {
-                        cChannel *Channel = new cChannel;
-                        Channel->SetId(ts.getOriginalNetworkId(), ts.getTransportStreamId(), 0, 0);
-                        if (Channel->SetCableTransponderData(Source, Frequencies[n], Modulation, SymbolRate, CodeRate))
-                           EITScanner.AddTransponder(Channel);
-                        else
-                           delete Channel;
+                        if (ISTRANSPONDER(Frequency / 1000, Transponder())) // only modify channels if we're actually receiving this transponder
+                           Channel->SetCableTransponderData(Source, Frequency, Modulation, SymbolRate, CodeRate);
                         }
+                    if (!found) {
+                        for (int n = 0; n < NumFrequencies; n++) {
+                           cChannel *Channel = new cChannel;
+                           Channel->SetId(ts.getOriginalNetworkId(), ts.getTransportStreamId(), 0, 0);
+                           if (Channel->SetCableTransponderData(Source, Frequencies[n], Modulation, SymbolRate, CodeRate))
+                              EITScanner.AddTransponder(Channel);
+                           else
+                              delete Channel;
+                           }
+                       }
                     }
                  }
                  break;
@@ -249,33 +250,33 @@
                         }
                     break;
                     }
-                 bool found = false;
-                 for (cChannel *Channel = Channels.First(); Channel; Channel = Channels.Next(Channel)) {
-                     if (!Channel->GroupSep() && Channel->Source() == Source && Channel->Nid() == ts.getOriginalNetworkId() && Channel->Tid() == ts.getTransportStreamId()) {
-                        if (Setup.UpdateChannels >= 5) {
-                           if (!ISTRANSPONDER(Frequency / 1000000, Channel->Transponder())) {
-                              for (int n = 0; n < NumFrequencies; n++) {
-                                  if (ISTRANSPONDER(Frequencies[n] / 1000000, Channel->Transponder())) {
-                                     Frequency = Frequencies[n];
-                                     break;
-                                     }
+                 if (Setup.UpdateChannels >= 5) {
+                    bool found = false;
+                    cIterator<cChannel> ChannelIterator = Channels.GetChannelsBySourceNidTid(Source, ts.getOriginalNetworkId(), ts.getTransportStreamId());
+                    for (cChannel *Channel = ChannelIterator.First(); Channel; Channel = ChannelIterator.Next()) {
+                        int transponder = Channel->Transponder();
+                        found = true;
+                        if (!ISTRANSPONDER(Frequency / 1000000, transponder)) {
+                           for (int n = 0; n < NumFrequencies; n++) {
+                               if (ISTRANSPONDER(Frequencies[n] / 1000000, transponder)) {
+                                  Frequency = Frequencies[n];
+                                  break;
                                   }
-                              }
-                           if (ISTRANSPONDER(Frequency / 1000000, Transponder())) // only modify channels if we're actually receiving this transponder
-                              Channel->SetTerrTransponderData(Source, Frequency, Bandwidth, Constellation, Hierarchy, CodeRateHP, CodeRateLP, GuardInterval, TransmissionMode);
+                               }
                            }
-                        found = true;
-                        }
-                     }
-                 if (!found && Setup.UpdateChannels >= 5) {
-                    for (int n = 0; n < NumFrequencies; n++) {
-                        cChannel *Channel = new cChannel;
-                        Channel->SetId(ts.getOriginalNetworkId(), ts.getTransportStreamId(), 0, 0);
-                        if (Channel->SetTerrTransponderData(Source, Frequencies[n], Bandwidth, Constellation, Hierarchy, CodeRateHP, CodeRateLP, GuardInterval, TransmissionMode))
-                           EITScanner.AddTransponder(Channel);
-                        else
-                           delete Channel;
+                        if (ISTRANSPONDER(Frequency / 1000000, Transponder())) // only modify channels if we're actually receiving this transponder
+                           Channel->SetTerrTransponderData(Source, Frequency, Bandwidth, Constellation, Hierarchy, CodeRateHP, CodeRateLP, GuardInterval, TransmissionMode);
                         }
+                    if (!found) {
+                       for (int n = 0; n < NumFrequencies; n++) {
+                           cChannel *Channel = new cChannel;
+                           Channel->SetId(ts.getOriginalNetworkId(), ts.getTransportStreamId(), 0, 0);
+                           if (Channel->SetTerrTransponderData(Source, Frequencies[n], Bandwidth, Constellation, Hierarchy, CodeRateHP, CodeRateLP, GuardInterval, TransmissionMode))
+                              EITScanner.AddTransponder(Channel);
+                           else
+                              delete Channel;
+                           }
+                       }
                     }
                  }
                  break;
diff -Naur VDR-NG-orig/osdbase.c VDR-NG/osdbase.c
--- VDR-NG-orig/osdbase.c	2010-02-10 16:56:56.000000000 +0100
+++ VDR-NG/osdbase.c	2010-02-10 17:11:00.000000000 +0100
@@ -41,7 +41,7 @@
 void cOsdItem::SetText(const char *Text, bool Copy)
 {
   free(text);
-  text = Copy ? strdup(Text) : (char *)Text; // text assumes ownership!
+  text = Copy ? strdup(Text ? Text : "") : (char *)Text; // text assumes ownership!
 }
 
 void cOsdItem::SetSelectable(bool Selectable)
@@ -210,6 +210,7 @@
          }
      if (current < 0)
         current = 0; // just for safety - there HAS to be a current item!
+     first = min(first, max(0, count - displayMenuItems)); // in case the menu size has changed
      if (current - first >= displayMenuItems || current < first) {
         first = current - displayMenuItems / 2;
         if (first + displayMenuItems > count)
diff -Naur VDR-NG-orig/osdbase.h VDR-NG/osdbase.h
--- VDR-NG-orig/osdbase.h	2010-02-10 16:57:10.000000000 +0100
+++ VDR-NG/osdbase.h	2010-02-10 16:59:02.000000000 +0100
@@ -58,11 +58,11 @@
   cOsdItem(eOSState State = osUnknown);
   cOsdItem(const char *Text, eOSState State = osUnknown, bool Selectable = true);
   virtual ~cOsdItem();
-  bool Selectable(void) { return selectable; }
+  bool Selectable(void) const { return selectable; }
   void SetText(const char *Text, bool Copy = true);
   void SetSelectable(bool Selectable);
   void SetFresh(bool Fresh);
-  const char *Text(void) { return text; }
+  const char *Text(void) const { return text; }
   virtual void Set(void) {}
   virtual eOSState ProcessKey(eKeys Key);
   };
@@ -77,7 +77,7 @@
   cOsdObject(bool FastResponse = false) { isMenu = false; needsFastResponse = FastResponse; }
   virtual ~cOsdObject() {}
   bool NeedsFastResponse(void) { return needsFastResponse; }
-  bool IsMenu(void) { return isMenu; }
+  bool IsMenu(void) const { return isMenu; }
   virtual void Show(void);
   virtual eOSState ProcessKey(eKeys Key) { return osUnknown; }
   };
@@ -123,7 +123,7 @@
 public:
   cOsdMenu(const char *Title, int c0 = 0, int c1 = 0, int c2 = 0, int c3 = 0, int c4 = 0);
   virtual ~cOsdMenu();
-  int Current(void) { return current; }
+  int Current(void) const { return current; }
   void Add(cOsdItem *Item, bool Current = false, cOsdItem *After = NULL);
   void Ins(cOsdItem *Item, bool Current = false, cOsdItem *Before = NULL);
   virtual void Display(void);
diff -Naur VDR-NG-orig/osd.c VDR-NG/osd.c
--- VDR-NG-orig/osd.c	2010-02-10 16:57:24.000000000 +0100
+++ VDR-NG/osd.c	2010-02-10 17:12:58.000000000 +0100
@@ -302,6 +302,8 @@
 
 bool cBitmap::SetXpm(const char *const Xpm[], bool IgnoreNone)
 {
+  if (!Xpm)
+     return false;
   const char *const *p = Xpm;
   int w, h, n, c;
   if (4 != sscanf(*p, "%d %d %d %d", &w, &h, &n, &c)) {
@@ -657,6 +659,7 @@
     case 6:          cy = y2; rx /= 2; break;
     case 7: cx = x2;          ry /= 2; break;
     case 8:          cy = y1; rx /= 2; break;
+    default: ;
     }
   int TwoASquare = 2 * rx * rx;
   int TwoBSquare = 2 * ry * ry;
@@ -682,6 +685,7 @@
           case -2: DrawRectangle(x1,     cy - y, cx - x, cy - y, Color); break;
           case -3: DrawRectangle(x1,     cy + y, cx - x, cy + y, Color); break;
           case -4: DrawRectangle(cx + x, cy + y, x2,     cy + y, Color); break;
+          default: ;
           }
         y++;
         StoppingY += TwoASquare;
@@ -716,6 +720,7 @@
           case -2: DrawRectangle(x1,     cy - y, cx - x, cy - y, Color); break;
           case -3: DrawRectangle(x1,     cy + y, cx - x, cy + y, Color); break;
           case -4: DrawRectangle(cx + x, cy + y, x2,     cy + y, Color); break;
+          default: ;
           }
         x++;
         StoppingX += TwoBSquare;
@@ -772,6 +777,18 @@
 
 // --- cOsd ------------------------------------------------------------------
 
+static const char *OsdErrorTexts[] = {
+  "ok",
+  "too many areas",
+  "too many colors",
+  "bpp not supported",
+  "areas overlap",
+  "wrong alignment",
+  "out of memory",
+  "wrong area size",
+  "unknown",
+  };
+
 int cOsd::isOpen = 0;
 bool cOsd::pinValid = false;   // PIN PATCH
 
@@ -833,7 +850,7 @@
         }
      }
   if (Result != oeOk)
-     esyslog("ERROR: cOsd::SetAreas returned %d", Result);
+     esyslog("ERROR: cOsd::SetAreas returned %d (%s)", Result, Result < oeUnknown ? OsdErrorTexts[Result] : OsdErrorTexts[oeUnknown]);
   return Result;
 }
 
diff -Naur VDR-NG-orig/osd.h VDR-NG/osd.h
--- VDR-NG-orig/osd.h	2010-02-10 16:57:24.000000000 +0100
+++ VDR-NG/osd.h	2010-02-10 17:11:00.000000000 +0100
@@ -30,7 +30,7 @@
   clrWhite       = 0xFFFCFCFC,
   };
 
-enum eOsdError { oeOk,
+enum eOsdError { oeOk, // see also OsdErrorTexts in osd.c
                  oeTooManyAreas,
                  oeTooManyColors,
                  oeBppNotSupported,
diff -Naur VDR-NG-orig/pat.c VDR-NG/pat.c
--- VDR-NG-orig/pat.c	2009-09-24 17:21:12.000000000 +0200
+++ VDR-NG/pat.c	2010-02-10 16:59:02.000000000 +0100
@@ -144,7 +144,7 @@
   q += sprintf(q, "CAM: %04X %5d %5d %04X %d -", source, transponder, serviceId, d->getCaType(), Stream);
   for (int i = 0; i < nca->Length(); i++)
       q += sprintf(q, " %02X", nca->Data()[i]);
-  dsyslog(buffer);
+  dsyslog("%s", buffer);
 #endif
 }
 
@@ -337,10 +337,12 @@
         int NumApids = 0;
         int NumDpids = 0;
         for (SI::Loop::Iterator it; pmt.streamLoop.getNext(stream, it); ) {
+            bool ProcessCaDescriptors = false;
             switch (stream.getStreamType()) {
               case 1: // STREAMTYPE_11172_VIDEO
               case 2: // STREAMTYPE_13818_VIDEO
                       Vpid = stream.getPid();
+                      ProcessCaDescriptors = true;
                       break;
               case 3: // STREAMTYPE_11172_AUDIO
               case 4: // STREAMTYPE_13818_AUDIO
@@ -373,6 +375,7 @@
                              }
                          NumApids++;
                          }
+                      ProcessCaDescriptors = true;
                       }
                       break;
               case 5: // STREAMTYPE_13818_PRIVATE
@@ -386,6 +389,7 @@
                           switch (d->getDescriptorTag()) {
                             case SI::AC3DescriptorTag:
                                  dpid = stream.getPid();
+                                 ProcessCaDescriptors = true;
                                  break;
                             case SI::TeletextDescriptorTag:
                                  Tpid = stream.getPid();
@@ -408,11 +412,13 @@
                          }
                       }
                       break;
-              //default: printf("PID: %5d %5d %2d %3d %3d\n", pmt.getServiceId(), stream.getPid(), stream.getStreamType(), pmt.getVersionNumber(), Channel->Number());//XXX
+              default: ;//printf("PID: %5d %5d %2d %3d %3d\n", pmt.getServiceId(), stream.getPid(), stream.getStreamType(), pmt.getVersionNumber(), Channel->Number());
               }
-            for (SI::Loop::Iterator it; (d = (SI::CaDescriptor*)stream.streamDescriptors.getNext(it, SI::CaDescriptorTag)); ) {
-                CaDescriptors->AddCaDescriptor(d, true);
-                delete d;
+            if (ProcessCaDescriptors) {
+                for (SI::Loop::Iterator it; (d = (SI::CaDescriptor*)stream.streamDescriptors.getNext(it, SI::CaDescriptorTag)); ) {
+                    CaDescriptors->AddCaDescriptor(d, true);
+                    delete d;
+                    }
                 }
             }
         if (Setup.UpdateChannels >= 2) {
diff -Naur VDR-NG-orig/player.c VDR-NG/player.c
--- VDR-NG-orig/player.c	2009-09-24 17:21:00.000000000 +0200
+++ VDR-NG/player.c	2010-02-10 16:59:02.000000000 +0100
@@ -77,8 +77,9 @@
 void cControl::Launch(cControl *Control)
 {
   cMutexLock MutexLock(&mutex);
-  delete control;
+  cControl *c = control; // keeps control from pointing to uninitialized memory
   control = Control;
+  delete c;
 }
 
 void cControl::Attach(void)
diff -Naur VDR-NG-orig/plugin.c VDR-NG/plugin.c
--- VDR-NG-orig/plugin.c	2010-02-10 16:57:02.000000000 +0100
+++ VDR-NG/plugin.c	2010-02-10 16:59:02.000000000 +0100
@@ -172,15 +172,15 @@
 static char *SkipQuote(char *s)
 {
   char c = *s;
-  strcpy(s, s + 1);
+  memmove(s, s + 1, strlen(s));
   while (*s && *s != c) {
         if (*s == '\\')
-           strcpy(s, s + 1);
+           memmove(s, s + 1, strlen(s));
         if (*s)
            s++;
         }
   if (*s) {
-     strcpy(s, s + 1);
+     memmove(s, s + 1, strlen(s));
      return s;
      }
   esyslog("ERROR: missing closing %c", c);
@@ -231,7 +231,7 @@
               if (!q)
                  q = p;
               switch (*p) {
-                case '\\': strcpy(p, p + 1);
+                case '\\': memmove(p, p + 1, strlen(p));
                            if (*p)
                               p++;
                            else {
diff -Naur VDR-NG-orig/receiver.c VDR-NG/receiver.c
--- VDR-NG-orig/receiver.c	2009-09-24 17:21:00.000000000 +0200
+++ VDR-NG/receiver.c	2010-02-10 16:59:02.000000000 +0100
@@ -41,7 +41,12 @@
 
 cReceiver::~cReceiver()
 {
-  Detach();
+  if (device) {
+     const char *msg = "ERROR: cReceiver has not been detached yet! This is a design fault and VDR will segfault now!";
+     esyslog("%s", msg);
+     fprintf(stderr, "%s\n", msg);
+     *(char *)0 = 0; // cause a segfault
+     }
 }
 
 bool cReceiver::WantsPid(int Pid)
diff -Naur VDR-NG-orig/recording.c VDR-NG/recording.c
--- VDR-NG-orig/recording.c	2010-02-10 16:57:20.000000000 +0100
+++ VDR-NG/recording.c	2010-02-10 16:59:02.000000000 +0100
@@ -8,6 +8,7 @@
  */
 
 #include "recording.h"
+#include <ctype.h>
 #include "iconpatch.h"
 #include <dirent.h>
 #include <errno.h>
@@ -31,8 +32,8 @@
 /* This was the original code, which works fine in a Linux only environment.
    Unfortunately, because of Windows and its brain dead file system, we have
    to use a more complicated approach, in order to allow users who have enabled
-   the VFAT compile time option to see their recordings even if they forget to
-   enable VFAT when compiling a new version of VDR... Gee, do I hate Windows.
+   the --vfat command line option to see their recordings even if they forget to
+   enable --vfat when restarting VDR... Gee, do I hate Windows.
    (kls 2002-07-27)
 #define DATAFORMAT   "%4d-%02d-%02d.%02d:%02d.%02d.%02d" RECEXT
 #define NAMEFORMAT   "%s/%s/" DATAFORMAT
@@ -55,9 +56,6 @@
 #define DISKCHECKDELTA    100 // seconds between checks for free disk space
 #define REMOVELATENCY      10 // seconds to wait until next check after removing a file
 
-#define TIMERMACRO_TITLE    "TITLE"
-#define TIMERMACRO_EPISODE  "EPISODE"
-
 #define MAX_SUBTITLE_LENGTH  40
 
 #define MAX_LINK_LEVEL  6
@@ -83,6 +81,7 @@
 
 void cRemoveDeletedRecordingsThread::Action(void)
 {
+  SetPriority(19);
   // Make sure only one instance of VDR does this:
   cLockFile LockFile(VideoDirectory);
   if (LockFile.Lock()) {
@@ -367,8 +366,8 @@
                             ownEvent->SetEventID(EventID);
                             ownEvent->SetStartTime(StartTime);
                             ownEvent->SetDuration(Duration);
-                            ownEvent->SetTableID(TableID);
-                            ownEvent->SetVersion(Version);
+                            ownEvent->SetTableID(uchar(TableID));
+                            ownEvent->SetVersion(uchar(Version));
                             }
                        }
                        break;
@@ -404,8 +403,8 @@
 
 struct tCharExchange { char a; char b; };
 tCharExchange CharExchange[] = {
-  { '~',  '/'    },
-  { '/',  '~'    },
+  { FOLDERDELIMCHAR,  '/'    },
+  { '/',  FOLDERDELIMCHAR    },
   { ' ',  '_'    },
   // backwards compatibility:
   { '\'', '\''   },
@@ -422,34 +421,14 @@
            // The VFAT file system can't handle all characters, so we
            // have to take extra efforts to encode/decode them:
            if (ToFileSystem) {
+              const char *InvalidChars = "\"\\/:*?|<>#";
               switch (*p) {
-                     // characters that can be used "as is":
-                     case '!':
-                     case '@':
-                     case '$':
-                     case '%':
-                     case '&':
-                     case '(':
-                     case ')':
-                     case '+':
-                     case ',':
-                     case '-':
-                     case ';':
-                     case '=':
-                     case '0' ... '9':
-                     case 'a' ... 'z':
-                     case 'A' ... 'Z':
-                     case 'ä': case 'Ä':
-                     case 'ö': case 'Ö':
-                     case 'ü': case 'Ü':
-                     case 'ß':
-                          break;
                      // characters that can be mapped to other characters:
                      case ' ': *p = '_'; break;
-                     case '~': *p = '/'; break;
+                     case FOLDERDELIMCHAR: *p = '/'; break;
                      // characters that have to be encoded:
                      default:
-                       if (*p != '.' || !*(p + 1) || *(p + 1) == '~') { // Windows can't handle '.' at the end of directory names
+                       if (strchr(InvalidChars, *p) || *p == '.' && (!*(p + 1) || *(p + 1) == FOLDERDELIMCHAR)) { // Windows can't handle '.' at the end of file/directory names
                           int l = p - s;
                           s = (char *)realloc(s, strlen(s) + 10);
                           p = s + l;
@@ -465,15 +444,17 @@
               switch (*p) {
                 // mapped characters:
                 case '_': *p = ' '; break;
-                case '/': *p = '~'; break;
-                // encodes characters:
+                case '/': *p = FOLDERDELIMCHAR; break;
+                // encoded characters:
                 case '#': {
-                     if (strlen(p) > 2) {
+                     if (strlen(p) > 2 && isxdigit(*(p + 1)) && isxdigit(*(p + 2))) {
                         char buf[3];
                         sprintf(buf, "%c%c", *(p + 1), *(p + 2));
-                        unsigned char c = strtol(buf, NULL, 16);
-                        *p = c;
-                        memmove(p + 1, p + 3, strlen(p) - 2);
+                        uchar c = uchar(strtol(buf, NULL, 16));
+                        if (c) {
+                           *p = c;
+                           memmove(p + 1, p + 3, strlen(p) - 2);
+                           }
                         }
                      }
                      break;
@@ -481,6 +462,7 @@
                 case '\x01': *p = '\''; break;
                 case '\x02': *p = '/';  break;
                 case '\x03': *p = ':';  break;
+                default: ;
                 }
               }
            }
@@ -522,8 +504,8 @@
      strn0cpy(SubtitleBuffer, Subtitle, MAX_SUBTITLE_LENGTH);
      Subtitle = SubtitleBuffer;
      }
-  char *macroTITLE   = strstr(Timer->File(), TIMERMACRO_TITLE);
-  char *macroEPISODE = strstr(Timer->File(), TIMERMACRO_EPISODE);
+  const char *macroTITLE   = strstr(Timer->File(), TIMERMACRO_TITLE);
+  const char *macroEPISODE = strstr(Timer->File(), TIMERMACRO_EPISODE);
   if (macroTITLE || macroEPISODE) {
      name = strdup(Timer->File());
      name = strreplace(name, TIMERMACRO_TITLE, Title);
@@ -531,7 +513,7 @@
      // avoid blanks at the end:
      int l = strlen(name);
      while (l-- > 2) {
-           if (name[l] == ' ' && name[l - 1] != '~')
+           if (name[l] == ' ' && name[l - 1] != FOLDERDELIMCHAR)
               name[l] = 0;
            else
               break;
@@ -565,9 +547,11 @@
      sortBuffer[i] = NULL;
      lastDirsFirst[i] = -1;
   }
-  fileName = strdup(FileName);
+  FileName = fileName = strdup(FileName);
+  if (*(fileName + strlen(fileName) - 1) == '/')
+     *(fileName + strlen(fileName) - 1) = 0;
   FileName += strlen(VideoDirectory) + 1;
-  char *p = strrchr(FileName, '/');
+  const char *p = strrchr(FileName, '/');
 
   name = NULL;
   info = new cRecordingInfo;
@@ -752,7 +736,7 @@
      struct tm tm_r;
      struct tm *t = localtime_r(&start, &tm_r);
      char *s;
-     if (Level > 0 && (s = strrchr(name, '~')) != NULL)
+     if (Level > 0 && (s = strrchr(name, FOLDERDELIMCHAR)) != NULL)
         s++;
      else
         s = name;
@@ -803,18 +787,18 @@
                                (Setup.ShowRecLength ? RecDelimiter : ""),
                                s);
         }
-     // let's not display a trailing '~':
+     // let's not display a trailing FOLDERDELIMCHAR:
      if (!NewIndicator)
         stripspace(titleBuffer);
      s = &titleBuffer[strlen(titleBuffer) - 1];
-     if (*s == '~')
+     if (*s == FOLDERDELIMCHAR)
         *s = 0;
      }
   else if (Level < HierarchyLevels()) {
      const char *s = name;
      const char *p = s;
      while (*++s) {
-           if (*s == '~') {
+           if (*s == FOLDERDELIMCHAR) {
               if (Level--)
                  p = s + 1;
               else
@@ -856,7 +840,7 @@
   const char *s = name;
   int level = 0;
   while (*++s) {
-        if (*s == '~')
+        if (*s == FOLDERDELIMCHAR)
            level++;
         }
   return level;
@@ -864,7 +848,7 @@
 
 bool cRecording::IsEdited(void) const
 {
-  const char *s = strrchr(name, '~');
+  const char *s = strrchr(name, FOLDERDELIMCHAR);
   s = !s ? name : s + 1;
   return *s == '%';
 }
@@ -1270,7 +1254,7 @@
 {
   if (command) {
      char *cmd;
-     asprintf(&cmd, "%s %s \"%s\"", command, State, *strescape(RecordingFileName, "\"$"));
+     asprintf(&cmd, "%s %s \"%s\"", command, State, *strescape(RecordingFileName, "\\\"$"));
      isyslog("executing '%s'", cmd);
      SystemExec(cmd);
      free(cmd);
@@ -1309,19 +1293,19 @@
         if (access(fileName, R_OK) == 0) {
            struct stat buf;
            if (stat(fileName, &buf) == 0) {
-              delta = buf.st_size % sizeof(tIndex);
+              delta = int(buf.st_size % sizeof(tIndex));
               if (delta) {
                  delta = sizeof(tIndex) - delta;
                  esyslog("ERROR: invalid file size (%ld) in '%s'", buf.st_size, fileName);
                  }
-              last = (buf.st_size + delta) / sizeof(tIndex) - 1;
+              last = int((buf.st_size + delta) / sizeof(tIndex) - 1);
               if (!Record && last >= 0) {
                  size = last + 1;
                  index = MALLOC(tIndex, size);
                  if (index) {
                     f = open(fileName, O_RDONLY);
                     if (f >= 0) {
-                       if ((int)safe_read(f, index, buf.st_size) != buf.st_size) {
+                       if (safe_read(f, index, size_t(buf.st_size)) != buf.st_size) {
                           esyslog("ERROR: can't read from file '%s'", fileName);
                           free(index);
                           index = NULL;
@@ -1540,10 +1524,10 @@
         if (PictureType)
            *PictureType = index[Index].type;
         if (Length) {
-           int fn = index[Index + 1].number;
-           int fo = index[Index + 1].offset;
+           uint16_t fn = index[Index + 1].number;
+           off_t fo = index[Index + 1].offset;
            if (fn == *FileNumber)
-              *Length = fo - *FileOffset;
+              *Length = int(fo - *FileOffset);
            else
               *Length = -1; // this means "everything up to EOF" (the buffer's Read function will act accordingly)
            }
@@ -1571,10 +1555,10 @@
                   FileOffset = &index[Index].offset;
                if (Length) {
                   // all recordings end with a non-I_FRAME, so the following should be safe:
-                  int fn = index[Index + 1].number;
-                  int fo = index[Index + 1].offset;
+                  uint16_t fn = index[Index + 1].number;
+                  off_t fo = index[Index + 1].offset;
                   if (fn == *FileNumber)
-                     *Length = fo - *FileOffset;
+                     *Length = int(fo - *FileOffset);
                   else {
                      esyslog("ERROR: 'I' frame at end of file #%d", *FileNumber);
                      *Length = -1;
@@ -1708,11 +1692,11 @@
   if (fileNumber != Number)
      Close();
   if (0 < Number && Number <= MAXFILESPERRECORDING) {
-     fileNumber = Number;
+     fileNumber = uint16_t(Number);
      sprintf(pFileNumber, RECORDFILESUFFIX, fileNumber);
      if (record) {
         if (access(fileName, F_OK) == 0) {
-           // files exists, check if it has non-zero size
+           // file exists, check if it has non-zero size
            struct stat buf;
            if (stat(fileName, &buf) == 0) {
               if (buf.st_size != 0)
diff -Naur VDR-NG-orig/recording.h VDR-NG/recording.h
--- VDR-NG-orig/recording.h	2010-02-10 16:57:26.000000000 +0100
+++ VDR-NG/recording.h	2010-02-10 16:59:02.000000000 +0100
@@ -13,6 +13,7 @@
 #include <time.h>
 #include "channels.h"
 #include "config.h"
+#include "device.h"
 #include "epg.h"
 #include "thread.h"
 #include "timers.h"
@@ -25,6 +26,10 @@
 #endif
 //M7X0 BEGIN AK
 
+#define FOLDERDELIMCHAR '~'
+#define TIMERMACRO_TITLE    "TITLE"
+#define TIMERMACRO_EPISODE  "EPISODE"
+
 extern bool VfatFileSystem;
 extern bool DirOrderState;
 
@@ -59,6 +64,7 @@
 public:
   ~cRecordingInfo();
   tChannelID ChannelID(void) const { return channelID; }
+  const cEvent *GetEvent(void) const { return event; }
   const char *Title(void) const { return event->Title(); }
   const char *ShortText(void) const { return event->ShortText(); }
   const char *Description(void) const { return event->Description(); }
@@ -197,7 +203,7 @@
 #define FRAMESPERSEC 25
 
 // The maximum size of a single frame (up to HDTV 1920x1080):
-#define MAXFRAMESIZE  KILOBYTE(512)
+#define MAXFRAMESIZE  (KILOBYTE(512) / TS_SIZE * TS_SIZE) // multiple of TS_SIZE to avoid breaking up TS packets
 
 // The maximum file size is limited by the range that can be covered
 // with 'int'. 4GB might be possible (if the range is considered
@@ -247,7 +253,7 @@
 class cFileName {
 private:
   cUnbufferedFile *file;
-  int fileNumber;
+  uint16_t fileNumber;
   char *fileName, *pFileNumber;
   bool record;
   bool blocking;
@@ -262,11 +268,11 @@
 #endif
   ~cFileName();
   const char *Name(void) { return fileName; }
-  int Number(void) { return fileNumber; }
+  uint16_t Number(void) { return fileNumber; }
   cUnbufferedFile *Open(void);
   void Close(void);
   int Unlink(void);
-  cUnbufferedFile *SetOffset(int Number, int Offset = 0);
+  cUnbufferedFile *SetOffset(int Number, int Offset = 0); // yes, Number is int for easier internal calculating
   int MaxFileSize();
       // Dynamic file size for this file
   cUnbufferedFile *NextFile(void);
diff -Naur VDR-NG-orig/remote.c VDR-NG/remote.c
--- VDR-NG-orig/remote.c	2010-02-10 16:57:16.000000000 +0100
+++ VDR-NG/remote.c	2010-02-10 16:59:02.000000000 +0100
@@ -121,7 +121,7 @@
 bool cRemote::Put(uint64_t Code, bool Repeat, bool Release)
 {
   char buffer[32];
-  snprintf(buffer, sizeof(buffer), "%016LX", Code);
+  snprintf(buffer, sizeof(buffer), "%016llX", Code);
   return Put(buffer, Repeat, Release);
 }
 
@@ -282,7 +282,9 @@
       if (p->code == Code)
          return p->func;
       }
-  return (Code <= 0xFF) ? Code : kfNone;
+  if (Code <= 0xFF)
+     return Code;
+  return kfNone;
 }
 
 int cKbdRemote::ReadKey(void)
@@ -332,9 +334,11 @@
                                 k |= key1 & 0xFF;
                                 } while (key1 != 0x7E);
                              break;
+                        default: ;
                         }
                       }
                    break;
+              default: ;
               }
             }
         }
diff -Naur VDR-NG-orig/remux.c VDR-NG/remux.c
--- VDR-NG-orig/remux.c	2009-09-24 17:21:08.000000000 +0200
+++ VDR-NG/remux.c	2010-02-10 16:59:02.000000000 +0100
@@ -1528,6 +1528,7 @@
                  switch (p[1]) {
                    case SC_PICTURE: PictureType = (p[3] >> 3) & 0x07;
                                     return Length;
+                   default: ;
                    }
                  p += 4; // continue scanning after 0x01ssxxyy
                  }
diff -Naur VDR-NG-orig/remux.h VDR-NG/remux.h
--- VDR-NG-orig/remux.h	2009-09-24 17:21:10.000000000 +0200
+++ VDR-NG/remux.h	2010-02-10 16:59:02.000000000 +0100
@@ -12,10 +12,6 @@
 #ifdef USE_HW_VIDEO_FRAME_EVENTS
 #define USE_DATAHEADER_IN_RECEIVER 1
 #endif
-#include <time.h> //XXX FIXME: DVB/linux/dvb/dmx.h should include <time.h> itself!!!
-//M7X0 BEGIN AK
-#include "m7x0_dvb/dmx.h"
-//M7X0 END AK
 #include "ringbuffer.h"
 #include "tools.h"
 
diff -Naur VDR-NG-orig/sdt.c VDR-NG/sdt.c
--- VDR-NG-orig/sdt.c	2009-09-24 17:21:12.000000000 +0200
+++ VDR-NG/sdt.c	2010-02-10 16:59:02.000000000 +0100
@@ -64,16 +64,18 @@
                         char *ps = compactspace(ShortNameBuf);
                         if (!*ps && cSource::IsCable(Source())) {
                            // Some cable providers don't mark short channel names according to the
-                           // standard, but rather go their own way and use "name>short name" or
-                           // "name, short name":
+                           // standard, but rather go their own way and use "name>short name":
                            char *p = strchr(pn, '>'); // fix for UPC Wien
-                           if (!p)
-                              p = strchr(pn, ','); // fix for "Kabel Deutschland"
                            if (p && p > pn) {
                               *p++ = 0;
                               strcpy(ShortNameBuf, skipspace(p));
                               }
                            }
+                        // Avoid ',' in short name (would cause trouble in channels.conf):
+                        for (char *p = ShortNameBuf; *p; p++) {
+                           if (*p == ',')
+                              *p = '.';
+                           }
                         sd->providerName.getText(ProviderNameBuf, sizeof(ProviderNameBuf));
                         char *pp = compactspace(ProviderNameBuf);
                         if (channel) {
@@ -91,6 +93,7 @@
                            patFilter->Trigger();
                            }
                         }
+                   default: ;
                    }
                  }
                  break;
diff -Naur VDR-NG-orig/skinclassic.c VDR-NG/skinclassic.c
--- VDR-NG-orig/skinclassic.c	2010-02-10 16:57:22.000000000 +0100
+++ VDR-NG/skinclassic.c	2010-02-10 16:59:02.000000000 +0100
@@ -312,6 +312,11 @@
      free(buffer);
      }
   y += ts.Height();
+  if (Event->ParentalRating()) {
+     cString buffer = cString::sprintf(" %s ", *Event->GetParentalRatingString());
+     const cFont *font = cFont::GetFont(fontSml);
+     osd->DrawText(x1 - font->Width(buffer), y, buffer, Theme.Color(clrMenuEventVpsFg), Theme.Color(clrMenuEventVpsBg), font);
+     }
   y += font->Height();
   ts.Set(osd, xl, y, x1 - xl, y3 - y, Event->Title(), font, Theme.Color(clrMenuEventTitle), Theme.Color(clrBackground));
   y += ts.Height();
@@ -320,6 +325,14 @@
      ts.Set(osd, xl, y, x1 - xl, y3 - y, Event->ShortText(), font, Theme.Color(clrMenuEventShortText), Theme.Color(clrBackground));
      y += ts.Height();
      }
+  for (int i = 0; Event->Contents(i); i++) {
+     const char *s = Event->ContentToString(Event->Contents(i));
+     if (!isempty(s)) {
+         const cFont *font = cFont::GetFont(fontSml);
+         ts.Set(osd, xl, y, x1 - xl, y3 - y, s, font, Theme.Color(clrMenuEventShortText), Theme.Color(clrBackground));
+         y += ts.Height();
+         }
+     }
   y += font->Height();
   if (!isempty(Event->Description())) {
      textScroller.Set(osd, xl, y, x1 - xl - 2 * ScrollWidth, y3 - y, Event->Description(), font, Theme.Color(clrMenuEventDescription), Theme.Color(clrBackground));
@@ -340,6 +353,11 @@
   snprintf(t, sizeof(t), "%s  %s", *DateString(Recording->start), *TimeString(Recording->start));
   ts.Set(osd, xl, y, x1 - xl, y3 - y, t, font, Theme.Color(clrMenuEventTime), Theme.Color(clrBackground));
   y += ts.Height();
+  if (Info->GetEvent()->ParentalRating()) {
+     cString buffer = cString::sprintf(" %s ", *Info->GetEvent()->GetParentalRatingString());
+     const cFont *font = cFont::GetFont(fontSml);
+     osd->DrawText(x1 - font->Width(buffer), y, buffer, Theme.Color(clrMenuEventVpsFg), Theme.Color(clrMenuEventVpsBg), font);
+     }
   y += font->Height();
   const char *Title = Info->Title();
   if (isempty(Title))
@@ -351,6 +369,14 @@
      ts.Set(osd, xl, y, x1 - xl, y3 - y, Info->ShortText(), font, Theme.Color(clrMenuEventShortText), Theme.Color(clrBackground));
      y += ts.Height();
      }
+  for (int i = 0; Info->GetEvent()->Contents(i); i++) {
+     const char *s = Info->GetEvent()->ContentToString(Info->GetEvent()->Contents(i));
+     if (!isempty(s)) {
+         const cFont *font = cFont::GetFont(fontSml);
+         ts.Set(osd, xl, y, x1 - xl, y3 - y, s, font, Theme.Color(clrMenuEventShortText), Theme.Color(clrBackground));
+         y += ts.Height();
+         }
+     }
   y += font->Height();
   if (!isempty(Info->Description())) {
      textScroller.Set(osd, xl, y, x1 - xl - 2 * ScrollWidth, y3 - y, Info->Description(), font, Theme.Color(clrMenuEventDescription), Theme.Color(clrBackground));
diff -Naur VDR-NG-orig/skinsttng.c VDR-NG/skinsttng.c
--- VDR-NG-orig/skinsttng.c	2010-02-10 16:57:22.000000000 +0100
+++ VDR-NG/skinsttng.c	2010-02-10 16:59:02.000000000 +0100
@@ -572,6 +572,14 @@
      free(buffer);
      }
   y += ts.Height();
+  if (Event->ParentalRating()) {
+     cString buffer = cString::sprintf(" %s ", *Event->GetParentalRatingString());
+     const cFont *font = cFont::GetFont(fontSml);
+     osd->DrawText(x4 - font->Width(buffer), y, buffer, Theme.Color(clrMenuEventVps), frameColor, font);
+     int yb = y + font->Height();
+     osd->DrawRectangle(x5, y, x6 - 1, yb - 1, frameColor);
+     osd->DrawEllipse  (x6, y, x7 - 1, yb - 1, frameColor, 5);
+     }
   y += font->Height();
   ts.Set(osd, xl, y, x4 - xl, y4 - y, Event->Title(), font, Theme.Color(clrMenuEventTitle), Theme.Color(clrBackground));
   y += ts.Height();
@@ -580,6 +588,14 @@
      ts.Set(osd, xl, y, x4 - xl, y4 - y, Event->ShortText(), font, Theme.Color(clrMenuEventShortText), Theme.Color(clrBackground));
      y += ts.Height();
      }
+  for (int i = 0; Event->Contents(i); i++) {
+     const char *s = Event->ContentToString(Event->Contents(i));
+     if (!isempty(s)) {
+         const cFont *font = cFont::GetFont(fontSml);
+         ts.Set(osd, xl, y, x4 - xl, y4 - y, s, font, Theme.Color(clrMenuEventShortText), Theme.Color(clrBackground));
+         y += ts.Height();
+         }
+     }
   y += font->Height();
   if (!isempty(Event->Description())) {
      int yt = y;
@@ -606,6 +622,14 @@
   snprintf(t, sizeof(t), "%s  %s", *DateString(Recording->start), *TimeString(Recording->start));
   ts.Set(osd, xl, y, x4 - xl, y4 - y, t, font, Theme.Color(clrMenuEventTime), Theme.Color(clrBackground));
   y += ts.Height();
+  if (Info->GetEvent()->ParentalRating()) {
+     cString buffer = cString::sprintf(" %s ", *Info->GetEvent()->GetParentalRatingString());
+     const cFont *font = cFont::GetFont(fontSml);
+     osd->DrawText(x4 - font->Width(buffer), y, buffer, Theme.Color(clrMenuEventVps), frameColor, font);
+     int yb = y + font->Height();
+     osd->DrawRectangle(x5, y, x6 - 1, yb - 1, frameColor);
+     osd->DrawEllipse  (x6, y, x7 - 1, yb - 1, frameColor, 5);
+     }
   y += font->Height();
   const char *Title = Info->Title();
   if (isempty(Title))
@@ -617,6 +641,14 @@
      ts.Set(osd, xl, y, x4 - xl, y4 - y, Info->ShortText(), font, Theme.Color(clrMenuEventShortText), Theme.Color(clrBackground));
      y += ts.Height();
      }
+  for (int i = 0; Info->GetEvent()->Contents(i); i++) {
+     const char *s = Info->GetEvent()->ContentToString(Info->GetEvent()->Contents(i));
+     if (!isempty(s)) {
+         const cFont *font = cFont::GetFont(fontSml);
+         ts.Set(osd, xl, y, x4 - xl, y4 - y, s, font, Theme.Color(clrMenuEventShortText), Theme.Color(clrBackground));
+         y += ts.Height();
+         }
+     }
   y += font->Height();
   if (!isempty(Info->Description())) {
      int yt = y;
@@ -1027,6 +1059,7 @@
     case 0: bm = &bmAudioStereo; break;
     case 1: bm = &bmAudioLeft;   break;
     case 2: bm = &bmAudioRight;  break;
+    default: ;
     }
   if (bm)
      osd->DrawBitmap(x3 + 5, y6 + (y7 - y6 - bm->Height()) / 2, *bm, Theme.Color(clrChannelSymbolOn), frameColor);
diff -Naur VDR-NG-orig/svdrp.c VDR-NG/svdrp.c
--- VDR-NG-orig/svdrp.c	2010-02-10 16:57:22.000000000 +0100
+++ VDR-NG/svdrp.c	2010-02-10 17:11:00.000000000 +0100
@@ -79,7 +79,7 @@
      struct sockaddr_in name;
      name.sin_family = AF_INET;
      name.sin_port = htons(port);
-     name.sin_addr.s_addr = htonl(INADDR_ANY);
+     name.sin_addr.s_addr = SVDRPhosts.LocalhostOnly() ? htonl(INADDR_LOOPBACK) : htonl(INADDR_ANY);
      if (bind(sock, (struct sockaddr *)&name, sizeof(name)) < 0) {
         LOG_ERROR;
         Close();
@@ -179,6 +179,8 @@
 // --- cSVDRP ----------------------------------------------------------------
 
 #define MAXHELPTOPIC 10
+#define EITDISABLETIME 10 // seconds until EIT processing is enabled again after a CLRE command
+                          // adjust the help for CLRE accordingly if changing this!
 
 const char *HelpPages[] = {
   "CHAN [ + | - | <number> | <name> | <id> ]\n"
@@ -187,7 +189,10 @@
   "    it returns the current channel number and name.",
   "CLRE [<number> | <name> | <id>]\n"
   "    Clear the EPG list of the given channel number, name or id. \n"
-  "    Without option it clears the entire EPG list.",
+  "    Without option it clears the entire EPG list.\n"
+  "    After a CLRE command, no further EPG processing is done for 10\n"
+  "    seconds, so that data sent with subsequent PUTE commands doesn't\n"
+  "    interfere with data from the broadcasters.",
   "CTRL <on|off>\n"
   "    Enable/Disable Input devices.",
   "DELC <number>\n"
@@ -220,10 +225,12 @@
   "HITK [ <key> ]\n"
   "    Hit the given remote control key. Without option a list of all\n"
   "    valid key names is given.",
-  "LSTC [ <number> | <name> ]\n"
+  "LSTC [ :groups | <number> | <name> ]\n"
   "    List channels. Without option, all channels are listed. Otherwise\n"
   "    only the given channel is listed. If a name is given, all channels\n"
-  "    containing the given string as part of their name are listed.",
+  "    containing the given string as part of their name are listed.\n"
+  "    If ':groups' is given, all channels are listed including group\n"
+  "    separators. The channel number of a group separator is always 0.",
   "LSTE [ <channel> ] [ now | next | nownext | at <time> | between <time> <time> | withid <number> ]\n"
   "    List EPG data. Without any parameters all data of all channels is\n"
   "    listed. If a channel is given (either by number or by channel ID),\n"
@@ -291,11 +298,14 @@
   "    If 'help' is followed by a command, the detailed help for that command is\n"
   "    given. The keyword 'main' initiates a call to the main menu function of the\n"
   "    given plugin.\n",
-  "PUTE\n"
+  "PUTE [ file ]\n"
   "    Put data into the EPG list. The data entered has to strictly follow the\n"
   "    format defined in vdr(5) for the 'epg.data' file.  A '.' on a line\n"
   "    by itself terminates the input and starts processing of the data (all\n"
-  "    entered data is buffered until the terminating '.' is seen).",
+  "    entered data is buffered until the terminating '.' is seen).\n"
+  "    If a file name is given, epg data will be read from this file (which\n"
+  "    must be accessible under the given name from the machine VDR is running\n"
+  "    on). In case of file input, no terminating '.' shall be given.\n",
   "RENR [<number> | <path>] <new name>\n"
   "    Rename recording. If a number is used, it must be the Number as \n"
   "    returned by LSTR command.",
@@ -503,14 +513,14 @@
         if (channel)
            n = channel->Number();
         else {
-           int i = 1;
-           while ((channel = Channels.GetByNumber(i, 1)) != NULL) {
-                 if (strcasecmp(channel->Name(), Option) == 0) {
-                    n = channel->Number();
-                    break;
-                    }
-                 i = channel->Number() + 1;
-                 }
+           for (cChannel *channel = Channels.First(); channel; channel = Channels.Next(channel)) {
+               if (!channel->GroupSep()) {
+                  if (strcasecmp(channel->Name(), Option) == 0) {
+                     n = channel->Number();
+                     break;
+                     }
+                  }
+               }
            }
         }
      if (n < 0) {
@@ -577,7 +587,7 @@
         
         if(schedule) {
           schedule->Cleanup(INT_MAX);
-          
+          cEitFilter::SetDisableUntil(time(NULL) + EITDISABLETIME);
           Reply(250, "EPG data from channel \"%s\" cleared", Option);
         } else {
           Reply(550, "No schedule found");
@@ -591,6 +601,7 @@
     }
   } else {
     cSchedules::ClearAll();
+    cEitFilter::SetDisableUntil(time(NULL) + EITDISABLETIME);
     Reply(250, "EPG data cleared");
   }
   
@@ -790,7 +801,7 @@
      char *strtok_next;
      FileName = strtok_r(p, delim, &strtok_next);
      // image type:
-     char *Extension = strrchr(FileName, '.');
+     const char *Extension = strrchr(FileName, '.');
      if (Extension) {
         if (strcasecmp(Extension, ".jpg") == 0 || strcasecmp(Extension, ".jpeg") == 0)
            Jpeg = true;
@@ -921,7 +932,7 @@
   if (*Option) {
      const char *hp = GetHelpPage(Option, HelpPages);
      if (hp)
-        Reply(214, "%s", hp);
+        Reply(-214, "%s", hp);
      else {
         Reply(504, "HELP topic \"%s\" unknown", Option);
         return;
@@ -966,7 +977,8 @@
 
 void cSVDRP::CmdLSTC(const char *Option)
 {
-  if (*Option) {
+  bool WithGroupSeps = strcasecmp(Option, ":groups") == 0;
+  if (*Option && !WithGroupSeps) {
      if (isnumber(Option)) {
         cChannel *channel = Channels.GetByNumber(strtol(Option, NULL, 10));
         if (channel)
@@ -975,23 +987,16 @@
            Reply(501, "Channel \"%s\" not defined", Option);
         }
      else {
-        int i = 1;
         cChannel *next = NULL;
-        while (i <= Channels.MaxNumber()) {
-              cChannel *channel = Channels.GetByNumber(i, 1);
-              if (channel) {
-                 if (strcasestr(channel->Name(), Option)) {
-                    if (next)
-                       Reply(-250, "%d %s", next->Number(), *next->ToText());
-                    next = channel;
-                    }
-                 }
-              else {
-                 Reply(501, "Channel \"%d\" not found", i);
-                 return;
-                 }
-              i = channel->Number() + 1;
-              }
+        for (cChannel *channel = Channels.First(); channel; channel = Channels.Next(channel)) {
+            if (!channel->GroupSep()) {
+               if (strcasestr(channel->Name(), Option)) {
+                  if (next)
+                     Reply(-250, "%d %s", next->Number(), *next->ToText());
+                  next = channel;
+                  }
+               }
+            }
         if (next)
            Reply(250, "%d %s", next->Number(), *next->ToText());
         else
@@ -999,15 +1004,12 @@
         }
      }
   else if (Channels.MaxNumber() >= 1) {
-     int i = 1;
-     while (i <= Channels.MaxNumber()) {
-           cChannel *channel = Channels.GetByNumber(i, 1);
-           if (channel)
-              Reply(channel->Number() < Channels.MaxNumber() ? -250 : 250, "%d %s", channel->Number(), *channel->ToText());
-           else
-              Reply(501, "Channel \"%d\" not found", i);
-           i = channel->Number() + 1;
-           }
+     for (cChannel *channel = Channels.First(); channel; channel = Channels.Next(channel)) {
+         if (WithGroupSeps)
+            Reply(channel->Next() ? -250: 250, "%d %s", channel->GroupSep() ? 0 : channel->Number(), *channel->ToText());
+         else if (!channel->GroupSep())
+            Reply(channel->Number() < Channels.MaxNumber() ? -250 : 250, "%d %s", channel->Number(), *channel->ToText());
+         }
      }
   else
      Reply(550, "No channels defined");
@@ -1590,11 +1592,27 @@
 
 void cSVDRP::CmdPUTE(const char *Option)
 {
-  delete PUTEhandler;
-  PUTEhandler = new cPUTEhandler;
-  Reply(PUTEhandler->Status(), "%s", PUTEhandler->Message());
-  if (PUTEhandler->Status() != 354)
-     DELETENULL(PUTEhandler);
+  if (*Option) {
+     FILE *f = fopen(Option, "r");
+     if (f) {
+        if (cSchedules::Read(f)) {
+           cSchedules::Cleanup(true);
+           Reply(250, "EPG data processed from \"%s\"", Option);
+           }
+        else
+           Reply(451, "Error while processing EPG from \"%s\"", Option);
+        fclose(f);
+        }
+     else
+        Reply(501, "Cannot open file \"%s\"", Option);
+     }
+  else {     
+     delete PUTEhandler;
+     PUTEhandler = new cPUTEhandler;
+     Reply(PUTEhandler->Status(), "%s", PUTEhandler->Message());
+     if (PUTEhandler->Status() != 354)
+        DELETENULL(PUTEhandler);
+     }
 }
 
 void cSVDRP::CmdSCAN(const char *Option)
diff -Naur VDR-NG-orig/thread.c VDR-NG/thread.c
--- VDR-NG-orig/thread.c	2009-09-24 17:21:00.000000000 +0200
+++ VDR-NG/thread.c	2010-02-10 16:59:02.000000000 +0100
@@ -27,11 +27,12 @@
 {
   struct timeval now;
   if (gettimeofday(&now, NULL) == 0) {           // get current time
-     now.tv_usec += MillisecondsFromNow * 1000;  // add the timeout
-     while (now.tv_usec >= 1000000) {            // take care of an overflow
-           now.tv_sec++;
-           now.tv_usec -= 1000000;
-           }
+     now.tv_sec  += MillisecondsFromNow / 1000;  // add full seconds
+     now.tv_usec += (MillisecondsFromNow % 1000) * 1000;  // add microseconds
+     if (now.tv_usec >= 1000000) {               // take care of an overflow
+        now.tv_sec++;
+        now.tv_usec -= 1000000;
+        }
      Abstime->tv_sec = now.tv_sec;          // seconds
      Abstime->tv_nsec = now.tv_usec * 1000; // nano seconds
      return true;
diff -Naur VDR-NG-orig/timers.c VDR-NG/timers.c
--- VDR-NG-orig/timers.c	2010-02-10 16:57:24.000000000 +0100
+++ VDR-NG/timers.c	2010-02-10 16:59:02.000000000 +0100
@@ -92,6 +92,7 @@
   channel = NULL;
   aux = NULL;
   event = NULL;
+  flags = tfNone;
   *this = Timer;
 }
 
diff -Naur VDR-NG-orig/tools.c VDR-NG/tools.c
--- VDR-NG-orig/tools.c	2010-02-10 16:57:34.000000000 +0100
+++ VDR-NG/tools.c	2010-02-10 16:59:02.000000000 +0100
@@ -100,6 +100,14 @@
   return p < 0 ? p : written;
 }
 
+int readchar(int filedes)
+{
+  char c;
+  if (safe_read(filedes, &c, sizeof(c)) != 1)
+     return -1;
+  return c;
+}
+
 void writechar(int filedes, char c)
 {
   safe_write(filedes, &c, sizeof(c));
@@ -158,11 +166,8 @@
 {
   if (s) {
      char *p = s;
-     while (*p) {
-           if (*p == c1)
-              *p = c2;
-           p++;
-           }
+     while ((p = strchr(p, c1)))
+           *p++ = c2;
      }
   return s;
 }
@@ -176,21 +181,15 @@
      int l1 = strlen(s1);
      int l2 = strlen(s2);
      if (l2 > l1)
-        s = (char *)realloc(s, strlen(s) + l2 - l1 + 1);
+        s = (char *)realloc(s, l + l2 - l1 + 1);
+     char *sof = s + of;
      if (l2 != l1)
-        memmove(s + of + l2, s + of + l1, l - of - l1 + 1);
-     strncpy(s + of, s2, l2);
+        memmove(sof + l2, sof + l1, l - of - l1 + 1);
+     strncpy(sof, s2, l2);
      }
   return s;
 }
 
-char *skipspace(const char *s)
-{
-  while (*s && isspace(*s))
-        s++;
-  return (char *)s;
-}
-
 char *stripspace(char *s)
 {
   if (s && *s) {
@@ -270,20 +269,22 @@
 
 int numdigits(int n)
 {
-  char buf[16];
-  snprintf(buf, sizeof(buf), "%d", n);
-  return strlen(buf);
+  int res = 1;
+  while (n >= 10) {
+        n /= 10;
+        res++;
+        }
+  return res;
 }
 
 bool isnumber(const char *s)
 {
   if (!*s)
      return false;
-  while (*s) {
-        if (!isdigit(*s))
-           return false;
-        s++;
-        }
+  do {
+     if (!isdigit(*s))
+        return false;
+     } while (*++s);
   return true;
 }
 
@@ -698,7 +699,7 @@
      time(&t);
   struct tm tm_r;
   tm *tm = localtime_r(&t, &tm_r);
-  snprintf(buffer, sizeof(buffer), "%s %02d.%02d %02d:%02d", *WeekDayName(tm->tm_wday), tm->tm_mday, tm->tm_mon + 1, tm->tm_hour, tm->tm_min);
+  snprintf(buffer, sizeof(buffer), "%s %02d.%02d. %02d:%02d", *WeekDayName(tm->tm_wday), tm->tm_mday, tm->tm_mon + 1, tm->tm_hour, tm->tm_min);
   return buffer;
 }
 
@@ -1121,6 +1122,8 @@
         LOG_ERROR_STR(tempName);
         result = false;
         }
+     fflush(f);
+     fsync(fileno(f));
      if (fclose(f) < 0) {
         LOG_ERROR_STR(tempName);
         result = false;
diff -Naur VDR-NG-orig/tools.h VDR-NG/tools.h
--- VDR-NG-orig/tools.h	2009-09-24 17:21:12.000000000 +0200
+++ VDR-NG/tools.h	2010-02-10 16:59:02.000000000 +0100
@@ -13,6 +13,8 @@
 #include <dirent.h>
 #include <errno.h>
 #include <fcntl.h>
+#include <float.h>
+#include <math.h>
 #include <poll.h>
 #include <stddef.h>
 #include <stdint.h>
@@ -78,7 +80,7 @@
 #define SECSINDAY  86400
 
 #define KILOBYTE(n) ((n) * 1024)
-#define MEGABYTE(n) ((n) * 1024 * 1024)
+#define MEGABYTE(n) ((n) * 1024LL * 1024LL)
 
 #define MALLOC(type, size)  (type *)malloc(sizeof(type) * (size))
 
@@ -113,7 +115,7 @@
 int BCD2INT(int x);
 
 // Unfortunately there are no platform independent macros for unaligned
-// access. so we do it this way:
+// access, so we do it this way:
 
 template<class T> inline T get_unaligned(const T *const p)
 {
@@ -127,6 +129,14 @@
   ((s *)p)->v = i;
 }
 
+// Comparing doubles for equality is unsafe, but unfortunately we can't
+// overwrite operator==(double, double), so this will have to do:
+
+inline bool DoubleEqual(double a, double b)
+{
+  return fabs(a - b) <= DBL_EPSILON;
+}
+
 class cString {
 private:
   char *s;
@@ -142,6 +152,7 @@
 
 ssize_t safe_read(int filedes, void *buffer, size_t size);
 ssize_t safe_write(int filedes, const void *buffer, size_t size);
+int readchar(int filedes);
 void writechar(int filedes, char c);
 int WriteAllOrNothing(int fd, const uchar *Data, int Length, int TimeoutMs = 0, int RetryMs = 0);
     ///< Writes either all Data to the given file descriptor, or nothing at all.
@@ -151,7 +162,14 @@
 char *strn0cpy(char *dest, const char *src, size_t n);
 char *strreplace(char *s, char c1, char c2);
 char *strreplace(char *s, const char *s1, const char *s2); ///< re-allocates 's' and deletes the original string if necessary!
-char *skipspace(const char *s);
+inline char *skipspace(const char *s)
+{
+  if ((uchar)*s > ' ') // most strings don't have any leading space, so handle this case as fast as possible
+     return (char *)s;
+  while (*s && (uchar)*s <= ' ') // avoiding isspace() here, because it is much slower
+        s++;
+  return (char *)s;
+}
 char *stripspace(char *s);
 char *compactspace(char *s);
 cString strescape(const char *s, const char *chars);
diff -Naur VDR-NG-orig/vdr.c VDR-NG/vdr.c
--- VDR-NG-orig/vdr.c	2010-02-10 16:57:36.000000000 +0100
+++ VDR-NG/vdr.c	2010-02-10 16:59:02.000000000 +0100
@@ -89,23 +89,23 @@
 #include "epgmode.h"
 //M7X0 END AK
 
-#define MINCHANNELWAIT     10 // seconds to wait between failed channel switchings
-#define ACTIVITYTIMEOUT    60 // seconds before starting housekeeping
-#define SHUTDOWNWAIT      300 // seconds to wait in user prompt before automatic shutdown
-#define SHUTDOWNRETRY     360 // seconds before trying again to shut down
-#define SHUTDOWNFORCEPROMPT 5 // seconds to wait in user prompt to allow forcing shutdown
-#define SHUTDOWNCANCELROMPT 5 // seconds to wait in user prompt to allow canceling shutdown
-#define RESTARTCANCELPROMPT 5 // seconds to wait in user prompt before restarting on SIGHUP
-#define CHANNELSAVEDELTA  600 // seconds before saving channels.conf after automatic modifications
-#define LASTCAMMENUTIMEOUT  3 // seconds to run the main loop 'fast' after a CAM menu has been closed
-                              // in order to react on a possible new CAM menu as soon as possible
-#define DEVICEREADYTIMEOUT 30 // seconds to wait until all devices are ready
-#define MENUTIMEOUT       120 // seconds of user inactivity after which an OSD display is closed
-#define TIMERCHECKDELTA    10 // seconds between checks for timers that need to see their channel
-#define TIMERDEVICETIMEOUT  8 // seconds before a device used for timer check may be reused
-#define TIMERLOOKAHEADTIME 60 // seconds before a non-VPS timer starts and the channel is switched if possible
-#define VPSLOOKAHEADTIME   24 // hours within which VPS timers will make sure their events are up to date
-#define VPSUPTODATETIME  3600 // seconds before the event or schedule of a VPS timer needs to be refreshed
+#define MINCHANNELWAIT        10 // seconds to wait between failed channel switchings
+#define ACTIVITYTIMEOUT       60 // seconds before starting housekeeping
+#define SHUTDOWNWAIT         300 // seconds to wait in user prompt before automatic shutdown
+#define SHUTDOWNRETRY        360 // seconds before trying again to shut down
+#define SHUTDOWNFORCEPROMPT    5 // seconds to wait in user prompt to allow forcing shutdown
+#define SHUTDOWNCANCELPROMPT   5 // seconds to wait in user prompt to allow canceling shutdown
+#define RESTARTCANCELPROMPT    5 // seconds to wait in user prompt before restarting on SIGHUP
+#define CHANNELSAVEDELTA     600 // seconds before saving channels.conf after automatic modifications
+#define LASTCAMMENUTIMEOUT     3 // seconds to run the main loop 'fast' after a CAM menu has been closed
+                                 // in order to react on a possible new CAM menu as soon as possible
+#define DEVICEREADYTIMEOUT    30 // seconds to wait until all devices are ready
+#define MENUTIMEOUT          120 // seconds of user inactivity after which an OSD display is closed
+#define TIMERCHECKDELTA       10 // seconds between checks for timers that need to see their channel
+#define TIMERDEVICETIMEOUT     8 // seconds before a device used for timer check may be reused
+#define TIMERLOOKAHEADTIME    60 // seconds before a non-VPS timer starts and the channel is switched if possible
+#define VPSLOOKAHEADTIME      24 // hours within which VPS timers will make sure their events are up to date
+#define VPSUPTODATETIME     3600 // seconds before the event or schedule of a VPS timer needs to be refreshed
 
 #define EXIT(v) { ShutdownHandler.Exit(v); goto Exit; }
 
@@ -174,8 +174,6 @@
 
 static void SignalHandler(int signum)
 {
-// DON'T EVER DO THIS OR YOU END UP WITH A SIGHANDLER RACE
-//  isyslog("caught signal %d", signum);
   switch (signum) {
     case SIGPIPE:
          break;
@@ -243,9 +241,6 @@
 #elif defined(REMOTE_RCU)
   RcuDevice = RCU_DEVICE;
 #endif
-#if defined(VFAT)
-  VfatFileSystem = true;
-#endif
 #if defined(VDR_USER)
   VdrUser = VDR_USER;
 #endif
@@ -257,6 +252,7 @@
       { "config",   required_argument, NULL, 'c' },
       { "daemon",   no_argument,       NULL, 'd' },
       { "device",   required_argument, NULL, 'D' },
+      { "edit",     required_argument, NULL, 'e' | 0x100 },
       { "epgfile",  required_argument, NULL, 'E' },
       { "grab",     required_argument, NULL, 'g' },
       { "help",     no_argument,       NULL, 'h' },
@@ -277,11 +273,11 @@
       { "vfat",     no_argument,       NULL, 'v' | 0x100 },
       { "video",    required_argument, NULL, 'v' },
       { "watchdog", required_argument, NULL, 'w' },
-      { NULL }
+      { NULL,       no_argument,       NULL,  0  }
     };
 
   int c;
-  while ((c = getopt_long(argc, argv, "a:c:dD:E:g:hi:l:L:mp:P:r:s:t:u:v:Vw:", long_options, NULL)) != -1) {
+  while ((c = getopt_long(argc, argv, "a:c:dD:e:E:g:hi:l:L:mp:P:r:s:t:u:v:Vw:", long_options, NULL)) != -1) {
         switch (c) {
           case 'a': AudioCommand = optarg;
                     break;
@@ -298,6 +294,8 @@
                     fprintf(stderr, "vdr: invalid DVB device number: %s\n", optarg);
                     return 2;
                     break;
+          case 'e' | 0x100:
+                    return CutRecording(optarg) ? 0 : 2;
           case 'E': EpgDataFileName = (*optarg != '-' ? optarg : NULL);
                     break;
           case 'g': cSVDRP::SetGrabImageDir(*optarg != '-' ? optarg : NULL);
@@ -437,6 +435,7 @@
                "  -D NUM,   --device=NUM   use only the given DVB device (NUM = 0, 1, 2...)\n"
                "                           there may be several -D options (default: all DVB\n"
                "                           devices will be used)\n"
+               "            --edit=REC     cut recording REC and exit\n"
                "  -E FILE,  --epgfile=FILE write the EPG data into the given FILE (default is\n"
                "                           '%s' in the video directory)\n"
                "                           '-E-' disables this\n"
@@ -549,6 +548,7 @@
      stdout = freopen(Terminal, "w", stdout);
      stderr = freopen(Terminal, "w", stderr);
      HasStdin = true;
+     tcgetattr(STDIN_FILENO, &savedTm);
      }
 
 //M7X0 BEGIN AK
@@ -589,6 +589,7 @@
   int MaxLatencyTime = 0;
   bool InhibitEpgScan = false;
   bool IsInfoMenu = false;
+  bool CheckHasProgramme = false;
   cSkin *CurrentSkin = NULL;
 
   // Load plugins:
@@ -788,10 +789,13 @@
 #endif
         // Attach launched player control:
         cControl::Attach();
+
+        time_t Now = time(NULL);
+
         // Make sure we have a visible programme in case device usage has changed:
         if (!EITScanner.Active() && cDevice::PrimaryDevice()->HasDecoder() && !cDevice::PrimaryDevice()->HasProgramme()) {
            static time_t lastTime = 0;
-           if (!scanning_on_receiving_device && time(NULL) - lastTime > MINCHANNELWAIT) {
+           if ((!scanning_on_receiving_device || CheckHasProgramme) && Now - lastTime > MINCHANNELWAIT) {
               cChannel *Channel = Channels.GetByNumber(cDevice::CurrentChannel());
               if (Channel && (Channel->Vpid() || Channel->Apid(0))) {
                  if (!Channels.SwitchTo(cDevice::CurrentChannel()) // try to switch to the original channel...
@@ -800,8 +804,9 @@
                      && !cDevice::SwitchChannel(-1)) // ...or the next lower available one
                     ;
                  }
-              lastTime = time(NULL); // don't do this too often
+              lastTime = Now; // don't do this too often
               LastTimerChannel = -1;
+              CheckHasProgramme = false;
               }
            }
         // Restart the Watchdog timer:
@@ -822,8 +827,8 @@
            if (modified == CHANNELSMOD_USER || Timers.Modified(TimerState))
               ChannelSaveTimeout = 1; // triggers an immediate save
            else if (modified && !ChannelSaveTimeout)
-              ChannelSaveTimeout = time(NULL) + CHANNELSAVEDELTA;
-           bool timeout = ChannelSaveTimeout == 1 || (ChannelSaveTimeout && time(NULL) > ChannelSaveTimeout && !cRecordControls::Active());
+              ChannelSaveTimeout = Now + CHANNELSAVEDELTA;
+           bool timeout = ChannelSaveTimeout == 1 || (ChannelSaveTimeout && Now > ChannelSaveTimeout && !cRecordControls::Active());
            if ((modified || timeout) && Channels.Lock(false, 100)) {
               if (timeout) {
                  Channels.Save();
@@ -851,16 +856,15 @@
            if (!Menu)
               Menu = new cDisplayChannel(cDevice::CurrentChannel(), LastChannel >= 0);
            LastChannel = cDevice::CurrentChannel();
-           LastChannelChanged = time(NULL);
+           LastChannelChanged = Now;
            }
-        if (time(NULL) - LastChannelChanged >= Setup.ZapTimeout && LastChannel != PreviousChannel[PreviousChannelIndex])
+        if (Now - LastChannelChanged >= Setup.ZapTimeout && LastChannel != PreviousChannel[PreviousChannelIndex])
            PreviousChannel[PreviousChannelIndex ^= 1] = LastChannel;
         // Timers and Recordings:
         if (!Timers.BeingEdited()) {
            // Assign events to timers:
            Timers.SetEvents();
            // Must do all following calls with the exact same time!
-           time_t Now = time(NULL);
            // Process ongoing recordings:
            cRecordControls::Process(Now);
            // Start new recordings:
@@ -953,7 +957,7 @@
                * is tuned to timers channel.
                */
               InhibitEpgScan = (!!InhibitEpgScan) & devNeed;
-              LastTimerCheck = time(NULL);
+              LastTimerCheck = Now;
               }
            // Delete expired timers:
            Timers.DeleteExpired();
@@ -968,14 +972,14 @@
            if (Menu)
               LastCamMenu = 0;
            else if (!LastCamMenu)
-              LastCamMenu = time(NULL);
+              LastCamMenu = Now;
            }
         // Queued messages:
         if (!Skins.IsOpen())
            Skins.ProcessQueuedMessages();
         // User Input:
         cOsdObject *Interact = Menu ? Menu : cControl::Control();
-        eKeys key = Interface->GetKey((!Interact || !Interact->NeedsFastResponse()) && time(NULL) - LastCamMenu > LASTCAMMENUTIMEOUT);
+        eKeys key = Interface->GetKey((!Interact || !Interact->NeedsFastResponse()) && Now - LastCamMenu > LASTCAMMENUTIMEOUT);
 
         if (ISREALKEY(key)) {
            cStatus::MsgUserAction(key, Interact);          // PIN PATCH
@@ -1123,8 +1127,12 @@
           case kPause:
                if (!cControl::Control()) {
                   DELETE_MENU;
-                  if (!cRecordControls::PauseLiveVideo())
-                     Skins.Message(mtError, tr("No free DVB device to record!"));
+                  if (Setup.PauseKeyHandling) {
+                     if (Setup.PauseKeyHandling > 1 || Interface->Confirm(tr("Pause live video?"))) {
+                        if (!cRecordControls::PauseLiveVideo())
+                           Skins.Message(mtError, tr("No free DVB device to record!"));
+                        }
+                     }
                   key = kNone; // nobody else needs to see this key
                   }
                break;
@@ -1163,7 +1171,7 @@
                    }
 		   if(Setup.ShutdownMessage){
                 // Ask the final question:
-                if (!Interface->Confirm(tr("Press any key to cancel shutdown"), SHUTDOWNCANCELROMPT, true))
+                if (!Interface->Confirm(tr("Press any key to cancel shutdown"), SHUTDOWNCANCELPROMPT, true))
                    // If final question was canceled, continue to be active:
                    break;
 		   } else {
@@ -1194,7 +1202,7 @@
                     continue;
                     }
                  }
-              else if (time(NULL) - cRemote::LastActivity() > MENUTIMEOUT)
+              else if (Now - cRemote::LastActivity() > MENUTIMEOUT)
                  state = osEnd;
               }
            // TODO make the CAM menu stay open in case of automatic updates and have it return osContinue; then the following two lines can be removed again
@@ -1214,6 +1222,7 @@
                             DELETE_MENU;
                             cControl::Shutdown();
                             Menu = new cMenuMain(osRecordings);
+                            CheckHasProgramme = true; // to have live tv after stopping replay with 'Back'
                             break;
              case osReplay: DELETE_MENU;
                             cControl::Shutdown();
@@ -1321,12 +1330,12 @@
                ShutdownHandler.countdown.Cancel();
             }
 
-         if (!Interact && !cRecordControls::Active() && !cCutter::Active() && !cUsbAutomounter::Active() && !Interface->HasSVDRPConnection() && (time(NULL) - cRemote::LastActivity()) > ACTIVITYTIMEOUT) {
+         if (!Interact && !cRecordControls::Active() && !cCutter::Active() && !cUsbAutomounter::Active() && !Interface->HasSVDRPConnection() && (Now - cRemote::LastActivity()) > ACTIVITYTIMEOUT) {
             // Handle housekeeping tasks
 
             // Shutdown:
             // Check whether VDR will be ready for shutdown in SHUTDOWNWAIT seconds:
-            time_t Soon = time(NULL) + SHUTDOWNWAIT;
+            time_t Soon = Now + SHUTDOWNWAIT;
             if (ShutdownHandler.IsUserInactive(Soon) && ShutdownHandler.Retry(Soon) && !ShutdownHandler.countdown) {
                if (ShutdownHandler.ConfirmShutdown(false) && !Setup.HotStandby)
                   // Time to shut down - start final countdown:
@@ -1404,9 +1413,11 @@
   ReportEpgBugFixStats();
   if (WatchdogTimeout > 0)
      dsyslog("max. latency time %d seconds", MaxLatencyTime);
-  isyslog("exiting, exit code %d", ShutdownHandler.GetExitCode());
+  if (LastSignal)
+     isyslog("caught signal %d", LastSignal);
   if (ShutdownHandler.EmergencyExitRequested())
      esyslog("emergency exit!");
+  isyslog("exiting, exit code %d", ShutdownHandler.GetExitCode());
 //M7X0 BEGIN AK
   //Syslog  reactivated
   if (SysLogLevel > 0)
