diff -Naur osdteletext-orig/common.h osdteletext/common.h
--- osdteletext-orig/common.h	1970-01-01 01:00:00.000000000 +0100
+++ osdteletext/common.h	2008-01-20 12:01:17.000000000 +0100
@@ -0,0 +1,22 @@
+/*
+ * common.h: OSDTELETEXT plugin for the Video Disk Recorder
+ *
+ *
+ */
+
+#ifndef __OSDTELETEXT_COMMON_H
+#define __OSDTELETEXT_COMMON_H
+
+#include <vdr/tools.h>
+#ifdef DEBUG
+#define debug(x...) dsyslog("OSDTeletext: " x);
+#define error(x...) esyslog("OSDTeletext: " x);
+#else
+#define debug(x...) ;
+#define error(x...) esyslog("OSDTeletext: " x);
+#endif
+
+#define TXT_CHARSIZE 2
+
+#endif // __OSDTELETEXT_COMMON_H
+
diff -Naur osdteletext-orig/hamm.c osdteletext/hamm.c
--- osdteletext-orig/hamm.c	1970-01-01 01:00:00.000000000 +0100
+++ osdteletext/hamm.c	2008-01-20 12:01:17.000000000 +0100
@@ -0,0 +1,313 @@
+/*
+ *  libzvbi - Error correction functions
+ *
+ *  Copyright (C) 2001, 2002, 2003, 2004 Michael H. Schimek
+ *
+ *  Based on code from AleVT 1.5.1
+ *  Copyright (C) 1998, 1999 Edgar Toernig <froese@gmx.de>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/* $Id: hamm.c,v 1.15 2005/06/28 01:00:59 mschimek Exp $ */
+
+#include <limits.h>		/* CHAR_BIT */
+#include "hamm.h"
+
+const uint8_t
+_vbi3_bit_reverse [256] = {
+	0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0,	
+	0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0,
+	0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8,	
+	0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8,
+
+	0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4,	
+	0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4,
+	0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec,	
+	0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc,
+
+	0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2,	
+	0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2,
+	0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea,	
+	0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa,
+
+	0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6,	
+	0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6,
+	0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee,	
+	0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe,
+
+	0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1,	
+	0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1,
+	0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9,	
+	0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9,
+
+	0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5,	
+	0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5,
+	0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed,	
+	0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd,
+
+	0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3,	
+	0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3,
+	0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb,	
+	0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb,
+
+	0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7,	
+	0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7,
+	0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef,	
+	0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff
+};
+
+/**
+ * @ingroup Error
+ *
+ * @param p Array of unsigned bytes.
+ * @param n Size of array.
+ * 
+ * Of each byte of the array, changes the most significant
+ * bit to make the number of set bits odd.
+ */
+void
+vbi3_par				(uint8_t *		p,
+				 unsigned long		n)
+{
+	while (n-- > 0) {
+		uint8_t c = *p;
+
+		/* if 0 == (inv_par[] & 32) change msb of *p. */
+		*p++ = c ^ (128 & ~(_vbi3_hamm24_inv_par[0][c] << 2));
+	}
+}
+
+/**
+ * @ingroup Error
+ * @param p Array of unsigned bytes.
+ * @param n Size of array.
+ * 
+ * Tests the parity and clears the most significant bit of
+ * each byte of the array.
+ *
+ * @return
+ * A negative value if any byte of the array had even
+ * parity (sum of bits modulo 2 is 0).
+ */
+int
+vbi3_unpar			(uint8_t *		p,
+				 unsigned long		n)
+{
+	int r = 0;
+
+	while (n-- > 0) {
+		uint8_t c = *p;
+
+		/* if 0 == (inv_par[] & 32) set msb of r. */
+		r |= ~ _vbi3_hamm24_inv_par[0][c]
+			<< (sizeof (int) * CHAR_BIT - 1 - 5);
+
+		*p++ = c & 127;
+	}
+
+	return r;
+}
+
+/* ETS 300 706, Section 8.2 Hamming 8/4 */
+
+const uint8_t
+_vbi3_hamm8_fwd [16] = {
+	0x15, 0x02, 0x49, 0x5e, 0x64, 0x73, 0x38, 0x2f,
+	0xd0, 0xc7, 0x8c, 0x9b, 0xa1, 0xb6, 0xfd, 0xea
+};
+
+const int8_t
+_vbi3_hamm8_inv [256] = {
+	0x01,   -1, 0x01, 0x01,   -1, 0x00, 0x01,   -1, 
+	  -1, 0x02, 0x01,   -1, 0x0a,   -1,   -1, 0x07, 
+	  -1, 0x00, 0x01,   -1, 0x00, 0x00,   -1, 0x00, 
+	0x06,   -1,   -1, 0x0b,   -1, 0x00, 0x03,   -1, 
+
+	  -1, 0x0c, 0x01,   -1, 0x04,   -1,   -1, 0x07, 
+	0x06,   -1,   -1, 0x07,   -1, 0x07, 0x07, 0x07, 
+	0x06,   -1,   -1, 0x05,   -1, 0x00, 0x0d,   -1, 
+	0x06, 0x06, 0x06,   -1, 0x06,   -1,   -1, 0x07, 
+
+	  -1, 0x02, 0x01,   -1, 0x04,   -1,   -1, 0x09, 
+	0x02, 0x02,   -1, 0x02,   -1, 0x02, 0x03,   -1, 
+	0x08,   -1,   -1, 0x05,   -1, 0x00, 0x03,   -1, 
+	  -1, 0x02, 0x03,   -1, 0x03,   -1, 0x03, 0x03, 
+
+	0x04,   -1,   -1, 0x05, 0x04, 0x04, 0x04,   -1, 
+	  -1, 0x02, 0x0f,   -1, 0x04,   -1,   -1, 0x07, 
+	  -1, 0x05, 0x05, 0x05, 0x04,   -1,   -1, 0x05, 
+	0x06,   -1,   -1, 0x05,   -1, 0x0e, 0x03,   -1, 
+
+	  -1, 0x0c, 0x01,   -1, 0x0a,   -1,   -1, 0x09, 
+	0x0a,   -1,   -1, 0x0b, 0x0a, 0x0a, 0x0a,   -1, 
+	0x08,   -1,   -1, 0x0b,   -1, 0x00, 0x0d,   -1, 
+	  -1, 0x0b, 0x0b, 0x0b, 0x0a,   -1,   -1, 0x0b, 
+
+	0x0c, 0x0c,   -1, 0x0c,   -1, 0x0c, 0x0d,   -1, 
+	  -1, 0x0c, 0x0f,   -1, 0x0a,   -1,   -1, 0x07, 
+	  -1, 0x0c, 0x0d,   -1, 0x0d,   -1, 0x0d, 0x0d, 
+	0x06,   -1,   -1, 0x0b,   -1, 0x0e, 0x0d,   -1, 
+
+	0x08,   -1,   -1, 0x09,   -1, 0x09, 0x09, 0x09, 
+	  -1, 0x02, 0x0f,   -1, 0x0a,   -1,   -1, 0x09, 
+	0x08, 0x08, 0x08,   -1, 0x08,   -1,   -1, 0x09, 
+	0x08,   -1,   -1, 0x0b,   -1, 0x0e, 0x03,   -1, 
+
+	  -1, 0x0c, 0x0f,   -1, 0x04,   -1,   -1, 0x09, 
+	0x0f,   -1, 0x0f, 0x0f,   -1, 0x0e, 0x0f,   -1, 
+	0x08,   -1,   -1, 0x05,   -1, 0x0e, 0x0d,   -1, 
+	  -1, 0x0e, 0x0f,   -1, 0x0e, 0x0e,   -1, 0x0e
+};
+
+/* ETS 300 706, Section 8.3 Hamming 18/24 (code from AleVT) */
+
+/* This table generates the parity checks for hamm24/18 decoding.
+   Bit 0 is for test A, 1 for B, ...
+   Thanks to R. Gancarz for this fine table *g* */
+const int8_t
+_vbi3_hamm24_inv_par [3][256] = {
+    {
+        /* Parities of first byte */
+	 0, 33, 34,  3, 35,  2,  1, 32, 36,  5,  6, 39,  7, 38, 37,  4,
+	37,  4,  7, 38,  6, 39, 36,  5,  1, 32, 35,  2, 34,  3,  0, 33,
+	38,  7,  4, 37,  5, 36, 39,  6,  2, 35, 32,  1, 33,  0,  3, 34,
+	 3, 34, 33,  0, 32,  1,  2, 35, 39,  6,  5, 36,  4, 37, 38,  7,
+
+	39,  6,  5, 36,  4, 37, 38,  7,  3, 34, 33,  0, 32,  1,  2, 35,
+	 2, 35, 32,  1, 33,  0,  3, 34, 38,  7,  4, 37,  5, 36, 39,  6,
+	 1, 32, 35,  2, 34,  3,  0, 33, 37,  4,  7, 38,  6, 39, 36,  5,
+	36,  5,  6, 39,  7, 38, 37,  4,  0, 33, 34,  3, 35,  2,  1, 32,
+
+	40,  9, 10, 43, 11, 42, 41,  8, 12, 45, 46, 15, 47, 14, 13, 44,
+	13, 44, 47, 14, 46, 15, 12, 45, 41,  8, 11, 42, 10, 43, 40,  9,
+	14, 47, 44, 13, 45, 12, 15, 46, 42, 11,  8, 41,  9, 40, 43, 10,
+	43, 10,  9, 40,  8, 41, 42, 11, 15, 46, 45, 12, 44, 13, 14, 47,
+
+	15, 46, 45, 12, 44, 13, 14, 47, 43, 10,  9, 40,  8, 41, 42, 11,
+	42, 11,  8, 41,  9, 40, 43, 10, 14, 47, 44, 13, 45, 12, 15, 46,
+	41,  8, 11, 42, 10, 43, 40,  9, 13, 44, 47, 14, 46, 15, 12, 45,
+	12, 45, 46, 15, 47, 14, 13, 44, 40,  9, 10, 43, 11, 42, 41,  8
+    }, { 
+        /* Parities of second byte */
+	 0, 41, 42,  3, 43,  2,  1, 40, 44,  5,  6, 47,  7, 46, 45,  4,
+	45,  4,  7, 46,  6, 47, 44,  5,  1, 40, 43,  2, 42,  3,  0, 41,
+	46,  7,  4, 45,  5, 44, 47,  6,  2, 43, 40,  1, 41,  0,  3, 42,
+	 3, 42, 41,  0, 40,  1,  2, 43, 47,  6,  5, 44,  4, 45, 46,  7,
+
+	47,  6,  5, 44,  4, 45, 46,  7,  3, 42, 41,  0, 40,  1,  2, 43,
+	 2, 43, 40,  1, 41,  0,  3, 42, 46,  7,  4, 45,  5, 44, 47,  6,
+	 1, 40, 43,  2, 42,  3,  0, 41, 45,  4,  7, 46,  6, 47, 44,  5,
+	44,  5,  6, 47,  7, 46, 45,  4,  0, 41, 42,  3, 43,  2,  1, 40,
+
+	48, 25, 26, 51, 27, 50, 49, 24, 28, 53, 54, 31, 55, 30, 29, 52,
+	29, 52, 55, 30, 54, 31, 28, 53, 49, 24, 27, 50, 26, 51, 48, 25,
+	30, 55, 52, 29, 53, 28, 31, 54, 50, 27, 24, 49, 25, 48, 51, 26,
+	51, 26, 25, 48, 24, 49, 50, 27, 31, 54, 53, 28, 52, 29, 30, 55,
+
+	31, 54, 53, 28, 52, 29, 30, 55, 51, 26, 25, 48, 24, 49, 50, 27,
+	50, 27, 24, 49, 25, 48, 51, 26, 30, 55, 52, 29, 53, 28, 31, 54,
+	49, 24, 27, 50, 26, 51, 48, 25, 29, 52, 55, 30, 54, 31, 28, 53,
+	28, 53, 54, 31, 55, 30, 29, 52, 48, 25, 26, 51, 27, 50, 49, 24
+    }, { 
+        /* Parities of third byte, xor 0x3F */
+	63, 14, 13, 60, 12, 61, 62, 15, 11, 58, 57,  8, 56,  9, 10, 59,
+	10, 59, 56,  9, 57,  8, 11, 58, 62, 15, 12, 61, 13, 60, 63, 14,
+	 9, 56, 59, 10, 58, 11,  8, 57, 61, 12, 15, 62, 14, 63, 60, 13,
+	60, 13, 14, 63, 15, 62, 61, 12,  8, 57, 58, 11, 59, 10,  9, 56,
+
+	 8, 57, 58, 11, 59, 10,  9, 56, 60, 13, 14, 63, 15, 62, 61, 12,
+	61, 12, 15, 62, 14, 63, 60, 13,  9, 56, 59, 10, 58, 11,  8, 57,
+	62, 15, 12, 61, 13, 60, 63, 14, 10, 59, 56,  9, 57,  8, 11, 58,
+	11, 58, 57,  8, 56,  9, 10, 59, 63, 14, 13, 60, 12, 61, 62, 15,
+
+	31, 46, 45, 28, 44, 29, 30, 47, 43, 26, 25, 40, 24, 41, 42, 27,
+	42, 27, 24, 41, 25, 40, 43, 26, 30, 47, 44, 29, 45, 28, 31, 46,
+	41, 24, 27, 42, 26, 43, 40, 25, 29, 44, 47, 30, 46, 31, 28, 45,
+	28, 45, 46, 31, 47, 30, 29, 44, 40, 25, 26, 43, 27, 42, 41, 24,
+
+	40, 25, 26, 43, 27, 42, 41, 24, 28, 45, 46, 31, 47, 30, 29, 44,
+	29, 44, 47, 30, 46, 31, 28, 45, 41, 24, 27, 42, 26, 43, 40, 25,
+	30, 47, 44, 29, 45, 28, 31, 46, 42, 27, 24, 41, 25, 40, 43, 26,
+	43, 26, 25, 40, 24, 41, 42, 27, 31, 46, 45, 28, 44, 29, 30, 47
+    }
+};
+
+/* Table to extract the lower 4 bits from first hamm24/18
+   encoded byte (P4 D4 D3 D2 P3 D1 P2 P1) */
+static const int8_t
+_vbi3_hamm24_val [128] = {
+	 0,  0,  0,  0,  1,  1,  1,  1,  0,  0,  0,  0,  1,  1,  1,  1,
+	 2,  2,  2,  2,  3,  3,  3,  3,  2,  2,  2,  2,  3,  3,  3,  3,
+	 4,  4,  4,  4,  5,  5,  5,  5,  4,  4,  4,  4,  5,  5,  5,  5,
+	 6,  6,  6,  6,  7,  7,  7,  7,  6,  6,  6,  6,  7,  7,  7,  7,
+
+	 8,  8,  8,  8,  9,  9,  9,  9,  8,  8,  8,  8,  9,  9,  9,  9,
+	10, 10, 10, 10, 11, 11, 11, 11, 10, 10, 10, 10, 11, 11, 11, 11,
+	12, 12, 12, 12, 13, 13, 13, 13, 12, 12, 12, 12, 13, 13, 13, 13,
+	14, 14, 14, 14, 15, 15, 15, 15, 14, 14, 14, 14, 15, 15, 15, 15
+};
+
+/* Correction of single bit error in decoded word,
+   according to test A ... F in table vbi3_hamm24_inv_tst.
+   MSB indicates double bit error. */
+static const int32_t
+_vbi3_hamm24_corr [64] = {
+	0x00000000, 0x80000000, 0x80000000, 0x80000000,
+	0x80000000, 0x80000000, 0x80000000, 0x80000000,
+	0x80000000, 0x80000000, 0x80000000, 0x80000000,
+	0x80000000, 0x80000000, 0x80000000, 0x80000000,
+
+	0x80000000, 0x80000000, 0x80000000, 0x80000000,
+	0x80000000, 0x80000000, 0x80000000, 0x80000000,
+	0x80000000, 0x80000000, 0x80000000, 0x80000000,
+	0x80000000, 0x80000000, 0x80000000, 0x80000000,
+
+	0x00000000, 0x00000000, 0x00000000, 0x00000001,
+	0x00000000, 0x00000002, 0x00000004, 0x00000008,
+	0x00000000, 0x00000010, 0x00000020, 0x00000040,
+	0x00000080, 0x00000100, 0x00000200, 0x00000400,
+
+	0x00000000, 0x00000800, 0x00001000, 0x00002000,
+	0x00004000, 0x00008000, 0x00010000, 0x00020000,
+	0x80000000, 0x80000000, 0x80000000, 0x80000000,
+	0x80000000, 0x80000000, 0x80000000, 0x80000000,
+};
+
+/**
+ * @ingroup Error
+ * @param p Pointer to a Hamming 24/18 protected 24 bit word,
+ *   last significant byte first, lsb first transmitted.
+ * 
+ * Decodes a Hamming 24/18 protected byte triplet
+ * as specified in ETS 300 706, Section 8.3.
+ * 
+ * @return
+ * Triplet data bits D18 [msb] ... D1 [lsb] or a negative value
+ * if the triplet contained incorrectable errors.
+ */
+int
+vbi3_unham24p			(const uint8_t *	p)
+{
+	int e = _vbi3_hamm24_inv_par[0][p[0]]
+		^ _vbi3_hamm24_inv_par[1][p[1]]
+		^ _vbi3_hamm24_inv_par[2][p[2]];
+
+	int x = _vbi3_hamm24_val[p[0] & 127]
+		+ (p[1] & 127) * 16
+		+ (p[2] & 127) * 2048;
+
+	return x ^ (int) _vbi3_hamm24_corr[e];
+}
diff -Naur osdteletext-orig/hamm.h osdteletext/hamm.h
--- osdteletext-orig/hamm.h	1970-01-01 01:00:00.000000000 +0100
+++ osdteletext/hamm.h	2008-01-20 12:01:17.000000000 +0100
@@ -0,0 +1,205 @@
+/*
+ *  libzvbi - Error correction functions
+ *
+ *  Copyright (C) 2001, 2002, 2003, 2004 Michael H. Schimek
+ *
+ *  Based on code from AleVT 1.5.1
+ *  Copyright (C) 1998, 1999 Edgar Toernig <froese@gmx.de>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/* $Id: hamm.h,v 1.16 2005/06/28 01:00:22 mschimek Exp $ */
+
+#ifndef __ZVBI3_HAMM_H__
+#define __ZVBI3_HAMM_H__
+
+#include <inttypes.h>		/* uintN_t */
+#include "macros.h"
+
+VBI3_BEGIN_DECLS
+
+extern const uint8_t		_vbi3_bit_reverse [256];
+extern const uint8_t		_vbi3_hamm8_fwd [16];
+extern const int8_t		_vbi3_hamm8_inv [256];
+extern const int8_t		_vbi3_hamm24_inv_par [3][256];
+
+/**
+ * @addtogroup Error Error correction functions
+ * @ingroup Raw
+ * @brief Helper functions to decode sliced VBI data.
+ * @{
+ */
+
+/**
+ * @param c Unsigned byte.
+ * 
+ * Reverses the bits of the argument.
+ * 
+ * @returns
+ * Data bits 0 [msb] ... 7 [lsb].
+ */
+vbi3_inline unsigned int
+vbi3_rev8			(unsigned int		c)
+{
+	return _vbi3_bit_reverse[(uint8_t) c];
+}
+
+/**
+ * @param c Unsigned 16 bit word.
+ * 
+ * Reverses the bits of the argument.
+ * 
+ * @returns
+ * Data bits 0 [msb] ... 15 [lsb].
+ */
+vbi3_inline unsigned int
+vbi3_rev16			(unsigned int		c)
+{
+	return _vbi3_bit_reverse[(uint8_t) c] * 256
+		+ _vbi3_bit_reverse[(uint8_t)(c >> 8)];
+}
+
+/**
+ * @param p Pointer to a 16 bit word, last significant
+ *   byte first.
+ * 
+ * Reverses the bits of the argument.
+ * 
+ * @returns
+ * Data bits 0 [msb] ... 15 [lsb].
+ */
+vbi3_inline unsigned int
+vbi3_rev16p			(const uint8_t *	p)
+{
+	return _vbi3_bit_reverse[p[0]] * 256
+		+ _vbi3_bit_reverse[p[1]];
+}
+
+/**
+ * @param c Unsigned byte.
+ *
+ * @returns
+ * Changes the most significant bit of the byte
+ * to make the number of set bits odd.
+ */
+vbi3_inline unsigned int
+vbi3_par8			(unsigned int		c)
+{
+	c &= 255;
+
+	/* if 0 == (inv_par[] & 32) change bit 7 of c. */
+	c ^= 128 & ~(_vbi3_hamm24_inv_par[0][c] << 2);
+
+	return c;
+}
+
+/**
+ * @param c Unsigned byte. 
+ * 
+ * @returns
+ * If the byte has odd parity (sum of bits modulo 2 is 1) the
+ * byte AND 127, otherwise a negative value.
+ */
+vbi3_inline int
+vbi3_unpar8			(unsigned int		c)
+{
+#ifdef __GNUC__
+#if #cpu (i686)
+	int r = c & 127;
+
+	/* This saves cache flushes and an explicit branch. */
+	__asm__ (" testb	%1,%1\n"
+		 " cmovp	%2,%0\n"
+		 : "+&a" (r) : "c" (c), "rm" (-1));
+	return r;
+#endif
+#endif
+	if (_vbi3_hamm24_inv_par[0][(uint8_t) c] & 32) {
+		return c & 127;
+	} else {
+		/* The idea is to OR results together to find a parity
+		   error in a sequence, rather than a test and branch on
+		   each byte. */
+		return -1;
+	}
+}
+
+extern void
+vbi3_par				(uint8_t *		p,
+				 unsigned long		n);
+extern int
+vbi3_unpar			(uint8_t *		p,
+				 unsigned long		n);
+
+/**
+ * @param c Integer between 0 ... 15.
+ * 
+ * Encodes a nibble with Hamming 8/4 protection
+ * as specified in EN 300 706, Section 8.2.
+ * 
+ * @returns
+ * Hamming encoded unsigned byte, lsb first transmitted.
+ */
+vbi3_inline unsigned int
+vbi3_ham8			(unsigned int		c)
+{
+	return _vbi3_hamm8_fwd[c & 15];
+}
+
+/**
+ * @param c Hamming 8/4 protected byte, lsb first transmitted.
+ * 
+ * Decodes a Hamming 8/4 protected byte
+ * as specified in EN 300 706, Section 8.2.
+ * 
+ * @returns
+ * Data bits (D4 [msb] ... D1 [lsb]) or a negative
+ * value if the byte contained incorrectable errors.
+ */
+vbi3_inline int
+vbi3_unham8			(unsigned int		c)
+{
+	return _vbi3_hamm8_inv[(uint8_t) c];
+}
+
+/**
+ * @param p Pointer to a Hamming 8/4 protected 16 bit word,
+ *   last significant byte first, lsb first transmitted.
+ * 
+ * Decodes a Hamming 8/4 protected byte pair
+ * as specified in EN 300 706, Section 8.2.
+ * 
+ * @returns
+ * Data bits D4 [msb] ... D1 of first byte and D4 ... D1 [lsb]
+ * of second byte, or a negative value if any of the bytes
+ * contained incorrectable errors.
+ */
+vbi3_inline int
+vbi3_unham16p			(const uint8_t *	p)
+{
+	return ((int) _vbi3_hamm8_inv[p[0]])
+	  | (((int) _vbi3_hamm8_inv[p[1]]) << 4);
+}
+
+extern int
+vbi3_unham24p			(const uint8_t *	p)
+  __attribute__ ((_vbi3_pure));
+
+/** @} */
+
+VBI3_END_DECLS
+
+#endif /* __ZVBI3_HAMM_H__ */
diff -Naur osdteletext-orig/i18n.c osdteletext/i18n.c
--- osdteletext-orig/i18n.c	2008-01-12 12:27:50.000000000 +0100
+++ osdteletext/i18n.c	2008-01-20 12:08:22.000000000 +0100
@@ -37,7 +37,7 @@
     "",               //Norwegian
     "ei löydy",       //Finnish
     "",               //Polish
-    "no encontrada",  //Spanish
+    "no encontrada todavía",  //Spanish
     "",               //Greek
     "",               //Swedish
     "",               //Romanian
@@ -109,7 +109,7 @@
     "",                  //Norwegian
     "Vaihda kanavaa",    //Finnish
     "",                  //Polish
-    "Cambio cadena",     //Spanish
+    "Cambiar canal",     //Spanish
     "",                  //Greek
     "",                  //Swedish
     "",                  //Romanian
@@ -397,7 +397,7 @@
     "",                          //Norwegian
     "Pystykeskitys",             //Finnish
     "",                          //Polish
-    "",                          //Spanish
+    "OSD alineación horizontal", //Spanish
     "",                          //Greek
     "",                          //Swedish
     "",                          //Romanian
@@ -415,7 +415,7 @@
     "",                          //Norwegian
     "Vaakakeskitys",             //Finnish
     "",                          //Polish
-    "",                          //Spanish
+    "OSD alineación vertical",   //Spanish
     "",                          //Greek
     "",                          //Swedish
     "",                          //Romanian
diff -Naur osdteletext-orig/macros.h osdteletext/macros.h
--- osdteletext-orig/macros.h	1970-01-01 01:00:00.000000000 +0100
+++ osdteletext/macros.h	2008-01-20 12:01:17.000000000 +0100
@@ -0,0 +1,99 @@
+/*
+ *  libzvbi - Useful macros
+ *
+ *  Copyright (C) 2002, 2003, 2004 Michael H. Schimek
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/* $Id: macros.h,v 1.5 2006/03/21 19:01:24 mschimek Exp $ */
+
+#ifndef __ZVBI3_MACROS_H__
+#define __ZVBI3_MACROS_H__
+
+#ifdef __cplusplus
+#  define VBI3_BEGIN_DECLS extern "C" {
+#  define VBI3_END_DECLS }
+#else
+#  define VBI3_BEGIN_DECLS
+#  define VBI3_END_DECLS
+#endif
+
+VBI3_BEGIN_DECLS
+
+#if __GNUC__ >= 4
+#  define _vbi3_sentinel sentinel(0)
+#else
+#  define _vbi3_sentinel
+#  define __restrict__
+#endif
+
+#if (__GNUC__ == 3 && __GNUC_MINOR__ >= 3) || __GNUC__ >= 4
+#  define _vbi3_nonnull(args...) nonnull(args)
+#else
+#  define _vbi3_nonnull(args...)
+#endif
+
+#if __GNUC__ >= 3
+#  define _vbi3_pure pure
+#  define _vbi3_alloc malloc
+#else
+#  define _vbi3_pure
+#  define _vbi3_alloc
+#endif
+
+#if __GNUC__ >= 2
+#  define vbi3_inline static __inline__
+#else
+#  define vbi3_inline static
+#  define __attribute__(args...)
+#endif
+
+/**
+ * @ingroup Basic
+ * @name Boolean type
+ * @{
+ */
+#ifndef TRUE
+#  define TRUE 1
+#endif
+#ifndef FALSE
+#  define FALSE 0
+#endif
+
+typedef int vbi3_bool;
+/** @} */
+
+#ifndef NULL
+#  ifdef __cplusplus
+#    define NULL (0L)
+#  else
+#    define NULL ((void *) 0)
+#  endif
+#endif
+
+/** XXX Document me - for variadic funcs.
+  (this is a pointer not int to take advantage of
+  __attribute__((sentinel))). */
+#define VBI3_END ((void *) 0)
+
+typedef void
+vbi3_lock_fn			(void *			user_data);
+typedef void
+vbi3_unlock_fn			(void *			user_data);
+
+VBI3_END_DECLS
+
+#endif /* __ZVBI3_MACROS_H__ */
diff -Naur osdteletext-orig/Makefile osdteletext/Makefile
--- osdteletext-orig/Makefile	2008-01-12 12:27:50.000000000 +0100
+++ osdteletext/Makefile	2008-01-20 12:01:17.000000000 +0100
@@ -51,7 +51,7 @@
 
 ### The object files (add further files here):
 
-OBJS = $(PLUGIN).o menu.o txtfont.o i18n.o txtrecv.o txtrender.o displaybase.o display.o
+OBJS = $(PLUGIN).o menu.o txtfont.o i18n.o txtrecv.o txtrender.o displaybase.o display.o hamm.o
 
 ### Implicit rules:
 
diff -Naur osdteletext-orig/menu.c osdteletext/menu.c
--- osdteletext-orig/menu.c	2008-01-12 12:27:50.000000000 +0100
+++ osdteletext/menu.c	2008-01-20 12:01:17.000000000 +0100
@@ -577,7 +577,7 @@
    t.Start();
    #endif
 
-   unsigned char cache[40*24+12];
+   unsigned char cache[(40*24)*2+12];
    StorageHandle fd;
    // Take a look if there is a xxx-00 page
    Storage *s=Storage::instance();
@@ -633,7 +633,7 @@
 
    Storage *s=Storage::instance();
    if ((fd=s->openForReading(PageID(channel, currentPage, currentSubPage), false)) ) {
-      uchar cache[960];
+      uchar cache[(40*24)*2];
       s->read(cache, 12, fd); //skip
       s->read(cache, sizeof(cache), fd);
       s->close(fd);
diff -Naur osdteletext-orig/txtfont.c osdteletext/txtfont.c
--- osdteletext-orig/txtfont.c	2008-01-12 12:27:50.000000000 +0100
+++ osdteletext/txtfont.c	2008-01-20 12:01:17.000000000 +0100
@@ -1,4 +1,5 @@
 #include "txtfont.h"
+#include "common.h"
 
 unsigned int TXT_Mask[11]= {
    0x0000,  // ************ ****
@@ -3105,7 +3106,6 @@
 };
    
 
-
 int NationalOptionSubsetG0Default[13]=
     {0x23,0x94,0x80,0   ,0   ,0   ,0x5e,0x5f,0   ,0   ,0   ,0   ,0   };
 
@@ -3136,6 +3136,25 @@
 int NationalOptionSubsetTR[13]=
     {0   ,0   ,0   ,0   ,0x5c,0xd7,0x5d,0   ,0   ,0   ,0x7c,0xcc,0x7d};
 
+int DiacriticalMarkNationalOptionSubsetPT_ES[26*2*16]=
+    {
+	0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,
+	0xf1,0x42,0x43,0x44,0xf2,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0xf6,0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0xc2,0x62,0x63,0x64,0xc9,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0xc8,0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,
+	0xf0,0x42,0x43,0x44,0x90,0x46,0x47,0x48,0xf3,0x4a,0x4b,0x4c,0x4d,0x4e,0xf5,0x50,0x51,0x52,0x53,0x54,0xf7,0x56,0x57,0x58,0x59,0x5a,0xeb,0x62,0x63,0x64,0xec,0x66,0x67,0x68,0xed,0x6a,0x6b,0x6c,0x6d,0x6e,0xee,0x70,0x71,0x72,0x73,0x74,0xef,0x76,0x77,0x78,0x79,0x7a,
+	0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,
+	0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0xe7,0x4f,0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0xe8,0x6f,0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,
+	0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,
+	0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,
+	0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,
+	0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0xf4,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,0x50,0x51,0x52,0x53,0x54,0x5d,0x56,0x57,0x58,0x59,0x5a,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0xd4,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,0x70,0x71,0x72,0x73,0x74,0x9a,0x76,0x77,0x78,0x79,0x7a,
+	0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,
+	0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,
+	0x41,0x42,0xd7,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x61,0x62,0xcc,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,
+	0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,
+	0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,
+	0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,	
+	0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,
+	};
 
 
 inline int NationalOptionSubset(int chr) {
@@ -3180,6 +3199,22 @@
     return res;
 }
 
+int DiacriticalMarkNationalOptionChar (int chr, unsigned char mode) {
+	int result=0;
+	
+	if ( mode <= 16 || mode > 31) return 0;	//No extended char
+   
+	if ( chr >= 0x41 && chr <= 0x5a ) {
+		result = chr - 0x41;
+	}
+	if ( chr >= 0x61 && chr <= 0x7a ) {
+		result = chr - 0x41;
+	}	   
+debug("Caracter extendido : %x -> %x",mode & 0x0f,chr);
+debug("Dibujar %d - %d -> %x",(mode & 0x0f ),result,DiacriticalMarkNationalOptionSubsetPT_ES[((mode & 0x0f )*26*2)+result]);
+	return result;
+	
+}
 
 
 unsigned int* GetFontChar(cTeletextChar c, unsigned int *buffer) {
@@ -3187,10 +3222,15 @@
 
     enumCharsets font=c.GetCharset();
     int chr=c.GetChar();
+	  unsigned char mode = c.GetExtMode();
     unsigned int *bitmap=NULL;
     int i;
     int NationalOption=NationalOptionSubset(chr);
-    
+    int DiacriticalMarkNationalOption=0;
+
+    DiacriticalMarkNationalOption=DiacriticalMarkNationalOptionChar(chr,mode);
+
+
     switch (font) {
     case CHARSET_LATIN_G0:
         if (NationalOption>=0) {
@@ -3232,15 +3272,21 @@
             }
         }           
         break;
-    case CHARSET_LATIN_G0_PT_ES:
-        if (NationalOption>=0) {
-            if (NationalOptionSubsetPT_ES[NationalOption]>0)
-                bitmap=TXT_Font[NationalOptionSubsetPT_ES[NationalOption]-0x20];
-        } else {
-            if (chr>=0x20 && chr<0x80) {
-                bitmap=TXT_Font[chr-0x20];
-            }
-        }           
+    case CHARSET_LATIN_G0_PT_ES:	 
+
+
+		if ( DiacriticalMarkNationalOption > 0 ) {
+        bitmap=TXT_Font[DiacriticalMarkNationalOptionSubsetPT_ES[((mode & 0x0f )*26*2)+DiacriticalMarkNationalOption]-0x20];
+		}else {
+	        if (NationalOption>=0) {
+	            if (NationalOptionSubsetPT_ES[NationalOption]>0)
+	                bitmap=TXT_Font[NationalOptionSubsetPT_ES[NationalOption]-0x20];
+	        } else {
+	            if (chr>=0x20 && chr<0x80) {
+	                bitmap=TXT_Font[chr-0x20];
+	            } 
+	        }           
+		}
         break;
     case CHARSET_LATIN_G0_SV_FI:
         if (NationalOption>=0) {
@@ -3305,13 +3351,14 @@
     case CHARSET_GRAPHICS_G3:
     case CHARSET_INVALID:
         // Totally unsupported
+debug("Font Charset invalid");
         break;
     }
     
     
     
     if (!buffer) {
-        printf("Warning: Undefined char: %x %x\n",font,chr);
+        debug("Warning: Undefined char: %x %x\n",font,chr);
         return NULL;
     }
     
diff -Naur osdteletext-orig/txtrecv.c osdteletext/txtrecv.c
--- osdteletext-orig/txtrecv.c	2008-01-12 12:27:50.000000000 +0100
+++ osdteletext/txtrecv.c	2008-01-20 12:01:17.000000000 +0100
@@ -13,6 +13,9 @@
 #include "txtrecv.h"
 #include "tables.h"
 #include "setup.h"
+#include "common.h"
+#include "txtfont.h"
+#include "hamm.h"
 
 #include <vdr/channels.h>
 #include <vdr/device.h>
@@ -222,7 +225,7 @@
    failedFreeSpace=false;
 }
 
-#define TELETEXT_PAGESIZE 972
+#define TELETEXT_PAGESIZE (12+(24*40)*TXT_CHARSIZE) //12+(24*40*2)
 
 LegacyStorage::LegacyStorage() {
    maxBytes=0;
@@ -490,21 +493,47 @@
   : mag(t_mag), flags(t_flags), lang(t_lang), page(t_page)
 {
    memset(pagebuf,' ',26*40);
+   memset(pagebuf_ext,' ',26*40*TXT_CHARSIZE);
 }
 
 cTelePage::~cTelePage() {
 }
 
-void cTelePage::SetLine(int line, uchar *myptr)
+void cTelePage::SetData(int line,int col, uchar c,uchar mode)
 {
-   memcpy(pagebuf+40*line,myptr,40);
+  int pos = (40*line + col)* TXT_CHARSIZE;
+  
+  pagebuf_ext[pos]=mode;
+  pagebuf_ext[pos+1]=c;
+
+}
+void cTelePage::SetLine(int line, uchar *myptr)
+{  
+  memcpy(pagebuf+40*line,myptr,40);
+
 }
 
 void cTelePage::save()
 {
+   
    Storage *s=Storage::instance();
    unsigned char buf;
    StorageHandle fd;
+
+   //Set extended characters
+   int i,j,pos,pos_ext;
+   for (i=0;   i<24 ; i++) {
+    for (j=0;  j<40 ; j++) {	  
+	  pos = (i*40+j);
+	  pos_ext = pos*TXT_CHARSIZE;	  
+      if (pagebuf_ext[pos_ext] == ' ') {
+        pagebuf_ext[pos_ext+1]= pagebuf[pos];
+      }else {
+	    debug("SetData: pagebuf %x->%x",pagebuf[pos],pagebuf_ext[pos_ext]);		
+	  }
+    }
+   }
+
    if ( (fd=s->openForWriting(page)) ) {
       s->write("VTXV4",5,fd);
       buf=0x01; s->write(&buf,1,fd);
@@ -514,7 +543,7 @@
       buf=lang; s->write(&buf,1,fd);
       buf=0x00; s->write(&buf,1,fd);
       buf=0x00; s->write(&buf,1,fd);
-      s->write(pagebuf,24*40,fd);
+      s->write(pagebuf_ext,24*40*TXT_CHARSIZE,fd);
       s->close(fd);
    }         
 }
@@ -860,16 +889,22 @@
    int hdr,mag,mag8,line;
    uchar *ptr;
    uchar flags,lang;
+   int i = 1;
+   uchar *aptr;   
+   int triplet;
+   uchar address=0;
+   uchar mode=0,data=0;
+   uchar active_row=0;
    
    hdr = unham16 (&TXT_buf[0x8]);
    mag = hdr & 0x07;
    mag8 = mag ?: 8;
    line = (hdr>>3) & 0x1f;
    ptr = &TXT_buf[10];
-   
    switch (line) {
    case 0: 
       {
+
       unsigned char b1, b2, b3, b4;
       int pgno, subno;
       b1 = unham16 (ptr);    
@@ -912,6 +947,21 @@
       if (TxtPage) TxtPage->SetLine((int)line,(uchar *)ptr); 
       break;
       }
+   case 26:{ //Extended characters Level 1.5 - diacritical mark
+      aptr=ptr+1;
+      for ( i = 0 ; i < 13 ; i++) {
+          triplet = vbi3_unham24p (aptr+(i*3));
+          address= triplet & 0x3f;
+          mode= (triplet >> 6) & 0x1f;
+          data= (triplet >>11) & 0x7f;
+          if ( address > 39 && mode == 4) {
+            active_row = address-40;           
+          }
+          if (address <=39 && mode >=16 && mode < 31) {            
+            if (TxtPage) TxtPage->SetData(active_row,address,data,mode);
+          }
+      }
+    }
    /*case 23: 
       {
       if (TxtPage) {
diff -Naur osdteletext-orig/txtrecv.h osdteletext/txtrecv.h
--- osdteletext-orig/txtrecv.h	2008-01-12 12:27:50.000000000 +0100
+++ osdteletext/txtrecv.h	2008-01-20 12:02:16.000000000 +0100
@@ -18,7 +18,7 @@
 
 #include <stdio.h>
 #include <unistd.h>
-
+#include "common.h"
 struct PageID {
    PageID() { page=subPage=0; }
    PageID(tChannelID id, int p, int s) { set(id, p, s); }
@@ -143,12 +143,14 @@
   unsigned char lang;
   PageID page;
   unsigned char pagebuf[27*40];
+  unsigned char pagebuf_ext[27*40*TXT_CHARSIZE]; //diacritical-mark
   char Directory [255];
  public:
   cTelePage(PageID page, uchar flags, uchar lang, int mag);
   ~cTelePage();
   void SetLine(int, uchar*);
   void save();
+  void SetData(int line,int col, uchar c,uchar mode);
  };
 
 class cRingTxtFrames : public cRingBufferFrame {
diff -Naur osdteletext-orig/txtrender.c osdteletext/txtrender.c
--- osdteletext-orig/txtrender.c	2008-01-12 12:27:50.000000000 +0100
+++ osdteletext/txtrender.c	2008-01-20 12:01:17.000000000 +0100
@@ -15,7 +15,7 @@
 
 #include <strings.h>
 #include "txtrender.h"
-
+#include "common.h"
 
 // Font tables
 
@@ -323,13 +323,17 @@
         // Pre-scan for double-height and double-size codes
         for (x=0;x<40;x++) {
             if (y==0 && x<8) x=8;
-            if ((PageCode[x+40*y] & 0x7f)==0x0D || (PageCode[x+40*y] & 0x7f)==0x0F)
+            if ((PageCode[((x+40*y)*2)+1] & 0x7f)==0x0D || (PageCode[((x+40*y)*2)+1] & 0x7f)==0x0F)
                 EmptyNextLine=true;
         }
 
         // Move through line
         for (x=0;x<40;x++) {
-            unsigned char ttc=PageCode[x+40*y] & 0x7f;
+//            debug("Caracter Extendido %x:%x",PageCode[(x+40*y)*2],PageCode[((x+40*y)*2)+1]);            
+			
+            unsigned char ttc=PageCode[((x+40*y)*2)+1] & 0x7f;
+			      unsigned char mode=PageCode[(x+40*y)*2]  ;
+            
             // skip parity check
 
             if (y==0 && x<8) continue;
@@ -389,14 +393,16 @@
             if (ttc<0x20) {
                 // Spacing code, display space or hold mosaic
                 if (HoldMosaics) {
+
                     c2.SetChar(HoldMosaicChar);
                     c2.SetCharset(HoldMosaicCharset);
                 } else {
+
                     c2.SetChar(' ');
                 }
             } else {
-                // Character code               
-                c2.SetChar(ttc);
+                // Character code  
+                c2.SetChar(ttc,mode);
                 if (GraphicCharset) {
                     if (ttc&0x20) {
                         // real graphics code, remember for HoldMosaics
diff -Naur osdteletext-orig/txtrender.h osdteletext/txtrender.h
--- osdteletext-orig/txtrender.h	2008-01-12 12:27:50.000000000 +0100
+++ osdteletext/txtrender.h	2008-01-20 12:01:17.000000000 +0100
@@ -17,6 +17,7 @@
 #define OSDTELETEXT_TXTRENDER_H_
 
 #include <stdio.h>
+#include "common.h"
 
 
 // Teletext character sets
@@ -111,6 +112,7 @@
     
 protected:
     unsigned int c;
+  	unsigned char m;
 
     static const unsigned int CHAR             = 0x000000FF;
     // character code
@@ -133,10 +135,10 @@
     static const unsigned int BLINK            = 0x80000000;
     // blinking character
 
-    cTeletextChar(unsigned int cc) { c=cc; }
+    cTeletextChar(unsigned int cc,unsigned char mm=' ') { c=cc; m=mm; }
 
 public:
-    cTeletextChar() { c=0; }
+    cTeletextChar() { c=0; m=' ';}
     
     // inline helper functions:
     // For each parameter encoded into the 32-bit int, there is
@@ -145,8 +147,14 @@
     
     inline unsigned char GetChar() 
         { return c&CHAR; }
-    inline void SetChar(unsigned char chr)
-        { c=(c&~CHAR)|chr; }
+    inline void SetChar(unsigned char chr,unsigned char mode=' ')
+        { c=(c&~CHAR)|chr;
+		     m=mode;         
+        }
+	inline unsigned char GetExtMode() 
+        {        
+        return m; 
+        }	  
     inline cTeletextChar ToChar(unsigned char chr)
         { return cTeletextChar((c&~CHAR)|chr); }
         
@@ -155,66 +163,66 @@
     inline void SetCharset(enumCharsets charset) 
         { c=(c&~CHARSET)|charset; }
     inline cTeletextChar ToCharset(enumCharsets charset) 
-        { return cTeletextChar((c&~CHARSET)|charset); }
+        { return cTeletextChar((c&~CHARSET)|charset,m); }
     
     inline enumTeletextColor GetFGColor() 
         { return (enumTeletextColor)((c&FGCOLOR) >> LowestSet32Bit(FGCOLOR)); }
     inline void SetFGColor(enumTeletextColor fgc) 
         { c=(c&~FGCOLOR) | (fgc << LowestSet32Bit(FGCOLOR)); }
     inline cTeletextChar ToFGColor(enumTeletextColor fgc) 
-        { return cTeletextChar((c&~FGCOLOR) | (fgc << LowestSet32Bit(FGCOLOR))); }
+        { return cTeletextChar((c&~FGCOLOR) | (fgc << LowestSet32Bit(FGCOLOR)),m); }
     
     inline enumTeletextColor GetBGColor() 
         { return (enumTeletextColor)((c&BGCOLOR) >> LowestSet32Bit(BGCOLOR)); }
     inline void SetBGColor(enumTeletextColor bgc) 
         { c=(c&~BGCOLOR) | (bgc << LowestSet32Bit(BGCOLOR)); }
     inline cTeletextChar ToBGColor(enumTeletextColor bgc) 
-        { return cTeletextChar((c&~BGCOLOR) | (bgc << LowestSet32Bit(BGCOLOR))); }
+        { return cTeletextChar((c&~BGCOLOR) | (bgc << LowestSet32Bit(BGCOLOR)),m); }
     
     inline bool GetBoxedOut() 
         { return c&BOXOUT; }
     inline void SetBoxedOut(bool BoxedOut) 
         { c=(BoxedOut)?(c|BOXOUT):(c&~BOXOUT); }
     inline cTeletextChar ToBoxedOut(bool BoxedOut) 
-        { return cTeletextChar((BoxedOut)?(c|BOXOUT):(c&~BOXOUT)); }
+        { return cTeletextChar((BoxedOut)?(c|BOXOUT):(c&~BOXOUT),m); }
     
     inline bool GetDirty() 
         { return c&DIRTY; }
     inline void SetDirty(bool Dirty) 
         { c=(Dirty)?(c|DIRTY):(c&~DIRTY); }
     inline cTeletextChar ToDirty(bool Dirty) 
-        { return cTeletextChar((Dirty)?(c|DIRTY):(c&~DIRTY)); }
+        { return cTeletextChar((Dirty)?(c|DIRTY):(c&~DIRTY),m); }
     
     inline enumDblHeight GetDblHeight() 
         { return (enumDblHeight)(c&DBLHEIGHT); }
     inline void SetDblHeight(enumDblHeight dh) 
         { c=(c&~(DBLHEIGHT)) | dh; }
     inline cTeletextChar ToDblHeight(enumDblHeight dh) 
-        { return cTeletextChar((c&~(DBLHEIGHT)) | dh); }
+        { return cTeletextChar((c&~(DBLHEIGHT)) | dh,m); }
     
     inline enumDblWidth GetDblWidth() 
         { return (enumDblWidth)(c&DBLWIDTH); }
     inline void SetDblWidth(enumDblWidth dw) 
         { c=(c&~(DBLWIDTH)) | dw; }
     inline cTeletextChar ToDblWidth(enumDblWidth dw) 
-        { return cTeletextChar((c&~(DBLWIDTH)) | dw); }
+        { return cTeletextChar((c&~(DBLWIDTH)) | dw,m); }
     
     inline bool GetConceal() 
         { return c&CONCEAL; }
     inline void SetConceal(bool Conceal) 
         { c=(Conceal)?(c|CONCEAL):(c&~CONCEAL); }
     inline cTeletextChar ToConceal(bool Conceal) 
-        { return cTeletextChar((Conceal)?(c|CONCEAL):(c&~CONCEAL)); }
+        { return cTeletextChar((Conceal)?(c|CONCEAL):(c&~CONCEAL),m); }
     
     inline bool GetBlink() 
         { return c&BLINK; }
     inline void SetBlink(bool Blink) 
         { c=(Blink)?(c|BLINK):(c&~BLINK); }
     inline cTeletextChar ToBlink(bool Blink) 
-        { return cTeletextChar((Blink)?(c|BLINK):(c&~BLINK)); }
+        { return cTeletextChar((Blink)?(c|BLINK):(c&~BLINK),m); }
         
-    bool operator==(cTeletextChar &chr) { return c==chr.c; }
-    bool operator!=(cTeletextChar &chr) { return c!=chr.c; }
+    bool operator==(cTeletextChar &chr) { return c==chr.c && m==chr.m; }
+    bool operator!=(cTeletextChar &chr) { return c!=chr.c || m!=chr.m; }
 };
 
 
