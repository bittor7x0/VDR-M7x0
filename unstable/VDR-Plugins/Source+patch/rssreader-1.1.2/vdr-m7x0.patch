diff -Naur -x .svn rssreader-1.1.2-orig/compatibility.c rssreader/compatibility.c
--- rssreader-1.1.2-orig/compatibility.c	1970-01-01 01:00:00.000000000 +0100
+++ rssreader/compatibility.c	2009-02-02 17:42:19.000000000 +0100
@@ -0,0 +1,259 @@
+#include "compatibility.h"
+
+#if VDRVERSNUM < 10500
+
+// --- UTF-8 support ---------------------------------------------------------
+
+static uint SystemToUtf8[128] = { 0 };
+
+
+int Utf8CharLen(const char *s)
+{
+  if (cCharSetConv::SystemCharacterTable())
+     return 1;
+#define MT(s, m, v) ((*(s) & (m)) == (v)) // Mask Test
+  if (MT(s, 0xE0, 0xC0) && MT(s + 1, 0xC0, 0x80))
+     return 2;
+  if (MT(s, 0xF0, 0xE0) && MT(s + 1, 0xC0, 0x80) && MT(s + 2, 0xC0, 0x80))
+     return 3;
+  if (MT(s, 0xF8, 0xF0) && MT(s + 1, 0xC0, 0x80) && MT(s + 2, 0xC0, 0x80) && MT(s + 3, 0xC0, 0x80))
+     return 4;
+  return 1;
+}
+
+uint Utf8CharGet(const char *s, int Length)
+{
+  if (cCharSetConv::SystemCharacterTable())
+     return (uchar)*s < 128 ? *s : SystemToUtf8[(uchar)*s - 128];
+  if (!Length)
+     Length = Utf8CharLen(s);
+  switch (Length) {
+    case 2: return ((*s & 0x1F) << 6) |  (*(s + 1) & 0x3F);
+    case 3: return ((*s & 0x0F) << 4) | ((*(s + 1) & 0x3F) << 6) |  (*(s + 2) & 0x3F);
+    case 4: return ((*s & 0x07) << 2) | ((*(s + 1) & 0x3F) << 4) | ((*(s + 2) & 0x3F) << 6) | (*(s + 3) & 0x3F);
+    }
+  return *s;
+}
+
+int Utf8CharSet(uint c, char *s)
+{
+  if (c < 0x80 || cCharSetConv::SystemCharacterTable()) {
+     if (s)
+        *s = c;
+     return 1;
+     }
+  if (c < 0x800) {
+     if (s) {
+        *s++ = ((c >> 6) & 0x1F) | 0xC0;
+        *s   = (c & 0x3F) | 0x80;
+        }
+     return 2;
+     }
+  if (c < 0x10000) {
+     if (s) {
+        *s++ = ((c >> 12) & 0x0F) | 0xE0;
+        *s++ = ((c >>  6) & 0x3F) | 0x80;
+        *s   = (c & 0x3F) | 0x80;
+        }
+     return 3;
+     }
+  if (c < 0x110000) {
+     if (s) {
+        *s++ = ((c >> 18) & 0x07) | 0xF0;
+        *s++ = ((c >> 12) & 0x3F) | 0x80;
+        *s++ = ((c >>  6) & 0x3F) | 0x80;
+        *s   = (c & 0x3F) | 0x80;
+        }
+     return 4;
+     }
+  return 0; // can't convert to UTF-8
+}
+
+int Utf8SymChars(const char *s, int Symbols)
+{
+  if (cCharSetConv::SystemCharacterTable())
+     return Symbols;
+  int n = 0;
+  while (*s && Symbols--) {
+        int sl = Utf8CharLen(s);
+        s += sl;
+        n += sl;
+        }
+  return n;
+}
+
+int Utf8StrLen(const char *s)
+{
+  if (cCharSetConv::SystemCharacterTable())
+     return strlen(s);
+  int n = 0;
+  while (*s) {
+        s += Utf8CharLen(s);
+        n++;
+        }
+  return n;
+}
+
+char *Utf8Strn0Cpy(char *Dest, const char *Src, int n)
+{
+
+  if (cCharSetConv::SystemCharacterTable()!=NULL)
+     return strn0cpy(Dest, Src, n);
+
+  char *d = Dest;
+  while (*Src) {
+        int sl = Utf8CharLen(Src);
+        n -= sl;
+        if (n > 0) {
+           while (sl--)
+                 *d++ = *Src++;
+           }
+        else
+           break;
+        }
+  *d = 0;
+  return Dest;
+}
+
+int Utf8ToArray(const char *s, uint *a, int Size)
+{
+  int n = 0;
+  while (*s && --Size > 0) {
+        if (cCharSetConv::SystemCharacterTable())
+           *a++ = (uchar)(*s++);
+        else {
+           int sl = Utf8CharLen(s);
+           *a++ = Utf8CharGet(s, sl);
+           s += sl;
+           }
+        n++;
+        }
+  if (Size > 0)
+     *a = 0;
+  return n;
+}
+
+int Utf8FromArray(const uint *a, char *s, int Size, int Max)
+{
+  int NumChars = 0;
+  int NumSyms = 0;
+  while (*a && NumChars < Size) {
+        if (Max >= 0 && NumSyms++ >= Max)
+           break;
+        if (cCharSetConv::SystemCharacterTable()) {
+           *s++ = *a++;
+           NumChars++;
+           }
+        else {
+           int sl = Utf8CharSet(*a);
+           if (NumChars + sl <= Size) {
+              Utf8CharSet(*a, s);
+              a++;
+              s += sl;
+              NumChars += sl;
+              }
+           else
+              break;
+           }
+        }
+  if (NumChars < Size)
+     *s = 0;
+  return NumChars;
+}
+
+// --- cCharSetConv ----------------------------------------------------------
+
+char *cCharSetConv::systemCharacterTable = NULL;
+
+cCharSetConv::cCharSetConv(const char *FromCode, const char *ToCode)
+{
+
+  if (!FromCode)
+     FromCode = systemCharacterTable;
+
+  if (!ToCode)
+     ToCode = "UTF-8";
+
+  cd = (FromCode && ToCode) ? iconv_open(ToCode, FromCode) : (iconv_t)-1;
+
+  result = NULL;
+  length = 0;
+}
+
+cCharSetConv::~cCharSetConv()
+{
+  free(result);
+  iconv_close(cd);
+}
+
+void cCharSetConv::SetSystemCharacterTable(const char *CharacterTable)
+{
+  free(systemCharacterTable);
+  systemCharacterTable = NULL;
+  if (!strcasestr(CharacterTable, "UTF-8")) {
+     // Set up a map for the character values 128...255:
+     char buf[129];
+     for (int i = 0; i < 128; i++)
+         buf[i] = i + 128;
+     buf[128] = 0;
+     cCharSetConv csc(CharacterTable);
+     const char *s = csc.Convert(buf);
+     int i = 0;
+     while (*s) {
+           int sl = Utf8CharLen(s);
+           SystemToUtf8[i] = Utf8CharGet(s, sl);
+           s += sl;
+           i++;
+           }
+     systemCharacterTable = strdup(CharacterTable);
+     }
+}
+
+const char *cCharSetConv::Convert(const char *From, char *To, size_t ToLength)
+{
+  if (cd != (iconv_t)-1 && From && *From) {
+     char *FromPtr = (char *)From;
+     size_t FromLength = strlen(From);
+     char *ToPtr = To;
+     if (!ToPtr) {
+        length = max(length, FromLength * 2); // some reserve to avoid later reallocations
+        result = (char *)realloc(result, length);
+        ToPtr = result;
+        ToLength = length;
+        }
+     else if (!ToLength)
+        return From; // can't convert into a zero sized buffer
+     ToLength--; // save space for terminating 0
+     char *Converted = ToPtr;
+     while (FromLength > 0) {
+           if (iconv(cd, &FromPtr, &FromLength, &ToPtr, &ToLength) == size_t(-1)) {
+              if (errno == E2BIG || errno == EILSEQ && ToLength < 1) {
+                 if (To)
+                    break; // caller provided a fixed size buffer, but it was too small
+                 // The result buffer is too small, so increase it:
+                 size_t d = ToPtr - result;
+                 size_t r = length / 2;
+                 length += r;
+                 Converted = result = (char *)realloc(result, length);
+                 ToLength += r;
+                 ToPtr = result + d;
+                 }
+              if (errno == EILSEQ) {
+                 // A character can't be converted, so mark it with '?' and proceed:
+                 FromPtr++;
+                 FromLength--;
+                 *ToPtr++ = '?';
+                 ToLength--;
+                 }
+              else if (errno != E2BIG)
+                 return From; // unknown error, return original string
+              }
+           }
+     *ToPtr = 0;
+     return Converted;
+     }
+  return From;
+}
+
+#endif // VDRVERSNUM < 10500
+
diff -Naur -x .svn rssreader-1.1.2-orig/compatibility.h rssreader/compatibility.h
--- rssreader-1.1.2-orig/compatibility.h	1970-01-01 01:00:00.000000000 +0100
+++ rssreader/compatibility.h	2009-02-02 17:42:19.000000000 +0100
@@ -0,0 +1,98 @@
+#ifndef __rssreader_compatibility_h__
+#define __rssreader_compatibility_h__
+
+
+
+#if VDRVERSNUM < 10500
+
+#include "common.h"
+#include <vdr/tools.h>
+#include <stdlib.h>
+#include <iconv.h>
+
+#define uint unsigned int
+#define uchar unsigned char
+
+// When handling strings that might contain UTF-8 characters, it may be necessary
+// to process a "symbol" that consists of several actual character bytes. The
+// following functions allow transparently accessing a "char *" string without
+// having to worry about what character set is actually used.
+
+int Utf8CharLen(const char *s);
+    ///< Returns the number of character bytes at the beginning of the given
+    ///< string that form a UTF-8 symbol.
+uint Utf8CharGet(const char *s, int Length = 0);
+    ///< Returns the UTF-8 symbol at the beginning of the given string.
+    ///< Length can be given from a previous call to Utf8CharLen() to avoid calculating
+    ///< it again. If no Length is given, Utf8CharLen() will be called.
+int Utf8CharSet(uint c, char *s = NULL);
+    ///< Converts the given UTF-8 symbol to a sequence of character bytes and copies
+    ///< them to the given string. Returns the number of bytes written. If no string
+    ///< is given, only the number of bytes is returned and nothing is copied.
+int Utf8SymChars(const char *s, int Symbols);
+    ///< Returns the number of character bytes at the beginning of the given
+    ///< string that form at most the given number of UTF-8 symbols.
+int Utf8StrLen(const char *s);
+    ///< Returns the number of UTF-8 symbols formed by the given string of
+    ///< character bytes.
+char *Utf8Strn0Cpy(char *Dest, const char *Src, int n);
+    ///< Copies at most n character bytes from Src to Dst, making sure that the
+    ///< resulting copy ends with a complete UTF-8 symbol. The copy is guaranteed
+    ///< to be zero terminated.
+    ///< Returns a pointer to Dest.
+int Utf8ToArray(const char *s, uint *a, int Size);
+    ///< Converts the given character bytes (including the terminating 0) into an
+    ///< array of UTF-8 symbols of the given Size. Returns the number of symbols
+    ///< in the array (without the terminating 0).
+int Utf8FromArray(const uint *a, char *s, int Size, int Max = -1);
+    ///< Converts the given array of UTF-8 symbols (including the terminating 0)
+    ///< into a sequence of character bytes of at most Size length. Returns the
+    ///< number of character bytes written (without the terminating 0).
+    ///< If Max is given, only that many symbols will be converted.
+    ///< The resulting string is always zero-terminated if Size is big enough.
+
+// When allocating buffer space, make sure we reserve enough space to hold
+// a string in UTF-8 representation:
+
+#define Utf8BufSize(s) ((s) * 4)
+
+// The following macros automatically use the correct versions of the character
+// class functions:
+
+#define Utf8to(conv, c) (cCharSetConv::SystemCharacterTable() ? to##conv(c) : tow##conv(c))
+#define Utf8is(ccls, c) (cCharSetConv::SystemCharacterTable() ? is##ccls(c) : isw##ccls(c))
+
+class cCharSetConv {
+private:
+  iconv_t cd;
+  char *result;
+  size_t length;
+  static char *systemCharacterTable;
+public:
+  cCharSetConv(const char *FromCode = NULL, const char *ToCode = NULL);
+     ///< Sets up a character set converter to convert from FromCode to ToCode.
+     ///< If FromCode is NULL, the previously set systemCharacterTable is used.
+     ///< If ToCode is NULL, "UTF-8" is used.
+  ~cCharSetConv();
+  const char *Convert(const char *From, char *To = NULL, size_t ToLength = 0);
+     ///< Converts the given Text from FromCode to ToCode (as set in the cosntructor).
+     ///< If To is given, it is used to copy at most ToLength bytes of the result
+     ///< (including the terminating 0) into that buffer. If To is not given,
+     ///< the result is copied into a dynamically allocated buffer and is valid as
+     ///< long as this object lives, or until the next call to Convert(). The
+     ///< return value always points to the result if the conversion was successful
+     ///< (even if a fixed size To buffer was given and the result didn't fit into
+     ///< it). If the string could not be converted, the result points to the
+     ///< original From string.
+  static const char *SystemCharacterTable(void) { return systemCharacterTable; }
+  static void SetSystemCharacterTable(const char *CharacterTable);
+  };
+
+
+
+
+#endif // VDRVERSNUM < 10500
+
+#endif // __rssreader_compatibility_h__
+
+
diff -Naur -x .svn rssreader-1.1.2-orig/ezxml.c rssreader/ezxml.c
--- rssreader-1.1.2-orig/ezxml.c	1970-01-01 01:00:00.000000000 +0100
+++ rssreader/ezxml.c	2009-02-02 17:45:10.000000000 +0100
@@ -0,0 +1,1004 @@
+/* ezxml.c
+ *
+ * Copyright 2004-2006 Aaron Voisine <aaron@voisine.org>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdarg.h>
+#include <string.h>
+#include <ctype.h>
+#include <unistd.h>
+#include <sys/types.h>
+
+#include <sys/stat.h>
+#include "ezxml.h"
+
+#define EZXML_WS   "\t\r\n "  // whitespace
+#define EZXML_ERRL 128        // maximum error string length
+
+typedef struct ezxml_root *ezxml_root_t;
+struct ezxml_root {       // additional data for the root tag
+    struct ezxml xml;     // is a super-struct built on top of ezxml struct
+    ezxml_t cur;          // current xml tree insertion point
+    char *m;              // original xml string
+    size_t len;           // length of allocated memory for mmap, -1 for malloc
+    char *u;              // UTF-8 conversion of string if original was UTF-16
+    char *s;              // start of work area
+    char *e;              // end of work area
+    char **ent;           // general entities (ampersand sequences)
+    char ***attr;         // default attributes
+    char ***pi;           // processing instructions
+    short standalone;     // non-zero if <?xml standalone="yes"?>
+    char err[EZXML_ERRL]; // error string
+};
+
+char *EZXML_NIL[] = { NULL }; // empty, null terminated array of strings
+
+// returns the first child tag with the given name or NULL if not found
+ezxml_t ezxml_child(ezxml_t xml, const char *name)
+{
+    xml = (xml) ? xml->child : NULL;
+    while (xml && strcmp(name, xml->name)) xml = xml->sibling;
+    return xml;
+}
+
+// returns the Nth tag with the same name in the same subsection or NULL if not
+// found
+ezxml_t ezxml_idx(ezxml_t xml, int idx)
+{
+    for (; xml && idx; idx--) xml = xml->next;
+    return xml;
+}
+
+// returns the value of the requested tag attribute or NULL if not found
+const char *ezxml_attr(ezxml_t xml, const char *attr)
+{
+    int i = 0, j = 1;
+    ezxml_root_t root = (ezxml_root_t)xml;
+
+    if (! xml || ! xml->attr) return NULL;
+    while (xml->attr[i] && strcmp(attr, xml->attr[i])) i += 2;
+    if (xml->attr[i]) return xml->attr[i + 1]; // found attribute
+
+    while (root->xml.parent) root = (ezxml_root_t)root->xml.parent; // root tag
+    for (i = 0; root->attr[i] && strcmp(xml->name, root->attr[i][0]); i++);
+    if (! root->attr[i]) return NULL; // no matching default attributes
+    while (root->attr[i][j] && strcmp(attr, root->attr[i][j])) j += 3;
+    return (root->attr[i][j]) ? root->attr[i][j + 1] : NULL; // found default
+}
+
+// same as ezxml_get but takes an already initialized va_list
+ezxml_t ezxml_vget(ezxml_t xml, va_list ap)
+{
+    char *name = va_arg(ap, char *);
+    int idx = -1;
+
+    if (name && *name) {
+        idx = va_arg(ap, int);    
+        xml = ezxml_child(xml, name);
+    }
+    return (idx < 0) ? xml : ezxml_vget(ezxml_idx(xml, idx), ap);
+}
+
+// Traverses the xml tree to retrieve a specific subtag. Takes a variable
+// length list of tag names and indexes. The argument list must be terminated
+// by either an index of -1 or an empty string tag name. Example: 
+// title = ezxml_get(library, "shelf", 0, "book", 2, "title", -1);
+// This retrieves the title of the 3rd book on the 1st shelf of library.
+// Returns NULL if not found.
+ezxml_t ezxml_get(ezxml_t xml, ...)
+{
+    va_list ap;
+    ezxml_t r;
+
+    va_start(ap, xml);
+    r = ezxml_vget(xml, ap);
+    va_end(ap);
+    return r;
+}
+
+// returns a null terminated array of processing instructions for the given
+// target
+const char **ezxml_pi(ezxml_t xml, const char *target)
+{
+    ezxml_root_t root = (ezxml_root_t)xml;
+    int i = 0;
+
+    if (! root) return (const char **)EZXML_NIL;
+    while (root->xml.parent) root = (ezxml_root_t)root->xml.parent; // root tag
+    while (root->pi[i] && strcmp(target, root->pi[i][0])) i++; // find target
+    return (const char **)((root->pi[i]) ? root->pi[i] + 1 : EZXML_NIL);
+}
+
+// set an error string and return root
+ezxml_t ezxml_err(ezxml_root_t root, char *s, const char *err, ...)
+{
+    va_list ap;
+    int line = 1;
+    char *t, fmt[EZXML_ERRL];
+    
+    for (t = root->s; t < s; t++) if (*t == '\n') line++;
+    snprintf(fmt, EZXML_ERRL, "[error near line %d]: %s", line, err);
+
+    va_start(ap, err);
+    vsnprintf(root->err, EZXML_ERRL, fmt, ap);
+    va_end(ap);
+
+    return &root->xml;
+}
+
+// Recursively decodes entity and character references and normalizes new lines
+// ent is a null terminated array of alternating entity names and values. set t
+// to '&' for general entity decoding, '%' for parameter entity decoding, 'c'
+// for cdata sections, ' ' for attribute normalization, or '*' for non-cdata
+// attribute normalization. Returns s, or if the decoded string is longer than
+// s, returns a malloced string that must be freed.
+char *ezxml_decode(char *s, char **ent, char t)
+{
+	return s;
+	
+	/* JM comentado porque convierte a utf algunas entidades html, en el plugin rssreader
+    char *e, *r = s, *m = s;
+    long b, c, d, l;
+
+    for (; *s; s++) { // normalize line endings
+        while (*s == '\r') {
+            *(s++) = '\n';
+            if (*s == '\n') memmove(s, (s + 1), strlen(s));
+        }
+    }
+    
+    for (s = r; ; ) {
+        while (*s && *s != '&' && (*s != '%' || t != '%') && !isspace(*s)) s++;
+
+        if (! *s) break;
+        else if (t != 'c' && ! strncmp(s, "&#", 2)) { // character reference
+            if (s[2] == 'x') c = strtol(s + 3, &e, 16); // base 16
+            else c = strtol(s + 2, &e, 10); // base 10
+            if (! c || *e != ';') { s++; continue; } // not a character ref
+
+            if (c < 0x80) *(s++) = c; // US-ASCII subset
+            else { // multi-byte UTF-8 sequence
+                for (b = 0, d = c; d; d /= 2) b++; // number of bits in c
+                b = (b - 2) / 5; // number of bytes in payload
+                *(s++) = (0xFF << (7 - b)) | (c >> (6 * b)); // head
+                while (b) *(s++) = 0x80 | ((c >> (6 * --b)) & 0x3F); // payload
+            }
+
+            memmove(s, strchr(s, ';') + 1, strlen(strchr(s, ';')));
+        }
+        else if ((*s == '&' && (t == '&' || t == ' ' || t == '*')) ||
+                 (*s == '%' && t == '%')) { // entity reference
+            for (b = 0; ent[b] && strncmp(s + 1, ent[b], strlen(ent[b]));
+                 b += 2); // find entity in entity list
+
+            if (ent[b++]) { // found a match
+                if ((c = strlen(ent[b])) - 1 > (e = strchr(s, ';')) - s) {
+                    l = (d = (s - r)) + c + strlen(e); // new length
+                    r = (r == m) ? strcpy((char*)malloc(l), r) : (char*)realloc(r, l);
+                    e = strchr((s = r + d), ';'); // fix up pointers
+                }
+
+                memmove(s + c, e + 1, strlen(e)); // shift rest of string
+                strncpy(s, ent[b], c); // copy in replacement text
+            }
+            else s++; // not a known entity
+        }
+        else if ((t == ' ' || t == '*') && isspace(*s)) *(s++) = ' ';
+        else s++; // no decoding needed
+    }
+
+    if (t == '*') { // normalize spaces for non-cdata attributes
+        for (s = r; *s; s++) {
+            if ((l = strspn(s, " "))) memmove(s, s + l, strlen(s + l) + 1);
+            while (*s && *s != ' ') s++;
+        }
+        if (--s >= r && *s == ' ') *s = '\0'; // trim any trailing space
+    }
+    return r;
+    */
+}
+
+// called when parser finds start of new tag
+void ezxml_open_tag(ezxml_root_t root, char *name, char **attr)
+{
+    ezxml_t xml = root->cur;
+    
+    if (xml->name) xml = ezxml_add_child(xml, name, strlen(xml->txt));
+    else xml->name = name; // first open tag
+
+    xml->attr = attr;
+    root->cur = xml; // update tag insertion point
+}
+
+// called when parser finds character content between open and closing tag
+void ezxml_char_content(ezxml_root_t root, char *s, size_t len, char t)
+{
+    ezxml_t xml = root->cur;
+    char *m = s;
+    size_t l;
+
+    if (! xml || ! xml->name || ! len) return; // sanity check
+
+    s[len] = '\0'; // null terminate text (calling functions anticipate this)
+    len = strlen(s = ezxml_decode(s, root->ent, t)) + 1;
+
+    if (! *(xml->txt)) xml->txt = s; // initial character content
+    else { // allocate our own memory and make a copy
+        xml->txt = (xml->flags & EZXML_TXTM) // allocate some space
+                   ? (char*)realloc(xml->txt, (l = strlen(xml->txt)) + len)
+                   : strcpy((char*)malloc((l = strlen(xml->txt)) + len), xml->txt);
+        strcpy(xml->txt + l, s); // add new char content
+        if (s != m) free(s); // free s if it was malloced by ezxml_decode()
+    }
+
+    if (xml->txt != m) ezxml_set_flag(xml, EZXML_TXTM);
+}
+
+// called when parser finds closing tag
+ezxml_t ezxml_close_tag(ezxml_root_t root, char *name, char *s)
+{
+    if (! root->cur || ! root->cur->name || strcmp(name, root->cur->name))
+        return ezxml_err(root, s, "unexpected closing tag </%s>", name);
+
+    root->cur = root->cur->parent;
+    return NULL;
+}
+
+// checks for circular entity references, returns non-zero if no circular
+// references are found, zero otherwise
+int ezxml_ent_ok(char *name, char *s, char **ent)
+{
+    int i;
+
+    for (; ; s++) {
+        while (*s && *s != '&') s++; // find next entity reference
+        if (! *s) return 1;
+        if (! strncmp(s + 1, name, strlen(name))) return 0; // circular ref.
+        for (i = 0; ent[i] && strncmp(ent[i], s + 1, strlen(ent[i])); i += 2);
+        if (ent[i] && ! ezxml_ent_ok(name, ent[i + 1], ent)) return 0;
+    }
+}
+
+// called when the parser finds a processing instruction
+void ezxml_proc_inst(ezxml_root_t root, char *s, size_t len)
+{
+    int i = 0, j = 1;
+    char *target = s;
+
+    s[len] = '\0'; // null terminate instruction
+    if (*(s += strcspn(s, EZXML_WS))) {
+        *s = '\0'; // null terminate target
+        s += strspn(s + 1, EZXML_WS) + 1; // skip whitespace after target
+    }
+
+    if (! strcmp(target, "xml")) { // <?xml ... ?>
+        if ((s = strstr(s, "standalone")) && ! strncmp(s + strspn(s + 10,
+            EZXML_WS "='\"") + 10, "yes", 3)) root->standalone = 1;
+        return;
+    }
+
+    if (! root->pi[0]) *(root->pi = (char***)malloc(sizeof(char **))) = NULL; //first pi
+
+    while (root->pi[i] && strcmp(target, root->pi[i][0])) i++; // find target
+    if (! root->pi[i]) { // new target
+        root->pi = (char***)realloc(root->pi, sizeof(char **) * (i + 2));
+        root->pi[i] = (char**)malloc(sizeof(char *) * 3);
+        root->pi[i][0] = target;
+        root->pi[i][1] = (char *)(root->pi[i + 1] = NULL); // terminate pi list
+        root->pi[i][2] = strdup(""); // empty document position list
+    }
+
+    while (root->pi[i][j]) j++; // find end of instruction list for this target
+    root->pi[i] = (char**)realloc(root->pi[i], sizeof(char *) * (j + 3));
+    root->pi[i][j + 2] = (char*)realloc(root->pi[i][j + 1], j + 1);
+    strcpy(root->pi[i][j + 2] + j - 1, (root->xml.name) ? ">" : "<");
+    root->pi[i][j + 1] = NULL; // null terminate pi list for this target
+    root->pi[i][j] = s; // set instruction
+}
+
+// called when the parser finds an internal doctype subset
+short ezxml_internal_dtd(ezxml_root_t root, char *s, size_t len)
+{
+    char q, *c, *t, *n = NULL, *v, **ent, **pe;
+    int i, j;
+    
+    pe = (char**)memcpy(malloc(sizeof(EZXML_NIL)), EZXML_NIL, sizeof(EZXML_NIL));
+
+    for (s[len] = '\0'; s; ) {
+        while (*s && *s != '<' && *s != '%') s++; // find next declaration
+
+        if (! *s) break;
+        else if (! strncmp(s, "<!ENTITY", 8)) { // parse entity definitions
+            c = s += strspn(s + 8, EZXML_WS) + 8; // skip white space separator
+            n = s + strspn(s, EZXML_WS "%"); // find name
+            *(s = n + strcspn(n, EZXML_WS)) = ';'; // append ; to name
+
+            v = s + strspn(s + 1, EZXML_WS) + 1; // find value
+            if ((q = *(v++)) != '"' && q != '\'') { // skip externals
+                s = strchr(s, '>');
+                continue;
+            }
+
+            for (i = 0, ent = (*c == '%') ? pe : root->ent; ent[i]; i++);
+            ent = (char**)realloc(ent, (i + 3) * sizeof(char *)); // space for next ent
+            if (*c == '%') pe = ent;
+            else root->ent = ent;
+
+            *(++s) = '\0'; // null terminate name
+            if ((s = strchr(v, q))) *(s++) = '\0'; // null terminate value
+            ent[i + 1] = ezxml_decode(v, pe, '%'); // set value
+            ent[i + 2] = NULL; // null terminate entity list
+            if (! ezxml_ent_ok(n, ent[i + 1], ent)) { // circular reference
+                if (ent[i + 1] != v) free(ent[i + 1]);
+                ezxml_err(root, v, "circular entity declaration &%s", n);
+                break;
+            }
+            else ent[i] = n; // set entity name
+        }
+        else if (! strncmp(s, "<!ATTLIST", 9)) { // parse default attributes
+            t = s + strspn(s + 9, EZXML_WS) + 9; // skip whitespace separator
+            if (! *t) { ezxml_err(root, t, "unclosed <!ATTLIST"); break; }
+            if (*(s = t + strcspn(t, EZXML_WS ">")) == '>') continue;
+            else *s = '\0'; // null terminate tag name
+            for (i = 0; root->attr[i] && strcmp(n, root->attr[i][0]); i++);
+
+            while (*(n = ++s + strspn(s, EZXML_WS)) && *n != '>') {
+                if (*(s = n + strcspn(n, EZXML_WS))) *s = '\0'; // attr name
+                else { ezxml_err(root, t, "malformed <!ATTLIST"); break; }
+
+                s += strspn(s + 1, EZXML_WS) + 1; // find next token
+                c = (strncmp(s, "CDATA", 5)) ? (char*)"*" : (char*)" "; // is it cdata?
+                if (! strncmp(s, "NOTATION", 8))
+                    s += strspn(s + 8, EZXML_WS) + 8;
+                s = (*s == '(') ? strchr(s, ')') : s + strcspn(s, EZXML_WS);
+                if (! s) { ezxml_err(root, t, "malformed <!ATTLIST"); break; }
+
+                s += strspn(s, EZXML_WS ")"); // skip white space separator
+                if (! strncmp(s, "#FIXED", 6))
+                    s += strspn(s + 6, EZXML_WS) + 6;
+                if (*s == '#') { // no default value
+                    s += strcspn(s, EZXML_WS ">") - 1;
+                    if (*c == ' ') continue; // cdata is default, nothing to do
+                    v = NULL;
+                }
+                else if ((*s == '"' || *s == '\'')  &&  // default value
+                         (s = strchr(v = s + 1, *s))) *s = '\0';
+                else { ezxml_err(root, t, "malformed <!ATTLIST"); break; }
+
+                if (! root->attr[i]) { // new tag name
+                    root->attr = (! i) ? (char***)malloc(2 * sizeof(char **))
+                                       : (char***)realloc(root->attr,
+                                                 (i + 2) * sizeof(char **));
+                    root->attr[i] = (char**)malloc(2 * sizeof(char *));
+                    root->attr[i][0] = t; // set tag name
+                    root->attr[i][1] = (char *)(root->attr[i + 1] = NULL);
+                }
+
+                for (j = 1; root->attr[i][j]; j += 3); // find end of list
+                root->attr[i] = (char**)realloc(root->attr[i],
+                                        (j + 4) * sizeof(char *));
+
+                root->attr[i][j + 3] = NULL; // null terminate list
+                root->attr[i][j + 2] = c; // is it cdata?
+                root->attr[i][j + 1] = (v) ? ezxml_decode(v, root->ent, *c)
+                                           : NULL;
+                root->attr[i][j] = n; // attribute name 
+            }
+        }
+        else if (! strncmp(s, "<!--", 4)) s = strstr(s + 4, "-->"); // comments
+        else if (! strncmp(s, "<?", 2)) { // processing instructions
+            if ((s = strstr(c = s + 2, "?>")))
+                ezxml_proc_inst(root, c, s++ - c);
+        }
+        else if (*s == '<') s = strchr(s, '>'); // skip other declarations
+        else if (*(s++) == '%' && ! root->standalone) break;
+    }
+
+    free(pe);
+    return ! *root->err;
+}
+
+// Converts a UTF-16 string to UTF-8. Returns a new string that must be freed
+// or NULL if no conversion was needed.
+char *ezxml_str2utf8(char **s, size_t *len)
+{
+    char *u;
+    size_t l = 0, sl, max = *len;
+    long c, d;
+    int b, be = (**s == '\xFE') ? 1 : (**s == '\xFF') ? 0 : -1;
+
+    if (be == -1) return NULL; // not UTF-16
+
+    u = (char*)malloc(max);
+    for (sl = 2; sl < *len - 1; sl += 2) {
+        c = (be) ? (((*s)[sl] & 0xFF) << 8) | ((*s)[sl + 1] & 0xFF)  //UTF-16BE
+                 : (((*s)[sl + 1] & 0xFF) << 8) | ((*s)[sl] & 0xFF); //UTF-16LE
+        if (c >= 0xD800 && c <= 0xDFFF && (sl += 2) < *len - 1) { // high-half
+            d = (be) ? (((*s)[sl] & 0xFF) << 8) | ((*s)[sl + 1] & 0xFF)
+                     : (((*s)[sl + 1] & 0xFF) << 8) | ((*s)[sl] & 0xFF);
+            c = (((c & 0x3FF) << 10) | (d & 0x3FF)) + 0x10000;
+        }
+
+        while (l + 6 > max) u = (char*)realloc(u, max += EZXML_BUFSIZE);
+        if (c < 0x80) u[l++] = c; // US-ASCII subset
+        else { // multi-byte UTF-8 sequence
+            for (b = 0, d = c; d; d /= 2) b++; // bits in c
+            b = (b - 2) / 5; // bytes in payload
+            u[l++] = (0xFF << (7 - b)) | (c >> (6 * b)); // head
+            while (b) u[l++] = 0x80 | ((c >> (6 * --b)) & 0x3F); // payload
+        }
+    }
+    return *s = (char*)realloc(u, *len = l);
+}
+
+// frees a tag attribute list
+void ezxml_free_attr(char **attr) {
+    int i = 0;
+    char *m;
+    
+    if (! attr || attr == EZXML_NIL) return; // nothing to free
+    while (attr[i]) i += 2; // find end of attribute list
+    m = attr[i + 1]; // list of which names and values are malloced
+    for (i = 0; m[i]; i++) {
+        if (m[i] & EZXML_NAMEM) free(attr[i * 2]);
+        if (m[i] & EZXML_TXTM) free(attr[(i * 2) + 1]);
+    }
+    free(m);
+    free(attr);
+}
+
+// parse the given xml string and return an ezxml structure
+ezxml_t ezxml_parse_str(char *s, size_t len)
+{
+    ezxml_root_t root = (ezxml_root_t)ezxml_new(NULL);
+    char q, e, *d, **attr, **a = NULL; // initialize a to avoid compile warning
+    int l, i, j;
+
+    root->m = s;
+    if (! len) return ezxml_err(root, NULL, "root tag missing");
+    root->u = ezxml_str2utf8(&s, &len); // convert utf-16 to utf-8
+    root->e = (root->s = s) + len; // record start and end of work area
+    
+    e = s[len - 1]; // save end char
+    s[len - 1] = '\0'; // turn end char into null terminator
+
+    while (*s && *s != '<') s++; // find first tag
+    if (! *s) return ezxml_err(root, s, "root tag missing");
+
+    for (; ; ) {
+        attr = (char **)EZXML_NIL;
+        d = ++s;
+        
+        if (isalpha(*s) || *s == '_' || *s == ':' || *s < '\0') { // new tag
+            if (! root->cur)
+                return ezxml_err(root, d, "markup outside of root element");
+
+            s += strcspn(s, EZXML_WS "/>");
+            while (isspace(*s)) *(s++) = '\0'; // null terminate tag name
+  
+            if (*s && *s != '/' && *s != '>') // find tag in default attr list
+                for (i = 0; (a = root->attr[i]) && strcmp(a[0], d); i++);
+
+            for (l = 0; *s && *s != '/' && *s != '>'; l += 2) { // new attrib
+                attr = (l) ? (char**)realloc(attr, (l + 4) * sizeof(char *))
+                           : (char**)malloc(4 * sizeof(char *)); // allocate space
+                attr[l + 3] = (l) ? (char*)realloc(attr[l + 1], (l / 2) + 2)
+                                  : (char*)malloc(2); // mem for list of maloced vals
+                strcpy(attr[l + 3] + (l / 2), " "); // value is not malloced
+                attr[l + 2] = NULL; // null terminate list
+                attr[l + 1] = ""; // temporary attribute value
+                attr[l] = s; // set attribute name
+
+                s += strcspn(s, EZXML_WS "=/>");
+                if (*s == '=' || isspace(*s)) { 
+                    *(s++) = '\0'; // null terminate tag attribute name
+                    q = *(s += strspn(s, EZXML_WS "="));
+                    if (q == '"' || q == '\'') { // attribute value
+                        attr[l + 1] = ++s;
+                        while (*s && *s != q) s++;
+                        if (*s) *(s++) = '\0'; // null terminate attribute val
+                        else {
+                            ezxml_free_attr(attr);
+                            return ezxml_err(root, d, "missing %c", q);
+                        }
+
+                        for (j = 1; a && a[j] && strcmp(a[j], attr[l]); j +=3);
+                        attr[l + 1] = ezxml_decode(attr[l + 1], root->ent, (a
+                                                   && a[j]) ? *a[j + 2] : ' ');
+                        if (attr[l + 1] < d || attr[l + 1] > s)
+                            attr[l + 3][l / 2] = EZXML_TXTM; // value malloced
+                    }
+                }
+                while (isspace(*s)) s++;
+            }
+
+            if (*s == '/') { // self closing tag
+                *(s++) = '\0';
+                if ((*s && *s != '>') || (! *s && e != '>')) {
+                    if (l) ezxml_free_attr(attr);
+                    return ezxml_err(root, d, "missing >");
+                }
+                ezxml_open_tag(root, d, attr);
+                ezxml_close_tag(root, d, s);
+            }
+            else if ((q = *s) == '>' || (! *s && e == '>')) { // open tag
+                *s = '\0'; // temporarily null terminate tag name
+                ezxml_open_tag(root, d, attr);
+                *s = q;
+            }
+            else {
+                if (l) ezxml_free_attr(attr);
+                return ezxml_err(root, d, "missing >"); 
+            }
+        }
+        else if (*s == '/') { // close tag
+            s += strcspn(d = s + 1, EZXML_WS ">") + 1;
+            if (! (q = *s) && e != '>') return ezxml_err(root, d, "missing >");
+            *s = '\0'; // temporarily null terminate tag name
+            if (ezxml_close_tag(root, d, s)) return &root->xml;
+            if (isspace(*s = q)) s += strspn(s, EZXML_WS);
+        }
+        else if (! strncmp(s, "!--", 3)) { // xml comment
+            if (! (s = strstr(s + 3, "--")) || (*(s += 2) != '>' && *s) ||
+                (! *s && e != '>')) return ezxml_err(root, d, "unclosed <!--");
+        }
+        else if (! strncmp(s, "![CDATA[", 8)) { // cdata
+            if ((s = strstr(s, "]]>")))
+                ezxml_char_content(root, d + 8, (s += 2) - d - 10, 'c');
+            else return ezxml_err(root, d, "unclosed <![CDATA[");
+        }
+        else if (! strncmp(s, "!DOCTYPE", 8)) { // dtd
+            for (l = 0; *s && ((! l && *s != '>') || (l && (*s != ']' || 
+                 *(s + strspn(s + 1, EZXML_WS) + 1) != '>')));
+                 l = (*s == '[') ? 1 : l) s += strcspn(s + 1, "[]>") + 1;
+            if (! *s && e != '>')
+                return ezxml_err(root, d, "unclosed <!DOCTYPE");
+            d = (l) ? strchr(d, '[') + 1 : d;
+            if (l && ! ezxml_internal_dtd(root, d, s++ - d)) return &root->xml;
+        }
+        else if (*s == '?') { // <?...?> processing instructions
+            do { s = strchr(s, '?'); } while (s && *(++s) && *s != '>');
+            if (! s || (! *s && e != '>')) 
+                return ezxml_err(root, d, "unclosed <?");
+            else ezxml_proc_inst(root, d + 1, s - d - 2);
+        }
+        else return ezxml_err(root, d, "unexpected <");
+        
+        if (! s || ! *s) break;
+        *s = '\0';
+        d = ++s;
+        if (*s && *s != '<') { // tag character content
+            while (*s && *s != '<') s++;
+            if (*s) ezxml_char_content(root, d, s - d, '&');
+            else break;
+        }
+        else if (! *s) break;
+    }
+
+    if (! root->cur) return &root->xml;
+    else if (! root->cur->name) return ezxml_err(root, d, "root tag missing");
+    else return ezxml_err(root, d, "unclosed tag <%s>", root->cur->name);
+}
+
+// Wrapper for ezxml_parse_str() that accepts a file stream. Reads the entire
+// stream into memory and then parses it. For xml files, use ezxml_parse_file()
+// or ezxml_parse_fd()
+ezxml_t ezxml_parse_fp(FILE *fp)
+{
+    ezxml_root_t root;
+    size_t l, len = 0;
+    char *s;
+
+    if (! (s = (char*)malloc(EZXML_BUFSIZE))) return NULL;
+    do {
+        len += (l = fread((s + len), 1, EZXML_BUFSIZE, fp));
+        if (l == EZXML_BUFSIZE) s = (char*)realloc(s, len + EZXML_BUFSIZE);
+    } while (s && l == EZXML_BUFSIZE);
+
+    if (! s) return NULL;
+    root = (ezxml_root_t)ezxml_parse_str(s, len);
+    root->len = -1; // so we know to free s in ezxml_free()
+    return &root->xml;
+}
+
+// A wrapper for ezxml_parse_str() that accepts a file descriptor. First
+// attempts to mem map the file. Failing that, reads the file into memory.
+// Returns NULL on failure.
+ezxml_t ezxml_parse_fd(int fd)
+{
+    ezxml_root_t root;
+    struct stat st;
+    size_t l;
+    void *m;
+
+    if (fd < 0) return NULL;
+    fstat(fd, &st);
+
+
+        l = read(fd, m = (char*)malloc(st.st_size), st.st_size);
+        root = (ezxml_root_t)ezxml_parse_str((char*)m, l);
+        root->len = -1; // so we know to free s in ezxml_free()
+
+    return &root->xml;
+}
+
+// a wrapper for ezxml_parse_fd that accepts a file name
+ezxml_t ezxml_parse_file(const char *file)
+{
+    int fd = open(file, O_RDONLY, 0);
+    ezxml_t xml = ezxml_parse_fd(fd);
+    
+    if (fd >= 0) close(fd);
+    return xml;
+}
+
+// Encodes ampersand sequences appending the results to *dst, reallocating *dst
+// if length excedes max. a is non-zero for attribute encoding. Returns *dst
+char *ezxml_ampencode(const char *s, size_t len, char **dst, size_t *dlen,
+                      size_t *max, short a)
+{
+    const char *e;
+    
+    for (e = s + len; s != e; s++) {
+        while (*dlen + 10 > *max) *dst = (char*)realloc(*dst, *max += EZXML_BUFSIZE);
+
+        switch (*s) {
+        case '\0': return *dst;
+        case '&': *dlen += sprintf(*dst + *dlen, "&amp;"); break;
+        case '<': *dlen += sprintf(*dst + *dlen, "&lt;"); break;
+        case '>': *dlen += sprintf(*dst + *dlen, "&gt;"); break;
+        case '"': *dlen += sprintf(*dst + *dlen, (a) ? "&quot;" : "\""); break;
+        case '\n': *dlen += sprintf(*dst + *dlen, (a) ? "&#xA;" : "\n"); break;
+        case '\t': *dlen += sprintf(*dst + *dlen, (a) ? "&#x9;" : "\t"); break;
+        case '\r': *dlen += sprintf(*dst + *dlen, "&#xD;"); break;
+        default: (*dst)[(*dlen)++] = *s;
+        }
+    }
+    return *dst;
+}
+
+// Recursively converts each tag to xml appending it to *s. Reallocates *s if
+// its length excedes max. start is the location of the previous tag in the
+// parent tag's character content. Returns *s.
+char *ezxml_toxml_r(ezxml_t xml, char **s, size_t *len, size_t *max,
+                    size_t start, char ***attr)
+{
+    int i, j;
+    char *txt = (char*)((xml->parent) ? xml->parent->txt : "");
+    size_t off = 0;
+
+    // parent character content up to this tag
+    *s = ezxml_ampencode(txt + start, xml->off - start, s, len, max, 0);
+
+    while (*len + strlen(xml->name) + 4 > *max) // reallocate s
+        *s = (char*)realloc(*s, *max += EZXML_BUFSIZE);
+
+    *len += sprintf(*s + *len, "<%s", xml->name); // open tag
+    for (i = 0; xml->attr[i]; i += 2) { // tag attributes
+        if (ezxml_attr(xml, xml->attr[i]) != xml->attr[i + 1]) continue;
+        while (*len + strlen(xml->attr[i]) + 7 > *max) // reallocate s
+            *s = (char*)realloc(*s, *max += EZXML_BUFSIZE);
+
+        *len += sprintf(*s + *len, " %s=\"", xml->attr[i]);
+        ezxml_ampencode(xml->attr[i + 1], -1, s, len, max, 1);
+        *len += sprintf(*s + *len, "\"");
+    }
+
+    for (i = 0; attr[i] && strcmp(attr[i][0], xml->name); i++);
+    for (j = 1; attr[i] && attr[i][j]; j += 3) { // default attributes
+        if (! attr[i][j + 1] || ezxml_attr(xml, attr[i][j]) != attr[i][j + 1])
+            continue; // skip duplicates and non-values
+        while (*len + strlen(attr[i][j]) + 7 > *max) // reallocate s
+            *s = (char*)realloc(*s, *max += EZXML_BUFSIZE);
+
+        *len += sprintf(*s + *len, " %s=\"", attr[i][j]);
+        ezxml_ampencode(attr[i][j + 1], -1, s, len, max, 1);
+        *len += sprintf(*s + *len, "\"");
+    }
+    *len += sprintf(*s + *len, ">");
+
+    *s = (xml->child) ? ezxml_toxml_r(xml->child, s, len, max, 0, attr) //child
+                      : ezxml_ampencode(xml->txt, -1, s, len, max, 0);  //data
+    
+    while (*len + strlen(xml->name) + 4 > *max) // reallocate s
+        *s = (char*)realloc(*s, *max += EZXML_BUFSIZE);
+
+    *len += sprintf(*s + *len, "</%s>", xml->name); // close tag
+
+    while (txt[off] && off < xml->off) off++; // make sure off is within bounds
+    return (xml->ordered) ? ezxml_toxml_r(xml->ordered, s, len, max, off, attr)
+                          : ezxml_ampencode(txt + off, -1, s, len, max, 0);
+}
+
+// Converts an ezxml structure back to xml. Returns a string of xml data that
+// must be freed.
+char *ezxml_toxml(ezxml_t xml)
+{
+    ezxml_t p = (xml) ? xml->parent : NULL, o = (xml) ? xml->ordered : NULL;
+    ezxml_root_t root = (ezxml_root_t)xml;
+    size_t len = 0, max = EZXML_BUFSIZE;
+    char *s = strcpy((char*)malloc(max), ""), *t, *n;
+    int i, j, k;
+
+    if (! xml || ! xml->name) return (char*)realloc(s, len + 1);
+    while (root->xml.parent) root = (ezxml_root_t)root->xml.parent; // root tag
+
+    for (i = 0; ! p && root->pi[i]; i++) { // pre-root processing instructions
+        for (k = 2; root->pi[i][k - 1]; k++);
+        for (j = 1; (n = root->pi[i][j]); j++) {
+            if (root->pi[i][k][j - 1] == '>') continue; // not pre-root
+            while (len + strlen(t = root->pi[i][0]) + strlen(n) + 7 > max)
+                s = (char*)realloc(s, max += EZXML_BUFSIZE);
+            len += sprintf(s + len, "<?%s%s%s?>\n", t, *n ? " " : "", n);
+        }
+    }
+
+    xml->parent = xml->ordered = NULL;
+    s = ezxml_toxml_r(xml, &s, &len, &max, 0, root->attr);
+    xml->parent = p;
+    xml->ordered = o;
+
+    for (i = 0; ! p && root->pi[i]; i++) { // post-root processing instructions
+        for (k = 2; root->pi[i][k - 1]; k++);
+        for (j = 1; (n = root->pi[i][j]); j++) {
+            if (root->pi[i][k][j - 1] == '<') continue; // not post-root
+            while (len + strlen(t = root->pi[i][0]) + strlen(n) + 7 > max)
+                s = (char*)realloc(s, max += EZXML_BUFSIZE);
+            len += sprintf(s + len, "\n<?%s%s%s?>", t, *n ? " " : "", n);
+        }
+    }
+    return (char*)realloc(s, len + 1);
+}
+
+// free the memory allocated for the ezxml structure
+void ezxml_free(ezxml_t xml)
+{
+    ezxml_root_t root = (ezxml_root_t)xml;
+    int i, j;
+    char **a, *s;
+
+    if (! xml) return;
+    ezxml_free(xml->child);
+    ezxml_free(xml->ordered);
+
+    if (! xml->parent) { // free root tag allocations
+        for (i = 10; root->ent[i]; i += 2) // 0 - 9 are default entites (<>&"')
+            if ((s = root->ent[i + 1]) < root->s || s > root->e) free(s);
+        free(root->ent); // free list of general entities
+
+        for (i = 0; (a = root->attr[i]); i++) {
+            for (j = 1; a[j++]; j += 2) // free malloced attribute values
+                if (a[j] && (a[j] < root->s || a[j] > root->e)) free(a[j]);
+            free(a);
+        }
+        if (root->attr[0]) free(root->attr); // free default attribute list
+
+        for (i = 0; root->pi[i]; i++) {
+            for (j = 1; root->pi[i][j]; j++);
+            free(root->pi[i][j + 1]);
+            free(root->pi[i]);
+        }            
+        if (root->pi[0]) free(root->pi); // free processing instructions
+
+        if (root->len == -1) free(root->m); // malloced xml data
+
+        if (root->u) free(root->u); // utf8 conversion
+    }
+
+    ezxml_free_attr(xml->attr); // tag attributes
+    if ((xml->flags & EZXML_TXTM)) free(xml->txt); // character content
+    if ((xml->flags & EZXML_NAMEM)) free(xml->name); // tag name
+    free(xml);
+}
+
+// return parser error message or empty string if none
+const char *ezxml_error(ezxml_t xml)
+{
+    while (xml && xml->parent) xml = xml->parent; // find root tag
+    return (xml) ? ((ezxml_root_t)xml)->err : "";
+}
+
+// returns a new empty ezxml structure with the given root tag name
+ezxml_t ezxml_new(const char *name)
+{
+    static char *ent[] = { "lt;", "&#60;", "gt;", "&#62;", "quot;", "&#34;",
+                           "apos;", "&#39;", "amp;", "&#38;", NULL };
+    ezxml_root_t root = (ezxml_root_t)memset(malloc(sizeof(struct ezxml_root)), 
+                                             '\0', sizeof(struct ezxml_root));
+    root->xml.name = (char *)name;
+    root->cur = &root->xml;
+    strcpy(root->err, root->xml.txt = "");
+    root->ent = (char**)memcpy(malloc(sizeof(ent)), ent, sizeof(ent));
+    root->attr = root->pi = (char ***)(root->xml.attr = EZXML_NIL);
+    return &root->xml;
+}
+
+// inserts an existing tag into an ezxml structure
+ezxml_t ezxml_insert(ezxml_t xml, ezxml_t dest, size_t off)
+{
+    ezxml_t cur, prev, head;
+
+    xml->next = xml->sibling = xml->ordered = NULL;
+    xml->off = off;
+    xml->parent = dest;
+
+    if ((head = dest->child)) { // already have sub tags
+        if (head->off <= off) { // not first subtag
+            for (cur = head; cur->ordered && cur->ordered->off <= off;
+                 cur = cur->ordered);
+            xml->ordered = cur->ordered;
+            cur->ordered = xml;
+        }
+        else { // first subtag
+            xml->ordered = head;
+            dest->child = xml;
+        }
+
+        for (cur = head, prev = NULL; cur && strcmp(cur->name, xml->name);
+             prev = cur, cur = cur->sibling); // find tag type
+        if (cur && cur->off <= off) { // not first of type
+            while (cur->next && cur->next->off <= off) cur = cur->next;
+            xml->next = cur->next;
+            cur->next = xml;
+        }
+        else { // first tag of this type
+            if (prev && cur) prev->sibling = cur->sibling; // remove old first
+            xml->next = cur; // old first tag is now next
+            for (cur = head, prev = NULL; cur && cur->off <= off;
+                 prev = cur, cur = cur->sibling); // new sibling insert point
+            xml->sibling = cur;
+            if (prev) prev->sibling = xml;
+        }
+    }
+    else dest->child = xml; // only sub tag
+
+    return xml;
+}
+
+// Adds a child tag. off is the offset of the child tag relative to the start
+// of the parent tag's character content. Returns the child tag.
+ezxml_t ezxml_add_child(ezxml_t xml, const char *name, size_t off)
+{
+    ezxml_t child;
+
+    if (! xml) return NULL;
+    child = (ezxml_t)memset(malloc(sizeof(struct ezxml)), '\0',
+                            sizeof(struct ezxml));
+    child->name = (char *)name;
+    child->attr = EZXML_NIL;
+    child->txt = "";
+
+    return ezxml_insert(child, xml, off);
+}
+
+// sets the character content for the given tag and returns the tag
+ezxml_t ezxml_set_txt(ezxml_t xml, const char *txt)
+{
+    if (! xml) return NULL;
+    if (xml->flags & EZXML_TXTM) free(xml->txt); // existing txt was malloced
+    xml->flags &= ~EZXML_TXTM;
+    xml->txt = (char *)txt;
+    return xml;
+}
+
+// Sets the given tag attribute or adds a new attribute if not found. A value
+// of NULL will remove the specified attribute. Returns the tag given.
+ezxml_t ezxml_set_attr(ezxml_t xml, const char *name, const char *value)
+{
+    int l = 0, c;
+
+    if (! xml) return NULL;
+    while (xml->attr[l] && strcmp(xml->attr[l], name)) l += 2;
+    if (! xml->attr[l]) { // not found, add as new attribute
+        if (! value) return xml; // nothing to do
+        if (xml->attr == EZXML_NIL) { // first attribute
+            xml->attr = (char**)malloc(4 * sizeof(char *));
+            xml->attr[1] = strdup(""); // empty list of malloced names/vals
+        }
+        else xml->attr = (char**)realloc(xml->attr, (l + 4) * sizeof(char *));
+
+        xml->attr[l] = (char *)name; // set attribute name
+        xml->attr[l + 2] = NULL; // null terminate attribute list
+        xml->attr[l + 3] = (char*)realloc(xml->attr[l + 1],
+                                   (c = strlen(xml->attr[l + 1])) + 2);
+        strcpy(xml->attr[l + 3] + c, " "); // set name/value as not malloced
+        if (xml->flags & EZXML_DUP) xml->attr[l + 3][c] = EZXML_NAMEM;
+    }
+    else if (xml->flags & EZXML_DUP) free((char *)name); // name was strduped
+
+    for (c = l; xml->attr[c]; c += 2); // find end of attribute list
+    if (xml->attr[c + 1][l / 2] & EZXML_TXTM) free(xml->attr[l + 1]); //old val
+    if (xml->flags & EZXML_DUP) xml->attr[c + 1][l / 2] |= EZXML_TXTM;
+    else xml->attr[c + 1][l / 2] &= ~EZXML_TXTM;
+
+    if (value) xml->attr[l + 1] = (char *)value; // set attribute value
+    else { // remove attribute
+        if (xml->attr[c + 1][l / 2] & EZXML_NAMEM) free(xml->attr[l]);
+        memmove(xml->attr + l, xml->attr + l + 2, (c - l + 2) * sizeof(char*));
+        xml->attr = (char**)realloc(xml->attr, (c + 2) * sizeof(char *));
+        memmove(xml->attr[c + 1] + (l / 2), xml->attr[c + 1] + (l / 2) + 1,
+                (c / 2) - (l / 2)); // fix list of which name/vals are malloced
+    }
+    xml->flags &= ~EZXML_DUP; // clear strdup() flag
+    return xml;
+}
+
+// sets a flag for the given tag and returns the tag
+ezxml_t ezxml_set_flag(ezxml_t xml, short flag)
+{
+    if (xml) xml->flags |= flag;
+    return xml;
+}
+
+// removes a tag along with its subtags without freeing its memory
+ezxml_t ezxml_cut(ezxml_t xml)
+{
+    ezxml_t cur;
+
+    if (! xml) return NULL; // nothing to do
+    if (xml->next) xml->next->sibling = xml->sibling; // patch sibling list
+
+    if (xml->parent) { // not root tag
+        cur = xml->parent->child; // find head of subtag list
+        if (cur == xml) xml->parent->child = xml->ordered; // first subtag
+        else { // not first subtag
+            while (cur->ordered != xml) cur = cur->ordered;
+            cur->ordered = cur->ordered->ordered; // patch ordered list
+
+            cur = xml->parent->child; // go back to head of subtag list
+            if (strcmp(cur->name, xml->name)) { // not in first sibling list
+                while (strcmp(cur->sibling->name, xml->name))
+                    cur = cur->sibling;
+                if (cur->sibling == xml) { // first of a sibling list
+                    cur->sibling = (xml->next) ? xml->next
+                                               : cur->sibling->sibling;
+                }
+                else cur = cur->sibling; // not first of a sibling list
+            }
+
+            while (cur->next && cur->next != xml) cur = cur->next;
+            if (cur->next) cur->next = cur->next->next; // patch next list
+        }        
+    }
+    xml->ordered = xml->sibling = xml->next = NULL;
+    return xml;
+}
+
+#ifdef EZXML_TEST // test harness
+int main(int argc, char **argv)
+{
+    ezxml_t xml;
+    char *s;
+    int i;
+
+    if (argc != 2) return fprintf(stderr, "usage: %s xmlfile\n", argv[0]);
+
+    xml = ezxml_parse_file(argv[1]);
+    printf("%s\n", (s = ezxml_toxml(xml)));
+    free(s);
+    i = fprintf(stderr, "%s", ezxml_error(xml));
+    ezxml_free(xml);
+    return (i) ? 1 : 0;
+}
+#endif // EZXML_TEST
diff -Naur -x .svn rssreader-1.1.2-orig/ezxml.h rssreader/ezxml.h
--- rssreader-1.1.2-orig/ezxml.h	1970-01-01 01:00:00.000000000 +0100
+++ rssreader/ezxml.h	2009-02-02 17:42:19.000000000 +0100
@@ -0,0 +1,167 @@
+/* ezxml.h
+ *
+ * Copyright 2004-2006 Aaron Voisine <aaron@voisine.org>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef _EZXML_H
+#define _EZXML_H
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdarg.h>
+#include <fcntl.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define EZXML_BUFSIZE 1024 // size of internal memory buffers
+#define EZXML_NAMEM   0x80 // name is malloced
+#define EZXML_TXTM    0x40 // txt is malloced
+#define EZXML_DUP     0x20 // attribute name and value are strduped
+
+typedef struct ezxml *ezxml_t;
+struct ezxml {
+    char *name;      // tag name
+    char **attr;     // tag attributes { name, value, name, value, ... NULL }
+    char *txt;       // tag character content, empty string if none
+    size_t off;      // tag offset from start of parent tag character content
+    ezxml_t next;    // next tag with same name in this section at this depth
+    ezxml_t sibling; // next tag with different name in same section and depth
+    ezxml_t ordered; // next tag, same section and depth, in original order
+    ezxml_t child;   // head of sub tag list, NULL if none
+    ezxml_t parent;  // parent tag, NULL if current tag is root tag
+    short flags;     // additional information
+};
+
+// Given a string of xml data and its length, parses it and creates an ezxml
+// structure. For efficiency, modifies the data by adding null terminators
+// and decoding ampersand sequences. If you don't want this, copy the data and
+// pass in the copy. Returns NULL on failure.
+ezxml_t ezxml_parse_str(char *s, size_t len);
+
+// A wrapper for ezxml_parse_str() that accepts a file descriptor. First
+// attempts to mem map the file. Failing that, reads the file into memory.
+// Returns NULL on failure.
+ezxml_t ezxml_parse_fd(int fd);
+
+// a wrapper for ezxml_parse_fd() that accepts a file name
+ezxml_t ezxml_parse_file(const char *file);
+    
+// Wrapper for ezxml_parse_str() that accepts a file stream. Reads the entire
+// stream into memory and then parses it. For xml files, use ezxml_parse_file()
+// or ezxml_parse_fd()
+ezxml_t ezxml_parse_fp(FILE *fp);
+
+// returns the first child tag (one level deeper) with the given name or NULL
+// if not found
+ezxml_t ezxml_child(ezxml_t xml, const char *name);
+
+// returns the next tag of the same name in the same section and depth or NULL
+// if not found
+#define ezxml_next(xml) ((xml) ? xml->next : NULL)
+
+// Returns the Nth tag with the same name in the same section at the same depth
+// or NULL if not found. An index of 0 returns the tag given.
+ezxml_t ezxml_idx(ezxml_t xml, int idx);
+
+// returns the name of the given tag
+#define ezxml_name(xml) ((xml) ? xml->name : NULL)
+
+// returns the given tag's character content or empty string if none
+#define ezxml_txt(xml) ((xml) ? xml->txt : "")
+
+// returns the value of the requested tag attribute, or NULL if not found
+const char *ezxml_attr(ezxml_t xml, const char *attr);
+
+// Traverses the ezxml sturcture to retrieve a specific subtag. Takes a
+// variable length list of tag names and indexes. The argument list must be
+// terminated by either an index of -1 or an empty string tag name. Example: 
+// title = ezxml_get(library, "shelf", 0, "book", 2, "title", -1);
+// This retrieves the title of the 3rd book on the 1st shelf of library.
+// Returns NULL if not found.
+ezxml_t ezxml_get(ezxml_t xml, ...);
+
+// Converts an ezxml structure back to xml. Returns a string of xml data that
+// must be freed.
+char *ezxml_toxml(ezxml_t xml);
+
+// returns a NULL terminated array of processing instructions for the given
+// target
+const char **ezxml_pi(ezxml_t xml, const char *target);
+
+// frees the memory allocated for an ezxml structure
+void ezxml_free(ezxml_t xml);
+    
+// returns parser error message or empty string if none
+const char *ezxml_error(ezxml_t xml);
+
+// returns a new empty ezxml structure with the given root tag name
+ezxml_t ezxml_new(const char *name);
+
+// wrapper for ezxml_new() that strdup()s name
+#define ezxml_new_d(name) ezxml_set_flag(ezxml_new(strdup(name)), EZXML_NAMEM)
+
+// Adds a child tag. off is the offset of the child tag relative to the start
+// of the parent tag's character content. Returns the child tag.
+ezxml_t ezxml_add_child(ezxml_t xml, const char *name, size_t off);
+
+// wrapper for ezxml_add_child() that strdup()s name
+#define ezxml_add_child_d(xml, name, off) \
+    ezxml_set_flag(ezxml_add_child(xml, strdup(name), off), EZXML_NAMEM)
+
+// sets the character content for the given tag and returns the tag
+ezxml_t ezxml_set_txt(ezxml_t xml, const char *txt);
+
+// wrapper for ezxml_set_txt() that strdup()s txt
+#define ezxml_set_txt_d(xml, txt) \
+    ezxml_set_flag(ezxml_set_txt(xml, strdup(txt)), EZXML_TXTM)
+
+// Sets the given tag attribute or adds a new attribute if not found. A value
+// of NULL will remove the specified attribute. Returns the tag given.
+ezxml_t ezxml_set_attr(ezxml_t xml, const char *name, const char *value);
+
+// Wrapper for ezxml_set_attr() that strdup()s name/value. Value cannot be NULL
+#define ezxml_set_attr_d(xml, name, value) \
+    ezxml_set_attr(ezxml_set_flag(xml, EZXML_DUP), strdup(name), strdup(value))
+
+// sets a flag for the given tag and returns the tag
+ezxml_t ezxml_set_flag(ezxml_t xml, short flag);
+
+// removes a tag along with its subtags without freeing its memory
+ezxml_t ezxml_cut(ezxml_t xml);
+
+// inserts an existing tag into an ezxml structure
+ezxml_t ezxml_insert(ezxml_t xml, ezxml_t dest, size_t off);
+
+// Moves an existing tag to become a subtag of dest at the given offset from
+// the start of dest's character content. Returns the moved tag.
+#define ezxml_move(xml, dest, off) ezxml_insert(ezxml_cut(xml), dest, off)
+
+// removes a tag along with all its subtags
+#define ezxml_remove(xml) ezxml_free(ezxml_cut(xml))
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // _EZXML_H
diff -Naur -x .svn rssreader-1.1.2-orig/HISTORY rssreader/HISTORY
--- rssreader-1.1.2-orig/HISTORY	2009-02-02 17:41:49.000000000 +0100
+++ rssreader/HISTORY	2009-02-02 17:42:19.000000000 +0100
@@ -88,3 +88,7 @@
 
 - Cleaned up translations.
 - Improved html tag stripping.
+
+2007-10-12: Version 1.1.3
+- Version vdr-m740x
+- Fix bug in html tag stripping.
diff -Naur -x .svn rssreader-1.1.2-orig/http_error_codes.c rssreader/http_error_codes.c
--- rssreader-1.1.2-orig/http_error_codes.c	1970-01-01 01:00:00.000000000 +0100
+++ rssreader/http_error_codes.c	2009-02-02 17:42:19.000000000 +0100
@@ -0,0 +1,39 @@
+/* http_error_codes.c - Error code declarations
+
+	HTTP Fetcher 
+ 	Copyright (C) 2001, 2003, 2004 Lyle Hanson (lhanson@users.sourceforge.net)
+
+	This library is free software; you can redistribute it and/or
+	modify it under the terms of the GNU Library General Public
+	License as published by the Free Software Foundation; either
+	version 2 of the License, or (at your option) any later version.
+
+	This library is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+	Library General Public License for more details.
+
+	See LICENSE file for details
+ */
+
+
+	/* Note that '%d' cannot be escaped at this time */
+const char *http_errlist[] =
+	{
+	"Success",										/* HF_SUCCESS		*/
+	"Internal Error. What the hell?!",				/* HF_METAERROR		*/
+	"Got NULL url",									/* HF_NULLURL		*/
+	"Timed out, no metadata for %d seconds",		/* HF_HEADTIMEOUT 	*/
+	"Timed out, no data for %d seconds",			/* HF_DATATIMEOUT	*/
+	"Couldn't find return code in HTTP response",	/* HF_FRETURNCODE	*/
+	"Couldn't convert return code in HTTP response",/* HF_CRETURNCODE	*/
+	"Request returned a status code of %d",			/* HF_STATUSCODE	*/
+	"Couldn't convert Content-Length to integer",	/* HF_CONTENTLEN	*/
+	"Network error (description unavailable)",		/* HF_HERROR		*/
+	"Status code of %d but no Location: field",		/* HF_CANTREDIRECT  */
+	"Followed the maximum number of redirects (%d)" /* HF_MAXREDIRECTS  */
+	};
+
+	/* Used to copy in messages from http_errlist[] and replace %d's with
+	 *	the value of errorInt.  Then we can pass the pointer to THIS */
+char convertedError[128];
diff -Naur -x .svn rssreader-1.1.2-orig/http_error_codes.h rssreader/http_error_codes.h
--- rssreader-1.1.2-orig/http_error_codes.h	1970-01-01 01:00:00.000000000 +0100
+++ rssreader/http_error_codes.h	2009-02-02 17:42:19.000000000 +0100
@@ -0,0 +1,42 @@
+/* http_error_codes.h - Error code definitions
+
+	HTTP Fetcher
+	Copyright (C) 2001, 2003, 2004 Lyle Hanson (lhanson@users.sourceforge.net)
+
+	This library is free software; you can redistribute it and/or
+	modify it under the terms of the GNU Library General Public
+	License as published by the Free Software Foundation; either
+	version 2 of the License, or (at your option) any later version.
+
+	This library is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+	Library General Public License for more details.
+
+	See LICENSE file for details
+
+ */
+
+#ifndef HTTP_ERROR_CODES_H
+#define HTTP_ERROR_CODES_H
+
+/* Error sources */
+#define FETCHER_ERROR	0
+#define ERRNO			1
+#define H_ERRNO			2
+
+/* HTTP Fetcher error codes */
+#define HF_SUCCESS		0
+#define HF_METAERROR	1
+#define HF_NULLURL		2
+#define HF_HEADTIMEOUT	3
+#define HF_DATATIMEOUT	4
+#define HF_FRETURNCODE	5
+#define HF_CRETURNCODE	6
+#define HF_STATUSCODE	7
+#define HF_CONTENTLEN	8
+#define HF_HERROR		9
+#define HF_CANTREDIRECT 10
+#define HF_MAXREDIRECTS 11
+
+#endif
diff -Naur -x .svn rssreader-1.1.2-orig/http_fetcher.c rssreader/http_fetcher.c
--- rssreader-1.1.2-orig/http_fetcher.c	1970-01-01 01:00:00.000000000 +0100
+++ rssreader/http_fetcher.c	2009-02-02 17:42:19.000000000 +0100
@@ -0,0 +1,816 @@
+/* http_fetcher.c - HTTP handling functions
+
+	HTTP Fetcher 
+	Copyright (C) 2001, 2003, 2004 Lyle Hanson (lhanson@users.sourceforge.net)
+
+	This library is free software; you can redistribute it and/or
+	modify it under the terms of the GNU Library General Public
+	License as published by the Free Software Foundation; either
+	version 2 of the License, or (at your option) any later version.
+
+	This library is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+	Library General Public License for more details.
+
+	See LICENSE file for details
+
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <strings.h>
+#include <ctype.h>
+#include <errno.h>
+#include <netdb.h>
+#include <unistd.h>
+#include <netinet/in.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/time.h>
+#include "http_fetcher.h"
+
+/* Globals */
+int timeout = DEFAULT_READ_TIMEOUT;
+char *userAgent = NULL;
+char *referer = NULL;
+int hideUserAgent = 0;
+int hideReferer = 1;
+static int followRedirects = DEFAULT_REDIRECTS;	/* # of redirects to follow */
+extern const char *http_errlist[];	/* Array of HTTP Fetcher error messages */
+extern char convertedError[128];	/* Buffer to used when errors contain %d */
+static int errorSource = 0;
+static int http_errno = 0;
+static int errorInt = 0;			/* When the error message has a %d in it,
+									 *	this variable is inserted */
+
+
+	/* 
+	 * Actually downloads the page, registering a hit (donation)
+	 *	If the fileBuf passed in is NULL, the url is downloaded and then
+	 *	freed; otherwise the necessary space is allocated for fileBuf.
+	 *	Returns size of download on success, -1 on error is set, 
+	 */
+int http_fetch(const char *url_tmp, char **fileBuf)
+	{
+	fd_set rfds;
+	struct timeval tv;
+	char headerBuf[HEADER_BUF_SIZE];
+	char *tmp, *url, *pageBuf, *requestBuf = NULL, *host, *charIndex;
+	int sock, bytesRead = 0, contentLength = -1, bufsize = REQUEST_BUF_SIZE;
+	int i,
+		ret = -1,
+		tempSize,
+		selectRet,
+		found = 0,	/* For redirects */
+		redirectsFollowed = 0;
+
+
+	if(url_tmp == NULL)
+		{
+		errorSource = FETCHER_ERROR;
+		http_errno = HF_NULLURL;
+		return -1;
+		}
+
+	/* Copy the url passed in into a buffer we can work with, change, etc. */
+	url = (char*)malloc(strlen(url_tmp)+1);
+	if(url == NULL)
+		{
+		errorSource = ERRNO;
+		return -1;
+		}
+	strncpy(url, url_tmp, strlen(url_tmp) + 1);
+	
+	/* This loop allows us to follow redirects if need be.  An afterthought,
+	 * added to provide this basic functionality.  Will hopefully be designed
+	 * better in 2.x.x ;) */
+/*	while(!found &&
+		  (followRedirects < 0 || redirectsFollowed < followRedirects) )
+  */  do
+		{
+		/* Seek to the file path portion of the url */
+		charIndex = strstr(url, "://");
+		if(charIndex != NULL)
+			{
+			/* url contains a protocol field */
+			charIndex += strlen("://");
+			host = charIndex;
+			charIndex = strchr(charIndex, '/');
+			}
+		else
+			{
+			host = (char *)url;
+			charIndex = strchr(url, '/');
+			}
+
+		/* Compose a request string */
+		requestBuf = (char*)malloc(bufsize);
+		if(requestBuf == NULL)
+			{
+			free(url);
+			errorSource = ERRNO;
+			return -1;
+			}
+		requestBuf[0] = 0;
+
+		if(charIndex == NULL)
+			{
+			/* The url has no '/' in it, assume the user is making a root-level
+			 *	request */ 
+			tempSize = strlen("GET /") + strlen(HTTP_VERSION) + 2;
+			if(_checkBufSize(&requestBuf, &bufsize, tempSize) ||
+				snprintf(requestBuf, bufsize, "GET / %s\r\n", HTTP_VERSION) < 0)
+				{
+				free(url);
+				free(requestBuf);
+				errorSource = ERRNO;
+				return -1;
+				}
+			}
+		else
+			{
+			tempSize = strlen("GET ") + strlen(charIndex) +
+  	          strlen(HTTP_VERSION) + 4;
+		 	/* + 4 is for ' ', '\r', '\n', and NULL */
+                                    
+			if(_checkBufSize(&requestBuf, &bufsize, tempSize) ||
+					snprintf(requestBuf, bufsize, "GET %s %s\r\n",
+					charIndex, HTTP_VERSION) < 0)
+				{
+				free(url);
+				free(requestBuf);
+				errorSource = ERRNO;
+				return -1;
+				}
+			}
+
+		/* Null out the end of the hostname if need be */
+		if(charIndex != NULL)
+			*charIndex = 0;
+
+		/* Use Host: even though 1.0 doesn't specify it.  Some servers
+		 *	won't play nice if we don't send Host, and it shouldn't
+		 *	hurt anything */
+		ret = bufsize - strlen(requestBuf); /* Space left in buffer */
+		tempSize = (int)strlen("Host: ") + (int)strlen(host) + 3;
+        /* +3 for "\r\n\0" */
+		if(_checkBufSize(&requestBuf, &bufsize, tempSize + 128))
+			{
+			free(url);
+			free(requestBuf);
+			errorSource = ERRNO;
+			return -1;
+			}
+		strcat(requestBuf, "Host: ");
+		strcat(requestBuf, host);
+		strcat(requestBuf, "\r\n");
+
+		if(!hideReferer && referer != NULL)	/* NO default referer */
+			{
+			tempSize = (int)strlen("Referer: ") + (int)strlen(referer) + 3;
+   	        /* + 3 is for '\r', '\n', and NULL */
+			if(_checkBufSize(&requestBuf, &bufsize, tempSize))
+				{
+				free(url);
+				free(requestBuf);
+				errorSource = ERRNO;
+				return -1;
+				}
+			strcat(requestBuf, "Referer: ");
+			strcat(requestBuf, referer);
+			strcat(requestBuf, "\r\n");
+			}
+
+		if(!hideUserAgent && userAgent == NULL)
+			{
+			tempSize = (int)strlen("User-Agent: ") +
+				(int)strlen(DEFAULT_USER_AGENT) + (int)strlen(VERSION) + 4;
+   	        /* + 4 is for '\', '\r', '\n', and NULL */
+			if(_checkBufSize(&requestBuf, &bufsize, tempSize))
+				{
+				free(url);
+				free(requestBuf);
+				errorSource = ERRNO;
+				return -1;
+				}
+			strcat(requestBuf, "User-Agent: ");
+			strcat(requestBuf, DEFAULT_USER_AGENT);
+			strcat(requestBuf, "/");
+			strcat(requestBuf, VERSION);
+			strcat(requestBuf, "\r\n");
+			}
+		else if(!hideUserAgent)
+			{
+			tempSize = (int)strlen("User-Agent: ") + (int)strlen(userAgent) + 3;
+   	        /* + 3 is for '\r', '\n', and NULL */
+			if(_checkBufSize(&requestBuf, &bufsize, tempSize))
+				{
+				free(url);
+				free(requestBuf);
+				errorSource = ERRNO;
+				return -1;
+				}
+			strcat(requestBuf, "User-Agent: ");
+			strcat(requestBuf, userAgent);
+			strcat(requestBuf, "\r\n");
+			}
+
+		tempSize = (int)strlen("Connection: Close\r\n\r\n");
+		if(_checkBufSize(&requestBuf, &bufsize, tempSize))
+			{
+			free(url);
+			free(requestBuf);
+			errorSource = ERRNO;
+			return -1;
+			}
+		strcat(requestBuf, "Connection: Close\r\n\r\n");
+
+		/* Now free any excess memory allocated to the buffer */
+		tmp = (char*)realloc(requestBuf, strlen(requestBuf) + 1);
+		if(tmp == NULL)
+			{
+			free(url);
+			free(requestBuf);
+			errorSource = ERRNO;
+			return -1;
+			}
+		requestBuf = tmp;
+
+		sock = makeSocket(host);		/* errorSource set within makeSocket */
+		if(sock == -1) { free(url); free(requestBuf); return -1;}
+
+		free(url);
+        url = NULL;
+
+		if(write(sock, requestBuf, strlen(requestBuf)) == -1)
+			{
+			close(sock);
+			free(requestBuf);
+			errorSource = ERRNO;
+			return -1;
+			}
+
+		free(requestBuf);
+        requestBuf = NULL;
+
+		/* Grab enough of the response to get the metadata */
+		ret = _http_read_header(sock, headerBuf);	/* errorSource set within */
+		if(ret < 0) { close(sock); return -1; }
+
+		/* Get the return code */
+		charIndex = strstr(headerBuf, "HTTP/");
+		if(charIndex == NULL)
+			{
+			close(sock);
+			errorSource = FETCHER_ERROR;
+			http_errno = HF_FRETURNCODE;
+			return -1;
+			}
+		while(*charIndex != ' ')
+			charIndex++;
+		charIndex++;
+
+		ret = sscanf(charIndex, "%d", &i);
+		if(ret != 1)
+			{
+			close(sock);
+			errorSource = FETCHER_ERROR;
+			http_errno = HF_CRETURNCODE;
+			return -1;
+			}
+		if(i<200 || i>307)
+			{
+			close(sock);
+			errorInt = i;	/* Status code, to be inserted in error string */
+			errorSource = FETCHER_ERROR;
+			http_errno = HF_STATUSCODE;
+			return -1;
+			}
+
+		/* If a redirect, repeat operation until final URL is found or we
+		 *  redirect followRedirects times.  Note the case sensitive "Location",
+		 *  should probably be made more robust in the future (without relying
+		 *  on the non-standard strcasecmp()).
+		 * This bit mostly by Dean Wilder, tweaked by me */
+		if(i >= 300)
+			{
+		    redirectsFollowed++;
+
+			/* Pick up redirect URL, allocate new url, and repeat process */
+			charIndex = strstr(headerBuf, "Location:");
+			if(!charIndex)
+				{
+				close(sock);
+				errorInt = i; /* Status code, to be inserted in error string */
+				errorSource = FETCHER_ERROR;
+				http_errno = HF_CANTREDIRECT;
+				return -1;
+				}
+			charIndex += strlen("Location:");
+            /* Skip any whitespace... */
+            while(*charIndex != '\0' && isspace(*charIndex))
+                charIndex++;
+            if(*charIndex == '\0')
+                {
+				close(sock);
+				errorInt = i; /* Status code, to be inserted in error string */
+				errorSource = FETCHER_ERROR;
+				http_errno = HF_CANTREDIRECT;
+				return -1;
+                }
+
+			i = strcspn(charIndex, " \r\n");
+			if(i > 0)
+				{
+				url = (char *)malloc(i + 1);
+				strncpy(url, charIndex, i);
+				url[i] = '\0';
+				}
+			else
+                /* Found 'Location:' but contains no URL!  We'll handle it as
+                 * 'found', hopefully the resulting document will give the user
+                 * a hint as to what happened. */
+                found = 1;
+            }
+		else
+			found = 1;
+	    } while(!found &&
+                (followRedirects < 0 || redirectsFollowed <= followRedirects) );
+
+    if(url) /* Redirection code may malloc this, then exceed followRedirects */
+        {
+        free(url);
+        url = NULL;
+        }
+    
+    if(redirectsFollowed >= followRedirects && !found)
+        {
+        close(sock);
+    	errorInt = followRedirects; /* To be inserted in error string */
+    	errorSource = FETCHER_ERROR;
+    	http_errno = HF_MAXREDIRECTS;
+	    return -1;
+        }
+	
+	/*
+	 * Parse out about how big the data segment is.
+	 *	Note that under current HTTP standards (1.1 and prior), the
+	 *	Content-Length field is not guaranteed to be accurate or even present. 
+	 *	I just use it here so I can allocate a ballpark amount of memory.
+	 *
+	 * Note that some servers use different capitalization
+	 */
+	charIndex = strstr(headerBuf, "Content-Length:");
+	if(charIndex == NULL)
+		charIndex = strstr(headerBuf, "Content-length:");
+
+	if(charIndex != NULL)
+		{
+		ret = sscanf(charIndex + strlen("content-length: "), "%d",
+			&contentLength);
+		if(ret < 1)
+			{
+			close(sock);
+			errorSource = FETCHER_ERROR;
+			http_errno = HF_CONTENTLEN;
+			return -1;
+			}
+		}
+	
+	/* Allocate enough memory to hold the page */
+	if(contentLength == -1)
+		contentLength = DEFAULT_PAGE_BUF_SIZE;
+
+	pageBuf = (char *)malloc(contentLength);
+	if(pageBuf == NULL)
+		{
+		close(sock);
+		errorSource = ERRNO;
+		return -1;
+		}
+
+	/* Begin reading the body of the file */
+	while(ret > 0)
+		{
+		FD_ZERO(&rfds);
+		FD_SET(sock, &rfds);
+		tv.tv_sec = timeout; 
+		tv.tv_usec = 0;
+
+		if(timeout >= 0)
+			selectRet = select(sock+1, &rfds, NULL, NULL, &tv);
+		else		/* No timeout, can block indefinately */
+			selectRet = select(sock+1, &rfds, NULL, NULL, NULL);
+
+		if(selectRet == 0)
+			{
+			errorSource = FETCHER_ERROR;
+			http_errno = HF_DATATIMEOUT;
+			errorInt = timeout;
+			close(sock);
+			free(pageBuf);
+			return -1;
+			}
+		else if(selectRet == -1)
+			{
+			close(sock);
+			free(pageBuf);
+			errorSource = ERRNO;
+			return -1;
+			}
+
+		ret = read(sock, pageBuf + bytesRead, contentLength);
+		if(ret == -1)
+			{
+			close(sock);
+			free(pageBuf);
+			errorSource = ERRNO;
+			return -1;
+			}
+
+		bytesRead += ret;
+
+		if(ret > 0)
+			{
+			/* To be tolerant of inaccurate Content-Length fields, we'll
+			 *	allocate another read-sized chunk to make sure we have
+			 *	enough room.
+			 */
+			tmp = (char *)realloc(pageBuf, bytesRead + contentLength);
+			if(tmp == NULL)
+				{
+				close(sock);
+				free(pageBuf);
+				errorSource = ERRNO;
+				return -1;
+				}
+            pageBuf = tmp;
+			}
+		}
+	
+	/*
+	 * The download buffer is too large.  Trim off the safety padding.
+     * Note that we add one NULL byte to the end of the data, as it may not
+     *  already be NULL terminated and we can't be sure what type of data it
+     *  is or what the caller will do with it.
+	 */
+	tmp = (char *)realloc(pageBuf, bytesRead + 1);
+		/* tmp shouldn't be null, since we're _shrinking_ the buffer,
+		 *	and if it DID fail, we could go on with the too-large buffer,
+		 *	but something would DEFINATELY be wrong, so we'll just give
+		 *	an error message */
+	if(tmp == NULL)
+		{
+		close(sock);
+		free(pageBuf);
+		errorSource = ERRNO;
+		return -1;
+		}
+    pageBuf = tmp;
+    pageBuf[bytesRead] = '\0';  /* NULL terminate the data */
+
+	if(fileBuf == NULL)	/* They just wanted us to "hit" the url */
+		free(pageBuf);
+	else
+		*fileBuf = pageBuf;
+
+	close(sock);
+	return bytesRead;
+	}
+
+
+
+	/*
+	 * Changes the User Agent.  Returns 0 on success, -1 on error. 
+	 */
+int http_setUserAgent(const char *newAgent)
+	{
+	static int freeOldAgent = 0; /* Indicates previous malloc's */
+	char *tmp;
+
+	if(newAgent == NULL)
+		{
+		if(freeOldAgent) free(userAgent);
+		userAgent = NULL;
+		hideUserAgent = 1;
+		}
+	else
+		{
+		tmp = (char *)malloc(strlen(newAgent));
+		if(tmp == NULL) { errorSource = ERRNO; return -1; }
+		if(freeOldAgent) free(userAgent);
+		userAgent = tmp;
+		strcpy(userAgent, newAgent);
+		freeOldAgent = 1;
+		hideUserAgent = 0;
+		}
+
+	return 0;
+	}
+
+
+
+	/*
+	 * Changes the Referer.  Returns 0 on success, -1 on error
+	 */
+int http_setReferer(const char *newReferer)
+	{
+	static int freeOldReferer = 0; /* Indicated previous malloc's */
+	char *tmp;
+
+	if(newReferer == NULL)
+		{
+		if(freeOldReferer) free(referer);
+		referer = NULL;
+		hideReferer = 1;
+		}
+	else
+		{
+		tmp = (char *)malloc(strlen(newReferer));
+		if(tmp == NULL) { errorSource = ERRNO; return -1; }
+		if(freeOldReferer) free(referer);
+		referer = tmp;
+		strcpy(referer, newReferer);
+		freeOldReferer = 1;
+		hideReferer = 0;
+		}
+	
+	return 0;
+	}
+
+
+
+	/*
+	 * Changes the amount of time that HTTP Fetcher will wait for data
+	 *	before timing out on reads
+	 */
+void http_setTimeout(int seconds) { timeout = seconds; }
+
+
+
+	/*
+	 * Changes the number of HTTP redirects HTTP Fetcher will automatically
+	 *	follow.  If a request returns a status code of 3XX and contains
+	 *	a "Location:" field, the library will transparently follow up to
+	 *	the specified number of redirects.  With this implementation
+	 *	(which is just a stopgap, really) the caller won't be aware of any
+	 *	redirection and will assume the returned document came from the original
+	 *	URL.
+	 * To disable redirects, pass a 0.  To follow unlimited redirects (probably
+	 *  unwise), pass a negative value.  The default is to follow 3 redirects.
+	 */
+void http_setRedirects(int redirects) { followRedirects = redirects; }
+
+
+
+	/*
+	 * Puts the filename portion of the url into 'filename'.
+	 * Returns:
+	 *	0 on success
+	 *	1 when url contains no end filename (i.e., 'www.foo.com/'),
+	 *		and **filename should not be assumed to be valid
+	 *	-1 on error
+	 */
+int http_parseFilename(const char *url, char **filename)
+	{
+	char *ptr;
+
+	if(url == NULL)
+		{
+		errorSource = FETCHER_ERROR;
+		http_errno = HF_NULLURL;
+		return -1;
+		}
+
+	ptr = (char *)rindex(url, '/');
+	if(ptr == NULL)
+		/* Root level request, apparently */
+		return 1;
+
+	ptr++;
+	if(*ptr == '\0') return 1;
+
+	*filename = (char *)malloc(strlen(ptr));
+	if(*filename == NULL) { errorSource = ERRNO; return -1; }
+	strcpy(*filename, ptr);
+
+	return 0;
+	}
+
+	
+	
+	/* Depending on the source of error, calls either perror() or prints
+	 *	an HTTP Fetcher error message to stdout */
+void http_perror(const char *string)
+	{
+	if(errorSource == ERRNO)
+		perror(string);
+	else if(errorSource == H_ERRNO)
+		herror(string);
+	else if(errorSource == FETCHER_ERROR)
+		{
+		char *stringIndex;
+
+		if(strstr(http_errlist[http_errno], "%d") == NULL)
+			{
+			fputs(string, stderr);
+			fputs(": ", stderr);
+			fputs(http_errlist[http_errno], stderr);
+			fputs("\n", stderr);
+			}
+		else
+			{
+			/* The error string has a %d in it, we need to insert errorInt */
+			stringIndex = (char*)http_errlist[http_errno];
+			while(*stringIndex != '%')			/* Print up to the %d */
+				{
+				fputc(*stringIndex, stderr);
+				stringIndex++;
+				}
+			fprintf(stderr, "%d", errorInt);	/* Print the number */
+			stringIndex += 2;					/* Skip past the %d */
+			while(*stringIndex != 0)			/* Print up to the end NULL */
+				{
+				fputc(*stringIndex, stderr);
+				stringIndex++;
+				}
+			fputs("\n", stderr);
+			}
+		}
+	}
+
+
+
+	/* 
+	 * Returns a pointer to the current error description message. The
+	 *	message pointed to is only good until the next call to http_strerror(),
+	 *	so if you need to hold on to the message for a while you should make
+	 *	a copy of it
+	 */
+const char *http_strerror()
+	{
+	extern int errno;
+	
+	if(errorSource == ERRNO)
+		return strerror(errno);
+	else if(errorSource == H_ERRNO)
+#ifdef HAVE_HSTRERROR
+		return hstrerror(h_errno);
+#else
+		return http_errlist[HF_HERROR];
+#endif
+	else if(errorSource == FETCHER_ERROR)
+		{
+		if(strstr(http_errlist[http_errno], "%d") == NULL)
+			return http_errlist[http_errno];
+		else
+			{
+			/* The error string has a %d in it, we need to insert errorInt.
+			 *	convertedError[128] has been declared for that purpose */
+			char *stringIndex, *originalError;
+		
+			originalError = (char *)http_errlist[http_errno];
+			convertedError[0] = 0;		/* Start off with NULL */
+			stringIndex = strstr(originalError, "%d");
+			strncat(convertedError, originalError,		/* Copy up to %d */
+				abs(stringIndex - originalError));
+			sprintf(&convertedError[strlen(convertedError)],"%d",errorInt);
+			stringIndex += 2;		/* Skip past the %d */
+			strcat(convertedError, stringIndex);
+
+			return convertedError;
+			}
+		}
+		
+	return http_errlist[HF_METAERROR];	/* Should NEVER happen */
+	}
+
+	
+	/*
+	 * Reads the metadata of an HTTP response.
+	 * Perhaps a little inefficient, as it reads 1 byte at a time, but
+	 *	I don't think it's that much of a loss (most headers aren't HUGE).
+	 * Returns:
+	 *	# of bytes read on success, or
+	 *	-1 on error
+	 */
+int _http_read_header(int sock, char *headerPtr)
+	{
+	fd_set rfds;
+	struct timeval tv;
+	int bytesRead = 0, newlines = 0, ret, selectRet;
+
+	while(newlines != 2 && bytesRead != HEADER_BUF_SIZE)
+		{
+		FD_ZERO(&rfds);
+		FD_SET(sock, &rfds);
+		tv.tv_sec = timeout; 
+		tv.tv_usec = 0;
+
+		if(timeout >= 0)
+			selectRet = select(sock+1, &rfds, NULL, NULL, &tv);
+		else		/* No timeout, can block indefinately */
+			selectRet = select(sock+1, &rfds, NULL, NULL, NULL);
+		
+		if(selectRet == 0)
+			{
+			errorSource = FETCHER_ERROR;
+			http_errno = HF_HEADTIMEOUT;
+			errorInt = timeout;
+			return -1;
+			}
+		else if(selectRet == -1) { errorSource = ERRNO; return -1; }
+
+		ret = read(sock, headerPtr, 1);
+		if(ret == -1) { errorSource = ERRNO; return -1; }
+		bytesRead++;
+
+		if(*headerPtr == '\r')			/* Ignore CR */
+			{
+			/* Basically do nothing special, just don't set newlines
+			 *	to 0 */
+			headerPtr++;
+			continue;
+			}
+		else if(*headerPtr == '\n')		/* LF is the separator */
+			newlines++;
+		else
+			newlines = 0;
+
+		headerPtr++;
+		}
+
+	headerPtr -= 3;		/* Snip the trailing LF's */
+	*headerPtr = '\0';
+	return bytesRead;
+	}
+
+
+
+	/*
+	 * Opens a TCP socket and returns the descriptor
+	 * Returns:
+	 *	socket descriptor, or
+	 *	-1 on error
+	 */
+int makeSocket(const char *host)
+	{
+	int sock;										/* Socket descriptor */
+	struct sockaddr_in sa;							/* Socket address */
+	struct hostent *hp;								/* Host entity */
+	int ret;
+    int port;
+    char *p;
+	
+    /* Check for port number specified in URL */
+    p = strchr(host, ':');
+    if(p)
+        {
+        port = atoi(p + 1);
+        *p = '\0';
+        }
+    else
+        port = PORT_NUMBER;
+
+	hp = gethostbyname(host);
+	if(hp == NULL) { errorSource = H_ERRNO; return -1; }
+		
+	/* Copy host address from hostent to (server) socket address */
+	memcpy((char *)&sa.sin_addr, (char *)hp->h_addr, hp->h_length);
+	sa.sin_family = hp->h_addrtype;		/* Set service sin_family to PF_INET */
+	sa.sin_port = htons(port);      	/* Put portnum into sockaddr */
+
+	sock = socket(hp->h_addrtype, SOCK_STREAM, 0);
+	if(sock == -1) { errorSource = ERRNO; return -1; }
+
+	ret = connect(sock, (struct sockaddr *)&sa, sizeof(sa));
+	if(ret == -1) { errorSource = ERRNO; return -1; }
+
+	return sock;
+	}
+
+
+
+	/*
+	 * Determines if the given NULL-terminated buffer is large enough to
+	 * 	concatenate the given number of characters.  If not, it attempts to
+	 * 	grow the buffer to fit.
+	 * Returns:
+	 *	0 on success, or
+	 *	-1 on error (original buffer is unchanged).
+	 */
+int _checkBufSize(char **buf, int *bufsize, int more)
+	{
+	char *tmp;
+	int roomLeft = *bufsize - (strlen(*buf) + 1);
+	if(roomLeft > more)
+		return 0;
+	tmp = (char*)realloc(*buf, *bufsize + more + 1);
+	if(tmp == NULL)
+		return -1;
+	*buf = tmp;
+	*bufsize += more + 1;
+	return 0;
+	}
diff -Naur -x .svn rssreader-1.1.2-orig/http_fetcher.h rssreader/http_fetcher.h
--- rssreader-1.1.2-orig/http_fetcher.h	1970-01-01 01:00:00.000000000 +0100
+++ rssreader/http_fetcher.h	2009-02-02 17:42:19.000000000 +0100
@@ -0,0 +1,160 @@
+/* http_fetcher.h - HTTP handling functions
+
+	HTTP Fetcher
+	Copyright (C) 2001, 2003, 2004 Lyle Hanson (lhanson@users.sourceforge.net)
+
+	This library is free software; you can redistribute it and/or
+	modify it under the terms of the GNU Library General Public
+	License as published by the Free Software Foundation; either
+	version 2 of the License, or (at your option) any later version.
+
+	This library is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+	Library General Public License for more details.
+
+	See LICENSE file for details
+									
+ */
+
+#ifndef HTTP_FETCHER_H
+#define HTTP_FETCHER_H
+
+#include "http_error_codes.h"
+
+#define VERSION				"1"
+#define PORT_NUMBER 			80
+#define HTTP_VERSION 			"HTTP/1.0"
+#define DEFAULT_USER_AGENT		"HTTP Fetcher"
+#define DEFAULT_READ_TIMEOUT	30		/* Seconds to wait before giving up
+										 *	when no data is arriving */
+	 
+#define REQUEST_BUF_SIZE 		1024
+#define HEADER_BUF_SIZE 		1024
+#define DEFAULT_PAGE_BUF_SIZE 	1024 * 200	/* 200K should hold most things */
+#define DEFAULT_REDIRECTS       3       /* Number of HTTP redirects to follow */
+
+
+
+/******************************************************************************/
+/**************** Function declarations and descriptions **********************/
+/******************************************************************************/
+
+/* 
+ * [!!! NOTE !!!]  All HTTP Fetcher functions return -1 on error.  You can
+ *	then either call http_perror to print the error message or call
+ *	http_strerror to get a pointer to it
+ */
+
+
+	/*
+	 * Download the page, registering a hit. If you pass it a NULL for fileBuf,
+	 *	'url' will be requested but will not remain in memory (useful for
+	 *	simply registering a hit).  Otherwise necessary space will be allocated
+	 *	and will be pointed to by fileBuf.  Note that a NULL byte is added to
+     *  the data, so the actual buffer will be the file size + 1.
+	 * Returns:
+	 *	# of bytes downloaded, or
+	 *	-1 on error
+	 */
+int http_fetch(const char *url, char **fileBuf);
+
+	/*
+	 * Changes the User Agent (shown to the web server with each request)
+	 *	Send it NULL to avoid telling the server a User Agent
+	 *	By default, the User Agent is sent (The default one unless changed)
+	 * Returns:
+	 *	0 on success, or
+	 *	-1 on error (previous value for agent remains unchanged)
+	 */
+int http_setUserAgent(const char *newAgent);
+
+	/*
+	 * Changes the Referer (shown to the web server with each request)
+	 *	Send it NULL to avoid thelling the server a Referer
+	 *	By default, no Referer is sent
+	 * Returns:
+	 *	0 on success, or
+	 *	-1 on error
+	 */
+int http_setReferer(const char *newReferer);
+
+	/*
+	 * Changes the maximum amount of time that HTTP Fetcher will wait on
+	 *	data.  If this many seconds elapses without more data from the
+	 *	server, http_fetch will return with an error.
+	 * If you pass a value less than 0, reads will not time out, potentially
+	 *	waiting forever (or until data shows up, whichever comes first)
+	 */
+void http_setTimeout(int seconds);
+
+	/*
+	 * Changes the number of HTTP redirects HTTP Fetcher will automatically
+	 *	follow.  If a request returns a status code of 3XX and contains
+	 *	a "Location:" field, the library will transparently follow up to
+	 *	the specified number of redirects.  With this implementation
+	 *	(which is just a stopgap, really) the caller won't be aware of any
+	 *	redirection and will assume the returned document came from the original
+	 *	URL.
+	 * To disable redirects, pass a 0.  To follow unlimited redirects (probably
+	 *  unwise), pass a negative value.  The default is to follow 3 redirects.
+	 */
+void http_setRedirects(int redirects);
+
+	/*
+	 * Takes a url and puts the filename portion of it into 'filename'.
+	 * Returns:
+	 *	0 on success, or
+	 *	1 when url contains no end filename (i.e., "www.foo.com/")
+	 *		and **filename should not be assumed to point to anything), or
+	 *	-1 on error
+	 */
+int http_parseFilename(const char *url, char **filename);
+
+	/*
+	 * Works like perror.  If an HTTP Fetcher function ever returns an
+	 *	error (-1), this will print a descriptive message to standard output
+	 */
+void http_perror(const char *string);
+
+	/*
+	 * Returns a pointer to the current error description message.  The
+	 *	message pointed to is only good until the next call to http_strerror(),
+	 *	so if you need to hold on to the message for a while you should make
+	 *	a copy of it.
+	 */
+const char *http_strerror();
+
+
+
+/******************************************************************************/
+/**** The following functions are used INTERNALLY by http_fetcher *************/
+/******************************************************************************/
+
+	/*
+	 * Reads the metadata of an HTTP response.  On success returns the number
+	 * Returns:
+	 *	# of bytes read on success, or
+	 *	-1 on error
+	 */
+int _http_read_header(int sock, char *headerPtr);
+
+	/*
+	 * Opens a TCP socket and returns the descriptor
+	 * Returns:
+	 *	socket descriptor, or
+	 *	-1 on error
+	 */
+int makeSocket(const char *host);
+
+	/*
+	 * Determines if the given NULL-terminated buffer is large enough to
+	 *	concatenate the given number of characters.  If not, it attempts to
+	 *	grow the buffer to fit.
+	 * Returns:
+	 *	0 on success, or
+	 *	-1 on error (original buffer is unchanged).
+	 */
+int _checkBufSize(char **buf, int *bufsize, int more);
+
+#endif
diff -Naur -x .svn rssreader-1.1.2-orig/i18n.c rssreader/i18n.c
--- rssreader-1.1.2-orig/i18n.c	1970-01-01 01:00:00.000000000 +0100
+++ rssreader/i18n.c	2009-02-02 17:42:19.000000000 +0100
@@ -0,0 +1,612 @@
+/*
+ * i18n.c: Internationalization
+ *
+ * See the README file for copyright information and how to reach the author.
+ *
+ * $Id: i18n.c 481 2005-06-02 00:12:13Z udo $
+ */
+
+#include "i18n.h"
+
+#if VDRVERSNUM < 10507
+const tI18nPhrase StreamplayerPhrases[] = {
+// START I18N - automatically generated by po2i18n.pl
+  { "<no date available>",
+    "<kein Datum vorhanden>",
+    "",
+    "",
+    "",
+    "",
+    "<pas de date disponible>",
+    "",
+    "<pivmr ei ole saatavilla>",
+    "",
+    "<Fecha no disponible>",
+    "",
+    "",
+    "",
+    "",
+    "",
+#if VDRVERSNUM >= 10302
+    "",
+#endif
+#if VDRVERSNUM >= 10307
+    "",
+#endif
+#if VDRVERSNUM >= 10313
+    "",
+#endif
+#if VDRVERSNUM >= 10316
+    "",
+#endif
+#if VDRVERSNUM >= 10342
+    "",
+#endif
+#if VDRVERSNUM >= 10502
+    "",
+#endif
+  },
+  { "<no description available>",
+    "<keine Beschreibung vorhanden>",
+    "",
+    "",
+    "",
+    "",
+    "<pas de dscriptif disponible>",
+    "",
+    "<kuvaus ei ole saatavilla>",
+    "",
+    "<Descripcin no disponible>",
+    "",
+    "",
+    "",
+    "",
+    "",
+#if VDRVERSNUM >= 10302
+    "",
+#endif
+#if VDRVERSNUM >= 10307
+    "",
+#endif
+#if VDRVERSNUM >= 10313
+    "",
+#endif
+#if VDRVERSNUM >= 10316
+    "",
+#endif
+#if VDRVERSNUM >= 10342
+    "",
+#endif
+#if VDRVERSNUM >= 10502
+    "",
+#endif
+  },
+  { "<no title available>",
+    "<kein Titel vorhanden>",
+    "",
+    "",
+    "",
+    "",
+    "<pas de titre disponible>",
+    "",
+    "<otsikko ei ole saatavilla>",
+    "",
+    "<Ttulo no disponible>",
+    "",
+    "",
+    "",
+    "",
+    "",
+#if VDRVERSNUM >= 10302
+    "",
+#endif
+#if VDRVERSNUM >= 10307
+    "",
+#endif
+#if VDRVERSNUM >= 10313
+    "",
+#endif
+#if VDRVERSNUM >= 10316
+    "",
+#endif
+#if VDRVERSNUM >= 10342
+    "",
+#endif
+#if VDRVERSNUM >= 10502
+    "",
+#endif
+  },
+  { "Can't download RSS stream!",
+    "Kann den RSS-Stream nicht laden!",
+    "",
+    "",
+    "",
+    "",
+    "Impossible de charger le flux!",
+    "",
+    "RSS-virtaa ei pystyt vastaanottamaan!",
+    "",
+    "Error descargando datos RSS!",
+    "",
+    "",
+    "",
+    "",
+    "",
+#if VDRVERSNUM >= 10302
+    "",
+#endif
+#if VDRVERSNUM >= 10307
+    "",
+#endif
+#if VDRVERSNUM >= 10313
+    "",
+#endif
+#if VDRVERSNUM >= 10316
+    "",
+#endif
+#if VDRVERSNUM >= 10342
+    "",
+#endif
+#if VDRVERSNUM >= 10502
+    "",
+#endif
+  },
+  { "Can't parse RSS stream!",
+    "Kann den RSS-Stream nicht parsen!",
+    "",
+    "",
+    "",
+    "",
+    "Impossible d'analyser le flux RSS!",
+    "",
+    "RSS-virtaa ei pystyt tulkkaamaan!",
+    "",
+    "Error leyendo datos RSS!",
+    "",
+    "",
+    "",
+    "",
+    "",
+#if VDRVERSNUM >= 10302
+    "",
+#endif
+#if VDRVERSNUM >= 10307
+    "",
+#endif
+#if VDRVERSNUM >= 10313
+    "",
+#endif
+#if VDRVERSNUM >= 10316
+    "",
+#endif
+#if VDRVERSNUM >= 10342
+    "",
+#endif
+#if VDRVERSNUM >= 10502
+    "",
+#endif
+  },
+  { "HTTP proxy server",
+    "HTTP Proxy Name",
+    "",
+    "",
+    "",
+    "",
+    "Nom du proxy HTTP",
+    "",
+    "HTTP-vlityspalvelimen osoite",
+    "",
+    "",
+    "",
+    "",
+    "",
+    "",
+    "",
+#if VDRVERSNUM >= 10302
+    "",
+#endif
+#if VDRVERSNUM >= 10307
+    "",
+#endif
+#if VDRVERSNUM >= 10313
+    "",
+#endif
+#if VDRVERSNUM >= 10316
+    "",
+#endif
+#if VDRVERSNUM >= 10342
+    "",
+#endif
+#if VDRVERSNUM >= 10502
+    "",
+#endif
+  },
+  { "Hide main menu entry",
+    "Hauptmeneintrag verstecken",
+    "",
+    "",
+    "",
+    "",
+    "Cacher le menu",
+    "",
+    "Piilota valinta pvalikosta",
+    "",
+    "Ocultar entrada en men principal",
+    "",
+    "",
+    "",
+    "",
+    "",
+#if VDRVERSNUM >= 10302
+    "",
+#endif
+#if VDRVERSNUM >= 10307
+    "",
+#endif
+#if VDRVERSNUM >= 10313
+    "",
+#endif
+#if VDRVERSNUM >= 10316
+    "",
+#endif
+#if VDRVERSNUM >= 10342
+    "",
+#endif
+#if VDRVERSNUM >= 10502
+    "",
+#endif
+  },
+  { "Hide non-existent elements",
+    "Nur vorhandene Elemente zeigen",
+    "",
+    "",
+    "",
+    "",
+    "N'afficher que les lments existants",
+    "",
+    "Piilota tyhjt elementit",
+    "",
+    "Ocultar elementos vacos",
+    "",
+    "",
+    "",
+    "",
+    "",
+#if VDRVERSNUM >= 10302
+    "",
+#endif
+#if VDRVERSNUM >= 10307
+    "",
+#endif
+#if VDRVERSNUM >= 10313
+    "",
+#endif
+#if VDRVERSNUM >= 10316
+    "",
+#endif
+#if VDRVERSNUM >= 10342
+    "",
+#endif
+#if VDRVERSNUM >= 10502
+    "",
+#endif
+  },
+  { "RSS Reader",
+    "RSS-Reader",
+    "",
+    "",
+    "",
+    "",
+    "Lecteur de flux RSS",
+    "",
+    "RSS-lukija",
+    "",
+    "Lector RSS",
+    "",
+    "",
+    "",
+    "",
+    "",
+#if VDRVERSNUM >= 10302
+    "",
+#endif
+#if VDRVERSNUM >= 10307
+    "",
+#endif
+#if VDRVERSNUM >= 10313
+    "",
+#endif
+#if VDRVERSNUM >= 10316
+    "",
+#endif
+#if VDRVERSNUM >= 10342
+    "",
+#endif
+#if VDRVERSNUM >= 10502
+    "",
+#endif
+  },
+  { "RSS Reader for OSD",
+    "RSS-Reader fr OSD",
+    "",
+    "",
+    "",
+    "",
+    "Lecteur RSS pour OSD",
+    "",
+    "RSS-lukija kuvaruutunytlle",
+    "",
+    "Lector RSS para OSD",
+    "",
+    "",
+    "",
+    "",
+    "",
+#if VDRVERSNUM >= 10302
+    "",
+#endif
+#if VDRVERSNUM >= 10307
+    "",
+#endif
+#if VDRVERSNUM >= 10313
+    "",
+#endif
+#if VDRVERSNUM >= 10316
+    "",
+#endif
+#if VDRVERSNUM >= 10342
+    "",
+#endif
+#if VDRVERSNUM >= 10502
+    "",
+#endif
+  },
+  { "RSS item",
+    "RSS-Artikel",
+    "",
+    "",
+    "",
+    "",
+    "Article RSS",
+    "",
+    "RSS-artikkeli",
+    "",
+    "RSS-Articulo",
+    "",
+    "",
+    "",
+    "",
+    "",
+#if VDRVERSNUM >= 10302
+    "",
+#endif
+#if VDRVERSNUM >= 10307
+    "",
+#endif
+#if VDRVERSNUM >= 10313
+    "",
+#endif
+#if VDRVERSNUM >= 10316
+    "",
+#endif
+#if VDRVERSNUM >= 10342
+    "",
+#endif
+#if VDRVERSNUM >= 10502
+    "",
+#endif
+  },
+  { "Select RSS item",
+    "Auswahl RSS-Artikel",
+    "",
+    "",
+    "",
+    "",
+    "Choix de article RSS",
+    "",
+    "Valitse RSS-artikkeli",
+    "",
+    "RSS-Articulo",
+    "",
+    "",
+    "",
+    "",
+    "",
+#if VDRVERSNUM >= 10302
+    "",
+#endif
+#if VDRVERSNUM >= 10307
+    "",
+#endif
+#if VDRVERSNUM >= 10313
+    "",
+#endif
+#if VDRVERSNUM >= 10316
+    "",
+#endif
+#if VDRVERSNUM >= 10342
+    "",
+#endif
+#if VDRVERSNUM >= 10502
+    "",
+#endif
+  },
+  { "Select RSS stream",
+    "Auswahl RSS-Stream",
+    "",
+    "",
+    "",
+    "",
+    "Choix des flux RSS",
+    "",
+    "Valitse RSS-virta",
+    "",
+    "Selecciona fuente RSS",
+    "",
+    "",
+    "",
+    "",
+    "",
+#if VDRVERSNUM >= 10302
+    "",
+#endif
+#if VDRVERSNUM >= 10307
+    "",
+#endif
+#if VDRVERSNUM >= 10313
+    "",
+#endif
+#if VDRVERSNUM >= 10316
+    "",
+#endif
+#if VDRVERSNUM >= 10342
+    "",
+#endif
+#if VDRVERSNUM >= 10502
+    "",
+#endif
+  },
+  { "Servidor proxy HTTP",
+    "",
+    "",
+    "",
+    "",
+    "",
+    "",
+    "",
+    "",
+    "",
+    "",
+    "",
+    "",
+    "",
+    "",
+    "",
+#if VDRVERSNUM >= 10302
+    "",
+#endif
+#if VDRVERSNUM >= 10307
+    "",
+#endif
+#if VDRVERSNUM >= 10313
+    "",
+#endif
+#if VDRVERSNUM >= 10316
+    "",
+#endif
+#if VDRVERSNUM >= 10342
+    "",
+#endif
+#if VDRVERSNUM >= 10502
+    "",
+#endif
+  },
+  { "Unknown error!",
+    "Unbekannt Fehler!",
+    "",
+    "",
+    "",
+    "",
+    "Erreur inconnue",
+    "",
+    "Tuntematon virhe!",
+    "",
+    "Error desconocido!",
+    "",
+    "",
+    "",
+    "",
+    "",
+#if VDRVERSNUM >= 10302
+    "",
+#endif
+#if VDRVERSNUM >= 10307
+    "",
+#endif
+#if VDRVERSNUM >= 10313
+    "",
+#endif
+#if VDRVERSNUM >= 10316
+    "",
+#endif
+#if VDRVERSNUM >= 10342
+    "",
+#endif
+#if VDRVERSNUM >= 10502
+    "",
+#endif
+  },
+  { "Use HTTP proxy server",
+    "HTTP Proxy benutzen",
+    "",
+    "",
+    "",
+    "",
+    "Utiliser le Proxy HTTP",
+    "",
+    "Kyt HTTP-vlityspalvelinta",
+    "",
+    "Usar servidor proxy HTTP",
+    "",
+    "",
+    "",
+    "",
+    "",
+#if VDRVERSNUM >= 10302
+    "",
+#endif
+#if VDRVERSNUM >= 10307
+    "",
+#endif
+#if VDRVERSNUM >= 10313
+    "",
+#endif
+#if VDRVERSNUM >= 10316
+    "",
+#endif
+#if VDRVERSNUM >= 10342
+    "",
+#endif
+#if VDRVERSNUM >= 10502
+    "",
+#endif
+  },
+  { "Loading RSS stream...",
+    "",
+    "",
+    "",
+    "",
+    "",
+    "",
+    "",
+    "",
+    "",
+    "Cargando elemento RSS",
+    "",
+    "",
+    "",
+    "",
+    "",
+#if VDRVERSNUM >= 10302
+    "",
+#endif
+#if VDRVERSNUM >= 10307
+    "",
+#endif
+#if VDRVERSNUM >= 10313
+    "",
+#endif
+#if VDRVERSNUM >= 10316
+    "",
+#endif
+#if VDRVERSNUM >= 10342
+    "",
+#endif
+#if VDRVERSNUM >= 10502
+    "",
+#endif
+  },
+// END I18N - automatically generated by po2i18n.pl
+  { NULL }
+  };
+#endif
diff -Naur -x .svn rssreader-1.1.2-orig/i18n.h rssreader/i18n.h
--- rssreader-1.1.2-orig/i18n.h	1970-01-01 01:00:00.000000000 +0100
+++ rssreader/i18n.h	2009-02-02 17:42:19.000000000 +0100
@@ -0,0 +1,18 @@
+/*
+ * i18n.h: Internationalization
+ *
+ * See the README file for copyright information and how to reach the author.
+ *
+ * $Id: i18n.h 481 2005-06-02 00:12:13Z udo $
+ */
+
+#ifndef __STREAMPLAYER_I18N_H
+#define __STREAMPLAYER_I18N_H
+
+#include <vdr/i18n.h>
+
+#if VDRVERSNUM < 10507
+extern const tI18nPhrase StreamplayerPhrases[];
+#endif
+
+#endif //_I18N__H
diff -Naur -x .svn rssreader-1.1.2-orig/i18n-template.c rssreader/i18n-template.c
--- rssreader-1.1.2-orig/i18n-template.c	1970-01-01 01:00:00.000000000 +0100
+++ rssreader/i18n-template.c	2009-02-02 17:42:19.000000000 +0100
@@ -0,0 +1,17 @@
+/*
+ * i18n.c: Internationalization
+ *
+ * See the README file for copyright information and how to reach the author.
+ *
+ * $Id: i18n.c 481 2005-06-02 00:12:13Z udo $
+ */
+
+#include "i18n.h"
+
+#if VDRVERSNUM < 10507
+const tI18nPhrase StreamplayerPhrases[] = {
+// START I18N
+// END I18N
+  { NULL }
+  };
+#endif
diff -Naur -x .svn rssreader-1.1.2-orig/Makefile rssreader/Makefile
--- rssreader-1.1.2-orig/Makefile	2009-02-02 17:41:49.000000000 +0100
+++ rssreader/Makefile	2009-02-02 17:42:19.000000000 +0100
@@ -26,14 +26,10 @@
 
 ### The directory environment:
 
-VDRDIR = ../../..
-LIBDIR = ../../lib
+VDRDIR ?= ../../..
+LIBDIR ?= ../../lib
 TMPDIR = /tmp
 
-### Libraries
-
-LIBS = -lexpat -lcurl
-
 ### Allow user defined options to overwrite defaults:
 
 -include $(VDRDIR)/Make.config
@@ -49,7 +45,8 @@
 
 ### Includes and Defines (add further entries here):
 
-INCLUDES += -I$(VDRDIR)/include
+INCLUDES += -I$(VDRDIR)/include 
+
 
 DEFINES += -D_GNU_SOURCE -DPLUGIN_NAME_I18N='"$(PLUGIN)"'
 
@@ -59,17 +56,24 @@
 
 ### The object files (add further files here):
 
-OBJS = rssreader.o parser.o menu.o config.o tools.o
+OBJS =  http_error_codes.o http_fetcher.o ezxml.o rssreader.o parser.o menu.o config.o tools.o compatibility.o i18n.o
 
 ### The main target:
 
-all: libvdr-$(PLUGIN).so i18n
+all: libvdr-$(PLUGIN).so 
+#i18n
 
 ### Implicit rules:
 
 %.o: %.c
 	$(CXX) $(CXXFLAGS) -c $(DEFINES) $(INCLUDES) $<
 
+
+#i18n compatibility generator:
+#i18n.c: i18n-template.c po2i18n.pl
+#	./po2i18n.pl < i18n-template.c > i18n.c
+
+
 # Dependencies:
 
 MAKEDEP = $(CXX) -MM -MG
@@ -81,28 +85,28 @@
 
 ### Internationalization (I18N):
 
-PODIR     = po
-LOCALEDIR = $(VDRDIR)/locale
-I18Npo    = $(wildcard $(PODIR)/*.po)
-I18Nmo    = $(addsuffix .mo, $(foreach file, $(I18Npo), $(basename $(file))))
-I18Ndirs  = $(notdir $(foreach file, $(I18Npo), $(basename $(file))))
-I18Npot   = $(PODIR)/$(PLUGIN).pot
-
-%.mo: %.po
-	msgfmt -c -o $@ $<
-
-$(I18Npot): $(wildcard *.c)
-	xgettext -C -cTRANSLATORS --no-wrap --no-location -k -ktr -ktrNOOP --msgid-bugs-address='Rolf Ahrenberg' -o $@ $(wildcard *.c)
-
-$(I18Npo): $(I18Npot)
-	msgmerge -U --no-wrap --no-location --backup=none -q $@ $<
-
-i18n: $(I18Npot) $(I18Nmo)
-	@mkdir -p $(LOCALEDIR)
-	for i in $(I18Ndirs); do\
-	    mkdir -p $(LOCALEDIR)/$$i/LC_MESSAGES;\
-	    cp $(PODIR)/$$i.mo $(LOCALEDIR)/$$i/LC_MESSAGES/vdr-$(PLUGIN).mo;\
-	    done
+#PODIR     = po
+#LOCALEDIR = $(VDRDIR)/locale
+#I18Npo    = $(wildcard $(PODIR)/*.po)
+#I18Nmo    = $(addsuffix .mo, $(foreach file, $(I18Npo), $(basename $(file))))
+#I18Ndirs  = $(notdir $(foreach file, $(I18Npo), $(basename $(file))))
+#I18Npot   = $(PODIR)/$(PLUGIN).pot
+#
+#%.mo: %.po
+#	msgfmt -c -o $@ $<
+#
+#$(I18Npot): $(wildcard *.c)
+#	xgettext -C -cTRANSLATORS --no-wrap --no-location -k -ktr -ktrNOOP --msgid-bugs-address='Rolf Ahrenberg' -o $@ $(wildcard *.c)
+#
+#$(I18Npo): $(I18Npot)
+#	msgmerge -U --no-wrap --no-location --backup=none -q $@ $<
+#
+#i18n: $(I18Npot) $(I18Nmo)
+#	@mkdir -p $(LOCALEDIR)
+#	for i in $(I18Ndirs); do\
+#	    mkdir -p $(LOCALEDIR)/$$i/LC_MESSAGES;\
+#	    cp $(PODIR)/$$i.mo $(LOCALEDIR)/$$i/LC_MESSAGES/vdr-$(PLUGIN).mo;\
+#	    done
 
 ### Targets:
 
diff -Naur -x .svn rssreader-1.1.2-orig/menu.c rssreader/menu.c
--- rssreader-1.1.2-orig/menu.c	2009-02-02 17:41:49.000000000 +0100
+++ rssreader/menu.c	2009-02-02 17:42:19.000000000 +0100
@@ -66,7 +66,7 @@
            (*Title       || !RssConfig.hideelem) ? "\n\n" : "",
            *Description  ? strdup(Description)   : RssConfig.hideelem ? "" : tr("<no description available>"),
            (*Description || !RssConfig.hideelem) ? "\n\n" : "",
-           *Link         ? strdup(Link)          : RssConfig.hideelem ? "" : tr("<no link available>"));
+           *Link         ? strdup("")          : RssConfig.hideelem ? "" : "");
 }
 
 cRssMenuItem::~cRssMenuItem()
@@ -168,7 +168,10 @@
      debug("cRssStreamsMenu::Select(): downloading and parsing '%s'", rssItem->Title());
      // the following message generates an annoying slowdown 
      //Skins.Message(mtInfo, tr("Loading RSS stream..."));
-     switch (Parser.DownloadAndParse(rssItem->Url())) {
+     SetStatus(tr("Loading RSS stream..."));
+     int result = Parser.DownloadAndParse(rssItem->Url());
+     SetStatus(NULL);
+     switch (result) {
        case (cParser::RSS_PARSING_OK):
             return AddSubMenu(new cRssItemsMenu);
        case (cParser::RSS_PARSING_ERROR):
@@ -182,6 +185,7 @@
             Skins.Message(mtError, tr("Unknown error!"));
             return osContinue;
        }
+       
      }
   return osEnd;
 }
diff -Naur -x .svn rssreader-1.1.2-orig/parser.c rssreader/parser.c
--- rssreader-1.1.2-orig/parser.c	2009-02-02 17:41:49.000000000 +0100
+++ rssreader/parser.c	2009-02-02 17:42:19.000000000 +0100
@@ -6,21 +6,13 @@
  * $Id$
  */
 
-#include <stack>
-#include <curl/curl.h>
-#include <curl/types.h>
-#include <curl/easy.h>
 #include <vdr/config.h>
 #include "common.h"
 #include "config.h"
 #include "tools.h"
 #include "parser.h"
-
-#include <expat.h>
-#define LIBEXPAT_VERSION(a,b,c) (((a) << 16) + ((b) << 8) + (c))
-#if LIBEXPAT_VERSION(XML_MAJOR_VERSION, XML_MINOR_VERSION, XML_MICRO_VERSION) < LIBEXPAT_VERSION(1, 95, 8)
-#warning "Expat XML parser library 1.95.8 or newer required!"
-#endif
+#include "http_fetcher.h"
+#include "ezxml.h"
 
 // --- Globals ----------------------------------------------------------
 
@@ -28,179 +20,48 @@
 
 // --- cItem(s) ---------------------------------------------------------
 
-cItem::cItem()
-: conv("UTF-8", cCharSetConv::SystemCharacterTable())
+cItem::cItem(const char *e): conv(e,DEFAULT_ENCONDING)
 {
-  strcpy(date, "");
-  strcpy(title, "");
-  strcpy(link, "");
-  strcpy(description, "");
+	debug("CItem::cItem [%s,%s]",e,DEFAULT_ENCONDING);
 }
 
 
 void cItem::Clear(void)
-{
-  strcpy(date, "");
-  strcpy(title, "");
-  strcpy(link, "");
-  strcpy(description, "");
+{  
+  debug("CItem::Clear [%s]",title.c_str());
+  date.clear();
+  title.clear();
+  link.clear();
+  description.clear();
 }
 
 void cItem::SetDate(const char *str)
 {
-  Utf8Strn0Cpy(date, str, sizeof(date));
-  compactspace(date);
-  Utf8Strn0Cpy(date, conv.Convert(date), sizeof(date));
+  date = conv.Convert(str);
+  striphtml(date);
 }
 
 void cItem::SetTitle(const char *str)
 {
-  Utf8Strn0Cpy(title, str, sizeof(title));
-  compactspace(title);
+  title = conv.Convert(str);
   striphtml(title);
-  Utf8Strn0Cpy(title, conv.Convert(title), sizeof(title));
 }
 
 void cItem::SetLink(const char *str)
 {
-  Utf8Strn0Cpy(link, str, sizeof(link));
-  compactspace(link);
-  Utf8Strn0Cpy(link, conv.Convert(link), sizeof(link));
+  link = conv.Convert(str);
+  striphtml(link);
 }
 
 void cItem::SetDescription(const char *str)
 {
-  Utf8Strn0Cpy(description, str, sizeof(description));
-  compactspace(description);
+  description = conv.Convert(str);
   striphtml(description);
-  Utf8Strn0Cpy(description, conv.Convert(description), sizeof(description));
 }
 
-// --- Parse RSS  -------------------------------------------------------
-
-struct XmlNode {
-  char nodename[SHORT_TEXT_LEN];
-  int  depth;
-};
-
-cItem *item = NULL;
-int depth = 0;
-char data_string[LONG_TEXT_LEN];
-std::stack<struct XmlNode> nodestack;
 
-static int XMLCALL UnknownEncodingHandler(void *data,const XML_Char *encoding, XML_Encoding *info)
-{
-  if (strcmp(encoding, "iso-8859-15") == 0) {
-     int i;
-     for (i = 0; i < 256; ++i)
-        info->map[i] = i;
-     info->data = NULL;
-     info->convert = NULL;
-     info->release = NULL;
-     return XML_STATUS_OK;
-     }
-  return XML_STATUS_ERROR;
-}
-
-static void XMLCALL StartHandler(void *data, const char *el, const char **attr)
-{
-  XmlNode node;
-
-  strn0cpy(node.nodename, el, sizeof(node.nodename));
-  node.depth = depth;
-  nodestack.push(node);
-
-  if (!strncmp(el, "item", 4)) {
-     cItem *tmpitem = new cItem;
-     item = tmpitem;
-     item->Clear();
-     }
-  depth++;
-}
-
-static void XMLCALL EndHandler(void *data, const char *el)
-{
-  char parent[SHORT_TEXT_LEN];
-  
-  if (nodestack.size() > 1) {
-     nodestack.pop();
-     } 
-  else {
-     nodestack.pop();
-     return;
-     }
-  strn0cpy(parent, (nodestack.top()).nodename, sizeof((nodestack.top()).nodename));
-  // No need to free the node
-  
-  depth--;
-  if (!strncmp(el, "item", 4)) {
-     // End of the current item
-     if (*item->GetTitle())
-        Parser.Items.Add(item);
-     }
-  else if (!strncmp(el, "title", 5)) {
-     if (!strncmp(parent, "item", 4)) {
-        item->SetTitle(data_string);
-        }
-     else if (!strncmp(parent, "channel", 7)) {
-        debug("cParser::EndHandler(): RSS title '%s'", data_string);
-        }
-     }
-  else if (!strncmp(el, "link", 4)) {
-     if (!strncmp(parent, "item", 4)) {
-        item->SetLink(data_string);
-        }
-     else if (!strncmp(parent, "channel", 7)) {
-        debug("cParser::EndHandler(): RSS link '%s'", data_string);
-        }
-     }
-  else if (!strncmp(el, "pubDate", 7)) {
-     if (!strncmp(parent, "item", 4)) {
-        item->SetDate(data_string);
-        }
-     else if (!strncmp(parent, "channel", 7)) {
-        debug("cParser::EndHandler(): RSS date '%s'", data_string);
-        }
-     }
-  else if (!strncmp(el, "description", 11)) {
-     if (!strncmp(parent, "item", 4)) {
-        item->SetDescription(data_string);
-        }
-     else if (!strncmp(parent, "channel", 7)) {
-        debug("cParser::EndHandler(): RSS description '%s'", data_string);
-        }
-     }
-  else if (!strncmp(el, "content:encoded", 15)) {
-     if (!strncmp(parent, "item", 4)) {
-        item->SetDescription(data_string); // overdrive description with content:encoded !
-        }
-     else if (!strncmp(parent, "channel", 7)) {
-        debug("cParser::EndHandler(): RSS content '%s'", data_string);
-        }
-     }
-  strcpy(data_string, "");
-}
-
-static void DataHandler(void *user_data, const XML_Char *s, int len)
-{
-  /* Only until the maximum size of the buffer */
-  if (strlen(data_string) + len <= LONG_TEXT_LEN)
-     strncat(data_string, s, len);
-}
+// --- Parse RSS  -------------------------------------------------------
 
-static size_t WriteMemoryCallback(void *ptr, size_t size, size_t nmemb, void *data)
-{
-  size_t realsize = size * nmemb;
-  struct MemoryStruct *mem = (struct MemoryStruct *)data;
-
-  mem->memory = (char *)myrealloc(mem->memory, mem->size + realsize + 1);
-  if (mem->memory) {
-     memcpy(&(mem->memory[mem->size]), ptr, realsize);
-     mem->size += realsize;
-     mem->memory[mem->size] = 0;
-     }
-  return realsize;
-}
 
 cParser::cParser()
 {
@@ -217,65 +78,40 @@
      }
 }
 
+
 int cParser::DownloadAndParse(const char *url)
 {
-  CURL *curl_handle;
 
-  // Clear Items list and initialize depth
+  // Clear Items list 
+  debug ("cParser::DownloadAndParse: entrando  %s",url);
   Items.Clear();
-  depth = 0;
+  debug ("cParser::DownloadAndParse: borrando  %s",url);
   if (data.memory)
      free(data.memory);
   data.memory = NULL;
   data.size = 0;
 
-  // Init the curl session
-  curl_global_init(CURL_GLOBAL_ALL);
-  curl_handle = curl_easy_init();
-
-  // Specify URL to get
-  curl_easy_setopt(curl_handle, CURLOPT_URL, url);
-
-  // Specify HTTP proxy: my.proxy.com:80
-  if (RssConfig.useproxy) {
-     curl_easy_setopt(curl_handle, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);
-     curl_easy_setopt(curl_handle, CURLOPT_PROXY, RssConfig.httpproxy);
-     }
-
-  // Send all data to this function
-  curl_easy_setopt(curl_handle, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);
-
-  // Set maximum file size to get (bytes)
-  curl_easy_setopt(curl_handle, CURLOPT_MAXFILESIZE, 1048576);
-
-  // No progress meter
-  curl_easy_setopt(curl_handle, CURLOPT_NOPROGRESS, 1);
-
-  // No signaling
-  curl_easy_setopt(curl_handle, CURLOPT_NOSIGNAL, 1);
-
-  // Set timeout to 30 seconds
-  curl_easy_setopt(curl_handle, CURLOPT_TIMEOUT, 30);
-
-  // Pass our 'data' struct to the callback function
-  curl_easy_setopt(curl_handle, CURLOPT_WRITEDATA, (void *)&data);
+  debug ("cParser::DownloadAndParse: Init download %s",url);
 
   // Some servers don't like requests that are made without a user-agent field
-  curl_easy_setopt(curl_handle, CURLOPT_USERAGENT, RSSREADER_USERAGENT);
+  http_setUserAgent(RSSREADER_USERAGENT);
+  // Set timeout to 30 seconds  
+  http_setTimeout(30);
+
+  data.size = http_fetch(url, &(data.memory));	/* Downloads page */
+  debug("End download %s +%d",url,(int)data.size);
+  if( (int)data.size == -1) {				/* All HTTP Fetcher functions return */
+	http_perror("http_fetch");		/*	-1 on error. */
+	error("cParser::DownloadAndParse(): couldn't download the stream: %s",http_strerror());
+	if (data.memory) {
+	        free(data.memory);
+	        data.memory = NULL;
+	        data.size = 0;
+        }
+     	return (RSS_DOWNLOAD_ERROR);
+  }
+	
 
-  // Get it!
-  if (curl_easy_perform(curl_handle) != 0) {
-     // Cleanup curl stuff
-     curl_easy_cleanup(curl_handle);
-     // Free allocated memory
-     if (data.memory) {
-        free(data.memory);
-        data.memory = NULL;
-        data.size = 0;
-        }
-     error("cParser::DownloadAndParse(): couldn't download the stream");
-     return (RSS_DOWNLOAD_ERROR);
-     }
 
   if (data.size) {
 #ifdef DEBUG
@@ -286,47 +122,101 @@
         fclose(fp);
         }
 #endif
-     // Setup expat
-     XML_Parser p = XML_ParserCreate(NULL);
-     if (!p) {
-        // Cleanup curl stuff
-        curl_easy_cleanup(curl_handle);
-        // Free allocated memory
-        if (data.memory) {
-           free(data.memory);
-           data.memory = NULL;
-           data.size = 0;
-           }
-        error("cParser::DownloadAndParse(): couldn't allocate memory for parser");
-        return (RSS_UNKNOWN_ERROR);
-        }
-     XML_SetElementHandler(p, StartHandler, EndHandler);
-     XML_SetCharacterDataHandler(p, DataHandler);
-     XML_SetUnknownEncodingHandler(p, UnknownEncodingHandler, NULL);
-
-     if (XML_Parse(p, data.memory, data.size, 1) == XML_STATUS_ERROR) {
-        // Cleanup curl stuff
-        curl_easy_cleanup(curl_handle);
-        // Free allocated memory
-        if (data.memory) {
-           free(data.memory);
-           data.memory = NULL;
-           data.size = 0;
-           }
-        error("cParser::DownloadAndParse(): Parse error at line %ld:\n%s\n", XML_GetCurrentLineNumber(p), XML_ErrorString(XML_GetErrorCode(p)));
-        return (RSS_PARSING_ERROR);
-        }
-     }
-
-  // Cleanup curl stuff
-  curl_easy_cleanup(curl_handle);
+  //Get encoding
+  SetEncoding(data.memory);
+  debug("cParser::DownloadAndParse(): enconding [%s]",encoding);
+
+	ezxml_t f1 = ezxml_parse_str(data.memory,data.size);
+
+	if ( f1 == NULL ) {
+		// Free allocated memory
+		if (data.memory) {
+		   free(data.memory);
+		   data.memory = NULL;
+		   data.size = 0;
+		   }
+		error("cParser::DownloadAndParse(): Parse error ");
+        	return (RSS_PARSING_ERROR);
+	}else {
+		int rss_rdf=1; //rss - 1 , rdf - 0
+		debug("cParser::DownloadAndParse(): Parse ok ");
+    
+    
+
+		ezxml_t node = NULL;
+		ezxml_t child = NULL;
+		debug("cParser::DownloadAndParse(): root node [%s]",ezxml_name(f1));
+		if ( !strcmp(ezxml_name(f1),"rdf:RDF") ) {				
+			rss_rdf=0;
+		} 
+		if ( rss_rdf ) {
+			node = ezxml_get(f1,"channel",0,"item",-1);
+		}else {
+			node = ezxml_get(f1,"item",-1);
+		}
+		if (node == NULL ) {
+			// Free allocated memory
+			if (data.memory) {
+			   free(data.memory);
+			   data.memory = NULL;
+			   data.size = 0;
+			   }
+			error("cParser::DownloadAndParse(): Parse error file");
+			return (RSS_PARSING_ERROR);
+		}else {
+		}
+		
+		for (; node != NULL; node = node->next) {
+			debug("cParser::DownloadAndParse(): item?");
+			child=ezxml_child(node,"title");
+			if (child !=NULL ) {
+				debug("cParser::DownloadAndParse(): Read item [%s]",ezxml_txt(child));
+				cItem *pitem = new cItem(encoding); 			
+        
+				Parser.Items.Add(pitem);			
+
+				pitem->SetTitle(ezxml_txt(child)) ;			
+
+				if ( rss_rdf ) {
+					child = ezxml_child(node,"pubDate");
+				} else {
+					child = ezxml_child(node,"dc:date");
+				}
+				pitem->SetDate(ezxml_txt(child));		
+				child = ezxml_child(node,"description");				
+				pitem->SetDescription(ezxml_txt(child));
+
+				child = ezxml_child(node,"content:encoded");
+				if ( child) pitem->SetDescription(ezxml_txt(child)); // overdrive description with content:encoded !
+		
+			}
+		
+		}
+		// Free memory
+		ezxml_free (f1);
+	}
+  }
+	
   // Free allocated memory
   if (data.memory) {
-     free(data.memory);
+     free(data.memory);	
      data.memory = NULL;
      data.size = 0;
      }
-
+  debug("cParser::DownloadAndParse(): Parsing OK");
   return (RSS_PARSING_OK);
 }
 
+void cParser::SetEncoding(const char *str) {
+  char *aux;
+  int len=0,ini=0;
+  if ((aux=strstr(str, "encoding")))  {
+     ini= strspn(aux + 8," ='\"") + 8;
+     len= strcspn(aux + ini , "'\"");
+     debug("[%s] %d %d\n",aux+ini,ini,len);
+     strn0cpy(encoding, aux+ini, sizeof(char)*(len+1));
+  } else {
+     strn0cpy(encoding,"UTF-8", sizeof(char)*(6+1));
+  }
+  debug("Encoding [%s]\n",encoding);
+}  
diff -Naur -x .svn rssreader-1.1.2-orig/parser.h rssreader/parser.h
--- rssreader-1.1.2-orig/parser.h	2009-02-02 17:41:49.000000000 +0100
+++ rssreader/parser.h	2009-02-02 17:42:19.000000000 +0100
@@ -10,6 +10,10 @@
 #define __RSSREADER_PARSER_H
 
 #include "common.h"
+#include "compatibility.h"
+#include <string>
+
+using namespace std;
 
 // --- Defines ----------------------------------------------------------
 
@@ -19,23 +23,25 @@
 // --- cItem(s) ---------------------------------------------------------
 
 class cItem : public cListObject {
+	
 private:
   cCharSetConv conv;
-  char date[SHORT_TEXT_LEN];
-  char title[SHORT_TEXT_LEN];
-  char link[SHORT_TEXT_LEN];
-  char description[LONG_TEXT_LEN];
+  string date;
+  string title;
+  string link;
+  string description; 
 public:
-  cItem();
+  cItem(const char *e);
+//  ~cItem(){debug ("destruir citem [%s]",title.c_str());};
   void Clear(void);
-  char *GetDate(void) { return date; }
-  char *GetTitle(void) { return title; }
-  char *GetLink(void) { return link; }
-  char *GetDescription(void)  { return description; }
+  const char *GetDate(void) { return date.c_str(); }
+  const char *GetTitle(void) { return title.c_str(); }
+  const char *GetLink(void) { return link.c_str(); }
+  const char *GetDescription(void)  { return description.c_str(); }
   void SetDate(const char *str);
   void SetTitle(const char *str);
   void SetLink(const char *str);
-  void SetDescription(const char *str);
+  void SetDescription(const char *str);  
 };
 
 class cItems : public cList<cItem> {
@@ -53,6 +59,8 @@
 class cParser {
 private:
   struct MemoryStruct data;
+  char encoding[SHORT_TEXT_LEN];
+  void SetEncoding(const char *str);
 public:
   enum {
     RSS_PARSING_OK     =  0,
diff -Naur -x .svn rssreader-1.1.2-orig/po/de_DE.po rssreader/po/de_DE.po
--- rssreader-1.1.2-orig/po/de_DE.po	2009-02-02 17:41:49.000000000 +0100
+++ rssreader/po/de_DE.po	2009-02-02 17:42:19.000000000 +0100
@@ -7,7 +7,7 @@
 msgstr ""
 "Project-Id-Version: VDR 1.5.7\n"
 "Report-Msgid-Bugs-To: Rolf Ahrenberg\n"
-"POT-Creation-Date: 2007-08-28 23:51+0300\n"
+"POT-Creation-Date: 2007-12-22 13:05+0100\n"
 "PO-Revision-Date: 2007-08-12 21:33+0300\n"
 "Last-Translator: Walter Koch\n"
 "Language-Team: <vdr@linuxtv.org>\n"
@@ -27,9 +27,6 @@
 msgid "<no description available>"
 msgstr "<keine Beschreibung vorhanden>"
 
-msgid "<no link available>"
-msgstr "<kein Link vorhanden>"
-
 msgid "Select RSS item"
 msgstr "Auswahl RSS-Artikel"
 
@@ -62,3 +59,6 @@
 
 msgid "HTTP proxy server"
 msgstr "HTTP Proxy Name"
+
+#~ msgid "<no link available>"
+#~ msgstr "<kein Link vorhanden>"
diff -Naur -x .svn rssreader-1.1.2-orig/po/es_ES.po rssreader/po/es_ES.po
--- rssreader-1.1.2-orig/po/es_ES.po	1970-01-01 01:00:00.000000000 +0100
+++ rssreader/po/es_ES.po	2009-02-02 17:42:19.000000000 +0100
@@ -0,0 +1,65 @@
+# VDR plugin language source file.
+# Copyright (C) 2007 Klaus Schmidinger <kls@cadsoft.de>
+# This file is distributed under the same license as the VDR package.
+# Siegfried Dngler
+# Walter Koch
+msgid ""
+msgstr ""
+"Project-Id-Version: VDR 1.5.7\n"
+"Report-Msgid-Bugs-To: Rolf Ahrenberg\n"
+"POT-Creation-Date: 2007-12-22 19:09+0100\n"
+"PO-Revision-Date: 2007-08-12 21:33+0300\n"
+"Last-Translator: Walter Koch\n"
+"Language-Team: <vdr@linuxtv.org>\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=ISO-8859-15\n"
+"Content-Transfer-Encoding: 8bit\n"
+
+msgid "RSS item"
+msgstr "RSS-Articulo"
+
+msgid "<no date available>"
+msgstr "<Fecha no disponible>"
+
+msgid "<no title available>"
+msgstr "<Ttulo no disponible>"
+
+msgid "<no description available>"
+msgstr "<Descripcin no disponible>"
+
+#, fuzzy
+msgid "Select RSS item"
+msgstr "RSS-Articulo"
+
+msgid "Select RSS stream"
+msgstr "Selecciona fuente RSS"
+
+#, fuzzy
+msgid "Can't parse RSS stream!"
+msgstr "Error leyendo datos RSS!"
+
+#, fuzzy
+msgid "Can't download RSS stream!"
+msgstr "Error descargando datos RSS!"
+
+msgid "Unknown error!"
+msgstr "Error desconocido!"
+
+msgid "RSS Reader for OSD"
+msgstr "Lector RSS para OSD"
+
+msgid "RSS Reader"
+msgstr "Lector RSS"
+
+msgid "Hide main menu entry"
+msgstr "Ocultar entrada en men principal"
+
+msgid "Hide non-existent elements"
+msgstr "Ocultar elementos vacos"
+
+msgid "Use HTTP proxy server"
+msgstr "Usar servidor proxy HTTP"
+
+#, fuzzy
+msgid "HTTP proxy server"
+msgstr "Usar servidor proxy HTTP"
diff -Naur -x .svn rssreader-1.1.2-orig/po/fi_FI.po rssreader/po/fi_FI.po
--- rssreader-1.1.2-orig/po/fi_FI.po	2009-02-02 17:41:49.000000000 +0100
+++ rssreader/po/fi_FI.po	2009-02-02 17:42:19.000000000 +0100
@@ -6,7 +6,7 @@
 msgstr ""
 "Project-Id-Version: VDR 1.5.7\n"
 "Report-Msgid-Bugs-To: Rolf Ahrenberg\n"
-"POT-Creation-Date: 2007-08-28 23:51+0300\n"
+"POT-Creation-Date: 2007-12-22 13:05+0100\n"
 "PO-Revision-Date: 2007-08-12 18:35+0300\n"
 "Last-Translator: Rolf Ahrenberg\n"
 "Language-Team: <vdr@linuxtv.org>\n"
@@ -26,9 +26,6 @@
 msgid "<no description available>"
 msgstr "<kuvaus ei ole saatavilla>"
 
-msgid "<no link available>"
-msgstr "<linkki ei ole saatavilla>"
-
 msgid "Select RSS item"
 msgstr "Valitse RSS-artikkeli"
 
@@ -61,3 +58,6 @@
 
 msgid "HTTP proxy server"
 msgstr "HTTP-vlityspalvelimen osoite"
+
+#~ msgid "<no link available>"
+#~ msgstr "<linkki ei ole saatavilla>"
diff -Naur -x .svn rssreader-1.1.2-orig/po/fr_FR.po rssreader/po/fr_FR.po
--- rssreader-1.1.2-orig/po/fr_FR.po	2009-02-02 17:41:49.000000000 +0100
+++ rssreader/po/fr_FR.po	2009-02-02 17:42:19.000000000 +0100
@@ -6,7 +6,7 @@
 msgstr ""
 "Project-Id-Version: VDR 1.5.7\n"
 "Report-Msgid-Bugs-To: Rolf Ahrenberg\n"
-"POT-Creation-Date: 2007-08-28 23:51+0300\n"
+"POT-Creation-Date: 2007-12-22 13:05+0100\n"
 "PO-Revision-Date: 2007-08-12 21:33+0300\n"
 "Last-Translator: Patrice Staudt\n"
 "Language-Team: <vdr@linuxtv.org>\n"
@@ -26,9 +26,6 @@
 msgid "<no description available>"
 msgstr "<pas de dscriptif disponible>"
 
-msgid "<no link available>"
-msgstr "<pas de lien disponible>"
-
 msgid "Select RSS item"
 msgstr "Choix de article RSS"
 
@@ -61,3 +58,6 @@
 
 msgid "HTTP proxy server"
 msgstr "Nom du proxy HTTP"
+
+#~ msgid "<no link available>"
+#~ msgstr "<pas de lien disponible>"
diff -Naur -x .svn rssreader-1.1.2-orig/po2i18n.pl rssreader/po2i18n.pl
--- rssreader-1.1.2-orig/po2i18n.pl	1970-01-01 01:00:00.000000000 +0100
+++ rssreader/po2i18n.pl	2009-02-02 17:42:19.000000000 +0100
@@ -0,0 +1,134 @@
+#!/usr/bin/perl
+
+use strict;
+use warnings;
+
+my @LANGS = (
+  "en_US",
+  "de_DE",
+  "sl_SI",
+  "it_IT",
+  "nl_NL",
+  "pt_PT",
+  "fr_FR",
+  "nn_NO",
+  "fi_FI",
+  "pl_PL",
+  "es_ES",
+  "el_GR",
+  "sv_SE",
+  "ro_RO",
+  "hu_HU",
+  "ca_ES",
+  "ru_RU",
+  "hr_HR",
+  "et_EE",
+  "da_DK",
+  "cs_CZ",
+  "tr_TR"
+  );
+
+my %VERS = (
+  "en_US" => 10200,
+  "de_DE" => 10200,
+  "sl_SI" => 10200,
+  "it_IT" => 10200,
+  "nl_NL" => 10200,
+  "pt_PT" => 10200,
+  "fr_FR" => 10200,
+  "nn_NO" => 10200,
+  "fi_FI" => 10200,
+  "pl_PL" => 10200,
+  "es_ES" => 10200,
+  "el_GR" => 10200,
+  "sv_SE" => 10200,
+  "ro_RO" => 10200,
+  "hu_HU" => 10200,
+  "ca_ES" => 10200,
+  "ru_RU" => 10302,
+  "hr_HR" => 10307,
+  "et_EE" => 10313,
+  "da_DK" => 10316,
+  "cs_CZ" => 10342,
+  "tr_TR" => 10502
+  );
+
+
+my %strings;
+
+foreach my $lang (@LANGS) { $strings{$lang} = { }; }
+
+
+sub LoadLanguage(*) {
+    my ($lang) = @_;
+    
+    if (!open FILE, "<", "po/$lang.po") {
+        return 0;   
+    }
+    
+    my $msgid = "";
+    while (<FILE>) {
+        chomp;
+        my $line = $_;
+        
+        if ($line =~ /^msgid "(.*)"$/) {
+            $msgid = $1;
+        } elsif ($line =~ /^msgstr "(.*)"$/) {
+            my $msgstr = $1;
+            $strings{$lang}->{$msgid} = $msgstr;
+            $strings{"en_US"}->{$msgid} = $msgid;
+        }
+    }
+    
+    close FILE;
+}
+
+
+
+foreach my $lang (@LANGS) { 
+    LoadLanguage($lang);
+}
+
+my @msgids = sort keys %{$strings{"en_US"}};
+
+
+my $silent = 0;
+
+while (<>) {
+    my $line = $_;
+
+    if ($line =~ /^\/\/ START I18N/) {
+        print "// START I18N - automatically generated by po2i18n.pl\n";
+        for my $msgid (@msgids) {
+            next if $msgid eq "";
+
+            my $head = "  { ";
+            my $endif = "";
+            my $versnum = 10200;
+            
+            for my $lang (@LANGS) {
+                if ($VERS{$lang} ne $versnum) {
+                    $versnum = $VERS{$lang};
+                    print $endif;
+                    print "#if VDRVERSNUM >= $versnum\n";
+                    $endif = "#endif\n";
+                }
+                my $msgstr = $strings{$lang}->{$msgid};
+                $msgstr = "" if !defined $msgstr;
+                
+                print "$head\"$msgstr\",\n";
+                $head = "    ";
+            }
+            print $endif;
+            print "  },\n";
+        }
+        $silent = 1;
+    }
+
+    if (!$silent) { print $line; }
+
+    if ($line =~ /^\/\/ END I18N/) { 
+        print "// END I18N - automatically generated by po2i18n.pl\n";
+        $silent = 0; 
+    }    
+}
diff -Naur -x .svn rssreader-1.1.2-orig/rssreader.c rssreader/rssreader.c
--- rssreader-1.1.2-orig/rssreader.c	2009-02-02 17:41:49.000000000 +0100
+++ rssreader/rssreader.c	2009-02-02 17:42:19.000000000 +0100
@@ -11,12 +11,12 @@
 #include "menu.h"
 #include "config.h"
 #include "common.h"
+#include "i18n.h"
 
-#if defined(APIVERSNUM) && APIVERSNUM < 10508
-#error "VDR-1.5.8 API version or greater is required!"
-#endif
 
-static const char VERSION[]       = "1.1.2";
+#define trNOOP(x) x
+
+static const char VERSION[]       = "1.1.3";
 static const char DESCRIPTION[]   = trNOOP("RSS Reader for OSD");
 static const char MAINMENUENTRY[] = trNOOP("RSS Reader");
 
@@ -84,6 +84,9 @@
 bool cPluginRssReader::Initialize(void)
 {
   // Initialize any background activities the plugin shall perform.
+#if VDRVERSNUM < 10507
+  RegisterI18n(StreamplayerPhrases);
+#endif
   return true;
 }
 
diff -Naur -x .svn rssreader-1.1.2-orig/tools.c rssreader/tools.c
--- rssreader-1.1.2-orig/tools.c	2009-02-02 17:41:49.000000000 +0100
+++ rssreader/tools.c	2009-02-02 17:44:05.000000000 +0100
@@ -6,133 +6,169 @@
  * $Id$
  */
 
+#include "compatibility.h"
+
 #include "tools.h"
 #include "common.h"
+#include <stdlib.h>
+#include <string>
+
+using namespace std;
 
 // --- Static -----------------------------------------------------------
 
 #define ELEMENTS(x) (sizeof(x) / sizeof(x[0]))
 
+
+
 struct conv_table {
-  char *from;
-  char *to;
+  const char *from;
+  const char *to;
 };
 
-static struct conv_table pre_conv_table[] =
-{
-  // 'to' field must be smaller than 'from'
-  {"<br />",   "\n"}
-};
 
 static struct conv_table post_conv_table[] =
 {
-  // 'to' field must be smaller than 'from'
-  {"&#228;",   "\xc3\xa4"},
-  {"&auml;",   "\xc3\xa4"},
+   // 'to' field must be smaller than 'from'
+  {"&amp;",    "&"},
+  {"&#039;",   "'"},
+  {"&#160;",   " "},
+  {"&#171;",   "\xc2\xab"},
+  {"&#176;",   "\xc2\xb0"},
+  {"&#180;",   "'"},
+  {"&#187;",   "\xc2\xbb"},
+  {"&#191;",   "\xc2\xbf"},  
+  {"&#193;",   "\xc3\x81"},
   {"&#196;",   "\xc3\x84"},
-  {"&Auml;",   "\xc3\x84"},
-  {"&#246;",   "\xc3\xb6"},
-  {"&ouml;",   "\xc3\xb6"},
-  {"&#214;",   "\xc3\x96"},
-  {"&Ouml;",   "\xc3\x96"},
-  {"&#229;",   "\xc3\xa5"},
   {"&#197;",   "\xc3\x85"},
+  {"&#201;",   "\xc3\x89"},
+  {"&#205;",   "\xc3\x8d"},
+  {"&#209;",   "\xc3\x91"},  
+  {"&#211;",   "\xc3\x93"},
+  {"&#214;",   "\xc3\x96"},
+  {"&#218;",   "\xc3\x9a"},
   {"&#220;",   "\xc3\x9c"},
-  {"&Uuml;",   "\xc3\x9c"},
-  {"&#252;",   "\xc3\xbc"},
-  {"&uuml;",   "\xc3\xbc"},
-  {"&#223;",   "\xc3\x9f"},
-  {"&szlig;",  "\xc3\x9f"},
+  {"&#223;",   "\xc3\x9f"},  
+  {"&#225;",   "\xc3\xa1"},
+  {"&#226;",   "\xc3\xa2"},
+  {"&#228;",   "\xc3\xa4"},
+  {"&#229;",   "\xc3\xa5"},
+  {"&#231;",   "\xc3\xa7"},  
+  {"&#233;",   "\xc3\xa9"},
   {"&#234;",   "\xc3\xaa"},
-  {"&#176;",   "\xc2\xb0"},
-  {"&#8211;",  "-"},
-  {"&ndash;",  "-"},
+  {"&#237;",   "\xc3\xad"},
+  {"&#241;",   "\xc3\xb1"},
+  {"&#243;",   "\xc3\xb3"},
+  {"&#246;",   "\xc3\xb6"},
+  {"&#250;",   "\xc3\xba"},
+  {"&#252;",   "\xc3\xbc"},
   {"&#38;",    "&"},
-  {"&amp;",    "&"},
-  {"&#58;",    ":"},
-  {"&#91;",    "["},
-  {"&#93;",    "]"},
   {"&#40;",    "'"},
   {"&#41;",    "'"},
-  {"&#039;",   "'"},
-  {"&#180;",   "'"},
-  {"&acute;",  "'"},
+  {"&#58;",    ":"},
+  {"&#60;",    "<"},
+  {"&#62;",    ">"},
+  {"&#8211;",  "-"},
   {"&#8216;",  "'"},
   {"&#8217;",  "'"},
-  {"&#231;",   "\xc3\xa7"},
-  {"&ccedil;", "\xc3\xa7"},
-  {"&#233;",   "\xc3\xa9"},
-  {"&eacute;", "\xc3\xa9"},
-  {"&#226;",   "\xc3\xa2"},
-  {"&acirc;",  "\xc3\xa2"},
-  {"&#8364;",  "\xe2\x82\xac"},
-  {"&euro;",   "\xe2\x82\xac"},
-  {"&quot;",   "\""},
   {"&#8220;",  "\""},
   {"&#8221;",  "\""},
   {"&#8222;",  "\""},
-  {"&#160;",   " "},
-  {"&nbsp;",   " "},
-  {"&lt;",     "<"},
+  {"&#8364;",  "\xe2\x82\xac"},
+  {"&#91;",    "["},
+  {"&#93;",    "]"},  
+  {"&aacute;", "\xc3\xa1"},
+  {"&Aacute;", "\xc3\xa1"},
+  {"&acirc;",  "\xc3\xa2"},
+  {"&acute;",  "'"},  
+  {"&Auml;",   "\xc3\x84"},
+  {"&auml;",   "\xc3\xa4"},
+  {"<br />",   "\n"},
+  {"<br/>",    "\n"},
+  {"&ccedil;", "\xc3\xa7"},  
+  {"&Ccedil;", "\xc3\xa7"},  
+  {"&eacute;", "\xc3\xa9"},
+  {"&Eacute;", "\xc3\x89"},
+  {"&euro;",   "\xe2\x82\xac"},
   {"&gt;",     ">"},
+  {"&iacute;", "\xc3\xad"},
+  {"&Iacute;", "\xc3\x8d"},
+  {"&lt;",     "<"},
+  {"&nbsp;",   " "},
+  {"&ndash;",  "-"},
   {"\n\n",     "\n"}, // let's also strip multiple linefeeds
+  {"&ntilde;", "\xc3\xb1"},
+  {"&Ntilde;", "\xc3\x91"},     
+  {"&oacute;", "\xc3\xb3"},
+  {"&Oacute;", "\xc3\x93"},  
+  {"&Ouml;",   "\xc3\x96"},
+  {"&ouml;",   "\xc3\xb6"},
+  {"&quot;",   "\""},
+  {"&szlig;",  "\xc3\x9f"},
+  {"&uacute;", "\xc3\xba"},
+  {"&Uacute;", "\xc3\x9a"},
+  {"&Uuml;",   "\xc3\x9c"},
+  {"&uuml;",   "\xc3\xbc"},
+  {NULL,NULL}
 };
 
-static char *htmlcharconv(char *str, struct conv_table *conv, unsigned int elem)
-{
-  if (str && conv) {
-     for (unsigned int i = 0; i < elem; ++i) {
-        char *ptr = strstr(str, conv[i].from);
-        while (ptr) {
-           int of = ptr - str;
-           int l  = strlen(str);
-           int l1 = strlen(conv[i].from);
-           int l2 = strlen(conv[i].to);
-           if (l2 > l1) {
-              error("htmlcharconv(): cannot reallocate string");
-              return str;
-              }
-           if (l2 != l1)
-              memmove(str + of + l2, str + of + l1, l - of - l1 + 1);
-           strncpy(str + of, conv[i].to, l2);
-           ptr = strstr(str, conv[i].from);
-           }
-        }
-     return str;
-     }
-  return NULL;
-}
 
-// --- General functions ------------------------------------------------
 
-char *striphtml(char *str)
-{
-  if (str) {
-     char *c, t = 0, *r;
-     str = htmlcharconv(str, pre_conv_table, ELEMENTS(pre_conv_table));
-     c = str;
-     r = str;
-     while (*str != '\0') {
-       if (*str == '<')
-          t++;
-       else if (*str == '>')
-          t--;
-       else if (t < 1)
-          *(c++) = *str;
-       str++;
-       }
-     *c = '\0';
-     return htmlcharconv(r, post_conv_table, ELEMENTS(post_conv_table));
-     }
-  return NULL;
+// --- General functions ------------------------------------------------
+ 
+string& replace_all(string& context, const string& from, const string& to) {
+  size_t lookHere = 0;
+  size_t foundHere;
+  while ((foundHere = context.find(from, lookHere)) != string::npos) {
+    context.replace(foundHere, from.size(), to);
+    lookHere = foundHere + to.size();
+  }
+  return context;
 }
 
-void *myrealloc(void *ptr, size_t size)
-{
-  /* There might be a realloc() out there that doesn't like reallocing
-     NULL pointers, so we take care of it here */
-  if (ptr)
-     return realloc(ptr, size);
-  else
-     return malloc(size);
+void striphtml(string &str){  
+  int i=0;
+  bool inTag = false;
+  bool done = false;
+  //Convert encoding
+  cCharSetConv conv("UTF-8",DEFAULT_ENCONDING);
+  while(1) {
+    if ( post_conv_table[i].from == NULL && post_conv_table[i].to == NULL ) break;
+    replace_all(str,post_conv_table[i].from,conv.Convert(post_conv_table[i].to));
+    i++;
+  }
+  //strip html
+  while(!done) {
+	if(inTag) {
+		// The previous line started an HTML tag
+		// but didn't finish. Must search for '>'.
+		size_t rightPos = str.find('>');
+		if(rightPos != string::npos) {
+			inTag = false;
+			str.erase(0, rightPos + 1);
+		}
+		else {
+			done = true;
+			str.erase();
+		}
+	}
+	else {
+		// Look for start of tag:
+		size_t leftPos = str.find('<');
+		if(leftPos != string::npos) {
+			// See if tag close is in this line:
+			size_t rightPos = str.find('>');
+			if(rightPos == string::npos) {
+				inTag = done = true;
+				str.erase(leftPos);
+			}
+			else
+				str.erase(leftPos, rightPos - leftPos + 1);
+			}		
+		else
+			done = true;
+	}
+  }	
+  
 }
+
diff -Naur -x .svn rssreader-1.1.2-orig/tools.h rssreader/tools.h
--- rssreader-1.1.2-orig/tools.h	2009-02-02 17:41:49.000000000 +0100
+++ rssreader/tools.h	2009-02-02 17:42:19.000000000 +0100
@@ -10,9 +10,14 @@
 #define __RSSREADER_TOOLS_H
 
 #include <vdr/tools.h>
+#include <string>
+
+#define DEFAULT_ENCONDING "ISO-8859-1"
+
+using namespace std;
+
+void striphtml(string &str);
 
-char *striphtml(char *str);
-void *myrealloc(void *ptr, size_t size);
 
 #endif // __RSSREADER_TOOLS_H
 
