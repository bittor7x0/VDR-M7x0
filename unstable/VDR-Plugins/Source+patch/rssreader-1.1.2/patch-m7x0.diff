diff -Naur rssreader-1.1.2-orig/compatibility.c rssreader/compatibility.c
--- rssreader-1.1.2-orig/compatibility.c	1970-01-01 01:00:00.000000000 +0100
+++ rssreader/compatibility.c	2008-01-12 14:09:02.000000000 +0100
@@ -0,0 +1,259 @@
+#include "compatibility.h"
+
+#if VDRVERSNUM < 10500
+
+// --- UTF-8 support ---------------------------------------------------------
+
+static uint SystemToUtf8[128] = { 0 };
+
+
+int Utf8CharLen(const char *s)
+{
+  if (cCharSetConv::SystemCharacterTable())
+     return 1;
+#define MT(s, m, v) ((*(s) & (m)) == (v)) // Mask Test
+  if (MT(s, 0xE0, 0xC0) && MT(s + 1, 0xC0, 0x80))
+     return 2;
+  if (MT(s, 0xF0, 0xE0) && MT(s + 1, 0xC0, 0x80) && MT(s + 2, 0xC0, 0x80))
+     return 3;
+  if (MT(s, 0xF8, 0xF0) && MT(s + 1, 0xC0, 0x80) && MT(s + 2, 0xC0, 0x80) && MT(s + 3, 0xC0, 0x80))
+     return 4;
+  return 1;
+}
+
+uint Utf8CharGet(const char *s, int Length)
+{
+  if (cCharSetConv::SystemCharacterTable())
+     return (uchar)*s < 128 ? *s : SystemToUtf8[(uchar)*s - 128];
+  if (!Length)
+     Length = Utf8CharLen(s);
+  switch (Length) {
+    case 2: return ((*s & 0x1F) << 6) |  (*(s + 1) & 0x3F);
+    case 3: return ((*s & 0x0F) << 4) | ((*(s + 1) & 0x3F) << 6) |  (*(s + 2) & 0x3F);
+    case 4: return ((*s & 0x07) << 2) | ((*(s + 1) & 0x3F) << 4) | ((*(s + 2) & 0x3F) << 6) | (*(s + 3) & 0x3F);
+    }
+  return *s;
+}
+
+int Utf8CharSet(uint c, char *s)
+{
+  if (c < 0x80 || cCharSetConv::SystemCharacterTable()) {
+     if (s)
+        *s = c;
+     return 1;
+     }
+  if (c < 0x800) {
+     if (s) {
+        *s++ = ((c >> 6) & 0x1F) | 0xC0;
+        *s   = (c & 0x3F) | 0x80;
+        }
+     return 2;
+     }
+  if (c < 0x10000) {
+     if (s) {
+        *s++ = ((c >> 12) & 0x0F) | 0xE0;
+        *s++ = ((c >>  6) & 0x3F) | 0x80;
+        *s   = (c & 0x3F) | 0x80;
+        }
+     return 3;
+     }
+  if (c < 0x110000) {
+     if (s) {
+        *s++ = ((c >> 18) & 0x07) | 0xF0;
+        *s++ = ((c >> 12) & 0x3F) | 0x80;
+        *s++ = ((c >>  6) & 0x3F) | 0x80;
+        *s   = (c & 0x3F) | 0x80;
+        }
+     return 4;
+     }
+  return 0; // can't convert to UTF-8
+}
+
+int Utf8SymChars(const char *s, int Symbols)
+{
+  if (cCharSetConv::SystemCharacterTable())
+     return Symbols;
+  int n = 0;
+  while (*s && Symbols--) {
+        int sl = Utf8CharLen(s);
+        s += sl;
+        n += sl;
+        }
+  return n;
+}
+
+int Utf8StrLen(const char *s)
+{
+  if (cCharSetConv::SystemCharacterTable())
+     return strlen(s);
+  int n = 0;
+  while (*s) {
+        s += Utf8CharLen(s);
+        n++;
+        }
+  return n;
+}
+
+char *Utf8Strn0Cpy(char *Dest, const char *Src, int n)
+{
+
+  if (cCharSetConv::SystemCharacterTable()!=NULL)
+     return strn0cpy(Dest, Src, n);
+
+  char *d = Dest;
+  while (*Src) {
+        int sl = Utf8CharLen(Src);
+        n -= sl;
+        if (n > 0) {
+           while (sl--)
+                 *d++ = *Src++;
+           }
+        else
+           break;
+        }
+  *d = 0;
+  return Dest;
+}
+
+int Utf8ToArray(const char *s, uint *a, int Size)
+{
+  int n = 0;
+  while (*s && --Size > 0) {
+        if (cCharSetConv::SystemCharacterTable())
+           *a++ = (uchar)(*s++);
+        else {
+           int sl = Utf8CharLen(s);
+           *a++ = Utf8CharGet(s, sl);
+           s += sl;
+           }
+        n++;
+        }
+  if (Size > 0)
+     *a = 0;
+  return n;
+}
+
+int Utf8FromArray(const uint *a, char *s, int Size, int Max)
+{
+  int NumChars = 0;
+  int NumSyms = 0;
+  while (*a && NumChars < Size) {
+        if (Max >= 0 && NumSyms++ >= Max)
+           break;
+        if (cCharSetConv::SystemCharacterTable()) {
+           *s++ = *a++;
+           NumChars++;
+           }
+        else {
+           int sl = Utf8CharSet(*a);
+           if (NumChars + sl <= Size) {
+              Utf8CharSet(*a, s);
+              a++;
+              s += sl;
+              NumChars += sl;
+              }
+           else
+              break;
+           }
+        }
+  if (NumChars < Size)
+     *s = 0;
+  return NumChars;
+}
+
+// --- cCharSetConv ----------------------------------------------------------
+
+char *cCharSetConv::systemCharacterTable = NULL;
+
+cCharSetConv::cCharSetConv(const char *FromCode, const char *ToCode)
+{
+
+  if (!FromCode)
+     FromCode = systemCharacterTable;
+
+  if (!ToCode)
+     ToCode = "UTF-8";
+
+  cd = (FromCode && ToCode) ? iconv_open(ToCode, FromCode) : (iconv_t)-1;
+
+  result = NULL;
+  length = 0;
+}
+
+cCharSetConv::~cCharSetConv()
+{
+  free(result);
+  iconv_close(cd);
+}
+
+void cCharSetConv::SetSystemCharacterTable(const char *CharacterTable)
+{
+  free(systemCharacterTable);
+  systemCharacterTable = NULL;
+  if (!strcasestr(CharacterTable, "UTF-8")) {
+     // Set up a map for the character values 128...255:
+     char buf[129];
+     for (int i = 0; i < 128; i++)
+         buf[i] = i + 128;
+     buf[128] = 0;
+     cCharSetConv csc(CharacterTable);
+     const char *s = csc.Convert(buf);
+     int i = 0;
+     while (*s) {
+           int sl = Utf8CharLen(s);
+           SystemToUtf8[i] = Utf8CharGet(s, sl);
+           s += sl;
+           i++;
+           }
+     systemCharacterTable = strdup(CharacterTable);
+     }
+}
+
+const char *cCharSetConv::Convert(const char *From, char *To, size_t ToLength)
+{
+  if (cd != (iconv_t)-1 && From && *From) {
+     char *FromPtr = (char *)From;
+     size_t FromLength = strlen(From);
+     char *ToPtr = To;
+     if (!ToPtr) {
+        length = max(length, FromLength * 2); // some reserve to avoid later reallocations
+        result = (char *)realloc(result, length);
+        ToPtr = result;
+        ToLength = length;
+        }
+     else if (!ToLength)
+        return From; // can't convert into a zero sized buffer
+     ToLength--; // save space for terminating 0
+     char *Converted = ToPtr;
+     while (FromLength > 0) {
+           if (iconv(cd, &FromPtr, &FromLength, &ToPtr, &ToLength) == size_t(-1)) {
+              if (errno == E2BIG || errno == EILSEQ && ToLength < 1) {
+                 if (To)
+                    break; // caller provided a fixed size buffer, but it was too small
+                 // The result buffer is too small, so increase it:
+                 size_t d = ToPtr - result;
+                 size_t r = length / 2;
+                 length += r;
+                 Converted = result = (char *)realloc(result, length);
+                 ToLength += r;
+                 ToPtr = result + d;
+                 }
+              if (errno == EILSEQ) {
+                 // A character can't be converted, so mark it with '?' and proceed:
+                 FromPtr++;
+                 FromLength--;
+                 *ToPtr++ = '?';
+                 ToLength--;
+                 }
+              else if (errno != E2BIG)
+                 return From; // unknown error, return original string
+              }
+           }
+     *ToPtr = 0;
+     return Converted;
+     }
+  return From;
+}
+
+#endif // VDRVERSNUM < 10500
+
diff -Naur rssreader-1.1.2-orig/compatibility.h rssreader/compatibility.h
--- rssreader-1.1.2-orig/compatibility.h	1970-01-01 01:00:00.000000000 +0100
+++ rssreader/compatibility.h	2008-01-12 14:09:02.000000000 +0100
@@ -0,0 +1,98 @@
+#ifndef __rssreader_compatibility_h__
+#define __rssreader_compatibility_h__
+
+
+
+#if VDRVERSNUM < 10500
+
+#include "common.h"
+#include <vdr/tools.h>
+#include <stdlib.h>
+#include <iconv.h>
+
+#define uint unsigned int
+#define uchar unsigned char
+
+// When handling strings that might contain UTF-8 characters, it may be necessary
+// to process a "symbol" that consists of several actual character bytes. The
+// following functions allow transparently accessing a "char *" string without
+// having to worry about what character set is actually used.
+
+int Utf8CharLen(const char *s);
+    ///< Returns the number of character bytes at the beginning of the given
+    ///< string that form a UTF-8 symbol.
+uint Utf8CharGet(const char *s, int Length = 0);
+    ///< Returns the UTF-8 symbol at the beginning of the given string.
+    ///< Length can be given from a previous call to Utf8CharLen() to avoid calculating
+    ///< it again. If no Length is given, Utf8CharLen() will be called.
+int Utf8CharSet(uint c, char *s = NULL);
+    ///< Converts the given UTF-8 symbol to a sequence of character bytes and copies
+    ///< them to the given string. Returns the number of bytes written. If no string
+    ///< is given, only the number of bytes is returned and nothing is copied.
+int Utf8SymChars(const char *s, int Symbols);
+    ///< Returns the number of character bytes at the beginning of the given
+    ///< string that form at most the given number of UTF-8 symbols.
+int Utf8StrLen(const char *s);
+    ///< Returns the number of UTF-8 symbols formed by the given string of
+    ///< character bytes.
+char *Utf8Strn0Cpy(char *Dest, const char *Src, int n);
+    ///< Copies at most n character bytes from Src to Dst, making sure that the
+    ///< resulting copy ends with a complete UTF-8 symbol. The copy is guaranteed
+    ///< to be zero terminated.
+    ///< Returns a pointer to Dest.
+int Utf8ToArray(const char *s, uint *a, int Size);
+    ///< Converts the given character bytes (including the terminating 0) into an
+    ///< array of UTF-8 symbols of the given Size. Returns the number of symbols
+    ///< in the array (without the terminating 0).
+int Utf8FromArray(const uint *a, char *s, int Size, int Max = -1);
+    ///< Converts the given array of UTF-8 symbols (including the terminating 0)
+    ///< into a sequence of character bytes of at most Size length. Returns the
+    ///< number of character bytes written (without the terminating 0).
+    ///< If Max is given, only that many symbols will be converted.
+    ///< The resulting string is always zero-terminated if Size is big enough.
+
+// When allocating buffer space, make sure we reserve enough space to hold
+// a string in UTF-8 representation:
+
+#define Utf8BufSize(s) ((s) * 4)
+
+// The following macros automatically use the correct versions of the character
+// class functions:
+
+#define Utf8to(conv, c) (cCharSetConv::SystemCharacterTable() ? to##conv(c) : tow##conv(c))
+#define Utf8is(ccls, c) (cCharSetConv::SystemCharacterTable() ? is##ccls(c) : isw##ccls(c))
+
+class cCharSetConv {
+private:
+  iconv_t cd;
+  char *result;
+  size_t length;
+  static char *systemCharacterTable;
+public:
+  cCharSetConv(const char *FromCode = NULL, const char *ToCode = NULL);
+     ///< Sets up a character set converter to convert from FromCode to ToCode.
+     ///< If FromCode is NULL, the previously set systemCharacterTable is used.
+     ///< If ToCode is NULL, "UTF-8" is used.
+  ~cCharSetConv();
+  const char *Convert(const char *From, char *To = NULL, size_t ToLength = 0);
+     ///< Converts the given Text from FromCode to ToCode (as set in the cosntructor).
+     ///< If To is given, it is used to copy at most ToLength bytes of the result
+     ///< (including the terminating 0) into that buffer. If To is not given,
+     ///< the result is copied into a dynamically allocated buffer and is valid as
+     ///< long as this object lives, or until the next call to Convert(). The
+     ///< return value always points to the result if the conversion was successful
+     ///< (even if a fixed size To buffer was given and the result didn't fit into
+     ///< it). If the string could not be converted, the result points to the
+     ///< original From string.
+  static const char *SystemCharacterTable(void) { return systemCharacterTable; }
+  static void SetSystemCharacterTable(const char *CharacterTable);
+  };
+
+
+
+
+#endif // VDRVERSNUM < 10500
+
+#endif // __rssreader_compatibility_h__
+
+
diff -Naur rssreader-1.1.2-orig/example/.svn/all-wcprops rssreader/example/.svn/all-wcprops
--- rssreader-1.1.2-orig/example/.svn/all-wcprops	2008-01-14 20:30:46.000000000 +0100
+++ rssreader/example/.svn/all-wcprops	1970-01-01 01:00:00.000000000 +0100
@@ -1,11 +0,0 @@
-K 25
-svn:wc:ra_dav:version-url
-V 104
-/svn/VDR-M7x0/!svn/ver/14/unstable/VDR-Plugins/Source+patch/rssreader-1.1.2/rssreader-1.1.2-orig/example
-END
-rssreader.conf
-K 25
-svn:wc:ra_dav:version-url
-V 119
-/svn/VDR-M7x0/!svn/ver/14/unstable/VDR-Plugins/Source+patch/rssreader-1.1.2/rssreader-1.1.2-orig/example/rssreader.conf
-END
diff -Naur rssreader-1.1.2-orig/example/.svn/entries rssreader/example/.svn/entries
--- rssreader-1.1.2-orig/example/.svn/entries	2008-01-14 20:30:46.000000000 +0100
+++ rssreader/example/.svn/entries	1970-01-01 01:00:00.000000000 +0100
@@ -1,40 +0,0 @@
-8
-
-dir
-62
-http://svn2.assembla.com/svn/VDR-M7x0/unstable/VDR-Plugins/Source+patch/rssreader-1.1.2/rssreader-1.1.2-orig/example
-http://svn2.assembla.com/svn/VDR-M7x0
-
-
-
-2007-12-11T17:51:41.858007Z
-14
-bittor
-
-
-svn:special svn:externals svn:needs-lock
-
-
-
-
-
-
-
-
-
-
-
-c3d1530f-68f5-4bd0-87dc-8ef779617e40
-
-rssreader.conf
-file
-
-
-
-
-2008-01-06T08:30:53.000000Z
-c3f0b7aba69eaa0c80ba456c8fb0f655
-2007-12-11T17:51:41.858007Z
-14
-bittor
-
diff -Naur rssreader-1.1.2-orig/example/.svn/format rssreader/example/.svn/format
--- rssreader-1.1.2-orig/example/.svn/format	2008-01-14 20:30:46.000000000 +0100
+++ rssreader/example/.svn/format	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-8
diff -Naur rssreader-1.1.2-orig/example/.svn/text-base/rssreader.conf.svn-base rssreader/example/.svn/text-base/rssreader.conf.svn-base
--- rssreader-1.1.2-orig/example/.svn/text-base/rssreader.conf.svn-base	2008-01-14 20:30:46.000000000 +0100
+++ rssreader/example/.svn/text-base/rssreader.conf.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,77 +0,0 @@
-# Configuration file for RssReader plugin (VDR)
-# "Label" : # Comment
-# "Title" : "URL"
--- VDR                 : # Label
-VDR Announcements      : http://www.linuxtv.fi/extras/vdr_announce_rss.php?num=10
-Linuxtv.fi foorumi     : http://www.linuxtv.fi/rss.php
-DVB.fi foorumi         : http://www.dvb.fi/external.php?type=rss
--- Kotimaiset          : # Label
-Lehti                  : http://lehti.samizdat.info/feed/rss2/
-Salakuunneltua         : http://www.salakuunneltua.fi/rss.php
-YLE                    : http://www.yle.fi/uutiset/rss/paauutiset.xml
-Helsingin Sanomat      : http://www.hs.fi/uutiset/rss/
-Keskisuomalainen       : http://media.keskisuomalainen.fi/rss/rss.xml
-Savon Sanomat          : http://savonsanomat.fi/rss/index.php
-Kauppalehti            : http://www.kauppalehti.fi/4/i/uutiset/etusivu/rss.jsp
-Digitoday              : http://www.digitoday.fi/feeds/Digitoday.xml
-Verkkouutiset          : http://www.verkkouutiset.fi/uusimmat-rss.php
-Tietokone              : http://www.tietokone.fi/uutta/rss.asp
-Tietoviikko            : http://www.tietoviikko.fi/rss.xml
-Helsingin kaupunki     : http://www.hel.fi/feeds/uutiset.xml
-CERT-FI varoitukset    : http://www.cert.fi/rss/varoitukset.xml
-CERT-FI haavoittuvuudet: http://www.cert.fi/rss/haavoittuvuudet.xml
-CERT-FI tietoturva nyt : http://www.cert.fi/rss/tietoturvanyt.xml
-EFFI uutiset           : http://www.effi.org/xml/uutiset.rss
-Seiska juorut          : http://www.seiska.fi/index.rss
-Viihdelehti Stara      : http://www.stara.fi/index.php?feed=rss2
-OHO                    : http://www.oho.fi/index.rss
-Saa - Helsinki-Vantaa  : http://www.rssweather.com/icao/EFHK/rss.php
--- Svenska             : # Label
-Huvudstadsbladet       : http://hbl.fi/rss.xml
-Dagens Nyheter         : http://www.dn.se/DNet/jsp/polopoly.jsp?d=1399
--- English             : # Label
-F1 live                : http://www.f1-live.com/f1/en/xml/infos/f1en_rss.xml
-BBC News               : http://newsrss.bbc.co.uk/rss/newsonline_uk_edition/front_page/rss.xml
-BBC World              : http://newsrss.bbc.co.uk/rss/newsonline_uk_edition/world/rss.xml
-BBC Science / Nature   : http://newsrss.bbc.co.uk/rss/newsonline_uk_edition/sci/tech/rss.xml
-BBC Technology         : http://newsrss.bbc.co.uk/rss/newsonline_uk_edition/technology/rss.xml
-BBC Entertainment      : http://newsrss.bbc.co.uk/rss/newsonline_uk_edition/entertainment/rss.xml
-BBC Business           : http://newsrss.bbc.co.uk/rss/newsonline_uk_edition/business/rss.xml
-BBC Health             : http://newsrss.bbc.co.uk/rss/newsonline_uk_edition/health/rss.xml
-CNN Europe             : http://xml.newsisfree.com/feeds/97/697.xml
-CNN Topstories         : http://rss.cnn.com/rss/cnn_topstories.rss
-Yahoo World News       : http://rss.news.yahoo.com/rss/world
-Wired News             : http://www.wired.com/news_drop/netcenter/netcenter.rdf
-Slashdot               : http://rss.slashdot.org/Slashdot/slashdot/to
-The Register           : http://www.theregister.co.uk/headlines.rss
-Anandtech              : http://www.anandtech.com/rss/articlefeed.aspx
-Tom's Hardware Guide   : http://www.pheedo.com/f/toms_hardware
-TG Daily               : http://www.pheedo.com/f/tg_daily
--- Deutsch             : # Label
-Golem                  : http://rss.golem.de/rss.php?feed=RSS2.0
-ZDNet                  : http://www.zdnet.de/feeds/news/xml/rss_h20.xml.htm
-Zeit                   : http://newsfeed.zeit.de/
-Stern                  : http://www.stern.de/standard/rss.php?channel=all
-Spiegel                : http://www.spiegel.de/schlagzeilen/rss/0,5291,,00.xml
-Bild.de                : http://feeds.feedburner.com/bild.xml
-Heise                  : http://www.heise.de/newsticker/heise.rdf
-Heise Telepolis        : http://www.heise.de/tp/news.rdf
-N24 Home               : http://www.n24.de/rss/?rubrik=home
-N24 Sport              : http://www.n24.de/rss/?rubrik=sport
-Erotische Geschichten  : http://www.erotische-geschichten.biz/?rss=1
-Immobilien News        : http://www.immobiliendienste.de/backend.rss
-Tagesschau             : http://www.tagesschau.de/newsticker.rdf
--- Osterreich          : # Label
-ORF News               : http://rss.orf.at/news.xml
-ORF Futurezone         : http://rss.orf.at/futurezone.xml
-ORF Osterreich         : http://rss.orf.at/oesterreich.xml
-Krone                  : http://wcm.krone.at/krone/S25/kmprog/rss.html
-Kurier                 : http://kurier.at/newsfeed/nachrichten_rss.xml
--- Linux               : # Label
-Linux Today            : http://www.linuxtoday.com/backend/biglt.rss
-Freshmeat.net          : http://rss.freshmeat.net/freshmeat/feeds/fm-releases-global
-LKML                   : http://lkml.org/rss.php
-LKML Linus Torvalds    : http://lkml.org/groupie.php?author=Linus+Torvalds
-LKML Andrew Morton     : http://lkml.org/groupie.php?author=Andrew+Morton
-LKML Ingo Molnar       : http://lkml.org/groupie.php?author=Ingo+Molnar
-Gentoo                 : http://www.gentoo.org/rdf/en/gentoo-news.rdf
diff -Naur rssreader-1.1.2-orig/ezxml.c rssreader/ezxml.c
--- rssreader-1.1.2-orig/ezxml.c	1970-01-01 01:00:00.000000000 +0100
+++ rssreader/ezxml.c	2008-01-12 14:09:02.000000000 +0100
@@ -0,0 +1,1000 @@
+/* ezxml.c
+ *
+ * Copyright 2004-2006 Aaron Voisine <aaron@voisine.org>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdarg.h>
+#include <string.h>
+#include <ctype.h>
+#include <unistd.h>
+#include <sys/types.h>
+
+#include <sys/stat.h>
+#include "ezxml.h"
+
+#define EZXML_WS   "\t\r\n "  // whitespace
+#define EZXML_ERRL 128        // maximum error string length
+
+typedef struct ezxml_root *ezxml_root_t;
+struct ezxml_root {       // additional data for the root tag
+    struct ezxml xml;     // is a super-struct built on top of ezxml struct
+    ezxml_t cur;          // current xml tree insertion point
+    char *m;              // original xml string
+    size_t len;           // length of allocated memory for mmap, -1 for malloc
+    char *u;              // UTF-8 conversion of string if original was UTF-16
+    char *s;              // start of work area
+    char *e;              // end of work area
+    char **ent;           // general entities (ampersand sequences)
+    char ***attr;         // default attributes
+    char ***pi;           // processing instructions
+    short standalone;     // non-zero if <?xml standalone="yes"?>
+    char err[EZXML_ERRL]; // error string
+};
+
+char *EZXML_NIL[] = { NULL }; // empty, null terminated array of strings
+
+// returns the first child tag with the given name or NULL if not found
+ezxml_t ezxml_child(ezxml_t xml, const char *name)
+{
+    xml = (xml) ? xml->child : NULL;
+    while (xml && strcmp(name, xml->name)) xml = xml->sibling;
+    return xml;
+}
+
+// returns the Nth tag with the same name in the same subsection or NULL if not
+// found
+ezxml_t ezxml_idx(ezxml_t xml, int idx)
+{
+    for (; xml && idx; idx--) xml = xml->next;
+    return xml;
+}
+
+// returns the value of the requested tag attribute or NULL if not found
+const char *ezxml_attr(ezxml_t xml, const char *attr)
+{
+    int i = 0, j = 1;
+    ezxml_root_t root = (ezxml_root_t)xml;
+
+    if (! xml || ! xml->attr) return NULL;
+    while (xml->attr[i] && strcmp(attr, xml->attr[i])) i += 2;
+    if (xml->attr[i]) return xml->attr[i + 1]; // found attribute
+
+    while (root->xml.parent) root = (ezxml_root_t)root->xml.parent; // root tag
+    for (i = 0; root->attr[i] && strcmp(xml->name, root->attr[i][0]); i++);
+    if (! root->attr[i]) return NULL; // no matching default attributes
+    while (root->attr[i][j] && strcmp(attr, root->attr[i][j])) j += 3;
+    return (root->attr[i][j]) ? root->attr[i][j + 1] : NULL; // found default
+}
+
+// same as ezxml_get but takes an already initialized va_list
+ezxml_t ezxml_vget(ezxml_t xml, va_list ap)
+{
+    char *name = va_arg(ap, char *);
+    int idx = -1;
+
+    if (name && *name) {
+        idx = va_arg(ap, int);    
+        xml = ezxml_child(xml, name);
+    }
+    return (idx < 0) ? xml : ezxml_vget(ezxml_idx(xml, idx), ap);
+}
+
+// Traverses the xml tree to retrieve a specific subtag. Takes a variable
+// length list of tag names and indexes. The argument list must be terminated
+// by either an index of -1 or an empty string tag name. Example: 
+// title = ezxml_get(library, "shelf", 0, "book", 2, "title", -1);
+// This retrieves the title of the 3rd book on the 1st shelf of library.
+// Returns NULL if not found.
+ezxml_t ezxml_get(ezxml_t xml, ...)
+{
+    va_list ap;
+    ezxml_t r;
+
+    va_start(ap, xml);
+    r = ezxml_vget(xml, ap);
+    va_end(ap);
+    return r;
+}
+
+// returns a null terminated array of processing instructions for the given
+// target
+const char **ezxml_pi(ezxml_t xml, const char *target)
+{
+    ezxml_root_t root = (ezxml_root_t)xml;
+    int i = 0;
+
+    if (! root) return (const char **)EZXML_NIL;
+    while (root->xml.parent) root = (ezxml_root_t)root->xml.parent; // root tag
+    while (root->pi[i] && strcmp(target, root->pi[i][0])) i++; // find target
+    return (const char **)((root->pi[i]) ? root->pi[i] + 1 : EZXML_NIL);
+}
+
+// set an error string and return root
+ezxml_t ezxml_err(ezxml_root_t root, char *s, const char *err, ...)
+{
+    va_list ap;
+    int line = 1;
+    char *t, fmt[EZXML_ERRL];
+    
+    for (t = root->s; t < s; t++) if (*t == '\n') line++;
+    snprintf(fmt, EZXML_ERRL, "[error near line %d]: %s", line, err);
+
+    va_start(ap, err);
+    vsnprintf(root->err, EZXML_ERRL, fmt, ap);
+    va_end(ap);
+
+    return &root->xml;
+}
+
+// Recursively decodes entity and character references and normalizes new lines
+// ent is a null terminated array of alternating entity names and values. set t
+// to '&' for general entity decoding, '%' for parameter entity decoding, 'c'
+// for cdata sections, ' ' for attribute normalization, or '*' for non-cdata
+// attribute normalization. Returns s, or if the decoded string is longer than
+// s, returns a malloced string that must be freed.
+char *ezxml_decode(char *s, char **ent, char t)
+{
+    char *e, *r = s, *m = s;
+    long b, c, d, l;
+
+    for (; *s; s++) { // normalize line endings
+        while (*s == '\r') {
+            *(s++) = '\n';
+            if (*s == '\n') memmove(s, (s + 1), strlen(s));
+        }
+    }
+    
+    for (s = r; ; ) {
+        while (*s && *s != '&' && (*s != '%' || t != '%') && !isspace(*s)) s++;
+
+        if (! *s) break;
+        else if (t != 'c' && ! strncmp(s, "&#", 2)) { // character reference
+            if (s[2] == 'x') c = strtol(s + 3, &e, 16); // base 16
+            else c = strtol(s + 2, &e, 10); // base 10
+            if (! c || *e != ';') { s++; continue; } // not a character ref
+
+            if (c < 0x80) *(s++) = c; // US-ASCII subset
+            else { // multi-byte UTF-8 sequence
+                for (b = 0, d = c; d; d /= 2) b++; // number of bits in c
+                b = (b - 2) / 5; // number of bytes in payload
+                *(s++) = (0xFF << (7 - b)) | (c >> (6 * b)); // head
+                while (b) *(s++) = 0x80 | ((c >> (6 * --b)) & 0x3F); // payload
+            }
+
+            memmove(s, strchr(s, ';') + 1, strlen(strchr(s, ';')));
+        }
+        else if ((*s == '&' && (t == '&' || t == ' ' || t == '*')) ||
+                 (*s == '%' && t == '%')) { // entity reference
+            for (b = 0; ent[b] && strncmp(s + 1, ent[b], strlen(ent[b]));
+                 b += 2); // find entity in entity list
+
+            if (ent[b++]) { // found a match
+                if ((c = strlen(ent[b])) - 1 > (e = strchr(s, ';')) - s) {
+                    l = (d = (s - r)) + c + strlen(e); // new length
+                    r = (r == m) ? strcpy((char*)malloc(l), r) : (char*)realloc(r, l);
+                    e = strchr((s = r + d), ';'); // fix up pointers
+                }
+
+                memmove(s + c, e + 1, strlen(e)); // shift rest of string
+                strncpy(s, ent[b], c); // copy in replacement text
+            }
+            else s++; // not a known entity
+        }
+        else if ((t == ' ' || t == '*') && isspace(*s)) *(s++) = ' ';
+        else s++; // no decoding needed
+    }
+
+    if (t == '*') { // normalize spaces for non-cdata attributes
+        for (s = r; *s; s++) {
+            if ((l = strspn(s, " "))) memmove(s, s + l, strlen(s + l) + 1);
+            while (*s && *s != ' ') s++;
+        }
+        if (--s >= r && *s == ' ') *s = '\0'; // trim any trailing space
+    }
+    return r;
+}
+
+// called when parser finds start of new tag
+void ezxml_open_tag(ezxml_root_t root, char *name, char **attr)
+{
+    ezxml_t xml = root->cur;
+    
+    if (xml->name) xml = ezxml_add_child(xml, name, strlen(xml->txt));
+    else xml->name = name; // first open tag
+
+    xml->attr = attr;
+    root->cur = xml; // update tag insertion point
+}
+
+// called when parser finds character content between open and closing tag
+void ezxml_char_content(ezxml_root_t root, char *s, size_t len, char t)
+{
+    ezxml_t xml = root->cur;
+    char *m = s;
+    size_t l;
+
+    if (! xml || ! xml->name || ! len) return; // sanity check
+
+    s[len] = '\0'; // null terminate text (calling functions anticipate this)
+    len = strlen(s = ezxml_decode(s, root->ent, t)) + 1;
+
+    if (! *(xml->txt)) xml->txt = s; // initial character content
+    else { // allocate our own memory and make a copy
+        xml->txt = (xml->flags & EZXML_TXTM) // allocate some space
+                   ? (char*)realloc(xml->txt, (l = strlen(xml->txt)) + len)
+                   : strcpy((char*)malloc((l = strlen(xml->txt)) + len), xml->txt);
+        strcpy(xml->txt + l, s); // add new char content
+        if (s != m) free(s); // free s if it was malloced by ezxml_decode()
+    }
+
+    if (xml->txt != m) ezxml_set_flag(xml, EZXML_TXTM);
+}
+
+// called when parser finds closing tag
+ezxml_t ezxml_close_tag(ezxml_root_t root, char *name, char *s)
+{
+    if (! root->cur || ! root->cur->name || strcmp(name, root->cur->name))
+        return ezxml_err(root, s, "unexpected closing tag </%s>", name);
+
+    root->cur = root->cur->parent;
+    return NULL;
+}
+
+// checks for circular entity references, returns non-zero if no circular
+// references are found, zero otherwise
+int ezxml_ent_ok(char *name, char *s, char **ent)
+{
+    int i;
+
+    for (; ; s++) {
+        while (*s && *s != '&') s++; // find next entity reference
+        if (! *s) return 1;
+        if (! strncmp(s + 1, name, strlen(name))) return 0; // circular ref.
+        for (i = 0; ent[i] && strncmp(ent[i], s + 1, strlen(ent[i])); i += 2);
+        if (ent[i] && ! ezxml_ent_ok(name, ent[i + 1], ent)) return 0;
+    }
+}
+
+// called when the parser finds a processing instruction
+void ezxml_proc_inst(ezxml_root_t root, char *s, size_t len)
+{
+    int i = 0, j = 1;
+    char *target = s;
+
+    s[len] = '\0'; // null terminate instruction
+    if (*(s += strcspn(s, EZXML_WS))) {
+        *s = '\0'; // null terminate target
+        s += strspn(s + 1, EZXML_WS) + 1; // skip whitespace after target
+    }
+
+    if (! strcmp(target, "xml")) { // <?xml ... ?>
+        if ((s = strstr(s, "standalone")) && ! strncmp(s + strspn(s + 10,
+            EZXML_WS "='\"") + 10, "yes", 3)) root->standalone = 1;
+        return;
+    }
+
+    if (! root->pi[0]) *(root->pi = (char***)malloc(sizeof(char **))) = NULL; //first pi
+
+    while (root->pi[i] && strcmp(target, root->pi[i][0])) i++; // find target
+    if (! root->pi[i]) { // new target
+        root->pi = (char***)realloc(root->pi, sizeof(char **) * (i + 2));
+        root->pi[i] = (char**)malloc(sizeof(char *) * 3);
+        root->pi[i][0] = target;
+        root->pi[i][1] = (char *)(root->pi[i + 1] = NULL); // terminate pi list
+        root->pi[i][2] = strdup(""); // empty document position list
+    }
+
+    while (root->pi[i][j]) j++; // find end of instruction list for this target
+    root->pi[i] = (char**)realloc(root->pi[i], sizeof(char *) * (j + 3));
+    root->pi[i][j + 2] = (char*)realloc(root->pi[i][j + 1], j + 1);
+    strcpy(root->pi[i][j + 2] + j - 1, (root->xml.name) ? ">" : "<");
+    root->pi[i][j + 1] = NULL; // null terminate pi list for this target
+    root->pi[i][j] = s; // set instruction
+}
+
+// called when the parser finds an internal doctype subset
+short ezxml_internal_dtd(ezxml_root_t root, char *s, size_t len)
+{
+    char q, *c, *t, *n = NULL, *v, **ent, **pe;
+    int i, j;
+    
+    pe = (char**)memcpy(malloc(sizeof(EZXML_NIL)), EZXML_NIL, sizeof(EZXML_NIL));
+
+    for (s[len] = '\0'; s; ) {
+        while (*s && *s != '<' && *s != '%') s++; // find next declaration
+
+        if (! *s) break;
+        else if (! strncmp(s, "<!ENTITY", 8)) { // parse entity definitions
+            c = s += strspn(s + 8, EZXML_WS) + 8; // skip white space separator
+            n = s + strspn(s, EZXML_WS "%"); // find name
+            *(s = n + strcspn(n, EZXML_WS)) = ';'; // append ; to name
+
+            v = s + strspn(s + 1, EZXML_WS) + 1; // find value
+            if ((q = *(v++)) != '"' && q != '\'') { // skip externals
+                s = strchr(s, '>');
+                continue;
+            }
+
+            for (i = 0, ent = (*c == '%') ? pe : root->ent; ent[i]; i++);
+            ent = (char**)realloc(ent, (i + 3) * sizeof(char *)); // space for next ent
+            if (*c == '%') pe = ent;
+            else root->ent = ent;
+
+            *(++s) = '\0'; // null terminate name
+            if ((s = strchr(v, q))) *(s++) = '\0'; // null terminate value
+            ent[i + 1] = ezxml_decode(v, pe, '%'); // set value
+            ent[i + 2] = NULL; // null terminate entity list
+            if (! ezxml_ent_ok(n, ent[i + 1], ent)) { // circular reference
+                if (ent[i + 1] != v) free(ent[i + 1]);
+                ezxml_err(root, v, "circular entity declaration &%s", n);
+                break;
+            }
+            else ent[i] = n; // set entity name
+        }
+        else if (! strncmp(s, "<!ATTLIST", 9)) { // parse default attributes
+            t = s + strspn(s + 9, EZXML_WS) + 9; // skip whitespace separator
+            if (! *t) { ezxml_err(root, t, "unclosed <!ATTLIST"); break; }
+            if (*(s = t + strcspn(t, EZXML_WS ">")) == '>') continue;
+            else *s = '\0'; // null terminate tag name
+            for (i = 0; root->attr[i] && strcmp(n, root->attr[i][0]); i++);
+
+            while (*(n = ++s + strspn(s, EZXML_WS)) && *n != '>') {
+                if (*(s = n + strcspn(n, EZXML_WS))) *s = '\0'; // attr name
+                else { ezxml_err(root, t, "malformed <!ATTLIST"); break; }
+
+                s += strspn(s + 1, EZXML_WS) + 1; // find next token
+                c = (strncmp(s, "CDATA", 5)) ? (char*)"*" : (char*)" "; // is it cdata?
+                if (! strncmp(s, "NOTATION", 8))
+                    s += strspn(s + 8, EZXML_WS) + 8;
+                s = (*s == '(') ? strchr(s, ')') : s + strcspn(s, EZXML_WS);
+                if (! s) { ezxml_err(root, t, "malformed <!ATTLIST"); break; }
+
+                s += strspn(s, EZXML_WS ")"); // skip white space separator
+                if (! strncmp(s, "#FIXED", 6))
+                    s += strspn(s + 6, EZXML_WS) + 6;
+                if (*s == '#') { // no default value
+                    s += strcspn(s, EZXML_WS ">") - 1;
+                    if (*c == ' ') continue; // cdata is default, nothing to do
+                    v = NULL;
+                }
+                else if ((*s == '"' || *s == '\'')  &&  // default value
+                         (s = strchr(v = s + 1, *s))) *s = '\0';
+                else { ezxml_err(root, t, "malformed <!ATTLIST"); break; }
+
+                if (! root->attr[i]) { // new tag name
+                    root->attr = (! i) ? (char***)malloc(2 * sizeof(char **))
+                                       : (char***)realloc(root->attr,
+                                                 (i + 2) * sizeof(char **));
+                    root->attr[i] = (char**)malloc(2 * sizeof(char *));
+                    root->attr[i][0] = t; // set tag name
+                    root->attr[i][1] = (char *)(root->attr[i + 1] = NULL);
+                }
+
+                for (j = 1; root->attr[i][j]; j += 3); // find end of list
+                root->attr[i] = (char**)realloc(root->attr[i],
+                                        (j + 4) * sizeof(char *));
+
+                root->attr[i][j + 3] = NULL; // null terminate list
+                root->attr[i][j + 2] = c; // is it cdata?
+                root->attr[i][j + 1] = (v) ? ezxml_decode(v, root->ent, *c)
+                                           : NULL;
+                root->attr[i][j] = n; // attribute name 
+            }
+        }
+        else if (! strncmp(s, "<!--", 4)) s = strstr(s + 4, "-->"); // comments
+        else if (! strncmp(s, "<?", 2)) { // processing instructions
+            if ((s = strstr(c = s + 2, "?>")))
+                ezxml_proc_inst(root, c, s++ - c);
+        }
+        else if (*s == '<') s = strchr(s, '>'); // skip other declarations
+        else if (*(s++) == '%' && ! root->standalone) break;
+    }
+
+    free(pe);
+    return ! *root->err;
+}
+
+// Converts a UTF-16 string to UTF-8. Returns a new string that must be freed
+// or NULL if no conversion was needed.
+char *ezxml_str2utf8(char **s, size_t *len)
+{
+    char *u;
+    size_t l = 0, sl, max = *len;
+    long c, d;
+    int b, be = (**s == '\xFE') ? 1 : (**s == '\xFF') ? 0 : -1;
+
+    if (be == -1) return NULL; // not UTF-16
+
+    u = (char*)malloc(max);
+    for (sl = 2; sl < *len - 1; sl += 2) {
+        c = (be) ? (((*s)[sl] & 0xFF) << 8) | ((*s)[sl + 1] & 0xFF)  //UTF-16BE
+                 : (((*s)[sl + 1] & 0xFF) << 8) | ((*s)[sl] & 0xFF); //UTF-16LE
+        if (c >= 0xD800 && c <= 0xDFFF && (sl += 2) < *len - 1) { // high-half
+            d = (be) ? (((*s)[sl] & 0xFF) << 8) | ((*s)[sl + 1] & 0xFF)
+                     : (((*s)[sl + 1] & 0xFF) << 8) | ((*s)[sl] & 0xFF);
+            c = (((c & 0x3FF) << 10) | (d & 0x3FF)) + 0x10000;
+        }
+
+        while (l + 6 > max) u = (char*)realloc(u, max += EZXML_BUFSIZE);
+        if (c < 0x80) u[l++] = c; // US-ASCII subset
+        else { // multi-byte UTF-8 sequence
+            for (b = 0, d = c; d; d /= 2) b++; // bits in c
+            b = (b - 2) / 5; // bytes in payload
+            u[l++] = (0xFF << (7 - b)) | (c >> (6 * b)); // head
+            while (b) u[l++] = 0x80 | ((c >> (6 * --b)) & 0x3F); // payload
+        }
+    }
+    return *s = (char*)realloc(u, *len = l);
+}
+
+// frees a tag attribute list
+void ezxml_free_attr(char **attr) {
+    int i = 0;
+    char *m;
+    
+    if (! attr || attr == EZXML_NIL) return; // nothing to free
+    while (attr[i]) i += 2; // find end of attribute list
+    m = attr[i + 1]; // list of which names and values are malloced
+    for (i = 0; m[i]; i++) {
+        if (m[i] & EZXML_NAMEM) free(attr[i * 2]);
+        if (m[i] & EZXML_TXTM) free(attr[(i * 2) + 1]);
+    }
+    free(m);
+    free(attr);
+}
+
+// parse the given xml string and return an ezxml structure
+ezxml_t ezxml_parse_str(char *s, size_t len)
+{
+    ezxml_root_t root = (ezxml_root_t)ezxml_new(NULL);
+    char q, e, *d, **attr, **a = NULL; // initialize a to avoid compile warning
+    int l, i, j;
+
+    root->m = s;
+    if (! len) return ezxml_err(root, NULL, "root tag missing");
+    root->u = ezxml_str2utf8(&s, &len); // convert utf-16 to utf-8
+    root->e = (root->s = s) + len; // record start and end of work area
+    
+    e = s[len - 1]; // save end char
+    s[len - 1] = '\0'; // turn end char into null terminator
+
+    while (*s && *s != '<') s++; // find first tag
+    if (! *s) return ezxml_err(root, s, "root tag missing");
+
+    for (; ; ) {
+        attr = (char **)EZXML_NIL;
+        d = ++s;
+        
+        if (isalpha(*s) || *s == '_' || *s == ':' || *s < '\0') { // new tag
+            if (! root->cur)
+                return ezxml_err(root, d, "markup outside of root element");
+
+            s += strcspn(s, EZXML_WS "/>");
+            while (isspace(*s)) *(s++) = '\0'; // null terminate tag name
+  
+            if (*s && *s != '/' && *s != '>') // find tag in default attr list
+                for (i = 0; (a = root->attr[i]) && strcmp(a[0], d); i++);
+
+            for (l = 0; *s && *s != '/' && *s != '>'; l += 2) { // new attrib
+                attr = (l) ? (char**)realloc(attr, (l + 4) * sizeof(char *))
+                           : (char**)malloc(4 * sizeof(char *)); // allocate space
+                attr[l + 3] = (l) ? (char*)realloc(attr[l + 1], (l / 2) + 2)
+                                  : (char*)malloc(2); // mem for list of maloced vals
+                strcpy(attr[l + 3] + (l / 2), " "); // value is not malloced
+                attr[l + 2] = NULL; // null terminate list
+                attr[l + 1] = ""; // temporary attribute value
+                attr[l] = s; // set attribute name
+
+                s += strcspn(s, EZXML_WS "=/>");
+                if (*s == '=' || isspace(*s)) { 
+                    *(s++) = '\0'; // null terminate tag attribute name
+                    q = *(s += strspn(s, EZXML_WS "="));
+                    if (q == '"' || q == '\'') { // attribute value
+                        attr[l + 1] = ++s;
+                        while (*s && *s != q) s++;
+                        if (*s) *(s++) = '\0'; // null terminate attribute val
+                        else {
+                            ezxml_free_attr(attr);
+                            return ezxml_err(root, d, "missing %c", q);
+                        }
+
+                        for (j = 1; a && a[j] && strcmp(a[j], attr[l]); j +=3);
+                        attr[l + 1] = ezxml_decode(attr[l + 1], root->ent, (a
+                                                   && a[j]) ? *a[j + 2] : ' ');
+                        if (attr[l + 1] < d || attr[l + 1] > s)
+                            attr[l + 3][l / 2] = EZXML_TXTM; // value malloced
+                    }
+                }
+                while (isspace(*s)) s++;
+            }
+
+            if (*s == '/') { // self closing tag
+                *(s++) = '\0';
+                if ((*s && *s != '>') || (! *s && e != '>')) {
+                    if (l) ezxml_free_attr(attr);
+                    return ezxml_err(root, d, "missing >");
+                }
+                ezxml_open_tag(root, d, attr);
+                ezxml_close_tag(root, d, s);
+            }
+            else if ((q = *s) == '>' || (! *s && e == '>')) { // open tag
+                *s = '\0'; // temporarily null terminate tag name
+                ezxml_open_tag(root, d, attr);
+                *s = q;
+            }
+            else {
+                if (l) ezxml_free_attr(attr);
+                return ezxml_err(root, d, "missing >"); 
+            }
+        }
+        else if (*s == '/') { // close tag
+            s += strcspn(d = s + 1, EZXML_WS ">") + 1;
+            if (! (q = *s) && e != '>') return ezxml_err(root, d, "missing >");
+            *s = '\0'; // temporarily null terminate tag name
+            if (ezxml_close_tag(root, d, s)) return &root->xml;
+            if (isspace(*s = q)) s += strspn(s, EZXML_WS);
+        }
+        else if (! strncmp(s, "!--", 3)) { // xml comment
+            if (! (s = strstr(s + 3, "--")) || (*(s += 2) != '>' && *s) ||
+                (! *s && e != '>')) return ezxml_err(root, d, "unclosed <!--");
+        }
+        else if (! strncmp(s, "![CDATA[", 8)) { // cdata
+            if ((s = strstr(s, "]]>")))
+                ezxml_char_content(root, d + 8, (s += 2) - d - 10, 'c');
+            else return ezxml_err(root, d, "unclosed <![CDATA[");
+        }
+        else if (! strncmp(s, "!DOCTYPE", 8)) { // dtd
+            for (l = 0; *s && ((! l && *s != '>') || (l && (*s != ']' || 
+                 *(s + strspn(s + 1, EZXML_WS) + 1) != '>')));
+                 l = (*s == '[') ? 1 : l) s += strcspn(s + 1, "[]>") + 1;
+            if (! *s && e != '>')
+                return ezxml_err(root, d, "unclosed <!DOCTYPE");
+            d = (l) ? strchr(d, '[') + 1 : d;
+            if (l && ! ezxml_internal_dtd(root, d, s++ - d)) return &root->xml;
+        }
+        else if (*s == '?') { // <?...?> processing instructions
+            do { s = strchr(s, '?'); } while (s && *(++s) && *s != '>');
+            if (! s || (! *s && e != '>')) 
+                return ezxml_err(root, d, "unclosed <?");
+            else ezxml_proc_inst(root, d + 1, s - d - 2);
+        }
+        else return ezxml_err(root, d, "unexpected <");
+        
+        if (! s || ! *s) break;
+        *s = '\0';
+        d = ++s;
+        if (*s && *s != '<') { // tag character content
+            while (*s && *s != '<') s++;
+            if (*s) ezxml_char_content(root, d, s - d, '&');
+            else break;
+        }
+        else if (! *s) break;
+    }
+
+    if (! root->cur) return &root->xml;
+    else if (! root->cur->name) return ezxml_err(root, d, "root tag missing");
+    else return ezxml_err(root, d, "unclosed tag <%s>", root->cur->name);
+}
+
+// Wrapper for ezxml_parse_str() that accepts a file stream. Reads the entire
+// stream into memory and then parses it. For xml files, use ezxml_parse_file()
+// or ezxml_parse_fd()
+ezxml_t ezxml_parse_fp(FILE *fp)
+{
+    ezxml_root_t root;
+    size_t l, len = 0;
+    char *s;
+
+    if (! (s = (char*)malloc(EZXML_BUFSIZE))) return NULL;
+    do {
+        len += (l = fread((s + len), 1, EZXML_BUFSIZE, fp));
+        if (l == EZXML_BUFSIZE) s = (char*)realloc(s, len + EZXML_BUFSIZE);
+    } while (s && l == EZXML_BUFSIZE);
+
+    if (! s) return NULL;
+    root = (ezxml_root_t)ezxml_parse_str(s, len);
+    root->len = -1; // so we know to free s in ezxml_free()
+    return &root->xml;
+}
+
+// A wrapper for ezxml_parse_str() that accepts a file descriptor. First
+// attempts to mem map the file. Failing that, reads the file into memory.
+// Returns NULL on failure.
+ezxml_t ezxml_parse_fd(int fd)
+{
+    ezxml_root_t root;
+    struct stat st;
+    size_t l;
+    void *m;
+
+    if (fd < 0) return NULL;
+    fstat(fd, &st);
+
+
+        l = read(fd, m = (char*)malloc(st.st_size), st.st_size);
+        root = (ezxml_root_t)ezxml_parse_str((char*)m, l);
+        root->len = -1; // so we know to free s in ezxml_free()
+
+    return &root->xml;
+}
+
+// a wrapper for ezxml_parse_fd that accepts a file name
+ezxml_t ezxml_parse_file(const char *file)
+{
+    int fd = open(file, O_RDONLY, 0);
+    ezxml_t xml = ezxml_parse_fd(fd);
+    
+    if (fd >= 0) close(fd);
+    return xml;
+}
+
+// Encodes ampersand sequences appending the results to *dst, reallocating *dst
+// if length excedes max. a is non-zero for attribute encoding. Returns *dst
+char *ezxml_ampencode(const char *s, size_t len, char **dst, size_t *dlen,
+                      size_t *max, short a)
+{
+    const char *e;
+    
+    for (e = s + len; s != e; s++) {
+        while (*dlen + 10 > *max) *dst = (char*)realloc(*dst, *max += EZXML_BUFSIZE);
+
+        switch (*s) {
+        case '\0': return *dst;
+        case '&': *dlen += sprintf(*dst + *dlen, "&amp;"); break;
+        case '<': *dlen += sprintf(*dst + *dlen, "&lt;"); break;
+        case '>': *dlen += sprintf(*dst + *dlen, "&gt;"); break;
+        case '"': *dlen += sprintf(*dst + *dlen, (a) ? "&quot;" : "\""); break;
+        case '\n': *dlen += sprintf(*dst + *dlen, (a) ? "&#xA;" : "\n"); break;
+        case '\t': *dlen += sprintf(*dst + *dlen, (a) ? "&#x9;" : "\t"); break;
+        case '\r': *dlen += sprintf(*dst + *dlen, "&#xD;"); break;
+        default: (*dst)[(*dlen)++] = *s;
+        }
+    }
+    return *dst;
+}
+
+// Recursively converts each tag to xml appending it to *s. Reallocates *s if
+// its length excedes max. start is the location of the previous tag in the
+// parent tag's character content. Returns *s.
+char *ezxml_toxml_r(ezxml_t xml, char **s, size_t *len, size_t *max,
+                    size_t start, char ***attr)
+{
+    int i, j;
+    char *txt = (char*)((xml->parent) ? xml->parent->txt : "");
+    size_t off = 0;
+
+    // parent character content up to this tag
+    *s = ezxml_ampencode(txt + start, xml->off - start, s, len, max, 0);
+
+    while (*len + strlen(xml->name) + 4 > *max) // reallocate s
+        *s = (char*)realloc(*s, *max += EZXML_BUFSIZE);
+
+    *len += sprintf(*s + *len, "<%s", xml->name); // open tag
+    for (i = 0; xml->attr[i]; i += 2) { // tag attributes
+        if (ezxml_attr(xml, xml->attr[i]) != xml->attr[i + 1]) continue;
+        while (*len + strlen(xml->attr[i]) + 7 > *max) // reallocate s
+            *s = (char*)realloc(*s, *max += EZXML_BUFSIZE);
+
+        *len += sprintf(*s + *len, " %s=\"", xml->attr[i]);
+        ezxml_ampencode(xml->attr[i + 1], -1, s, len, max, 1);
+        *len += sprintf(*s + *len, "\"");
+    }
+
+    for (i = 0; attr[i] && strcmp(attr[i][0], xml->name); i++);
+    for (j = 1; attr[i] && attr[i][j]; j += 3) { // default attributes
+        if (! attr[i][j + 1] || ezxml_attr(xml, attr[i][j]) != attr[i][j + 1])
+            continue; // skip duplicates and non-values
+        while (*len + strlen(attr[i][j]) + 7 > *max) // reallocate s
+            *s = (char*)realloc(*s, *max += EZXML_BUFSIZE);
+
+        *len += sprintf(*s + *len, " %s=\"", attr[i][j]);
+        ezxml_ampencode(attr[i][j + 1], -1, s, len, max, 1);
+        *len += sprintf(*s + *len, "\"");
+    }
+    *len += sprintf(*s + *len, ">");
+
+    *s = (xml->child) ? ezxml_toxml_r(xml->child, s, len, max, 0, attr) //child
+                      : ezxml_ampencode(xml->txt, -1, s, len, max, 0);  //data
+    
+    while (*len + strlen(xml->name) + 4 > *max) // reallocate s
+        *s = (char*)realloc(*s, *max += EZXML_BUFSIZE);
+
+    *len += sprintf(*s + *len, "</%s>", xml->name); // close tag
+
+    while (txt[off] && off < xml->off) off++; // make sure off is within bounds
+    return (xml->ordered) ? ezxml_toxml_r(xml->ordered, s, len, max, off, attr)
+                          : ezxml_ampencode(txt + off, -1, s, len, max, 0);
+}
+
+// Converts an ezxml structure back to xml. Returns a string of xml data that
+// must be freed.
+char *ezxml_toxml(ezxml_t xml)
+{
+    ezxml_t p = (xml) ? xml->parent : NULL, o = (xml) ? xml->ordered : NULL;
+    ezxml_root_t root = (ezxml_root_t)xml;
+    size_t len = 0, max = EZXML_BUFSIZE;
+    char *s = strcpy((char*)malloc(max), ""), *t, *n;
+    int i, j, k;
+
+    if (! xml || ! xml->name) return (char*)realloc(s, len + 1);
+    while (root->xml.parent) root = (ezxml_root_t)root->xml.parent; // root tag
+
+    for (i = 0; ! p && root->pi[i]; i++) { // pre-root processing instructions
+        for (k = 2; root->pi[i][k - 1]; k++);
+        for (j = 1; (n = root->pi[i][j]); j++) {
+            if (root->pi[i][k][j - 1] == '>') continue; // not pre-root
+            while (len + strlen(t = root->pi[i][0]) + strlen(n) + 7 > max)
+                s = (char*)realloc(s, max += EZXML_BUFSIZE);
+            len += sprintf(s + len, "<?%s%s%s?>\n", t, *n ? " " : "", n);
+        }
+    }
+
+    xml->parent = xml->ordered = NULL;
+    s = ezxml_toxml_r(xml, &s, &len, &max, 0, root->attr);
+    xml->parent = p;
+    xml->ordered = o;
+
+    for (i = 0; ! p && root->pi[i]; i++) { // post-root processing instructions
+        for (k = 2; root->pi[i][k - 1]; k++);
+        for (j = 1; (n = root->pi[i][j]); j++) {
+            if (root->pi[i][k][j - 1] == '<') continue; // not post-root
+            while (len + strlen(t = root->pi[i][0]) + strlen(n) + 7 > max)
+                s = (char*)realloc(s, max += EZXML_BUFSIZE);
+            len += sprintf(s + len, "\n<?%s%s%s?>", t, *n ? " " : "", n);
+        }
+    }
+    return (char*)realloc(s, len + 1);
+}
+
+// free the memory allocated for the ezxml structure
+void ezxml_free(ezxml_t xml)
+{
+    ezxml_root_t root = (ezxml_root_t)xml;
+    int i, j;
+    char **a, *s;
+
+    if (! xml) return;
+    ezxml_free(xml->child);
+    ezxml_free(xml->ordered);
+
+    if (! xml->parent) { // free root tag allocations
+        for (i = 10; root->ent[i]; i += 2) // 0 - 9 are default entites (<>&"')
+            if ((s = root->ent[i + 1]) < root->s || s > root->e) free(s);
+        free(root->ent); // free list of general entities
+
+        for (i = 0; (a = root->attr[i]); i++) {
+            for (j = 1; a[j++]; j += 2) // free malloced attribute values
+                if (a[j] && (a[j] < root->s || a[j] > root->e)) free(a[j]);
+            free(a);
+        }
+        if (root->attr[0]) free(root->attr); // free default attribute list
+
+        for (i = 0; root->pi[i]; i++) {
+            for (j = 1; root->pi[i][j]; j++);
+            free(root->pi[i][j + 1]);
+            free(root->pi[i]);
+        }            
+        if (root->pi[0]) free(root->pi); // free processing instructions
+
+        if (root->len == -1) free(root->m); // malloced xml data
+
+        if (root->u) free(root->u); // utf8 conversion
+    }
+
+    ezxml_free_attr(xml->attr); // tag attributes
+    if ((xml->flags & EZXML_TXTM)) free(xml->txt); // character content
+    if ((xml->flags & EZXML_NAMEM)) free(xml->name); // tag name
+    free(xml);
+}
+
+// return parser error message or empty string if none
+const char *ezxml_error(ezxml_t xml)
+{
+    while (xml && xml->parent) xml = xml->parent; // find root tag
+    return (xml) ? ((ezxml_root_t)xml)->err : "";
+}
+
+// returns a new empty ezxml structure with the given root tag name
+ezxml_t ezxml_new(const char *name)
+{
+    static char *ent[] = { "lt;", "&#60;", "gt;", "&#62;", "quot;", "&#34;",
+                           "apos;", "&#39;", "amp;", "&#38;", NULL };
+    ezxml_root_t root = (ezxml_root_t)memset(malloc(sizeof(struct ezxml_root)), 
+                                             '\0', sizeof(struct ezxml_root));
+    root->xml.name = (char *)name;
+    root->cur = &root->xml;
+    strcpy(root->err, root->xml.txt = "");
+    root->ent = (char**)memcpy(malloc(sizeof(ent)), ent, sizeof(ent));
+    root->attr = root->pi = (char ***)(root->xml.attr = EZXML_NIL);
+    return &root->xml;
+}
+
+// inserts an existing tag into an ezxml structure
+ezxml_t ezxml_insert(ezxml_t xml, ezxml_t dest, size_t off)
+{
+    ezxml_t cur, prev, head;
+
+    xml->next = xml->sibling = xml->ordered = NULL;
+    xml->off = off;
+    xml->parent = dest;
+
+    if ((head = dest->child)) { // already have sub tags
+        if (head->off <= off) { // not first subtag
+            for (cur = head; cur->ordered && cur->ordered->off <= off;
+                 cur = cur->ordered);
+            xml->ordered = cur->ordered;
+            cur->ordered = xml;
+        }
+        else { // first subtag
+            xml->ordered = head;
+            dest->child = xml;
+        }
+
+        for (cur = head, prev = NULL; cur && strcmp(cur->name, xml->name);
+             prev = cur, cur = cur->sibling); // find tag type
+        if (cur && cur->off <= off) { // not first of type
+            while (cur->next && cur->next->off <= off) cur = cur->next;
+            xml->next = cur->next;
+            cur->next = xml;
+        }
+        else { // first tag of this type
+            if (prev && cur) prev->sibling = cur->sibling; // remove old first
+            xml->next = cur; // old first tag is now next
+            for (cur = head, prev = NULL; cur && cur->off <= off;
+                 prev = cur, cur = cur->sibling); // new sibling insert point
+            xml->sibling = cur;
+            if (prev) prev->sibling = xml;
+        }
+    }
+    else dest->child = xml; // only sub tag
+
+    return xml;
+}
+
+// Adds a child tag. off is the offset of the child tag relative to the start
+// of the parent tag's character content. Returns the child tag.
+ezxml_t ezxml_add_child(ezxml_t xml, const char *name, size_t off)
+{
+    ezxml_t child;
+
+    if (! xml) return NULL;
+    child = (ezxml_t)memset(malloc(sizeof(struct ezxml)), '\0',
+                            sizeof(struct ezxml));
+    child->name = (char *)name;
+    child->attr = EZXML_NIL;
+    child->txt = "";
+
+    return ezxml_insert(child, xml, off);
+}
+
+// sets the character content for the given tag and returns the tag
+ezxml_t ezxml_set_txt(ezxml_t xml, const char *txt)
+{
+    if (! xml) return NULL;
+    if (xml->flags & EZXML_TXTM) free(xml->txt); // existing txt was malloced
+    xml->flags &= ~EZXML_TXTM;
+    xml->txt = (char *)txt;
+    return xml;
+}
+
+// Sets the given tag attribute or adds a new attribute if not found. A value
+// of NULL will remove the specified attribute. Returns the tag given.
+ezxml_t ezxml_set_attr(ezxml_t xml, const char *name, const char *value)
+{
+    int l = 0, c;
+
+    if (! xml) return NULL;
+    while (xml->attr[l] && strcmp(xml->attr[l], name)) l += 2;
+    if (! xml->attr[l]) { // not found, add as new attribute
+        if (! value) return xml; // nothing to do
+        if (xml->attr == EZXML_NIL) { // first attribute
+            xml->attr = (char**)malloc(4 * sizeof(char *));
+            xml->attr[1] = strdup(""); // empty list of malloced names/vals
+        }
+        else xml->attr = (char**)realloc(xml->attr, (l + 4) * sizeof(char *));
+
+        xml->attr[l] = (char *)name; // set attribute name
+        xml->attr[l + 2] = NULL; // null terminate attribute list
+        xml->attr[l + 3] = (char*)realloc(xml->attr[l + 1],
+                                   (c = strlen(xml->attr[l + 1])) + 2);
+        strcpy(xml->attr[l + 3] + c, " "); // set name/value as not malloced
+        if (xml->flags & EZXML_DUP) xml->attr[l + 3][c] = EZXML_NAMEM;
+    }
+    else if (xml->flags & EZXML_DUP) free((char *)name); // name was strduped
+
+    for (c = l; xml->attr[c]; c += 2); // find end of attribute list
+    if (xml->attr[c + 1][l / 2] & EZXML_TXTM) free(xml->attr[l + 1]); //old val
+    if (xml->flags & EZXML_DUP) xml->attr[c + 1][l / 2] |= EZXML_TXTM;
+    else xml->attr[c + 1][l / 2] &= ~EZXML_TXTM;
+
+    if (value) xml->attr[l + 1] = (char *)value; // set attribute value
+    else { // remove attribute
+        if (xml->attr[c + 1][l / 2] & EZXML_NAMEM) free(xml->attr[l]);
+        memmove(xml->attr + l, xml->attr + l + 2, (c - l + 2) * sizeof(char*));
+        xml->attr = (char**)realloc(xml->attr, (c + 2) * sizeof(char *));
+        memmove(xml->attr[c + 1] + (l / 2), xml->attr[c + 1] + (l / 2) + 1,
+                (c / 2) - (l / 2)); // fix list of which name/vals are malloced
+    }
+    xml->flags &= ~EZXML_DUP; // clear strdup() flag
+    return xml;
+}
+
+// sets a flag for the given tag and returns the tag
+ezxml_t ezxml_set_flag(ezxml_t xml, short flag)
+{
+    if (xml) xml->flags |= flag;
+    return xml;
+}
+
+// removes a tag along with its subtags without freeing its memory
+ezxml_t ezxml_cut(ezxml_t xml)
+{
+    ezxml_t cur;
+
+    if (! xml) return NULL; // nothing to do
+    if (xml->next) xml->next->sibling = xml->sibling; // patch sibling list
+
+    if (xml->parent) { // not root tag
+        cur = xml->parent->child; // find head of subtag list
+        if (cur == xml) xml->parent->child = xml->ordered; // first subtag
+        else { // not first subtag
+            while (cur->ordered != xml) cur = cur->ordered;
+            cur->ordered = cur->ordered->ordered; // patch ordered list
+
+            cur = xml->parent->child; // go back to head of subtag list
+            if (strcmp(cur->name, xml->name)) { // not in first sibling list
+                while (strcmp(cur->sibling->name, xml->name))
+                    cur = cur->sibling;
+                if (cur->sibling == xml) { // first of a sibling list
+                    cur->sibling = (xml->next) ? xml->next
+                                               : cur->sibling->sibling;
+                }
+                else cur = cur->sibling; // not first of a sibling list
+            }
+
+            while (cur->next && cur->next != xml) cur = cur->next;
+            if (cur->next) cur->next = cur->next->next; // patch next list
+        }        
+    }
+    xml->ordered = xml->sibling = xml->next = NULL;
+    return xml;
+}
+
+#ifdef EZXML_TEST // test harness
+int main(int argc, char **argv)
+{
+    ezxml_t xml;
+    char *s;
+    int i;
+
+    if (argc != 2) return fprintf(stderr, "usage: %s xmlfile\n", argv[0]);
+
+    xml = ezxml_parse_file(argv[1]);
+    printf("%s\n", (s = ezxml_toxml(xml)));
+    free(s);
+    i = fprintf(stderr, "%s", ezxml_error(xml));
+    ezxml_free(xml);
+    return (i) ? 1 : 0;
+}
+#endif // EZXML_TEST
diff -Naur rssreader-1.1.2-orig/ezxml.h rssreader/ezxml.h
--- rssreader-1.1.2-orig/ezxml.h	1970-01-01 01:00:00.000000000 +0100
+++ rssreader/ezxml.h	2008-01-12 14:09:02.000000000 +0100
@@ -0,0 +1,167 @@
+/* ezxml.h
+ *
+ * Copyright 2004-2006 Aaron Voisine <aaron@voisine.org>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef _EZXML_H
+#define _EZXML_H
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdarg.h>
+#include <fcntl.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define EZXML_BUFSIZE 1024 // size of internal memory buffers
+#define EZXML_NAMEM   0x80 // name is malloced
+#define EZXML_TXTM    0x40 // txt is malloced
+#define EZXML_DUP     0x20 // attribute name and value are strduped
+
+typedef struct ezxml *ezxml_t;
+struct ezxml {
+    char *name;      // tag name
+    char **attr;     // tag attributes { name, value, name, value, ... NULL }
+    char *txt;       // tag character content, empty string if none
+    size_t off;      // tag offset from start of parent tag character content
+    ezxml_t next;    // next tag with same name in this section at this depth
+    ezxml_t sibling; // next tag with different name in same section and depth
+    ezxml_t ordered; // next tag, same section and depth, in original order
+    ezxml_t child;   // head of sub tag list, NULL if none
+    ezxml_t parent;  // parent tag, NULL if current tag is root tag
+    short flags;     // additional information
+};
+
+// Given a string of xml data and its length, parses it and creates an ezxml
+// structure. For efficiency, modifies the data by adding null terminators
+// and decoding ampersand sequences. If you don't want this, copy the data and
+// pass in the copy. Returns NULL on failure.
+ezxml_t ezxml_parse_str(char *s, size_t len);
+
+// A wrapper for ezxml_parse_str() that accepts a file descriptor. First
+// attempts to mem map the file. Failing that, reads the file into memory.
+// Returns NULL on failure.
+ezxml_t ezxml_parse_fd(int fd);
+
+// a wrapper for ezxml_parse_fd() that accepts a file name
+ezxml_t ezxml_parse_file(const char *file);
+    
+// Wrapper for ezxml_parse_str() that accepts a file stream. Reads the entire
+// stream into memory and then parses it. For xml files, use ezxml_parse_file()
+// or ezxml_parse_fd()
+ezxml_t ezxml_parse_fp(FILE *fp);
+
+// returns the first child tag (one level deeper) with the given name or NULL
+// if not found
+ezxml_t ezxml_child(ezxml_t xml, const char *name);
+
+// returns the next tag of the same name in the same section and depth or NULL
+// if not found
+#define ezxml_next(xml) ((xml) ? xml->next : NULL)
+
+// Returns the Nth tag with the same name in the same section at the same depth
+// or NULL if not found. An index of 0 returns the tag given.
+ezxml_t ezxml_idx(ezxml_t xml, int idx);
+
+// returns the name of the given tag
+#define ezxml_name(xml) ((xml) ? xml->name : NULL)
+
+// returns the given tag's character content or empty string if none
+#define ezxml_txt(xml) ((xml) ? xml->txt : "")
+
+// returns the value of the requested tag attribute, or NULL if not found
+const char *ezxml_attr(ezxml_t xml, const char *attr);
+
+// Traverses the ezxml sturcture to retrieve a specific subtag. Takes a
+// variable length list of tag names and indexes. The argument list must be
+// terminated by either an index of -1 or an empty string tag name. Example: 
+// title = ezxml_get(library, "shelf", 0, "book", 2, "title", -1);
+// This retrieves the title of the 3rd book on the 1st shelf of library.
+// Returns NULL if not found.
+ezxml_t ezxml_get(ezxml_t xml, ...);
+
+// Converts an ezxml structure back to xml. Returns a string of xml data that
+// must be freed.
+char *ezxml_toxml(ezxml_t xml);
+
+// returns a NULL terminated array of processing instructions for the given
+// target
+const char **ezxml_pi(ezxml_t xml, const char *target);
+
+// frees the memory allocated for an ezxml structure
+void ezxml_free(ezxml_t xml);
+    
+// returns parser error message or empty string if none
+const char *ezxml_error(ezxml_t xml);
+
+// returns a new empty ezxml structure with the given root tag name
+ezxml_t ezxml_new(const char *name);
+
+// wrapper for ezxml_new() that strdup()s name
+#define ezxml_new_d(name) ezxml_set_flag(ezxml_new(strdup(name)), EZXML_NAMEM)
+
+// Adds a child tag. off is the offset of the child tag relative to the start
+// of the parent tag's character content. Returns the child tag.
+ezxml_t ezxml_add_child(ezxml_t xml, const char *name, size_t off);
+
+// wrapper for ezxml_add_child() that strdup()s name
+#define ezxml_add_child_d(xml, name, off) \
+    ezxml_set_flag(ezxml_add_child(xml, strdup(name), off), EZXML_NAMEM)
+
+// sets the character content for the given tag and returns the tag
+ezxml_t ezxml_set_txt(ezxml_t xml, const char *txt);
+
+// wrapper for ezxml_set_txt() that strdup()s txt
+#define ezxml_set_txt_d(xml, txt) \
+    ezxml_set_flag(ezxml_set_txt(xml, strdup(txt)), EZXML_TXTM)
+
+// Sets the given tag attribute or adds a new attribute if not found. A value
+// of NULL will remove the specified attribute. Returns the tag given.
+ezxml_t ezxml_set_attr(ezxml_t xml, const char *name, const char *value);
+
+// Wrapper for ezxml_set_attr() that strdup()s name/value. Value cannot be NULL
+#define ezxml_set_attr_d(xml, name, value) \
+    ezxml_set_attr(ezxml_set_flag(xml, EZXML_DUP), strdup(name), strdup(value))
+
+// sets a flag for the given tag and returns the tag
+ezxml_t ezxml_set_flag(ezxml_t xml, short flag);
+
+// removes a tag along with its subtags without freeing its memory
+ezxml_t ezxml_cut(ezxml_t xml);
+
+// inserts an existing tag into an ezxml structure
+ezxml_t ezxml_insert(ezxml_t xml, ezxml_t dest, size_t off);
+
+// Moves an existing tag to become a subtag of dest at the given offset from
+// the start of dest's character content. Returns the moved tag.
+#define ezxml_move(xml, dest, off) ezxml_insert(ezxml_cut(xml), dest, off)
+
+// removes a tag along with all its subtags
+#define ezxml_remove(xml) ezxml_free(ezxml_cut(xml))
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // _EZXML_H
diff -Naur rssreader-1.1.2-orig/http_error_codes.c rssreader/http_error_codes.c
--- rssreader-1.1.2-orig/http_error_codes.c	1970-01-01 01:00:00.000000000 +0100
+++ rssreader/http_error_codes.c	2008-01-12 14:09:02.000000000 +0100
@@ -0,0 +1,39 @@
+/* http_error_codes.c - Error code declarations
+
+	HTTP Fetcher 
+ 	Copyright (C) 2001, 2003, 2004 Lyle Hanson (lhanson@users.sourceforge.net)
+
+	This library is free software; you can redistribute it and/or
+	modify it under the terms of the GNU Library General Public
+	License as published by the Free Software Foundation; either
+	version 2 of the License, or (at your option) any later version.
+
+	This library is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+	Library General Public License for more details.
+
+	See LICENSE file for details
+ */
+
+
+	/* Note that '%d' cannot be escaped at this time */
+const char *http_errlist[] =
+	{
+	"Success",										/* HF_SUCCESS		*/
+	"Internal Error. What the hell?!",				/* HF_METAERROR		*/
+	"Got NULL url",									/* HF_NULLURL		*/
+	"Timed out, no metadata for %d seconds",		/* HF_HEADTIMEOUT 	*/
+	"Timed out, no data for %d seconds",			/* HF_DATATIMEOUT	*/
+	"Couldn't find return code in HTTP response",	/* HF_FRETURNCODE	*/
+	"Couldn't convert return code in HTTP response",/* HF_CRETURNCODE	*/
+	"Request returned a status code of %d",			/* HF_STATUSCODE	*/
+	"Couldn't convert Content-Length to integer",	/* HF_CONTENTLEN	*/
+	"Network error (description unavailable)",		/* HF_HERROR		*/
+	"Status code of %d but no Location: field",		/* HF_CANTREDIRECT  */
+	"Followed the maximum number of redirects (%d)" /* HF_MAXREDIRECTS  */
+	};
+
+	/* Used to copy in messages from http_errlist[] and replace %d's with
+	 *	the value of errorInt.  Then we can pass the pointer to THIS */
+char convertedError[128];
diff -Naur rssreader-1.1.2-orig/http_error_codes.h rssreader/http_error_codes.h
--- rssreader-1.1.2-orig/http_error_codes.h	1970-01-01 01:00:00.000000000 +0100
+++ rssreader/http_error_codes.h	2008-01-12 14:09:02.000000000 +0100
@@ -0,0 +1,42 @@
+/* http_error_codes.h - Error code definitions
+
+	HTTP Fetcher
+	Copyright (C) 2001, 2003, 2004 Lyle Hanson (lhanson@users.sourceforge.net)
+
+	This library is free software; you can redistribute it and/or
+	modify it under the terms of the GNU Library General Public
+	License as published by the Free Software Foundation; either
+	version 2 of the License, or (at your option) any later version.
+
+	This library is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+	Library General Public License for more details.
+
+	See LICENSE file for details
+
+ */
+
+#ifndef HTTP_ERROR_CODES_H
+#define HTTP_ERROR_CODES_H
+
+/* Error sources */
+#define FETCHER_ERROR	0
+#define ERRNO			1
+#define H_ERRNO			2
+
+/* HTTP Fetcher error codes */
+#define HF_SUCCESS		0
+#define HF_METAERROR	1
+#define HF_NULLURL		2
+#define HF_HEADTIMEOUT	3
+#define HF_DATATIMEOUT	4
+#define HF_FRETURNCODE	5
+#define HF_CRETURNCODE	6
+#define HF_STATUSCODE	7
+#define HF_CONTENTLEN	8
+#define HF_HERROR		9
+#define HF_CANTREDIRECT 10
+#define HF_MAXREDIRECTS 11
+
+#endif
diff -Naur rssreader-1.1.2-orig/http_fetcher.c rssreader/http_fetcher.c
--- rssreader-1.1.2-orig/http_fetcher.c	1970-01-01 01:00:00.000000000 +0100
+++ rssreader/http_fetcher.c	2008-01-12 14:09:02.000000000 +0100
@@ -0,0 +1,816 @@
+/* http_fetcher.c - HTTP handling functions
+
+	HTTP Fetcher 
+	Copyright (C) 2001, 2003, 2004 Lyle Hanson (lhanson@users.sourceforge.net)
+
+	This library is free software; you can redistribute it and/or
+	modify it under the terms of the GNU Library General Public
+	License as published by the Free Software Foundation; either
+	version 2 of the License, or (at your option) any later version.
+
+	This library is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+	Library General Public License for more details.
+
+	See LICENSE file for details
+
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <strings.h>
+#include <ctype.h>
+#include <errno.h>
+#include <netdb.h>
+#include <unistd.h>
+#include <netinet/in.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/time.h>
+#include "http_fetcher.h"
+
+/* Globals */
+int timeout = DEFAULT_READ_TIMEOUT;
+char *userAgent = NULL;
+char *referer = NULL;
+int hideUserAgent = 0;
+int hideReferer = 1;
+static int followRedirects = DEFAULT_REDIRECTS;	/* # of redirects to follow */
+extern const char *http_errlist[];	/* Array of HTTP Fetcher error messages */
+extern char convertedError[128];	/* Buffer to used when errors contain %d */
+static int errorSource = 0;
+static int http_errno = 0;
+static int errorInt = 0;			/* When the error message has a %d in it,
+									 *	this variable is inserted */
+
+
+	/* 
+	 * Actually downloads the page, registering a hit (donation)
+	 *	If the fileBuf passed in is NULL, the url is downloaded and then
+	 *	freed; otherwise the necessary space is allocated for fileBuf.
+	 *	Returns size of download on success, -1 on error is set, 
+	 */
+int http_fetch(const char *url_tmp, char **fileBuf)
+	{
+	fd_set rfds;
+	struct timeval tv;
+	char headerBuf[HEADER_BUF_SIZE];
+	char *tmp, *url, *pageBuf, *requestBuf = NULL, *host, *charIndex;
+	int sock, bytesRead = 0, contentLength = -1, bufsize = REQUEST_BUF_SIZE;
+	int i,
+		ret = -1,
+		tempSize,
+		selectRet,
+		found = 0,	/* For redirects */
+		redirectsFollowed = 0;
+
+
+	if(url_tmp == NULL)
+		{
+		errorSource = FETCHER_ERROR;
+		http_errno = HF_NULLURL;
+		return -1;
+		}
+
+	/* Copy the url passed in into a buffer we can work with, change, etc. */
+	url = (char*)malloc(strlen(url_tmp)+1);
+	if(url == NULL)
+		{
+		errorSource = ERRNO;
+		return -1;
+		}
+	strncpy(url, url_tmp, strlen(url_tmp) + 1);
+	
+	/* This loop allows us to follow redirects if need be.  An afterthought,
+	 * added to provide this basic functionality.  Will hopefully be designed
+	 * better in 2.x.x ;) */
+/*	while(!found &&
+		  (followRedirects < 0 || redirectsFollowed < followRedirects) )
+  */  do
+		{
+		/* Seek to the file path portion of the url */
+		charIndex = strstr(url, "://");
+		if(charIndex != NULL)
+			{
+			/* url contains a protocol field */
+			charIndex += strlen("://");
+			host = charIndex;
+			charIndex = strchr(charIndex, '/');
+			}
+		else
+			{
+			host = (char *)url;
+			charIndex = strchr(url, '/');
+			}
+
+		/* Compose a request string */
+		requestBuf = (char*)malloc(bufsize);
+		if(requestBuf == NULL)
+			{
+			free(url);
+			errorSource = ERRNO;
+			return -1;
+			}
+		requestBuf[0] = 0;
+
+		if(charIndex == NULL)
+			{
+			/* The url has no '/' in it, assume the user is making a root-level
+			 *	request */ 
+			tempSize = strlen("GET /") + strlen(HTTP_VERSION) + 2;
+			if(_checkBufSize(&requestBuf, &bufsize, tempSize) ||
+				snprintf(requestBuf, bufsize, "GET / %s\r\n", HTTP_VERSION) < 0)
+				{
+				free(url);
+				free(requestBuf);
+				errorSource = ERRNO;
+				return -1;
+				}
+			}
+		else
+			{
+			tempSize = strlen("GET ") + strlen(charIndex) +
+  	          strlen(HTTP_VERSION) + 4;
+		 	/* + 4 is for ' ', '\r', '\n', and NULL */
+                                    
+			if(_checkBufSize(&requestBuf, &bufsize, tempSize) ||
+					snprintf(requestBuf, bufsize, "GET %s %s\r\n",
+					charIndex, HTTP_VERSION) < 0)
+				{
+				free(url);
+				free(requestBuf);
+				errorSource = ERRNO;
+				return -1;
+				}
+			}
+
+		/* Null out the end of the hostname if need be */
+		if(charIndex != NULL)
+			*charIndex = 0;
+
+		/* Use Host: even though 1.0 doesn't specify it.  Some servers
+		 *	won't play nice if we don't send Host, and it shouldn't
+		 *	hurt anything */
+		ret = bufsize - strlen(requestBuf); /* Space left in buffer */
+		tempSize = (int)strlen("Host: ") + (int)strlen(host) + 3;
+        /* +3 for "\r\n\0" */
+		if(_checkBufSize(&requestBuf, &bufsize, tempSize + 128))
+			{
+			free(url);
+			free(requestBuf);
+			errorSource = ERRNO;
+			return -1;
+			}
+		strcat(requestBuf, "Host: ");
+		strcat(requestBuf, host);
+		strcat(requestBuf, "\r\n");
+
+		if(!hideReferer && referer != NULL)	/* NO default referer */
+			{
+			tempSize = (int)strlen("Referer: ") + (int)strlen(referer) + 3;
+   	        /* + 3 is for '\r', '\n', and NULL */
+			if(_checkBufSize(&requestBuf, &bufsize, tempSize))
+				{
+				free(url);
+				free(requestBuf);
+				errorSource = ERRNO;
+				return -1;
+				}
+			strcat(requestBuf, "Referer: ");
+			strcat(requestBuf, referer);
+			strcat(requestBuf, "\r\n");
+			}
+
+		if(!hideUserAgent && userAgent == NULL)
+			{
+			tempSize = (int)strlen("User-Agent: ") +
+				(int)strlen(DEFAULT_USER_AGENT) + (int)strlen(VERSION) + 4;
+   	        /* + 4 is for '\', '\r', '\n', and NULL */
+			if(_checkBufSize(&requestBuf, &bufsize, tempSize))
+				{
+				free(url);
+				free(requestBuf);
+				errorSource = ERRNO;
+				return -1;
+				}
+			strcat(requestBuf, "User-Agent: ");
+			strcat(requestBuf, DEFAULT_USER_AGENT);
+			strcat(requestBuf, "/");
+			strcat(requestBuf, VERSION);
+			strcat(requestBuf, "\r\n");
+			}
+		else if(!hideUserAgent)
+			{
+			tempSize = (int)strlen("User-Agent: ") + (int)strlen(userAgent) + 3;
+   	        /* + 3 is for '\r', '\n', and NULL */
+			if(_checkBufSize(&requestBuf, &bufsize, tempSize))
+				{
+				free(url);
+				free(requestBuf);
+				errorSource = ERRNO;
+				return -1;
+				}
+			strcat(requestBuf, "User-Agent: ");
+			strcat(requestBuf, userAgent);
+			strcat(requestBuf, "\r\n");
+			}
+
+		tempSize = (int)strlen("Connection: Close\r\n\r\n");
+		if(_checkBufSize(&requestBuf, &bufsize, tempSize))
+			{
+			free(url);
+			free(requestBuf);
+			errorSource = ERRNO;
+			return -1;
+			}
+		strcat(requestBuf, "Connection: Close\r\n\r\n");
+
+		/* Now free any excess memory allocated to the buffer */
+		tmp = (char*)realloc(requestBuf, strlen(requestBuf) + 1);
+		if(tmp == NULL)
+			{
+			free(url);
+			free(requestBuf);
+			errorSource = ERRNO;
+			return -1;
+			}
+		requestBuf = tmp;
+
+		sock = makeSocket(host);		/* errorSource set within makeSocket */
+		if(sock == -1) { free(url); free(requestBuf); return -1;}
+
+		free(url);
+        url = NULL;
+
+		if(write(sock, requestBuf, strlen(requestBuf)) == -1)
+			{
+			close(sock);
+			free(requestBuf);
+			errorSource = ERRNO;
+			return -1;
+			}
+
+		free(requestBuf);
+        requestBuf = NULL;
+
+		/* Grab enough of the response to get the metadata */
+		ret = _http_read_header(sock, headerBuf);	/* errorSource set within */
+		if(ret < 0) { close(sock); return -1; }
+
+		/* Get the return code */
+		charIndex = strstr(headerBuf, "HTTP/");
+		if(charIndex == NULL)
+			{
+			close(sock);
+			errorSource = FETCHER_ERROR;
+			http_errno = HF_FRETURNCODE;
+			return -1;
+			}
+		while(*charIndex != ' ')
+			charIndex++;
+		charIndex++;
+
+		ret = sscanf(charIndex, "%d", &i);
+		if(ret != 1)
+			{
+			close(sock);
+			errorSource = FETCHER_ERROR;
+			http_errno = HF_CRETURNCODE;
+			return -1;
+			}
+		if(i<200 || i>307)
+			{
+			close(sock);
+			errorInt = i;	/* Status code, to be inserted in error string */
+			errorSource = FETCHER_ERROR;
+			http_errno = HF_STATUSCODE;
+			return -1;
+			}
+
+		/* If a redirect, repeat operation until final URL is found or we
+		 *  redirect followRedirects times.  Note the case sensitive "Location",
+		 *  should probably be made more robust in the future (without relying
+		 *  on the non-standard strcasecmp()).
+		 * This bit mostly by Dean Wilder, tweaked by me */
+		if(i >= 300)
+			{
+		    redirectsFollowed++;
+
+			/* Pick up redirect URL, allocate new url, and repeat process */
+			charIndex = strstr(headerBuf, "Location:");
+			if(!charIndex)
+				{
+				close(sock);
+				errorInt = i; /* Status code, to be inserted in error string */
+				errorSource = FETCHER_ERROR;
+				http_errno = HF_CANTREDIRECT;
+				return -1;
+				}
+			charIndex += strlen("Location:");
+            /* Skip any whitespace... */
+            while(*charIndex != '\0' && isspace(*charIndex))
+                charIndex++;
+            if(*charIndex == '\0')
+                {
+				close(sock);
+				errorInt = i; /* Status code, to be inserted in error string */
+				errorSource = FETCHER_ERROR;
+				http_errno = HF_CANTREDIRECT;
+				return -1;
+                }
+
+			i = strcspn(charIndex, " \r\n");
+			if(i > 0)
+				{
+				url = (char *)malloc(i + 1);
+				strncpy(url, charIndex, i);
+				url[i] = '\0';
+				}
+			else
+                /* Found 'Location:' but contains no URL!  We'll handle it as
+                 * 'found', hopefully the resulting document will give the user
+                 * a hint as to what happened. */
+                found = 1;
+            }
+		else
+			found = 1;
+	    } while(!found &&
+                (followRedirects < 0 || redirectsFollowed <= followRedirects) );
+
+    if(url) /* Redirection code may malloc this, then exceed followRedirects */
+        {
+        free(url);
+        url = NULL;
+        }
+    
+    if(redirectsFollowed >= followRedirects && !found)
+        {
+        close(sock);
+    	errorInt = followRedirects; /* To be inserted in error string */
+    	errorSource = FETCHER_ERROR;
+    	http_errno = HF_MAXREDIRECTS;
+	    return -1;
+        }
+	
+	/*
+	 * Parse out about how big the data segment is.
+	 *	Note that under current HTTP standards (1.1 and prior), the
+	 *	Content-Length field is not guaranteed to be accurate or even present. 
+	 *	I just use it here so I can allocate a ballpark amount of memory.
+	 *
+	 * Note that some servers use different capitalization
+	 */
+	charIndex = strstr(headerBuf, "Content-Length:");
+	if(charIndex == NULL)
+		charIndex = strstr(headerBuf, "Content-length:");
+
+	if(charIndex != NULL)
+		{
+		ret = sscanf(charIndex + strlen("content-length: "), "%d",
+			&contentLength);
+		if(ret < 1)
+			{
+			close(sock);
+			errorSource = FETCHER_ERROR;
+			http_errno = HF_CONTENTLEN;
+			return -1;
+			}
+		}
+	
+	/* Allocate enough memory to hold the page */
+	if(contentLength == -1)
+		contentLength = DEFAULT_PAGE_BUF_SIZE;
+
+	pageBuf = (char *)malloc(contentLength);
+	if(pageBuf == NULL)
+		{
+		close(sock);
+		errorSource = ERRNO;
+		return -1;
+		}
+
+	/* Begin reading the body of the file */
+	while(ret > 0)
+		{
+		FD_ZERO(&rfds);
+		FD_SET(sock, &rfds);
+		tv.tv_sec = timeout; 
+		tv.tv_usec = 0;
+
+		if(timeout >= 0)
+			selectRet = select(sock+1, &rfds, NULL, NULL, &tv);
+		else		/* No timeout, can block indefinately */
+			selectRet = select(sock+1, &rfds, NULL, NULL, NULL);
+
+		if(selectRet == 0)
+			{
+			errorSource = FETCHER_ERROR;
+			http_errno = HF_DATATIMEOUT;
+			errorInt = timeout;
+			close(sock);
+			free(pageBuf);
+			return -1;
+			}
+		else if(selectRet == -1)
+			{
+			close(sock);
+			free(pageBuf);
+			errorSource = ERRNO;
+			return -1;
+			}
+
+		ret = read(sock, pageBuf + bytesRead, contentLength);
+		if(ret == -1)
+			{
+			close(sock);
+			free(pageBuf);
+			errorSource = ERRNO;
+			return -1;
+			}
+
+		bytesRead += ret;
+
+		if(ret > 0)
+			{
+			/* To be tolerant of inaccurate Content-Length fields, we'll
+			 *	allocate another read-sized chunk to make sure we have
+			 *	enough room.
+			 */
+			tmp = (char *)realloc(pageBuf, bytesRead + contentLength);
+			if(tmp == NULL)
+				{
+				close(sock);
+				free(pageBuf);
+				errorSource = ERRNO;
+				return -1;
+				}
+            pageBuf = tmp;
+			}
+		}
+	
+	/*
+	 * The download buffer is too large.  Trim off the safety padding.
+     * Note that we add one NULL byte to the end of the data, as it may not
+     *  already be NULL terminated and we can't be sure what type of data it
+     *  is or what the caller will do with it.
+	 */
+	tmp = (char *)realloc(pageBuf, bytesRead + 1);
+		/* tmp shouldn't be null, since we're _shrinking_ the buffer,
+		 *	and if it DID fail, we could go on with the too-large buffer,
+		 *	but something would DEFINATELY be wrong, so we'll just give
+		 *	an error message */
+	if(tmp == NULL)
+		{
+		close(sock);
+		free(pageBuf);
+		errorSource = ERRNO;
+		return -1;
+		}
+    pageBuf = tmp;
+    pageBuf[bytesRead] = '\0';  /* NULL terminate the data */
+
+	if(fileBuf == NULL)	/* They just wanted us to "hit" the url */
+		free(pageBuf);
+	else
+		*fileBuf = pageBuf;
+
+	close(sock);
+	return bytesRead;
+	}
+
+
+
+	/*
+	 * Changes the User Agent.  Returns 0 on success, -1 on error. 
+	 */
+int http_setUserAgent(const char *newAgent)
+	{
+	static int freeOldAgent = 0; /* Indicates previous malloc's */
+	char *tmp;
+
+	if(newAgent == NULL)
+		{
+		if(freeOldAgent) free(userAgent);
+		userAgent = NULL;
+		hideUserAgent = 1;
+		}
+	else
+		{
+		tmp = (char *)malloc(strlen(newAgent));
+		if(tmp == NULL) { errorSource = ERRNO; return -1; }
+		if(freeOldAgent) free(userAgent);
+		userAgent = tmp;
+		strcpy(userAgent, newAgent);
+		freeOldAgent = 1;
+		hideUserAgent = 0;
+		}
+
+	return 0;
+	}
+
+
+
+	/*
+	 * Changes the Referer.  Returns 0 on success, -1 on error
+	 */
+int http_setReferer(const char *newReferer)
+	{
+	static int freeOldReferer = 0; /* Indicated previous malloc's */
+	char *tmp;
+
+	if(newReferer == NULL)
+		{
+		if(freeOldReferer) free(referer);
+		referer = NULL;
+		hideReferer = 1;
+		}
+	else
+		{
+		tmp = (char *)malloc(strlen(newReferer));
+		if(tmp == NULL) { errorSource = ERRNO; return -1; }
+		if(freeOldReferer) free(referer);
+		referer = tmp;
+		strcpy(referer, newReferer);
+		freeOldReferer = 1;
+		hideReferer = 0;
+		}
+	
+	return 0;
+	}
+
+
+
+	/*
+	 * Changes the amount of time that HTTP Fetcher will wait for data
+	 *	before timing out on reads
+	 */
+void http_setTimeout(int seconds) { timeout = seconds; }
+
+
+
+	/*
+	 * Changes the number of HTTP redirects HTTP Fetcher will automatically
+	 *	follow.  If a request returns a status code of 3XX and contains
+	 *	a "Location:" field, the library will transparently follow up to
+	 *	the specified number of redirects.  With this implementation
+	 *	(which is just a stopgap, really) the caller won't be aware of any
+	 *	redirection and will assume the returned document came from the original
+	 *	URL.
+	 * To disable redirects, pass a 0.  To follow unlimited redirects (probably
+	 *  unwise), pass a negative value.  The default is to follow 3 redirects.
+	 */
+void http_setRedirects(int redirects) { followRedirects = redirects; }
+
+
+
+	/*
+	 * Puts the filename portion of the url into 'filename'.
+	 * Returns:
+	 *	0 on success
+	 *	1 when url contains no end filename (i.e., 'www.foo.com/'),
+	 *		and **filename should not be assumed to be valid
+	 *	-1 on error
+	 */
+int http_parseFilename(const char *url, char **filename)
+	{
+	char *ptr;
+
+	if(url == NULL)
+		{
+		errorSource = FETCHER_ERROR;
+		http_errno = HF_NULLURL;
+		return -1;
+		}
+
+	ptr = (char *)rindex(url, '/');
+	if(ptr == NULL)
+		/* Root level request, apparently */
+		return 1;
+
+	ptr++;
+	if(*ptr == '\0') return 1;
+
+	*filename = (char *)malloc(strlen(ptr));
+	if(*filename == NULL) { errorSource = ERRNO; return -1; }
+	strcpy(*filename, ptr);
+
+	return 0;
+	}
+
+	
+	
+	/* Depending on the source of error, calls either perror() or prints
+	 *	an HTTP Fetcher error message to stdout */
+void http_perror(const char *string)
+	{
+	if(errorSource == ERRNO)
+		perror(string);
+	else if(errorSource == H_ERRNO)
+		herror(string);
+	else if(errorSource == FETCHER_ERROR)
+		{
+		char *stringIndex;
+
+		if(strstr(http_errlist[http_errno], "%d") == NULL)
+			{
+			fputs(string, stderr);
+			fputs(": ", stderr);
+			fputs(http_errlist[http_errno], stderr);
+			fputs("\n", stderr);
+			}
+		else
+			{
+			/* The error string has a %d in it, we need to insert errorInt */
+			stringIndex = (char*)http_errlist[http_errno];
+			while(*stringIndex != '%')			/* Print up to the %d */
+				{
+				fputc(*stringIndex, stderr);
+				stringIndex++;
+				}
+			fprintf(stderr, "%d", errorInt);	/* Print the number */
+			stringIndex += 2;					/* Skip past the %d */
+			while(*stringIndex != 0)			/* Print up to the end NULL */
+				{
+				fputc(*stringIndex, stderr);
+				stringIndex++;
+				}
+			fputs("\n", stderr);
+			}
+		}
+	}
+
+
+
+	/* 
+	 * Returns a pointer to the current error description message. The
+	 *	message pointed to is only good until the next call to http_strerror(),
+	 *	so if you need to hold on to the message for a while you should make
+	 *	a copy of it
+	 */
+const char *http_strerror()
+	{
+	extern int errno;
+	
+	if(errorSource == ERRNO)
+		return strerror(errno);
+	else if(errorSource == H_ERRNO)
+#ifdef HAVE_HSTRERROR
+		return hstrerror(h_errno);
+#else
+		return http_errlist[HF_HERROR];
+#endif
+	else if(errorSource == FETCHER_ERROR)
+		{
+		if(strstr(http_errlist[http_errno], "%d") == NULL)
+			return http_errlist[http_errno];
+		else
+			{
+			/* The error string has a %d in it, we need to insert errorInt.
+			 *	convertedError[128] has been declared for that purpose */
+			char *stringIndex, *originalError;
+		
+			originalError = (char *)http_errlist[http_errno];
+			convertedError[0] = 0;		/* Start off with NULL */
+			stringIndex = strstr(originalError, "%d");
+			strncat(convertedError, originalError,		/* Copy up to %d */
+				abs(stringIndex - originalError));
+			sprintf(&convertedError[strlen(convertedError)],"%d",errorInt);
+			stringIndex += 2;		/* Skip past the %d */
+			strcat(convertedError, stringIndex);
+
+			return convertedError;
+			}
+		}
+		
+	return http_errlist[HF_METAERROR];	/* Should NEVER happen */
+	}
+
+	
+	/*
+	 * Reads the metadata of an HTTP response.
+	 * Perhaps a little inefficient, as it reads 1 byte at a time, but
+	 *	I don't think it's that much of a loss (most headers aren't HUGE).
+	 * Returns:
+	 *	# of bytes read on success, or
+	 *	-1 on error
+	 */
+int _http_read_header(int sock, char *headerPtr)
+	{
+	fd_set rfds;
+	struct timeval tv;
+	int bytesRead = 0, newlines = 0, ret, selectRet;
+
+	while(newlines != 2 && bytesRead != HEADER_BUF_SIZE)
+		{
+		FD_ZERO(&rfds);
+		FD_SET(sock, &rfds);
+		tv.tv_sec = timeout; 
+		tv.tv_usec = 0;
+
+		if(timeout >= 0)
+			selectRet = select(sock+1, &rfds, NULL, NULL, &tv);
+		else		/* No timeout, can block indefinately */
+			selectRet = select(sock+1, &rfds, NULL, NULL, NULL);
+		
+		if(selectRet == 0)
+			{
+			errorSource = FETCHER_ERROR;
+			http_errno = HF_HEADTIMEOUT;
+			errorInt = timeout;
+			return -1;
+			}
+		else if(selectRet == -1) { errorSource = ERRNO; return -1; }
+
+		ret = read(sock, headerPtr, 1);
+		if(ret == -1) { errorSource = ERRNO; return -1; }
+		bytesRead++;
+
+		if(*headerPtr == '\r')			/* Ignore CR */
+			{
+			/* Basically do nothing special, just don't set newlines
+			 *	to 0 */
+			headerPtr++;
+			continue;
+			}
+		else if(*headerPtr == '\n')		/* LF is the separator */
+			newlines++;
+		else
+			newlines = 0;
+
+		headerPtr++;
+		}
+
+	headerPtr -= 3;		/* Snip the trailing LF's */
+	*headerPtr = '\0';
+	return bytesRead;
+	}
+
+
+
+	/*
+	 * Opens a TCP socket and returns the descriptor
+	 * Returns:
+	 *	socket descriptor, or
+	 *	-1 on error
+	 */
+int makeSocket(const char *host)
+	{
+	int sock;										/* Socket descriptor */
+	struct sockaddr_in sa;							/* Socket address */
+	struct hostent *hp;								/* Host entity */
+	int ret;
+    int port;
+    char *p;
+	
+    /* Check for port number specified in URL */
+    p = strchr(host, ':');
+    if(p)
+        {
+        port = atoi(p + 1);
+        *p = '\0';
+        }
+    else
+        port = PORT_NUMBER;
+
+	hp = gethostbyname(host);
+	if(hp == NULL) { errorSource = H_ERRNO; return -1; }
+		
+	/* Copy host address from hostent to (server) socket address */
+	memcpy((char *)&sa.sin_addr, (char *)hp->h_addr, hp->h_length);
+	sa.sin_family = hp->h_addrtype;		/* Set service sin_family to PF_INET */
+	sa.sin_port = htons(port);      	/* Put portnum into sockaddr */
+
+	sock = socket(hp->h_addrtype, SOCK_STREAM, 0);
+	if(sock == -1) { errorSource = ERRNO; return -1; }
+
+	ret = connect(sock, (struct sockaddr *)&sa, sizeof(sa));
+	if(ret == -1) { errorSource = ERRNO; return -1; }
+
+	return sock;
+	}
+
+
+
+	/*
+	 * Determines if the given NULL-terminated buffer is large enough to
+	 * 	concatenate the given number of characters.  If not, it attempts to
+	 * 	grow the buffer to fit.
+	 * Returns:
+	 *	0 on success, or
+	 *	-1 on error (original buffer is unchanged).
+	 */
+int _checkBufSize(char **buf, int *bufsize, int more)
+	{
+	char *tmp;
+	int roomLeft = *bufsize - (strlen(*buf) + 1);
+	if(roomLeft > more)
+		return 0;
+	tmp = (char*)realloc(*buf, *bufsize + more + 1);
+	if(tmp == NULL)
+		return -1;
+	*buf = tmp;
+	*bufsize += more + 1;
+	return 0;
+	}
diff -Naur rssreader-1.1.2-orig/http_fetcher.h rssreader/http_fetcher.h
--- rssreader-1.1.2-orig/http_fetcher.h	1970-01-01 01:00:00.000000000 +0100
+++ rssreader/http_fetcher.h	2008-01-12 14:09:02.000000000 +0100
@@ -0,0 +1,160 @@
+/* http_fetcher.h - HTTP handling functions
+
+	HTTP Fetcher
+	Copyright (C) 2001, 2003, 2004 Lyle Hanson (lhanson@users.sourceforge.net)
+
+	This library is free software; you can redistribute it and/or
+	modify it under the terms of the GNU Library General Public
+	License as published by the Free Software Foundation; either
+	version 2 of the License, or (at your option) any later version.
+
+	This library is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+	Library General Public License for more details.
+
+	See LICENSE file for details
+									
+ */
+
+#ifndef HTTP_FETCHER_H
+#define HTTP_FETCHER_H
+
+#include "http_error_codes.h"
+
+#define VERSION				"1"
+#define PORT_NUMBER 			80
+#define HTTP_VERSION 			"HTTP/1.0"
+#define DEFAULT_USER_AGENT		"HTTP Fetcher"
+#define DEFAULT_READ_TIMEOUT	30		/* Seconds to wait before giving up
+										 *	when no data is arriving */
+	 
+#define REQUEST_BUF_SIZE 		1024
+#define HEADER_BUF_SIZE 		1024
+#define DEFAULT_PAGE_BUF_SIZE 	1024 * 200	/* 200K should hold most things */
+#define DEFAULT_REDIRECTS       3       /* Number of HTTP redirects to follow */
+
+
+
+/******************************************************************************/
+/**************** Function declarations and descriptions **********************/
+/******************************************************************************/
+
+/* 
+ * [!!! NOTE !!!]  All HTTP Fetcher functions return -1 on error.  You can
+ *	then either call http_perror to print the error message or call
+ *	http_strerror to get a pointer to it
+ */
+
+
+	/*
+	 * Download the page, registering a hit. If you pass it a NULL for fileBuf,
+	 *	'url' will be requested but will not remain in memory (useful for
+	 *	simply registering a hit).  Otherwise necessary space will be allocated
+	 *	and will be pointed to by fileBuf.  Note that a NULL byte is added to
+     *  the data, so the actual buffer will be the file size + 1.
+	 * Returns:
+	 *	# of bytes downloaded, or
+	 *	-1 on error
+	 */
+int http_fetch(const char *url, char **fileBuf);
+
+	/*
+	 * Changes the User Agent (shown to the web server with each request)
+	 *	Send it NULL to avoid telling the server a User Agent
+	 *	By default, the User Agent is sent (The default one unless changed)
+	 * Returns:
+	 *	0 on success, or
+	 *	-1 on error (previous value for agent remains unchanged)
+	 */
+int http_setUserAgent(const char *newAgent);
+
+	/*
+	 * Changes the Referer (shown to the web server with each request)
+	 *	Send it NULL to avoid thelling the server a Referer
+	 *	By default, no Referer is sent
+	 * Returns:
+	 *	0 on success, or
+	 *	-1 on error
+	 */
+int http_setReferer(const char *newReferer);
+
+	/*
+	 * Changes the maximum amount of time that HTTP Fetcher will wait on
+	 *	data.  If this many seconds elapses without more data from the
+	 *	server, http_fetch will return with an error.
+	 * If you pass a value less than 0, reads will not time out, potentially
+	 *	waiting forever (or until data shows up, whichever comes first)
+	 */
+void http_setTimeout(int seconds);
+
+	/*
+	 * Changes the number of HTTP redirects HTTP Fetcher will automatically
+	 *	follow.  If a request returns a status code of 3XX and contains
+	 *	a "Location:" field, the library will transparently follow up to
+	 *	the specified number of redirects.  With this implementation
+	 *	(which is just a stopgap, really) the caller won't be aware of any
+	 *	redirection and will assume the returned document came from the original
+	 *	URL.
+	 * To disable redirects, pass a 0.  To follow unlimited redirects (probably
+	 *  unwise), pass a negative value.  The default is to follow 3 redirects.
+	 */
+void http_setRedirects(int redirects);
+
+	/*
+	 * Takes a url and puts the filename portion of it into 'filename'.
+	 * Returns:
+	 *	0 on success, or
+	 *	1 when url contains no end filename (i.e., "www.foo.com/")
+	 *		and **filename should not be assumed to point to anything), or
+	 *	-1 on error
+	 */
+int http_parseFilename(const char *url, char **filename);
+
+	/*
+	 * Works like perror.  If an HTTP Fetcher function ever returns an
+	 *	error (-1), this will print a descriptive message to standard output
+	 */
+void http_perror(const char *string);
+
+	/*
+	 * Returns a pointer to the current error description message.  The
+	 *	message pointed to is only good until the next call to http_strerror(),
+	 *	so if you need to hold on to the message for a while you should make
+	 *	a copy of it.
+	 */
+const char *http_strerror();
+
+
+
+/******************************************************************************/
+/**** The following functions are used INTERNALLY by http_fetcher *************/
+/******************************************************************************/
+
+	/*
+	 * Reads the metadata of an HTTP response.  On success returns the number
+	 * Returns:
+	 *	# of bytes read on success, or
+	 *	-1 on error
+	 */
+int _http_read_header(int sock, char *headerPtr);
+
+	/*
+	 * Opens a TCP socket and returns the descriptor
+	 * Returns:
+	 *	socket descriptor, or
+	 *	-1 on error
+	 */
+int makeSocket(const char *host);
+
+	/*
+	 * Determines if the given NULL-terminated buffer is large enough to
+	 *	concatenate the given number of characters.  If not, it attempts to
+	 *	grow the buffer to fit.
+	 * Returns:
+	 *	0 on success, or
+	 *	-1 on error (original buffer is unchanged).
+	 */
+int _checkBufSize(char **buf, int *bufsize, int more);
+
+#endif
diff -Naur rssreader-1.1.2-orig/i18n.c rssreader/i18n.c
--- rssreader-1.1.2-orig/i18n.c	1970-01-01 01:00:00.000000000 +0100
+++ rssreader/i18n.c	2008-01-12 14:09:02.000000000 +0100
@@ -0,0 +1,577 @@
+/*
+ * i18n.c: Internationalization
+ *
+ * See the README file for copyright information and how to reach the author.
+ *
+ * $Id: i18n.c 481 2005-06-02 00:12:13Z udo $
+ */
+
+#include "i18n.h"
+
+#if VDRVERSNUM < 10507
+const tI18nPhrase StreamplayerPhrases[] = {
+// START I18N - automatically generated by po2i18n.pl
+  { "<no date available>",
+    "<kein Datum vorhanden>",
+    "",
+    "",
+    "",
+    "",
+    "<pas de date disponible>",
+    "",
+    "<pivmr ei ole saatavilla>",
+    "",
+    "<Fecha no disponible>",
+    "",
+    "",
+    "",
+    "",
+    "",
+#if VDRVERSNUM >= 10302
+    "",
+#endif
+#if VDRVERSNUM >= 10307
+    "",
+#endif
+#if VDRVERSNUM >= 10313
+    "",
+#endif
+#if VDRVERSNUM >= 10316
+    "",
+#endif
+#if VDRVERSNUM >= 10342
+    "",
+#endif
+#if VDRVERSNUM >= 10502
+    "",
+#endif
+  },
+  { "<no description available>",
+    "<keine Beschreibung vorhanden>",
+    "",
+    "",
+    "",
+    "",
+    "<pas de dscriptif disponible>",
+    "",
+    "<kuvaus ei ole saatavilla>",
+    "",
+    "<Descripcin no disponible>",
+    "",
+    "",
+    "",
+    "",
+    "",
+#if VDRVERSNUM >= 10302
+    "",
+#endif
+#if VDRVERSNUM >= 10307
+    "",
+#endif
+#if VDRVERSNUM >= 10313
+    "",
+#endif
+#if VDRVERSNUM >= 10316
+    "",
+#endif
+#if VDRVERSNUM >= 10342
+    "",
+#endif
+#if VDRVERSNUM >= 10502
+    "",
+#endif
+  },
+  { "<no title available>",
+    "<kein Titel vorhanden>",
+    "",
+    "",
+    "",
+    "",
+    "<pas de titre disponible>",
+    "",
+    "<otsikko ei ole saatavilla>",
+    "",
+    "<Ttulo no disponible>",
+    "",
+    "",
+    "",
+    "",
+    "",
+#if VDRVERSNUM >= 10302
+    "",
+#endif
+#if VDRVERSNUM >= 10307
+    "",
+#endif
+#if VDRVERSNUM >= 10313
+    "",
+#endif
+#if VDRVERSNUM >= 10316
+    "",
+#endif
+#if VDRVERSNUM >= 10342
+    "",
+#endif
+#if VDRVERSNUM >= 10502
+    "",
+#endif
+  },
+  { "Can't download RSS stream!",
+    "Kann den RSS-Stream nicht laden!",
+    "",
+    "",
+    "",
+    "",
+    "Impossible de charger le flux!",
+    "",
+    "RSS-virtaa ei pystyt vastaanottamaan!",
+    "",
+    "Error descargando datos RSS!",
+    "",
+    "",
+    "",
+    "",
+    "",
+#if VDRVERSNUM >= 10302
+    "",
+#endif
+#if VDRVERSNUM >= 10307
+    "",
+#endif
+#if VDRVERSNUM >= 10313
+    "",
+#endif
+#if VDRVERSNUM >= 10316
+    "",
+#endif
+#if VDRVERSNUM >= 10342
+    "",
+#endif
+#if VDRVERSNUM >= 10502
+    "",
+#endif
+  },
+  { "Can't parse RSS stream!",
+    "Kann den RSS-Stream nicht parsen!",
+    "",
+    "",
+    "",
+    "",
+    "Impossible d'analyser le flux RSS!",
+    "",
+    "RSS-virtaa ei pystyt tulkkaamaan!",
+    "",
+    "Error leyendo datos RSS!",
+    "",
+    "",
+    "",
+    "",
+    "",
+#if VDRVERSNUM >= 10302
+    "",
+#endif
+#if VDRVERSNUM >= 10307
+    "",
+#endif
+#if VDRVERSNUM >= 10313
+    "",
+#endif
+#if VDRVERSNUM >= 10316
+    "",
+#endif
+#if VDRVERSNUM >= 10342
+    "",
+#endif
+#if VDRVERSNUM >= 10502
+    "",
+#endif
+  },
+  { "HTTP proxy server",
+    "HTTP Proxy Name",
+    "",
+    "",
+    "",
+    "",
+    "Nom du proxy HTTP",
+    "",
+    "HTTP-vlityspalvelimen osoite",
+    "",
+    "",
+    "",
+    "",
+    "",
+    "",
+    "",
+#if VDRVERSNUM >= 10302
+    "",
+#endif
+#if VDRVERSNUM >= 10307
+    "",
+#endif
+#if VDRVERSNUM >= 10313
+    "",
+#endif
+#if VDRVERSNUM >= 10316
+    "",
+#endif
+#if VDRVERSNUM >= 10342
+    "",
+#endif
+#if VDRVERSNUM >= 10502
+    "",
+#endif
+  },
+  { "Hide main menu entry",
+    "Hauptmeneintrag verstecken",
+    "",
+    "",
+    "",
+    "",
+    "Cacher le menu",
+    "",
+    "Piilota valinta pvalikosta",
+    "",
+    "Ocultar entrada en men principal",
+    "",
+    "",
+    "",
+    "",
+    "",
+#if VDRVERSNUM >= 10302
+    "",
+#endif
+#if VDRVERSNUM >= 10307
+    "",
+#endif
+#if VDRVERSNUM >= 10313
+    "",
+#endif
+#if VDRVERSNUM >= 10316
+    "",
+#endif
+#if VDRVERSNUM >= 10342
+    "",
+#endif
+#if VDRVERSNUM >= 10502
+    "",
+#endif
+  },
+  { "Hide non-existent elements",
+    "Nur vorhandene Elemente zeigen",
+    "",
+    "",
+    "",
+    "",
+    "N'afficher que les lments existants",
+    "",
+    "Piilota tyhjt elementit",
+    "",
+    "Ocultar elementos vacos",
+    "",
+    "",
+    "",
+    "",
+    "",
+#if VDRVERSNUM >= 10302
+    "",
+#endif
+#if VDRVERSNUM >= 10307
+    "",
+#endif
+#if VDRVERSNUM >= 10313
+    "",
+#endif
+#if VDRVERSNUM >= 10316
+    "",
+#endif
+#if VDRVERSNUM >= 10342
+    "",
+#endif
+#if VDRVERSNUM >= 10502
+    "",
+#endif
+  },
+  { "RSS Reader",
+    "RSS-Reader",
+    "",
+    "",
+    "",
+    "",
+    "Lecteur de flux RSS",
+    "",
+    "RSS-lukija",
+    "",
+    "Lector RSS",
+    "",
+    "",
+    "",
+    "",
+    "",
+#if VDRVERSNUM >= 10302
+    "",
+#endif
+#if VDRVERSNUM >= 10307
+    "",
+#endif
+#if VDRVERSNUM >= 10313
+    "",
+#endif
+#if VDRVERSNUM >= 10316
+    "",
+#endif
+#if VDRVERSNUM >= 10342
+    "",
+#endif
+#if VDRVERSNUM >= 10502
+    "",
+#endif
+  },
+  { "RSS Reader for OSD",
+    "RSS-Reader fr OSD",
+    "",
+    "",
+    "",
+    "",
+    "Lecteur RSS pour OSD",
+    "",
+    "RSS-lukija kuvaruutunytlle",
+    "",
+    "Lector RSS para OSD",
+    "",
+    "",
+    "",
+    "",
+    "",
+#if VDRVERSNUM >= 10302
+    "",
+#endif
+#if VDRVERSNUM >= 10307
+    "",
+#endif
+#if VDRVERSNUM >= 10313
+    "",
+#endif
+#if VDRVERSNUM >= 10316
+    "",
+#endif
+#if VDRVERSNUM >= 10342
+    "",
+#endif
+#if VDRVERSNUM >= 10502
+    "",
+#endif
+  },
+  { "RSS item",
+    "RSS-Artikel",
+    "",
+    "",
+    "",
+    "",
+    "Article RSS",
+    "",
+    "RSS-artikkeli",
+    "",
+    "RSS-Articulo",
+    "",
+    "",
+    "",
+    "",
+    "",
+#if VDRVERSNUM >= 10302
+    "",
+#endif
+#if VDRVERSNUM >= 10307
+    "",
+#endif
+#if VDRVERSNUM >= 10313
+    "",
+#endif
+#if VDRVERSNUM >= 10316
+    "",
+#endif
+#if VDRVERSNUM >= 10342
+    "",
+#endif
+#if VDRVERSNUM >= 10502
+    "",
+#endif
+  },
+  { "Select RSS item",
+    "Auswahl RSS-Artikel",
+    "",
+    "",
+    "",
+    "",
+    "Choix de article RSS",
+    "",
+    "Valitse RSS-artikkeli",
+    "",
+    "RSS-Articulo",
+    "",
+    "",
+    "",
+    "",
+    "",
+#if VDRVERSNUM >= 10302
+    "",
+#endif
+#if VDRVERSNUM >= 10307
+    "",
+#endif
+#if VDRVERSNUM >= 10313
+    "",
+#endif
+#if VDRVERSNUM >= 10316
+    "",
+#endif
+#if VDRVERSNUM >= 10342
+    "",
+#endif
+#if VDRVERSNUM >= 10502
+    "",
+#endif
+  },
+  { "Select RSS stream",
+    "Auswahl RSS-Stream",
+    "",
+    "",
+    "",
+    "",
+    "Choix des flux RSS",
+    "",
+    "Valitse RSS-virta",
+    "",
+    "Selecciona fuente RSS",
+    "",
+    "",
+    "",
+    "",
+    "",
+#if VDRVERSNUM >= 10302
+    "",
+#endif
+#if VDRVERSNUM >= 10307
+    "",
+#endif
+#if VDRVERSNUM >= 10313
+    "",
+#endif
+#if VDRVERSNUM >= 10316
+    "",
+#endif
+#if VDRVERSNUM >= 10342
+    "",
+#endif
+#if VDRVERSNUM >= 10502
+    "",
+#endif
+  },
+  { "Servidor proxy HTTP",
+    "",
+    "",
+    "",
+    "",
+    "",
+    "",
+    "",
+    "",
+    "",
+    "",
+    "",
+    "",
+    "",
+    "",
+    "",
+#if VDRVERSNUM >= 10302
+    "",
+#endif
+#if VDRVERSNUM >= 10307
+    "",
+#endif
+#if VDRVERSNUM >= 10313
+    "",
+#endif
+#if VDRVERSNUM >= 10316
+    "",
+#endif
+#if VDRVERSNUM >= 10342
+    "",
+#endif
+#if VDRVERSNUM >= 10502
+    "",
+#endif
+  },
+  { "Unknown error!",
+    "Unbekannt Fehler!",
+    "",
+    "",
+    "",
+    "",
+    "Erreur inconnue",
+    "",
+    "Tuntematon virhe!",
+    "",
+    "Error desconocido!",
+    "",
+    "",
+    "",
+    "",
+    "",
+#if VDRVERSNUM >= 10302
+    "",
+#endif
+#if VDRVERSNUM >= 10307
+    "",
+#endif
+#if VDRVERSNUM >= 10313
+    "",
+#endif
+#if VDRVERSNUM >= 10316
+    "",
+#endif
+#if VDRVERSNUM >= 10342
+    "",
+#endif
+#if VDRVERSNUM >= 10502
+    "",
+#endif
+  },
+  { "Use HTTP proxy server",
+    "HTTP Proxy benutzen",
+    "",
+    "",
+    "",
+    "",
+    "Utiliser le Proxy HTTP",
+    "",
+    "Kyt HTTP-vlityspalvelinta",
+    "",
+    "Usar servidor proxy HTTP",
+    "",
+    "",
+    "",
+    "",
+    "",
+#if VDRVERSNUM >= 10302
+    "",
+#endif
+#if VDRVERSNUM >= 10307
+    "",
+#endif
+#if VDRVERSNUM >= 10313
+    "",
+#endif
+#if VDRVERSNUM >= 10316
+    "",
+#endif
+#if VDRVERSNUM >= 10342
+    "",
+#endif
+#if VDRVERSNUM >= 10502
+    "",
+#endif
+  },
+// END I18N - automatically generated by po2i18n.pl
+  { NULL }
+  };
+#endif
diff -Naur rssreader-1.1.2-orig/i18n.h rssreader/i18n.h
--- rssreader-1.1.2-orig/i18n.h	1970-01-01 01:00:00.000000000 +0100
+++ rssreader/i18n.h	2008-01-12 14:09:02.000000000 +0100
@@ -0,0 +1,18 @@
+/*
+ * i18n.h: Internationalization
+ *
+ * See the README file for copyright information and how to reach the author.
+ *
+ * $Id: i18n.h 481 2005-06-02 00:12:13Z udo $
+ */
+
+#ifndef __STREAMPLAYER_I18N_H
+#define __STREAMPLAYER_I18N_H
+
+#include <vdr/i18n.h>
+
+#if VDRVERSNUM < 10507
+extern const tI18nPhrase StreamplayerPhrases[];
+#endif
+
+#endif //_I18N__H
diff -Naur rssreader-1.1.2-orig/i18n-template.c rssreader/i18n-template.c
--- rssreader-1.1.2-orig/i18n-template.c	1970-01-01 01:00:00.000000000 +0100
+++ rssreader/i18n-template.c	2008-01-12 14:09:02.000000000 +0100
@@ -0,0 +1,17 @@
+/*
+ * i18n.c: Internationalization
+ *
+ * See the README file for copyright information and how to reach the author.
+ *
+ * $Id: i18n.c 481 2005-06-02 00:12:13Z udo $
+ */
+
+#include "i18n.h"
+
+#if VDRVERSNUM < 10507
+const tI18nPhrase StreamplayerPhrases[] = {
+// START I18N
+// END I18N
+  { NULL }
+  };
+#endif
diff -Naur rssreader-1.1.2-orig/Makefile rssreader/Makefile
--- rssreader-1.1.2-orig/Makefile	2008-01-14 20:30:47.000000000 +0100
+++ rssreader/Makefile	2008-01-12 14:09:02.000000000 +0100
@@ -26,14 +26,10 @@
 
 ### The directory environment:
 
-VDRDIR = ../../..
-LIBDIR = ../../lib
+VDRDIR ?= ../../..
+LIBDIR ?= ../../lib
 TMPDIR = /tmp
 
-### Libraries
-
-LIBS = -lexpat -lcurl
-
 ### Allow user defined options to overwrite defaults:
 
 -include $(VDRDIR)/Make.config
@@ -49,7 +45,7 @@
 
 ### Includes and Defines (add further entries here):
 
-INCLUDES += -I$(VDRDIR)/include
+INCLUDES += -I$(VDRDIR)/include -I/home/amoyse/Desktop/dev/vdr/ng/o7o_tc/m7x0_xtc_uclibc_Linux-i686/mips-linux/sys-include
 
 DEFINES += -D_GNU_SOURCE -DPLUGIN_NAME_I18N='"$(PLUGIN)"'
 
@@ -59,7 +55,7 @@
 
 ### The object files (add further files here):
 
-OBJS = rssreader.o parser.o menu.o config.o tools.o
+OBJS =  http_error_codes.o http_fetcher.o ezxml.o rssreader.o parser.o menu.o config.o tools.o compatibility.o i18n.o
 
 ### The main target:
 
@@ -70,6 +66,12 @@
 %.o: %.c
 	$(CXX) $(CXXFLAGS) -c $(DEFINES) $(INCLUDES) $<
 
+
+#i18n compatibility generator:
+i18n.c: i18n-template.c po2i18n.pl
+	./po2i18n.pl < i18n-template.c > i18n.c
+
+
 # Dependencies:
 
 MAKEDEP = $(CXX) -MM -MG
diff -Naur rssreader-1.1.2-orig/menu.c rssreader/menu.c
--- rssreader-1.1.2-orig/menu.c	2008-01-14 20:30:47.000000000 +0100
+++ rssreader/menu.c	2008-01-12 14:09:02.000000000 +0100
@@ -66,7 +66,7 @@
            (*Title       || !RssConfig.hideelem) ? "\n\n" : "",
            *Description  ? strdup(Description)   : RssConfig.hideelem ? "" : tr("<no description available>"),
            (*Description || !RssConfig.hideelem) ? "\n\n" : "",
-           *Link         ? strdup(Link)          : RssConfig.hideelem ? "" : tr("<no link available>"));
+           *Link         ? strdup("")          : RssConfig.hideelem ? "" : "");
 }
 
 cRssMenuItem::~cRssMenuItem()
diff -Naur rssreader-1.1.2-orig/parser.c rssreader/parser.c
--- rssreader-1.1.2-orig/parser.c	2008-01-14 20:30:47.000000000 +0100
+++ rssreader/parser.c	2008-01-14 18:54:12.000000000 +0100
@@ -6,31 +6,26 @@
  * $Id$
  */
 
-#include <stack>
-#include <curl/curl.h>
-#include <curl/types.h>
-#include <curl/easy.h>
 #include <vdr/config.h>
 #include "common.h"
 #include "config.h"
 #include "tools.h"
 #include "parser.h"
+#include "http_fetcher.h"
+#include "ezxml.h"
 
-#include <expat.h>
-#define LIBEXPAT_VERSION(a,b,c) (((a) << 16) + ((b) << 8) + (c))
-#if LIBEXPAT_VERSION(XML_MAJOR_VERSION, XML_MINOR_VERSION, XML_MICRO_VERSION) < LIBEXPAT_VERSION(1, 95, 8)
-#warning "Expat XML parser library 1.95.8 or newer required!"
-#endif
-
+#define Utf8Strn0Cpy strn0cpy
 // --- Globals ----------------------------------------------------------
 
 cParser Parser;
 
 // --- cItem(s) ---------------------------------------------------------
 
-cItem::cItem()
-: conv("UTF-8", cCharSetConv::SystemCharacterTable())
+cItem::cItem(const char *e)
+//: conv("UTF-8", cCharSetConv::SystemCharacterTable())
+: conv(e, "iso-8859-1")
 {
+  strcpy(encoding,e);
   strcpy(date, "");
   strcpy(title, "");
   strcpy(link, "");
@@ -40,6 +35,7 @@
 
 void cItem::Clear(void)
 {
+  strcpy(encoding, "");
   strcpy(date, "");
   strcpy(title, "");
   strcpy(link, "");
@@ -57,7 +53,7 @@
 {
   Utf8Strn0Cpy(title, str, sizeof(title));
   compactspace(title);
-  striphtml(title);
+  striphtml(title,encoding);
   Utf8Strn0Cpy(title, conv.Convert(title), sizeof(title));
 }
 
@@ -72,135 +68,13 @@
 {
   Utf8Strn0Cpy(description, str, sizeof(description));
   compactspace(description);
-  striphtml(description);
+  striphtml(description,encoding);
   Utf8Strn0Cpy(description, conv.Convert(description), sizeof(description));
 }
 
-// --- Parse RSS  -------------------------------------------------------
-
-struct XmlNode {
-  char nodename[SHORT_TEXT_LEN];
-  int  depth;
-};
-
-cItem *item = NULL;
-int depth = 0;
-char data_string[LONG_TEXT_LEN];
-std::stack<struct XmlNode> nodestack;
-
-static int XMLCALL UnknownEncodingHandler(void *data,const XML_Char *encoding, XML_Encoding *info)
-{
-  if (strcmp(encoding, "iso-8859-15") == 0) {
-     int i;
-     for (i = 0; i < 256; ++i)
-        info->map[i] = i;
-     info->data = NULL;
-     info->convert = NULL;
-     info->release = NULL;
-     return XML_STATUS_OK;
-     }
-  return XML_STATUS_ERROR;
-}
-
-static void XMLCALL StartHandler(void *data, const char *el, const char **attr)
-{
-  XmlNode node;
-
-  strn0cpy(node.nodename, el, sizeof(node.nodename));
-  node.depth = depth;
-  nodestack.push(node);
-
-  if (!strncmp(el, "item", 4)) {
-     cItem *tmpitem = new cItem;
-     item = tmpitem;
-     item->Clear();
-     }
-  depth++;
-}
-
-static void XMLCALL EndHandler(void *data, const char *el)
-{
-  char parent[SHORT_TEXT_LEN];
-  
-  if (nodestack.size() > 1) {
-     nodestack.pop();
-     } 
-  else {
-     nodestack.pop();
-     return;
-     }
-  strn0cpy(parent, (nodestack.top()).nodename, sizeof((nodestack.top()).nodename));
-  // No need to free the node
-  
-  depth--;
-  if (!strncmp(el, "item", 4)) {
-     // End of the current item
-     if (*item->GetTitle())
-        Parser.Items.Add(item);
-     }
-  else if (!strncmp(el, "title", 5)) {
-     if (!strncmp(parent, "item", 4)) {
-        item->SetTitle(data_string);
-        }
-     else if (!strncmp(parent, "channel", 7)) {
-        debug("cParser::EndHandler(): RSS title '%s'", data_string);
-        }
-     }
-  else if (!strncmp(el, "link", 4)) {
-     if (!strncmp(parent, "item", 4)) {
-        item->SetLink(data_string);
-        }
-     else if (!strncmp(parent, "channel", 7)) {
-        debug("cParser::EndHandler(): RSS link '%s'", data_string);
-        }
-     }
-  else if (!strncmp(el, "pubDate", 7)) {
-     if (!strncmp(parent, "item", 4)) {
-        item->SetDate(data_string);
-        }
-     else if (!strncmp(parent, "channel", 7)) {
-        debug("cParser::EndHandler(): RSS date '%s'", data_string);
-        }
-     }
-  else if (!strncmp(el, "description", 11)) {
-     if (!strncmp(parent, "item", 4)) {
-        item->SetDescription(data_string);
-        }
-     else if (!strncmp(parent, "channel", 7)) {
-        debug("cParser::EndHandler(): RSS description '%s'", data_string);
-        }
-     }
-  else if (!strncmp(el, "content:encoded", 15)) {
-     if (!strncmp(parent, "item", 4)) {
-        item->SetDescription(data_string); // overdrive description with content:encoded !
-        }
-     else if (!strncmp(parent, "channel", 7)) {
-        debug("cParser::EndHandler(): RSS content '%s'", data_string);
-        }
-     }
-  strcpy(data_string, "");
-}
-
-static void DataHandler(void *user_data, const XML_Char *s, int len)
-{
-  /* Only until the maximum size of the buffer */
-  if (strlen(data_string) + len <= LONG_TEXT_LEN)
-     strncat(data_string, s, len);
-}
 
-static size_t WriteMemoryCallback(void *ptr, size_t size, size_t nmemb, void *data)
-{
-  size_t realsize = size * nmemb;
-  struct MemoryStruct *mem = (struct MemoryStruct *)data;
+// --- Parse RSS  -------------------------------------------------------
 
-  mem->memory = (char *)myrealloc(mem->memory, mem->size + realsize + 1);
-  if (mem->memory) {
-     memcpy(&(mem->memory[mem->size]), ptr, realsize);
-     mem->size += realsize;
-     mem->memory[mem->size] = 0;
-     }
-  return realsize;
-}
 
 cParser::cParser()
 {
@@ -217,65 +91,38 @@
      }
 }
 
+
 int cParser::DownloadAndParse(const char *url)
 {
-  CURL *curl_handle;
 
-  // Clear Items list and initialize depth
+  // Clear Items list 
   Items.Clear();
-  depth = 0;
   if (data.memory)
      free(data.memory);
   data.memory = NULL;
   data.size = 0;
 
-  // Init the curl session
-  curl_global_init(CURL_GLOBAL_ALL);
-  curl_handle = curl_easy_init();
-
-  // Specify URL to get
-  curl_easy_setopt(curl_handle, CURLOPT_URL, url);
-
-  // Specify HTTP proxy: my.proxy.com:80
-  if (RssConfig.useproxy) {
-     curl_easy_setopt(curl_handle, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);
-     curl_easy_setopt(curl_handle, CURLOPT_PROXY, RssConfig.httpproxy);
-     }
-
-  // Send all data to this function
-  curl_easy_setopt(curl_handle, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);
-
-  // Set maximum file size to get (bytes)
-  curl_easy_setopt(curl_handle, CURLOPT_MAXFILESIZE, 1048576);
-
-  // No progress meter
-  curl_easy_setopt(curl_handle, CURLOPT_NOPROGRESS, 1);
-
-  // No signaling
-  curl_easy_setopt(curl_handle, CURLOPT_NOSIGNAL, 1);
-
-  // Set timeout to 30 seconds
-  curl_easy_setopt(curl_handle, CURLOPT_TIMEOUT, 30);
-
-  // Pass our 'data' struct to the callback function
-  curl_easy_setopt(curl_handle, CURLOPT_WRITEDATA, (void *)&data);
+  debug ("cParser::DownloadAndParse: Init download %s",url);
 
   // Some servers don't like requests that are made without a user-agent field
-  curl_easy_setopt(curl_handle, CURLOPT_USERAGENT, RSSREADER_USERAGENT);
+  http_setUserAgent(RSSREADER_USERAGENT);
+  // Set timeout to 30 seconds  
+  http_setTimeout(30);
+
+  data.size = http_fetch(url, &(data.memory));	/* Downloads page */
+  debug("End download %s +%d",url,(int)data.size);
+  if( (int)data.size == -1) {				/* All HTTP Fetcher functions return */
+	http_perror("http_fetch");		/*	-1 on error. */
+	error("cParser::DownloadAndParse(): couldn't download the stream: %s",http_strerror());
+	if (data.memory) {
+	        free(data.memory);
+	        data.memory = NULL;
+	        data.size = 0;
+        }
+     	return (RSS_DOWNLOAD_ERROR);
+  }
+	
 
-  // Get it!
-  if (curl_easy_perform(curl_handle) != 0) {
-     // Cleanup curl stuff
-     curl_easy_cleanup(curl_handle);
-     // Free allocated memory
-     if (data.memory) {
-        free(data.memory);
-        data.memory = NULL;
-        data.size = 0;
-        }
-     error("cParser::DownloadAndParse(): couldn't download the stream");
-     return (RSS_DOWNLOAD_ERROR);
-     }
 
   if (data.size) {
 #ifdef DEBUG
@@ -286,47 +133,104 @@
         fclose(fp);
         }
 #endif
-     // Setup expat
-     XML_Parser p = XML_ParserCreate(NULL);
-     if (!p) {
-        // Cleanup curl stuff
-        curl_easy_cleanup(curl_handle);
-        // Free allocated memory
-        if (data.memory) {
-           free(data.memory);
-           data.memory = NULL;
-           data.size = 0;
-           }
-        error("cParser::DownloadAndParse(): couldn't allocate memory for parser");
-        return (RSS_UNKNOWN_ERROR);
-        }
-     XML_SetElementHandler(p, StartHandler, EndHandler);
-     XML_SetCharacterDataHandler(p, DataHandler);
-     XML_SetUnknownEncodingHandler(p, UnknownEncodingHandler, NULL);
-
-     if (XML_Parse(p, data.memory, data.size, 1) == XML_STATUS_ERROR) {
-        // Cleanup curl stuff
-        curl_easy_cleanup(curl_handle);
-        // Free allocated memory
-        if (data.memory) {
-           free(data.memory);
-           data.memory = NULL;
-           data.size = 0;
-           }
-        error("cParser::DownloadAndParse(): Parse error at line %ld:\n%s\n", XML_GetCurrentLineNumber(p), XML_ErrorString(XML_GetErrorCode(p)));
-        return (RSS_PARSING_ERROR);
-        }
-     }
-
-  // Cleanup curl stuff
-  curl_easy_cleanup(curl_handle);
+  //Get encoding
+  SetEncoding(data.memory);
+  debug("cParser::DownloadAndParse(): enconding [%s]",encoding);
+
+	ezxml_t f1 = ezxml_parse_str(data.memory,data.size);
+
+	if ( f1 == NULL ) {
+		// Free allocated memory
+		if (data.memory) {
+		   free(data.memory);
+		   data.memory = NULL;
+		   data.size = 0;
+		   }
+		error("cParser::DownloadAndParse(): Parse error ");
+        	return (RSS_PARSING_ERROR);
+	}else {
+		int rss_rdf=1; //rss - 1 , rdf - 0
+		debug("cParser::DownloadAndParse(): Parse ok ");
+    
+    
+
+		ezxml_t node = NULL;
+		ezxml_t child = NULL;
+		debug("cParser::DownloadAndParse(): root node [%s]",ezxml_name(f1));
+		if ( !strcmp(ezxml_name(f1),"rdf:RDF") ) {				
+			rss_rdf=0;
+		} 
+		if ( rss_rdf ) {
+			node = ezxml_get(f1,"channel",0,"item",-1);
+		}else {
+			node = ezxml_get(f1,"item",-1);
+		}
+		if (node == NULL ) {
+			// Free allocated memory
+			if (data.memory) {
+			   free(data.memory);
+			   data.memory = NULL;
+			   data.size = 0;
+			   }
+			error("cParser::DownloadAndParse(): Parse error file");
+			return (RSS_PARSING_ERROR);
+		}else {
+		}
+		
+		for (; node != NULL; node = node->next) {
+			debug("cParser::DownloadAndParse(): item?");
+			child=ezxml_child(node,"title");
+			if (child !=NULL ) {
+				debug("cParser::DownloadAndParse(): Read item [%s]",ezxml_txt(child));
+				cItem *pitem = new cItem(encoding); 			
+
+        
+				Parser.Items.Add(pitem);
+			
+//	     	pitem->Clear(); 
+
+				pitem->SetTitle(ezxml_txt(child)) ;			
+
+				if ( rss_rdf ) {
+					child = ezxml_child(node,"pubDate");
+				} else {
+					child = ezxml_child(node,"dc:date");
+				}
+				pitem->SetDate(ezxml_txt(child));		
+				child = ezxml_child(node,"description");				
+				pitem->SetDescription(ezxml_txt(child));
+
+				child = ezxml_child(node,"content:encoded");
+				if ( child) pitem->SetDescription(ezxml_txt(child)); // overdrive description with content:encoded !
+		
+			}
+		
+		}
+		// Free memory
+		ezxml_free (f1);
+	}
+  }
+	
   // Free allocated memory
   if (data.memory) {
-     free(data.memory);
+     free(data.memory);	
      data.memory = NULL;
      data.size = 0;
      }
-
+  debug("cParser::DownloadAndParse(): Parsing OK");
   return (RSS_PARSING_OK);
 }
 
+void cParser::SetEncoding(const char *str) {
+  char *aux;
+  int len=0,ini=0;
+  if ((aux=strstr(str, "encoding")))  {
+     ini= strspn(aux + 8," ='\"") + 8;
+     len= strcspn(aux + ini , "'\"");
+     debug("[%s] %d %d\n",aux+ini,ini,len);
+     strn0cpy(encoding, aux+ini, sizeof(char)*(len+1));
+  } else {
+     strn0cpy(encoding,"UTF-8", sizeof(char)*(6+1));
+  }
+  debug("Encoding [%s]\n",encoding);
+}  
diff -Naur rssreader-1.1.2-orig/parser.h rssreader/parser.h
--- rssreader-1.1.2-orig/parser.h	2008-01-14 20:30:47.000000000 +0100
+++ rssreader/parser.h	2008-01-14 18:24:22.000000000 +0100
@@ -10,6 +10,7 @@
 #define __RSSREADER_PARSER_H
 
 #include "common.h"
+#include "compatibility.h"
 
 // --- Defines ----------------------------------------------------------
 
@@ -21,12 +22,13 @@
 class cItem : public cListObject {
 private:
   cCharSetConv conv;
+  char encoding[256];
   char date[SHORT_TEXT_LEN];
   char title[SHORT_TEXT_LEN];
   char link[SHORT_TEXT_LEN];
-  char description[LONG_TEXT_LEN];
+  char description[LONG_TEXT_LEN]; 
 public:
-  cItem();
+  cItem(const char *e);
   void Clear(void);
   char *GetDate(void) { return date; }
   char *GetTitle(void) { return title; }
@@ -35,7 +37,7 @@
   void SetDate(const char *str);
   void SetTitle(const char *str);
   void SetLink(const char *str);
-  void SetDescription(const char *str);
+  void SetDescription(const char *str);  
 };
 
 class cItems : public cList<cItem> {
@@ -53,6 +55,8 @@
 class cParser {
 private:
   struct MemoryStruct data;
+  char encoding[SHORT_TEXT_LEN];
+  void SetEncoding(const char *str);
 public:
   enum {
     RSS_PARSING_OK     =  0,
diff -Naur rssreader-1.1.2-orig/po/de_DE.po rssreader/po/de_DE.po
--- rssreader-1.1.2-orig/po/de_DE.po	2008-01-14 20:30:47.000000000 +0100
+++ rssreader/po/de_DE.po	2008-01-12 14:09:02.000000000 +0100
@@ -7,7 +7,7 @@
 msgstr ""
 "Project-Id-Version: VDR 1.5.7\n"
 "Report-Msgid-Bugs-To: Rolf Ahrenberg\n"
-"POT-Creation-Date: 2007-08-28 23:51+0300\n"
+"POT-Creation-Date: 2007-12-22 13:05+0100\n"
 "PO-Revision-Date: 2007-08-12 21:33+0300\n"
 "Last-Translator: Walter Koch\n"
 "Language-Team: <vdr@linuxtv.org>\n"
@@ -27,9 +27,6 @@
 msgid "<no description available>"
 msgstr "<keine Beschreibung vorhanden>"
 
-msgid "<no link available>"
-msgstr "<kein Link vorhanden>"
-
 msgid "Select RSS item"
 msgstr "Auswahl RSS-Artikel"
 
@@ -62,3 +59,6 @@
 
 msgid "HTTP proxy server"
 msgstr "HTTP Proxy Name"
+
+#~ msgid "<no link available>"
+#~ msgstr "<kein Link vorhanden>"
diff -Naur rssreader-1.1.2-orig/po/es_ES.po rssreader/po/es_ES.po
--- rssreader-1.1.2-orig/po/es_ES.po	1970-01-01 01:00:00.000000000 +0100
+++ rssreader/po/es_ES.po	2008-01-12 14:09:02.000000000 +0100
@@ -0,0 +1,65 @@
+# VDR plugin language source file.
+# Copyright (C) 2007 Klaus Schmidinger <kls@cadsoft.de>
+# This file is distributed under the same license as the VDR package.
+# Siegfried Dngler
+# Walter Koch
+msgid ""
+msgstr ""
+"Project-Id-Version: VDR 1.5.7\n"
+"Report-Msgid-Bugs-To: Rolf Ahrenberg\n"
+"POT-Creation-Date: 2007-12-22 19:09+0100\n"
+"PO-Revision-Date: 2007-08-12 21:33+0300\n"
+"Last-Translator: Walter Koch\n"
+"Language-Team: <vdr@linuxtv.org>\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=ISO-8859-15\n"
+"Content-Transfer-Encoding: 8bit\n"
+
+msgid "RSS item"
+msgstr "RSS-Articulo"
+
+msgid "<no date available>"
+msgstr "<Fecha no disponible>"
+
+msgid "<no title available>"
+msgstr "<Ttulo no disponible>"
+
+msgid "<no description available>"
+msgstr "<Descripcin no disponible>"
+
+#, fuzzy
+msgid "Select RSS item"
+msgstr "RSS-Articulo"
+
+msgid "Select RSS stream"
+msgstr "Selecciona fuente RSS"
+
+#, fuzzy
+msgid "Can't parse RSS stream!"
+msgstr "Error leyendo datos RSS!"
+
+#, fuzzy
+msgid "Can't download RSS stream!"
+msgstr "Error descargando datos RSS!"
+
+msgid "Unknown error!"
+msgstr "Error desconocido!"
+
+msgid "RSS Reader for OSD"
+msgstr "Lector RSS para OSD"
+
+msgid "RSS Reader"
+msgstr "Lector RSS"
+
+msgid "Hide main menu entry"
+msgstr "Ocultar entrada en men principal"
+
+msgid "Hide non-existent elements"
+msgstr "Ocultar elementos vacos"
+
+msgid "Use HTTP proxy server"
+msgstr "Usar servidor proxy HTTP"
+
+#, fuzzy
+msgid "HTTP proxy server"
+msgstr "Usar servidor proxy HTTP"
diff -Naur rssreader-1.1.2-orig/po/fi_FI.po rssreader/po/fi_FI.po
--- rssreader-1.1.2-orig/po/fi_FI.po	2008-01-14 20:30:47.000000000 +0100
+++ rssreader/po/fi_FI.po	2008-01-12 14:09:02.000000000 +0100
@@ -6,7 +6,7 @@
 msgstr ""
 "Project-Id-Version: VDR 1.5.7\n"
 "Report-Msgid-Bugs-To: Rolf Ahrenberg\n"
-"POT-Creation-Date: 2007-08-28 23:51+0300\n"
+"POT-Creation-Date: 2007-12-22 13:05+0100\n"
 "PO-Revision-Date: 2007-08-12 18:35+0300\n"
 "Last-Translator: Rolf Ahrenberg\n"
 "Language-Team: <vdr@linuxtv.org>\n"
@@ -26,9 +26,6 @@
 msgid "<no description available>"
 msgstr "<kuvaus ei ole saatavilla>"
 
-msgid "<no link available>"
-msgstr "<linkki ei ole saatavilla>"
-
 msgid "Select RSS item"
 msgstr "Valitse RSS-artikkeli"
 
@@ -61,3 +58,6 @@
 
 msgid "HTTP proxy server"
 msgstr "HTTP-vlityspalvelimen osoite"
+
+#~ msgid "<no link available>"
+#~ msgstr "<linkki ei ole saatavilla>"
diff -Naur rssreader-1.1.2-orig/po/fr_FR.po rssreader/po/fr_FR.po
--- rssreader-1.1.2-orig/po/fr_FR.po	2008-01-14 20:30:47.000000000 +0100
+++ rssreader/po/fr_FR.po	2008-01-12 14:09:02.000000000 +0100
@@ -6,7 +6,7 @@
 msgstr ""
 "Project-Id-Version: VDR 1.5.7\n"
 "Report-Msgid-Bugs-To: Rolf Ahrenberg\n"
-"POT-Creation-Date: 2007-08-28 23:51+0300\n"
+"POT-Creation-Date: 2007-12-22 13:05+0100\n"
 "PO-Revision-Date: 2007-08-12 21:33+0300\n"
 "Last-Translator: Patrice Staudt\n"
 "Language-Team: <vdr@linuxtv.org>\n"
@@ -26,9 +26,6 @@
 msgid "<no description available>"
 msgstr "<pas de dscriptif disponible>"
 
-msgid "<no link available>"
-msgstr "<pas de lien disponible>"
-
 msgid "Select RSS item"
 msgstr "Choix de article RSS"
 
@@ -61,3 +58,6 @@
 
 msgid "HTTP proxy server"
 msgstr "Nom du proxy HTTP"
+
+#~ msgid "<no link available>"
+#~ msgstr "<pas de lien disponible>"
diff -Naur rssreader-1.1.2-orig/po/.svn/all-wcprops rssreader/po/.svn/all-wcprops
--- rssreader-1.1.2-orig/po/.svn/all-wcprops	2008-01-14 20:30:47.000000000 +0100
+++ rssreader/po/.svn/all-wcprops	1970-01-01 01:00:00.000000000 +0100
@@ -1,23 +0,0 @@
-K 25
-svn:wc:ra_dav:version-url
-V 99
-/svn/VDR-M7x0/!svn/ver/14/unstable/VDR-Plugins/Source+patch/rssreader-1.1.2/rssreader-1.1.2-orig/po
-END
-fi_FI.po
-K 25
-svn:wc:ra_dav:version-url
-V 108
-/svn/VDR-M7x0/!svn/ver/14/unstable/VDR-Plugins/Source+patch/rssreader-1.1.2/rssreader-1.1.2-orig/po/fi_FI.po
-END
-fr_FR.po
-K 25
-svn:wc:ra_dav:version-url
-V 108
-/svn/VDR-M7x0/!svn/ver/14/unstable/VDR-Plugins/Source+patch/rssreader-1.1.2/rssreader-1.1.2-orig/po/fr_FR.po
-END
-de_DE.po
-K 25
-svn:wc:ra_dav:version-url
-V 108
-/svn/VDR-M7x0/!svn/ver/14/unstable/VDR-Plugins/Source+patch/rssreader-1.1.2/rssreader-1.1.2-orig/po/de_DE.po
-END
diff -Naur rssreader-1.1.2-orig/po/.svn/entries rssreader/po/.svn/entries
--- rssreader-1.1.2-orig/po/.svn/entries	2008-01-14 20:30:47.000000000 +0100
+++ rssreader/po/.svn/entries	1970-01-01 01:00:00.000000000 +0100
@@ -1,64 +0,0 @@
-8
-
-dir
-62
-http://svn2.assembla.com/svn/VDR-M7x0/unstable/VDR-Plugins/Source+patch/rssreader-1.1.2/rssreader-1.1.2-orig/po
-http://svn2.assembla.com/svn/VDR-M7x0
-
-
-
-2007-12-11T17:51:41.858007Z
-14
-bittor
-
-
-svn:special svn:externals svn:needs-lock
-
-
-
-
-
-
-
-
-
-
-
-c3d1530f-68f5-4bd0-87dc-8ef779617e40
-
-fi_FI.po
-file
-
-
-
-
-2008-01-06T08:30:53.000000Z
-ca34104ba59f878ad23a314a5da7c2ea
-2007-12-11T17:51:41.858007Z
-14
-bittor
-
-fr_FR.po
-file
-
-
-
-
-2008-01-06T08:30:53.000000Z
-000710443fe4425597d76095ae958330
-2007-12-11T17:51:41.858007Z
-14
-bittor
-
-de_DE.po
-file
-
-
-
-
-2008-01-06T08:30:53.000000Z
-15d9fec20465928dc91c5e09edab93bf
-2007-12-11T17:51:41.858007Z
-14
-bittor
-
diff -Naur rssreader-1.1.2-orig/po/.svn/format rssreader/po/.svn/format
--- rssreader-1.1.2-orig/po/.svn/format	2008-01-14 20:30:47.000000000 +0100
+++ rssreader/po/.svn/format	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-8
diff -Naur rssreader-1.1.2-orig/po/.svn/text-base/de_DE.po.svn-base rssreader/po/.svn/text-base/de_DE.po.svn-base
--- rssreader-1.1.2-orig/po/.svn/text-base/de_DE.po.svn-base	2008-01-14 20:30:46.000000000 +0100
+++ rssreader/po/.svn/text-base/de_DE.po.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,64 +0,0 @@
-# VDR plugin language source file.
-# Copyright (C) 2007 Klaus Schmidinger <kls@cadsoft.de>
-# This file is distributed under the same license as the VDR package.
-# Siegfried Dngler
-# Walter Koch
-msgid ""
-msgstr ""
-"Project-Id-Version: VDR 1.5.7\n"
-"Report-Msgid-Bugs-To: Rolf Ahrenberg\n"
-"POT-Creation-Date: 2007-08-28 23:51+0300\n"
-"PO-Revision-Date: 2007-08-12 21:33+0300\n"
-"Last-Translator: Walter Koch\n"
-"Language-Team: <vdr@linuxtv.org>\n"
-"MIME-Version: 1.0\n"
-"Content-Type: text/plain; charset=ISO-8859-15\n"
-"Content-Transfer-Encoding: 8bit\n"
-
-msgid "RSS item"
-msgstr "RSS-Artikel"
-
-msgid "<no date available>"
-msgstr "<kein Datum vorhanden>"
-
-msgid "<no title available>"
-msgstr "<kein Titel vorhanden>"
-
-msgid "<no description available>"
-msgstr "<keine Beschreibung vorhanden>"
-
-msgid "<no link available>"
-msgstr "<kein Link vorhanden>"
-
-msgid "Select RSS item"
-msgstr "Auswahl RSS-Artikel"
-
-msgid "Select RSS stream"
-msgstr "Auswahl RSS-Stream"
-
-msgid "Can't parse RSS stream!"
-msgstr "Kann den RSS-Stream nicht parsen!"
-
-msgid "Can't download RSS stream!"
-msgstr "Kann den RSS-Stream nicht laden!"
-
-msgid "Unknown error!"
-msgstr "Unbekannt Fehler!"
-
-msgid "RSS Reader for OSD"
-msgstr "RSS-Reader fr OSD"
-
-msgid "RSS Reader"
-msgstr "RSS-Reader"
-
-msgid "Hide main menu entry"
-msgstr "Hauptmeneintrag verstecken"
-
-msgid "Hide non-existent elements"
-msgstr "Nur vorhandene Elemente zeigen"
-
-msgid "Use HTTP proxy server"
-msgstr "HTTP Proxy benutzen"
-
-msgid "HTTP proxy server"
-msgstr "HTTP Proxy Name"
diff -Naur rssreader-1.1.2-orig/po/.svn/text-base/fi_FI.po.svn-base rssreader/po/.svn/text-base/fi_FI.po.svn-base
--- rssreader-1.1.2-orig/po/.svn/text-base/fi_FI.po.svn-base	2008-01-14 20:30:46.000000000 +0100
+++ rssreader/po/.svn/text-base/fi_FI.po.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,63 +0,0 @@
-# VDR plugin language source file.
-# Copyright (C) 2007 Klaus Schmidinger <kls@cadsoft.de>
-# This file is distributed under the same license as the VDR package.
-# Rolf Ahrenberg
-msgid ""
-msgstr ""
-"Project-Id-Version: VDR 1.5.7\n"
-"Report-Msgid-Bugs-To: Rolf Ahrenberg\n"
-"POT-Creation-Date: 2007-08-28 23:51+0300\n"
-"PO-Revision-Date: 2007-08-12 18:35+0300\n"
-"Last-Translator: Rolf Ahrenberg\n"
-"Language-Team: <vdr@linuxtv.org>\n"
-"MIME-Version: 1.0\n"
-"Content-Type: text/plain; charset=ISO-8859-15\n"
-"Content-Transfer-Encoding: 8bit\n"
-
-msgid "RSS item"
-msgstr "RSS-artikkeli"
-
-msgid "<no date available>"
-msgstr "<pivmr ei ole saatavilla>"
-
-msgid "<no title available>"
-msgstr "<otsikko ei ole saatavilla>"
-
-msgid "<no description available>"
-msgstr "<kuvaus ei ole saatavilla>"
-
-msgid "<no link available>"
-msgstr "<linkki ei ole saatavilla>"
-
-msgid "Select RSS item"
-msgstr "Valitse RSS-artikkeli"
-
-msgid "Select RSS stream"
-msgstr "Valitse RSS-virta"
-
-msgid "Can't parse RSS stream!"
-msgstr "RSS-virtaa ei pystyt tulkkaamaan!"
-
-msgid "Can't download RSS stream!"
-msgstr "RSS-virtaa ei pystyt vastaanottamaan!"
-
-msgid "Unknown error!"
-msgstr "Tuntematon virhe!"
-
-msgid "RSS Reader for OSD"
-msgstr "RSS-lukija kuvaruutunytlle"
-
-msgid "RSS Reader"
-msgstr "RSS-lukija"
-
-msgid "Hide main menu entry"
-msgstr "Piilota valinta pvalikosta"
-
-msgid "Hide non-existent elements"
-msgstr "Piilota tyhjt elementit"
-
-msgid "Use HTTP proxy server"
-msgstr "Kyt HTTP-vlityspalvelinta"
-
-msgid "HTTP proxy server"
-msgstr "HTTP-vlityspalvelimen osoite"
diff -Naur rssreader-1.1.2-orig/po/.svn/text-base/fr_FR.po.svn-base rssreader/po/.svn/text-base/fr_FR.po.svn-base
--- rssreader-1.1.2-orig/po/.svn/text-base/fr_FR.po.svn-base	2008-01-14 20:30:46.000000000 +0100
+++ rssreader/po/.svn/text-base/fr_FR.po.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,63 +0,0 @@
-# VDR plugin language source file.
-# Copyright (C) 2007 Klaus Schmidinger <kls@cadsoft.de>
-# This file is distributed under the same license as the VDR package.
-# Patrice Staudt
-msgid ""
-msgstr ""
-"Project-Id-Version: VDR 1.5.7\n"
-"Report-Msgid-Bugs-To: Rolf Ahrenberg\n"
-"POT-Creation-Date: 2007-08-28 23:51+0300\n"
-"PO-Revision-Date: 2007-08-12 21:33+0300\n"
-"Last-Translator: Patrice Staudt\n"
-"Language-Team: <vdr@linuxtv.org>\n"
-"MIME-Version: 1.0\n"
-"Content-Type: text/plain; charset=ISO-8859-1\n"
-"Content-Transfer-Encoding: 8bit\n"
-
-msgid "RSS item"
-msgstr "Article RSS"
-
-msgid "<no date available>"
-msgstr "<pas de date disponible>"
-
-msgid "<no title available>"
-msgstr "<pas de titre disponible>"
-
-msgid "<no description available>"
-msgstr "<pas de dscriptif disponible>"
-
-msgid "<no link available>"
-msgstr "<pas de lien disponible>"
-
-msgid "Select RSS item"
-msgstr "Choix de article RSS"
-
-msgid "Select RSS stream"
-msgstr "Choix des flux RSS"
-
-msgid "Can't parse RSS stream!"
-msgstr "Impossible d'analyser le flux RSS!"
-
-msgid "Can't download RSS stream!"
-msgstr "Impossible de charger le flux!"
-
-msgid "Unknown error!"
-msgstr "Erreur inconnue"
-
-msgid "RSS Reader for OSD"
-msgstr "Lecteur RSS pour OSD"
-
-msgid "RSS Reader"
-msgstr "Lecteur de flux RSS"
-
-msgid "Hide main menu entry"
-msgstr "Cacher le menu"
-
-msgid "Hide non-existent elements"
-msgstr "N'afficher que les lments existants"
-
-msgid "Use HTTP proxy server"
-msgstr "Utiliser le Proxy HTTP"
-
-msgid "HTTP proxy server"
-msgstr "Nom du proxy HTTP"
diff -Naur rssreader-1.1.2-orig/po2i18n.pl rssreader/po2i18n.pl
--- rssreader-1.1.2-orig/po2i18n.pl	1970-01-01 01:00:00.000000000 +0100
+++ rssreader/po2i18n.pl	2008-01-12 14:09:02.000000000 +0100
@@ -0,0 +1,134 @@
+#!/usr/bin/perl
+
+use strict;
+use warnings;
+
+my @LANGS = (
+  "en_US",
+  "de_DE",
+  "sl_SI",
+  "it_IT",
+  "nl_NL",
+  "pt_PT",
+  "fr_FR",
+  "nn_NO",
+  "fi_FI",
+  "pl_PL",
+  "es_ES",
+  "el_GR",
+  "sv_SE",
+  "ro_RO",
+  "hu_HU",
+  "ca_ES",
+  "ru_RU",
+  "hr_HR",
+  "et_EE",
+  "da_DK",
+  "cs_CZ",
+  "tr_TR"
+  );
+
+my %VERS = (
+  "en_US" => 10200,
+  "de_DE" => 10200,
+  "sl_SI" => 10200,
+  "it_IT" => 10200,
+  "nl_NL" => 10200,
+  "pt_PT" => 10200,
+  "fr_FR" => 10200,
+  "nn_NO" => 10200,
+  "fi_FI" => 10200,
+  "pl_PL" => 10200,
+  "es_ES" => 10200,
+  "el_GR" => 10200,
+  "sv_SE" => 10200,
+  "ro_RO" => 10200,
+  "hu_HU" => 10200,
+  "ca_ES" => 10200,
+  "ru_RU" => 10302,
+  "hr_HR" => 10307,
+  "et_EE" => 10313,
+  "da_DK" => 10316,
+  "cs_CZ" => 10342,
+  "tr_TR" => 10502
+  );
+
+
+my %strings;
+
+foreach my $lang (@LANGS) { $strings{$lang} = { }; }
+
+
+sub LoadLanguage(*) {
+    my ($lang) = @_;
+    
+    if (!open FILE, "<", "po/$lang.po") {
+        return 0;   
+    }
+    
+    my $msgid = "";
+    while (<FILE>) {
+        chomp;
+        my $line = $_;
+        
+        if ($line =~ /^msgid "(.*)"$/) {
+            $msgid = $1;
+        } elsif ($line =~ /^msgstr "(.*)"$/) {
+            my $msgstr = $1;
+            $strings{$lang}->{$msgid} = $msgstr;
+            $strings{"en_US"}->{$msgid} = $msgid;
+        }
+    }
+    
+    close FILE;
+}
+
+
+
+foreach my $lang (@LANGS) { 
+    LoadLanguage($lang);
+}
+
+my @msgids = sort keys %{$strings{"en_US"}};
+
+
+my $silent = 0;
+
+while (<>) {
+    my $line = $_;
+
+    if ($line =~ /^\/\/ START I18N/) {
+        print "// START I18N - automatically generated by po2i18n.pl\n";
+        for my $msgid (@msgids) {
+            next if $msgid eq "";
+
+            my $head = "  { ";
+            my $endif = "";
+            my $versnum = 10200;
+            
+            for my $lang (@LANGS) {
+                if ($VERS{$lang} ne $versnum) {
+                    $versnum = $VERS{$lang};
+                    print $endif;
+                    print "#if VDRVERSNUM >= $versnum\n";
+                    $endif = "#endif\n";
+                }
+                my $msgstr = $strings{$lang}->{$msgid};
+                $msgstr = "" if !defined $msgstr;
+                
+                print "$head\"$msgstr\",\n";
+                $head = "    ";
+            }
+            print $endif;
+            print "  },\n";
+        }
+        $silent = 1;
+    }
+
+    if (!$silent) { print $line; }
+
+    if ($line =~ /^\/\/ END I18N/) { 
+        print "// END I18N - automatically generated by po2i18n.pl\n";
+        $silent = 0; 
+    }    
+}
diff -Naur rssreader-1.1.2-orig/rssreader.c rssreader/rssreader.c
--- rssreader-1.1.2-orig/rssreader.c	2008-01-14 20:30:47.000000000 +0100
+++ rssreader/rssreader.c	2008-01-12 14:09:02.000000000 +0100
@@ -11,10 +11,10 @@
 #include "menu.h"
 #include "config.h"
 #include "common.h"
+#include "i18n.h"
 
-#if defined(APIVERSNUM) && APIVERSNUM < 10508
-#error "VDR-1.5.8 API version or greater is required!"
-#endif
+
+#define trNOOP(x) x
 
 static const char VERSION[]       = "1.1.2";
 static const char DESCRIPTION[]   = trNOOP("RSS Reader for OSD");
@@ -84,6 +84,9 @@
 bool cPluginRssReader::Initialize(void)
 {
   // Initialize any background activities the plugin shall perform.
+#if VDRVERSNUM < 10507
+  RegisterI18n(StreamplayerPhrases);
+#endif
   return true;
 }
 
diff -Naur rssreader-1.1.2-orig/.svn/all-wcprops rssreader/.svn/all-wcprops
--- rssreader-1.1.2-orig/.svn/all-wcprops	2008-01-14 20:30:46.000000000 +0100
+++ rssreader/.svn/all-wcprops	1970-01-01 01:00:00.000000000 +0100
@@ -1,89 +0,0 @@
-K 25
-svn:wc:ra_dav:version-url
-V 96
-/svn/VDR-M7x0/!svn/ver/14/unstable/VDR-Plugins/Source+patch/rssreader-1.1.2/rssreader-1.1.2-orig
-END
-tools.c
-K 25
-svn:wc:ra_dav:version-url
-V 104
-/svn/VDR-M7x0/!svn/ver/14/unstable/VDR-Plugins/Source+patch/rssreader-1.1.2/rssreader-1.1.2-orig/tools.c
-END
-HISTORY
-K 25
-svn:wc:ra_dav:version-url
-V 104
-/svn/VDR-M7x0/!svn/ver/14/unstable/VDR-Plugins/Source+patch/rssreader-1.1.2/rssreader-1.1.2-orig/HISTORY
-END
-parser.h
-K 25
-svn:wc:ra_dav:version-url
-V 105
-/svn/VDR-M7x0/!svn/ver/14/unstable/VDR-Plugins/Source+patch/rssreader-1.1.2/rssreader-1.1.2-orig/parser.h
-END
-menu.c
-K 25
-svn:wc:ra_dav:version-url
-V 103
-/svn/VDR-M7x0/!svn/ver/14/unstable/VDR-Plugins/Source+patch/rssreader-1.1.2/rssreader-1.1.2-orig/menu.c
-END
-tools.h
-K 25
-svn:wc:ra_dav:version-url
-V 104
-/svn/VDR-M7x0/!svn/ver/14/unstable/VDR-Plugins/Source+patch/rssreader-1.1.2/rssreader-1.1.2-orig/tools.h
-END
-config.c
-K 25
-svn:wc:ra_dav:version-url
-V 105
-/svn/VDR-M7x0/!svn/ver/14/unstable/VDR-Plugins/Source+patch/rssreader-1.1.2/rssreader-1.1.2-orig/config.c
-END
-COPYING
-K 25
-svn:wc:ra_dav:version-url
-V 104
-/svn/VDR-M7x0/!svn/ver/14/unstable/VDR-Plugins/Source+patch/rssreader-1.1.2/rssreader-1.1.2-orig/COPYING
-END
-menu.h
-K 25
-svn:wc:ra_dav:version-url
-V 103
-/svn/VDR-M7x0/!svn/ver/14/unstable/VDR-Plugins/Source+patch/rssreader-1.1.2/rssreader-1.1.2-orig/menu.h
-END
-config.h
-K 25
-svn:wc:ra_dav:version-url
-V 105
-/svn/VDR-M7x0/!svn/ver/14/unstable/VDR-Plugins/Source+patch/rssreader-1.1.2/rssreader-1.1.2-orig/config.h
-END
-rssreader.c
-K 25
-svn:wc:ra_dav:version-url
-V 108
-/svn/VDR-M7x0/!svn/ver/14/unstable/VDR-Plugins/Source+patch/rssreader-1.1.2/rssreader-1.1.2-orig/rssreader.c
-END
-README
-K 25
-svn:wc:ra_dav:version-url
-V 103
-/svn/VDR-M7x0/!svn/ver/14/unstable/VDR-Plugins/Source+patch/rssreader-1.1.2/rssreader-1.1.2-orig/README
-END
-parser.c
-K 25
-svn:wc:ra_dav:version-url
-V 105
-/svn/VDR-M7x0/!svn/ver/14/unstable/VDR-Plugins/Source+patch/rssreader-1.1.2/rssreader-1.1.2-orig/parser.c
-END
-Makefile
-K 25
-svn:wc:ra_dav:version-url
-V 105
-/svn/VDR-M7x0/!svn/ver/14/unstable/VDR-Plugins/Source+patch/rssreader-1.1.2/rssreader-1.1.2-orig/Makefile
-END
-common.h
-K 25
-svn:wc:ra_dav:version-url
-V 105
-/svn/VDR-M7x0/!svn/ver/14/unstable/VDR-Plugins/Source+patch/rssreader-1.1.2/rssreader-1.1.2-orig/common.h
-END
diff -Naur rssreader-1.1.2-orig/.svn/entries rssreader/.svn/entries
--- rssreader-1.1.2-orig/.svn/entries	2008-01-14 20:30:46.000000000 +0100
+++ rssreader/.svn/entries	1970-01-01 01:00:00.000000000 +0100
@@ -1,202 +0,0 @@
-8
-
-dir
-62
-http://svn2.assembla.com/svn/VDR-M7x0/unstable/VDR-Plugins/Source+patch/rssreader-1.1.2/rssreader-1.1.2-orig
-http://svn2.assembla.com/svn/VDR-M7x0
-
-
-
-2007-12-11T17:51:41.858007Z
-14
-bittor
-
-
-svn:special svn:externals svn:needs-lock
-
-
-
-
-
-
-
-
-
-
-
-c3d1530f-68f5-4bd0-87dc-8ef779617e40
-
-tools.c
-file
-
-
-
-
-2008-01-06T08:30:53.000000Z
-58da9dc73ae8ab5d2a757951ea6ddcd8
-2007-12-11T17:51:41.858007Z
-14
-bittor
-
-parser.h
-file
-
-
-
-
-2008-01-06T08:30:53.000000Z
-121b759ef30ce001fe2281e73e786095
-2007-12-11T17:51:41.858007Z
-14
-bittor
-
-menu.c
-file
-
-
-
-
-2008-01-06T08:30:53.000000Z
-3a4a6f7d8ff690cae11f23353d860544
-2007-12-11T17:51:41.858007Z
-14
-bittor
-
-tools.h
-file
-
-
-
-
-2008-01-06T08:30:53.000000Z
-6eea0be30c61b776f87dd4b05076f106
-2007-12-11T17:51:41.858007Z
-14
-bittor
-
-config.c
-file
-
-
-
-
-2008-01-06T08:30:53.000000Z
-b775a7712cc7403943b4722d3ade0f14
-2007-12-11T17:51:41.858007Z
-14
-bittor
-
-menu.h
-file
-
-
-
-
-2008-01-06T08:30:53.000000Z
-f65b8f6d721bc7f21497261d33dcb234
-2007-12-11T17:51:41.858007Z
-14
-bittor
-
-example
-dir
-
-config.h
-file
-
-
-
-
-2008-01-06T08:30:53.000000Z
-c3e7a92f1a5652a1042d6f0f3669a019
-2007-12-11T17:51:41.858007Z
-14
-bittor
-
-README
-file
-
-
-
-
-2008-01-06T08:30:53.000000Z
-d77115a667c90c7c0f0ff33b7b60ebbc
-2007-12-11T17:51:41.858007Z
-14
-bittor
-
-HISTORY
-file
-
-
-
-
-2008-01-06T08:30:53.000000Z
-9211052ed92f1141310ea9695d8eca5e
-2007-12-11T17:51:41.858007Z
-14
-bittor
-
-COPYING
-file
-
-
-
-
-2008-01-06T08:30:53.000000Z
-892f569a555ba9c07a568a7c0c4fa63a
-2007-12-11T17:51:41.858007Z
-14
-bittor
-
-rssreader.c
-file
-
-
-
-
-2008-01-06T08:30:53.000000Z
-294e4b7fdb6b6725a878764edd8bb02d
-2007-12-11T17:51:41.858007Z
-14
-bittor
-
-parser.c
-file
-
-
-
-
-2008-01-06T08:30:53.000000Z
-dc5fa296603b5acaea51ba6a6efd3554
-2007-12-11T17:51:41.858007Z
-14
-bittor
-
-Makefile
-file
-
-
-
-
-2008-01-06T08:30:53.000000Z
-5f4dc79d0c9cb84a263deddf5cc3d546
-2007-12-11T17:51:41.858007Z
-14
-bittor
-
-po
-dir
-
-common.h
-file
-
-
-
-
-2008-01-06T08:30:53.000000Z
-b472c4148a1ef54f2205a54b704345cd
-2007-12-11T17:51:41.858007Z
-14
-bittor
-
diff -Naur rssreader-1.1.2-orig/.svn/format rssreader/.svn/format
--- rssreader-1.1.2-orig/.svn/format	2008-01-14 20:30:46.000000000 +0100
+++ rssreader/.svn/format	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-8
diff -Naur rssreader-1.1.2-orig/.svn/text-base/common.h.svn-base rssreader/.svn/text-base/common.h.svn-base
--- rssreader-1.1.2-orig/.svn/text-base/common.h.svn-base	2008-01-14 20:30:46.000000000 +0100
+++ rssreader/.svn/text-base/common.h.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,24 +0,0 @@
-/*
- * common.h: RSS Reader plugin for the Video Disk Recorder
- *
- * See the README file for copyright information and how to reach the author.
- *
- * $Id$
- */
-
-#ifndef __RSSREADER_COMMON_H
-#define __RSSREADER_COMMON_H
-
-#ifdef DEBUG
-#define debug(x...) dsyslog("RSSReader: " x);
-#define error(x...) esyslog("RSSReader: " x);
-#else
-#define debug(x...) ;
-#define error(x...) esyslog("RSSReader: " x);
-#endif
-
-// User agent string for servers
-#define RSSREADER_USERAGENT "libcurl-agent/1.0"
-
-#endif // __RSSREADER_COMMON_H
-
diff -Naur rssreader-1.1.2-orig/.svn/text-base/config.c.svn-base rssreader/.svn/text-base/config.c.svn-base
--- rssreader-1.1.2-orig/.svn/text-base/config.c.svn-base	2008-01-14 20:30:46.000000000 +0100
+++ rssreader/.svn/text-base/config.c.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,19 +0,0 @@
-/*
- * config.c: RSS Reader plugin for the Video Disk Recorder
- *
- * See the README file for copyright information and how to reach the author.
- *
- * $Id$
- */
-
-#include "tools.h"
-#include "config.h"
-#include "common.h"
-
-cRssReaderConfig RssConfig;
-
-cRssReaderConfig::cRssReaderConfig(void)
-: hidemenu(0), hideelem(0), useproxy(0)
-{
-  strn0cpy(httpproxy, "127.0.0.1:8000", sizeof(httpproxy));
-}
diff -Naur rssreader-1.1.2-orig/.svn/text-base/config.h.svn-base rssreader/.svn/text-base/config.h.svn-base
--- rssreader-1.1.2-orig/.svn/text-base/config.h.svn-base	2008-01-14 20:30:46.000000000 +0100
+++ rssreader/.svn/text-base/config.h.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,24 +0,0 @@
-/*
- * config.h: RSS Reader plugin for the Video Disk Recorder
- *
- * See the README file for copyright information and how to reach the author.
- *
- * $Id$
- */
-
-#ifndef __RSSREADER_CONFIG_H
-#define __RSSREADER_CONFIG_H
-
-struct cRssReaderConfig
-{
-public:
-  cRssReaderConfig(void);
-  int hidemenu;
-  int hideelem;
-  int useproxy;
-  char httpproxy[256];
-};
-
-extern cRssReaderConfig RssConfig;
-
-#endif // __RSSREADER_CONFIG_H
diff -Naur rssreader-1.1.2-orig/.svn/text-base/COPYING.svn-base rssreader/.svn/text-base/COPYING.svn-base
--- rssreader-1.1.2-orig/.svn/text-base/COPYING.svn-base	2008-01-14 20:30:46.000000000 +0100
+++ rssreader/.svn/text-base/COPYING.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,340 +0,0 @@
-		    GNU GENERAL PUBLIC LICENSE
-		       Version 2, June 1991
-
- Copyright (C) 1989, 1991 Free Software Foundation, Inc.
- 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- Everyone is permitted to copy and distribute verbatim copies
- of this license document, but changing it is not allowed.
-
-			    Preamble
-
-  The licenses for most software are designed to take away your
-freedom to share and change it.  By contrast, the GNU General Public
-License is intended to guarantee your freedom to share and change free
-software--to make sure the software is free for all its users.  This
-General Public License applies to most of the Free Software
-Foundation's software and to any other program whose authors commit to
-using it.  (Some other Free Software Foundation software is covered by
-the GNU Lesser General Public License instead.)  You can apply it to
-your programs, too.
-
-  When we speak of free software, we are referring to freedom, not
-price.  Our General Public Licenses are designed to make sure that you
-have the freedom to distribute copies of free software (and charge for
-this service if you wish), that you receive source code or can get it
-if you want it, that you can change the software or use pieces of it
-in new free programs; and that you know you can do these things.
-
-  To protect your rights, we need to make restrictions that forbid
-anyone to deny you these rights or to ask you to surrender the rights.
-These restrictions translate to certain responsibilities for you if you
-distribute copies of the software, or if you modify it.
-
-  For example, if you distribute copies of such a program, whether
-gratis or for a fee, you must give the recipients all the rights that
-you have.  You must make sure that they, too, receive or can get the
-source code.  And you must show them these terms so they know their
-rights.
-
-  We protect your rights with two steps: (1) copyright the software, and
-(2) offer you this license which gives you legal permission to copy,
-distribute and/or modify the software.
-
-  Also, for each author's protection and ours, we want to make certain
-that everyone understands that there is no warranty for this free
-software.  If the software is modified by someone else and passed on, we
-want its recipients to know that what they have is not the original, so
-that any problems introduced by others will not reflect on the original
-authors' reputations.
-
-  Finally, any free program is threatened constantly by software
-patents.  We wish to avoid the danger that redistributors of a free
-program will individually obtain patent licenses, in effect making the
-program proprietary.  To prevent this, we have made it clear that any
-patent must be licensed for everyone's free use or not licensed at all.
-
-  The precise terms and conditions for copying, distribution and
-modification follow.
-
-		    GNU GENERAL PUBLIC LICENSE
-   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
-
-  0. This License applies to any program or other work which contains
-a notice placed by the copyright holder saying it may be distributed
-under the terms of this General Public License.  The "Program", below,
-refers to any such program or work, and a "work based on the Program"
-means either the Program or any derivative work under copyright law:
-that is to say, a work containing the Program or a portion of it,
-either verbatim or with modifications and/or translated into another
-language.  (Hereinafter, translation is included without limitation in
-the term "modification".)  Each licensee is addressed as "you".
-
-Activities other than copying, distribution and modification are not
-covered by this License; they are outside its scope.  The act of
-running the Program is not restricted, and the output from the Program
-is covered only if its contents constitute a work based on the
-Program (independent of having been made by running the Program).
-Whether that is true depends on what the Program does.
-
-  1. You may copy and distribute verbatim copies of the Program's
-source code as you receive it, in any medium, provided that you
-conspicuously and appropriately publish on each copy an appropriate
-copyright notice and disclaimer of warranty; keep intact all the
-notices that refer to this License and to the absence of any warranty;
-and give any other recipients of the Program a copy of this License
-along with the Program.
-
-You may charge a fee for the physical act of transferring a copy, and
-you may at your option offer warranty protection in exchange for a fee.
-
-  2. You may modify your copy or copies of the Program or any portion
-of it, thus forming a work based on the Program, and copy and
-distribute such modifications or work under the terms of Section 1
-above, provided that you also meet all of these conditions:
-
-    a) You must cause the modified files to carry prominent notices
-    stating that you changed the files and the date of any change.
-
-    b) You must cause any work that you distribute or publish, that in
-    whole or in part contains or is derived from the Program or any
-    part thereof, to be licensed as a whole at no charge to all third
-    parties under the terms of this License.
-
-    c) If the modified program normally reads commands interactively
-    when run, you must cause it, when started running for such
-    interactive use in the most ordinary way, to print or display an
-    announcement including an appropriate copyright notice and a
-    notice that there is no warranty (or else, saying that you provide
-    a warranty) and that users may redistribute the program under
-    these conditions, and telling the user how to view a copy of this
-    License.  (Exception: if the Program itself is interactive but
-    does not normally print such an announcement, your work based on
-    the Program is not required to print an announcement.)
-
-These requirements apply to the modified work as a whole.  If
-identifiable sections of that work are not derived from the Program,
-and can be reasonably considered independent and separate works in
-themselves, then this License, and its terms, do not apply to those
-sections when you distribute them as separate works.  But when you
-distribute the same sections as part of a whole which is a work based
-on the Program, the distribution of the whole must be on the terms of
-this License, whose permissions for other licensees extend to the
-entire whole, and thus to each and every part regardless of who wrote it.
-
-Thus, it is not the intent of this section to claim rights or contest
-your rights to work written entirely by you; rather, the intent is to
-exercise the right to control the distribution of derivative or
-collective works based on the Program.
-
-In addition, mere aggregation of another work not based on the Program
-with the Program (or with a work based on the Program) on a volume of
-a storage or distribution medium does not bring the other work under
-the scope of this License.
-
-  3. You may copy and distribute the Program (or a work based on it,
-under Section 2) in object code or executable form under the terms of
-Sections 1 and 2 above provided that you also do one of the following:
-
-    a) Accompany it with the complete corresponding machine-readable
-    source code, which must be distributed under the terms of Sections
-    1 and 2 above on a medium customarily used for software interchange; or,
-
-    b) Accompany it with a written offer, valid for at least three
-    years, to give any third party, for a charge no more than your
-    cost of physically performing source distribution, a complete
-    machine-readable copy of the corresponding source code, to be
-    distributed under the terms of Sections 1 and 2 above on a medium
-    customarily used for software interchange; or,
-
-    c) Accompany it with the information you received as to the offer
-    to distribute corresponding source code.  (This alternative is
-    allowed only for noncommercial distribution and only if you
-    received the program in object code or executable form with such
-    an offer, in accord with Subsection b above.)
-
-The source code for a work means the preferred form of the work for
-making modifications to it.  For an executable work, complete source
-code means all the source code for all modules it contains, plus any
-associated interface definition files, plus the scripts used to
-control compilation and installation of the executable.  However, as a
-special exception, the source code distributed need not include
-anything that is normally distributed (in either source or binary
-form) with the major components (compiler, kernel, and so on) of the
-operating system on which the executable runs, unless that component
-itself accompanies the executable.
-
-If distribution of executable or object code is made by offering
-access to copy from a designated place, then offering equivalent
-access to copy the source code from the same place counts as
-distribution of the source code, even though third parties are not
-compelled to copy the source along with the object code.
-
-  4. You may not copy, modify, sublicense, or distribute the Program
-except as expressly provided under this License.  Any attempt
-otherwise to copy, modify, sublicense or distribute the Program is
-void, and will automatically terminate your rights under this License.
-However, parties who have received copies, or rights, from you under
-this License will not have their licenses terminated so long as such
-parties remain in full compliance.
-
-  5. You are not required to accept this License, since you have not
-signed it.  However, nothing else grants you permission to modify or
-distribute the Program or its derivative works.  These actions are
-prohibited by law if you do not accept this License.  Therefore, by
-modifying or distributing the Program (or any work based on the
-Program), you indicate your acceptance of this License to do so, and
-all its terms and conditions for copying, distributing or modifying
-the Program or works based on it.
-
-  6. Each time you redistribute the Program (or any work based on the
-Program), the recipient automatically receives a license from the
-original licensor to copy, distribute or modify the Program subject to
-these terms and conditions.  You may not impose any further
-restrictions on the recipients' exercise of the rights granted herein.
-You are not responsible for enforcing compliance by third parties to
-this License.
-
-  7. If, as a consequence of a court judgment or allegation of patent
-infringement or for any other reason (not limited to patent issues),
-conditions are imposed on you (whether by court order, agreement or
-otherwise) that contradict the conditions of this License, they do not
-excuse you from the conditions of this License.  If you cannot
-distribute so as to satisfy simultaneously your obligations under this
-License and any other pertinent obligations, then as a consequence you
-may not distribute the Program at all.  For example, if a patent
-license would not permit royalty-free redistribution of the Program by
-all those who receive copies directly or indirectly through you, then
-the only way you could satisfy both it and this License would be to
-refrain entirely from distribution of the Program.
-
-If any portion of this section is held invalid or unenforceable under
-any particular circumstance, the balance of the section is intended to
-apply and the section as a whole is intended to apply in other
-circumstances.
-
-It is not the purpose of this section to induce you to infringe any
-patents or other property right claims or to contest validity of any
-such claims; this section has the sole purpose of protecting the
-integrity of the free software distribution system, which is
-implemented by public license practices.  Many people have made
-generous contributions to the wide range of software distributed
-through that system in reliance on consistent application of that
-system; it is up to the author/donor to decide if he or she is willing
-to distribute software through any other system and a licensee cannot
-impose that choice.
-
-This section is intended to make thoroughly clear what is believed to
-be a consequence of the rest of this License.
-
-  8. If the distribution and/or use of the Program is restricted in
-certain countries either by patents or by copyrighted interfaces, the
-original copyright holder who places the Program under this License
-may add an explicit geographical distribution limitation excluding
-those countries, so that distribution is permitted only in or among
-countries not thus excluded.  In such case, this License incorporates
-the limitation as if written in the body of this License.
-
-  9. The Free Software Foundation may publish revised and/or new versions
-of the General Public License from time to time.  Such new versions will
-be similar in spirit to the present version, but may differ in detail to
-address new problems or concerns.
-
-Each version is given a distinguishing version number.  If the Program
-specifies a version number of this License which applies to it and "any
-later version", you have the option of following the terms and conditions
-either of that version or of any later version published by the Free
-Software Foundation.  If the Program does not specify a version number of
-this License, you may choose any version ever published by the Free Software
-Foundation.
-
-  10. If you wish to incorporate parts of the Program into other free
-programs whose distribution conditions are different, write to the author
-to ask for permission.  For software which is copyrighted by the Free
-Software Foundation, write to the Free Software Foundation; we sometimes
-make exceptions for this.  Our decision will be guided by the two goals
-of preserving the free status of all derivatives of our free software and
-of promoting the sharing and reuse of software generally.
-
-			    NO WARRANTY
-
-  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
-FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
-OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
-PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
-OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
-TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
-PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
-REPAIR OR CORRECTION.
-
-  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
-WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
-REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
-INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
-OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
-TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
-YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
-PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGES.
-
-		     END OF TERMS AND CONDITIONS
-
-	    How to Apply These Terms to Your New Programs
-
-  If you develop a new program, and you want it to be of the greatest
-possible use to the public, the best way to achieve this is to make it
-free software which everyone can redistribute and change under these terms.
-
-  To do so, attach the following notices to the program.  It is safest
-to attach them to the start of each source file to most effectively
-convey the exclusion of warranty; and each file should have at least
-the "copyright" line and a pointer to where the full notice is found.
-
-    <one line to give the program's name and a brief idea of what it does.>
-    Copyright (C) <year>  <name of author>
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-
-
-Also add information on how to contact you by electronic and paper mail.
-
-If the program is interactive, make it output a short notice like this
-when it starts in an interactive mode:
-
-    Gnomovision version 69, Copyright (C) year name of author
-    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
-    This is free software, and you are welcome to redistribute it
-    under certain conditions; type `show c' for details.
-
-The hypothetical commands `show w' and `show c' should show the appropriate
-parts of the General Public License.  Of course, the commands you use may
-be called something other than `show w' and `show c'; they could even be
-mouse-clicks or menu items--whatever suits your program.
-
-You should also get your employer (if you work as a programmer) or your
-school, if any, to sign a "copyright disclaimer" for the program, if
-necessary.  Here is a sample; alter the names:
-
-  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
-  `Gnomovision' (which makes passes at compilers) written by James Hacker.
-
-  <signature of Ty Coon>, 1 April 1989
-  Ty Coon, President of Vice
-
-This General Public License does not permit incorporating your program into
-proprietary programs.  If your program is a subroutine library, you may
-consider it more useful to permit linking proprietary applications with the
-library.  If this is what you want to do, use the GNU Lesser General
-Public License instead of this License.
diff -Naur rssreader-1.1.2-orig/.svn/text-base/HISTORY.svn-base rssreader/.svn/text-base/HISTORY.svn-base
--- rssreader-1.1.2-orig/.svn/text-base/HISTORY.svn-base	2008-01-14 20:30:46.000000000 +0100
+++ rssreader/.svn/text-base/HISTORY.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,90 +0,0 @@
-VDR Plugin 'rssreader' Revision History
----------------------------------
-
-2005-12-18: Version 0.0.1
-
-- Initial revision.
-
-2005-12-18: Version 0.0.2
-
-- Hotfix release.
-- Fixed charset encoding for iso-8859-15.
-- Showing "link" instead of "target" on the item menu.
-
-2005-12-19: Version 0.0.3
-
-- Removed obsolete "target" code.
-- Fixed RSSREADER_TEMPFILE Makefile parameter.
-  (Thanks to Ronny Kornexl for reporting this one)
-- Added label support into rssreader.conf.
-- User inactivity doesn't close menu anymore.
-- Added German translation (Thanks to Siegfried Dngler).
-
-2005-12-21: Version 0.0.4
-
-- Completed German translation (Thanks to Walter Koch).
-- Added new RSS streams into "example/rssreader.conf".
-- Fixed RSS URLs with several '&' characters (Thanks to Matthias).
-- Added new setup options to hide mainmenu entry and to hide
-  non-existent elements.
-- Fixed RSS parsing engine.
-- Added '-f' command line option for RSSREADER_TEMPFILE.
-- Fixed OSD menu related crash bug.
-
-2006-01-25: Version 0.1.0
-
-- Updated for vdr-1.3.40.
-- Fixed typos in "example/rssreader.conf" (Thanks to Thilo Wunderlich).
-- Added pragma warning, if libexpat is non-existent or incompatible version.
-- Some internal cleanups.
-
-2006-02-06: Version 0.1.1
-
-- Updated for vdr-1.3.42.
-- Changed wget to libcurl so there's no need to define a temporary file anymore.
-- Added new setup options for HTTP proxy.
-- Improved RSS formatting.
-- Updated "example/rssreader.conf".
-
-2006-02-10: Version 0.1.2
-
-- The RSS item menu doesn't use the fixed font anymore.
-- Updated HTML entities conversion table.
-
-2006-04-20: Version 0.2.0
-
-- Updated for vdr-1.3.47.
-- Updated "example/rssreader.conf".
-- Updated HTML entities conversion table.
-
-2006-04-23: Version 0.3.0
-
-- Added STRIP option for Makefile (Thanks to Ville Skytt).
-- Modified APIVERSION code in Makefile.
-
-2006-04-30: Version 1.0.0
-
-- Updated for vdr-1.4.0.
-- Modified APIVERSION code in Makefile.
-
-2006-07-01: Version 1.0.1
-
-- Added French translation (Thanks to Patrice Staudt).
-- Updated "example/rssreader.conf".
-
-2007-10-12: Version 1.0.2
-
-- Backported from 1.1.2.
-
-2007-08-14: Version 1.1.0
-
-- Updated for vdr-1.5.7.
-
-2007-08-19: Version 1.1.1
-
-- Updated for vdr-1.5.8.
-
-2007-10-12: Version 1.1.2
-
-- Cleaned up translations.
-- Improved html tag stripping.
diff -Naur rssreader-1.1.2-orig/.svn/text-base/Makefile.svn-base rssreader/.svn/text-base/Makefile.svn-base
--- rssreader-1.1.2-orig/.svn/text-base/Makefile.svn-base	2008-01-14 20:30:46.000000000 +0100
+++ rssreader/.svn/text-base/Makefile.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,126 +0,0 @@
-#
-# Makefile for a Video Disk Recorder RSS Reader plugin
-#
-# $Id$
-
-# Debugging on/off 
-#RSSREADER_DEBUG = 1
-
-# Strip debug symbols?  Set eg. to /bin/true if not
-STRIP = strip
-
-# The official name of this plugin.
-# This name will be used in the '-P...' option of VDR to load the plugin.
-# By default the main source file also carries this name.
-#
-PLUGIN = rssreader
-
-### The version number of this plugin (taken from the main source file):
-
-VERSION = $(shell grep 'static const char VERSION\[\] *=' $(PLUGIN).c | awk '{ print $$6 }' | sed -e 's/[";]//g')
-
-### The C++ compiler and options:
-
-CXX      ?= g++
-CXXFLAGS ?= -fPIC -g -O2 -Wall -Woverloaded-virtual
-
-### The directory environment:
-
-VDRDIR = ../../..
-LIBDIR = ../../lib
-TMPDIR = /tmp
-
-### Libraries
-
-LIBS = -lexpat -lcurl
-
-### Allow user defined options to overwrite defaults:
-
--include $(VDRDIR)/Make.config
-
-### The version number of VDR's plugin API (taken from VDR's "config.h"):
-
-APIVERSION = $(shell sed -ne '/define APIVERSION/s/^.*"\(.*\)".*$$/\1/p' $(VDRDIR)/config.h)
-
-### The name of the distribution archive:
-
-ARCHIVE = $(PLUGIN)-$(VERSION)
-PACKAGE = vdr-$(ARCHIVE)
-
-### Includes and Defines (add further entries here):
-
-INCLUDES += -I$(VDRDIR)/include
-
-DEFINES += -D_GNU_SOURCE -DPLUGIN_NAME_I18N='"$(PLUGIN)"'
-
-ifdef RSSREADER_DEBUG
-DEFINES += -DDEBUG
-endif
-
-### The object files (add further files here):
-
-OBJS = rssreader.o parser.o menu.o config.o tools.o
-
-### The main target:
-
-all: libvdr-$(PLUGIN).so i18n
-
-### Implicit rules:
-
-%.o: %.c
-	$(CXX) $(CXXFLAGS) -c $(DEFINES) $(INCLUDES) $<
-
-# Dependencies:
-
-MAKEDEP = $(CXX) -MM -MG
-DEPFILE = .dependencies
-$(DEPFILE): Makefile
-	@$(MAKEDEP) $(DEFINES) $(INCLUDES) $(OBJS:%.o=%.c) > $@
-
--include $(DEPFILE)
-
-### Internationalization (I18N):
-
-PODIR     = po
-LOCALEDIR = $(VDRDIR)/locale
-I18Npo    = $(wildcard $(PODIR)/*.po)
-I18Nmo    = $(addsuffix .mo, $(foreach file, $(I18Npo), $(basename $(file))))
-I18Ndirs  = $(notdir $(foreach file, $(I18Npo), $(basename $(file))))
-I18Npot   = $(PODIR)/$(PLUGIN).pot
-
-%.mo: %.po
-	msgfmt -c -o $@ $<
-
-$(I18Npot): $(wildcard *.c)
-	xgettext -C -cTRANSLATORS --no-wrap --no-location -k -ktr -ktrNOOP --msgid-bugs-address='Rolf Ahrenberg' -o $@ $(wildcard *.c)
-
-$(I18Npo): $(I18Npot)
-	msgmerge -U --no-wrap --no-location --backup=none -q $@ $<
-
-i18n: $(I18Npot) $(I18Nmo)
-	@mkdir -p $(LOCALEDIR)
-	for i in $(I18Ndirs); do\
-	    mkdir -p $(LOCALEDIR)/$$i/LC_MESSAGES;\
-	    cp $(PODIR)/$$i.mo $(LOCALEDIR)/$$i/LC_MESSAGES/vdr-$(PLUGIN).mo;\
-	    done
-
-### Targets:
-
-libvdr-$(PLUGIN).so: $(OBJS)
-	$(CXX) $(CXXFLAGS) -shared $(OBJS) $(LIBS) -o $@
-ifndef RSSREADER_DEBUG
-	@$(STRIP) $@
-endif
-	@cp --remove-destination $@ $(LIBDIR)/$@.$(APIVERSION)
-
-dist: clean
-	@-rm -rf $(TMPDIR)/$(ARCHIVE)
-	@mkdir $(TMPDIR)/$(ARCHIVE)
-	@cp -a * $(TMPDIR)/$(ARCHIVE)
-	@tar czf $(PACKAGE).tgz -C $(TMPDIR) $(ARCHIVE)
-	@-rm -rf $(TMPDIR)/$(ARCHIVE)
-	@echo Distribution package created as $(PACKAGE).tgz
-
-clean:
-	@-rm -f $(PODIR)/*.mo $(PODIR)/*.pot
-	@-rm -f $(OBJS) $(DEPFILE) *.so *.tgz core* *~
diff -Naur rssreader-1.1.2-orig/.svn/text-base/menu.c.svn-base rssreader/.svn/text-base/menu.c.svn-base
--- rssreader-1.1.2-orig/.svn/text-base/menu.c.svn-base	2008-01-14 20:30:46.000000000 +0100
+++ rssreader/.svn/text-base/menu.c.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,202 +0,0 @@
-/*
- * menu.c: RSS Reader plugin for the Video Disk Recorder
- *
- * See the README file for copyright information and how to reach the author.
- *
- * $Id$
- */
- 
-#include <vdr/status.h>
-#include "parser.h"
-#include "config.h"
-#include "menu.h"
-#include "common.h"
-
-// --- Globals ----------------------------------------------------------
-
-cRssItems RssItems;
-
-// --- cRssItem(s) ------------------------------------------------------
-
-cRssItem::cRssItem(void)
-{ 
-  title = url = NULL;
-}
-
-cRssItem::~cRssItem()
-{
-  free(title);
-  free(url);
-}
-
-bool cRssItem::Parse(const char *s)
-{
-  const char *p = strchr(s, ':');
-  if (p) {
-     int l = p - s;
-     if (l > 0) {
-        title = MALLOC(char, l + 1);
-        stripspace(strn0cpy(title, s, l + 1));
-        if (!isempty(title)) {
-           url = stripspace(strdup(skipspace(p + 1)));
-           return true;
-           }
-        }
-     }
-  return false;
-}
-
-bool cRssItems::Load(const char *filename)
-{
-  if (cConfig<cRssItem>::Load(filename, true)) {
-     return true;
-     }
-  return false;
-}
-
-// --- cRssMenuItem --------------------------------------------------------
-
-cRssMenuItem::cRssMenuItem(const char *Date, const char *Title, const char *Link, const char *Description)
-:cOsdMenu(tr("RSS item"))
-{
-  asprintf(&text, "\n%s%s%s%s%s%s%s",
-           *Date         ? strdup(Date)          : RssConfig.hideelem ? "" : tr("<no date available>"),
-           (*Date        || !RssConfig.hideelem) ? "\n\n" : "",
-           *Title        ? strdup(Title)         : RssConfig.hideelem ? "" : tr("<no title available>"),
-           (*Title       || !RssConfig.hideelem) ? "\n\n" : "",
-           *Description  ? strdup(Description)   : RssConfig.hideelem ? "" : tr("<no description available>"),
-           (*Description || !RssConfig.hideelem) ? "\n\n" : "",
-           *Link         ? strdup(Link)          : RssConfig.hideelem ? "" : tr("<no link available>"));
-}
-
-cRssMenuItem::~cRssMenuItem()
-{
-  free(text);
-}
-
-void cRssMenuItem::Display(void)
-{
-  cOsdMenu::Display();
-  debug("cRssMenuItem::Display(): '%s'\n", text);
-  DisplayMenu()->SetText(text, false);
-  cStatus::MsgOsdTextItem(text);
-}
-
-eOSState cRssMenuItem::ProcessKey(eKeys Key)
-{
-  switch (Key) {
-    case kUp|k_Repeat:
-    case kUp:
-    case kDown|k_Repeat:
-    case kDown:
-    case kLeft|k_Repeat:
-    case kLeft:
-    case kRight|k_Repeat:
-    case kRight:
-         DisplayMenu()->Scroll(NORMALKEY(Key) == kUp || NORMALKEY(Key) == kLeft, NORMALKEY(Key) == kLeft || NORMALKEY(Key) == kRight);
-         cStatus::MsgOsdTextItem(NULL, NORMALKEY(Key) == kUp);
-         return osContinue;
-    default:
-         break;
-    }
-
-  eOSState state = cOsdMenu::ProcessKey(Key);
-
-  if (state == osUnknown) {
-     switch (Key) {
-       case kOk:
-            return osBack;
-       default:
-            state = osContinue;
-       }
-     state = osContinue;
-     }
-  return state;
-}
-
-// --- cRssItemsMenu --------------------------------------------------------
-
-cRssItemsMenu::cRssItemsMenu()
-:cOsdMenu(tr("Select RSS item"))
-{
-  for (cItem *rssItem = Parser.Items.First(); rssItem; rssItem = Parser.Items.Next(rssItem))
-     Add(new cOsdItem(rssItem->GetTitle()));
-  Display();
-}
-
-eOSState cRssItemsMenu::ProcessKey(eKeys Key)
-{
-  eOSState state = cOsdMenu::ProcessKey(Key);
-  if (state == osUnknown) {
-     switch (Key) {
-       case kOk:
-            return ShowDetails();
-       default:
-            break;
-       }
-     state = osContinue;
-     }
-  return state;
-}
-
-eOSState cRssItemsMenu::ShowDetails(void)
-{
-  cItem *rssItem = (cItem *)Parser.Items.Get(Current());
-  return AddSubMenu(new cRssMenuItem(rssItem->GetDate(), rssItem->GetTitle(), rssItem->GetLink(), rssItem->GetDescription()));
-}
-
-// --- cRssStreamsMenu -----------------------------------------------------
-
-cRssStreamsMenu::cRssStreamsMenu()
-:cOsdMenu(tr("Select RSS stream"))
-{
-  for (cRssItem *rssItem = RssItems.First(); rssItem; rssItem = RssItems.Next(rssItem)) {
-      cOsdItem *osdItem = new cOsdItem;
-      if (!*rssItem->Url())
-         osdItem->SetSelectable(false);
-      osdItem->SetText(rssItem->Title());
-      debug("StreamsMenu: '%s' : '%s'", rssItem->Title(), rssItem->Url());
-      Add(osdItem);
-    }
-  Display();
-}
-
-eOSState cRssStreamsMenu::Select(void)
-{
-  cRssItem *rssItem = (cRssItem *)RssItems.Get(Current());
-  if (rssItem) {
-     debug("cRssStreamsMenu::Select(): downloading and parsing '%s'", rssItem->Title());
-     // the following message generates an annoying slowdown 
-     //Skins.Message(mtInfo, tr("Loading RSS stream..."));
-     switch (Parser.DownloadAndParse(rssItem->Url())) {
-       case (cParser::RSS_PARSING_OK):
-            return AddSubMenu(new cRssItemsMenu);
-       case (cParser::RSS_PARSING_ERROR):
-            Skins.Message(mtError, tr("Can't parse RSS stream!"));
-            return osContinue;
-       case (cParser::RSS_DOWNLOAD_ERROR):
-            Skins.Message(mtError, tr("Can't download RSS stream!"));
-            return osContinue;
-       case (cParser::RSS_UNKNOWN_ERROR):
-       default:
-            Skins.Message(mtError, tr("Unknown error!"));
-            return osContinue;
-       }
-     }
-  return osEnd;
-}
-
-eOSState cRssStreamsMenu::ProcessKey(eKeys Key)
-{
-  eOSState state = cOsdMenu::ProcessKey(Key);
-  if (state == osUnknown) {
-     switch (Key) {
-       case kOk:
-            return Select();
-       default:
-            break;
-       }
-     state = osContinue;
-     }
-  return state;
-}
diff -Naur rssreader-1.1.2-orig/.svn/text-base/menu.h.svn-base rssreader/.svn/text-base/menu.h.svn-base
--- rssreader-1.1.2-orig/.svn/text-base/menu.h.svn-base	2008-01-14 20:30:46.000000000 +0100
+++ rssreader/.svn/text-base/menu.h.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,67 +0,0 @@
-/*
- * menu.h: RSS Reader plugin for the Video Disk Recorder
- *
- * See the README file for copyright information and how to reach the author.
- *
- * $Id$
- */
-
-#ifndef __RSSREADER_MENU_H
-#define __RSSREADER_MENU_H
-
-#include <vdr/osdbase.h>
-#include <vdr/tools.h>
-
-// --- cRssItem(s) ------------------------------------------------------
-
-class cRssItem : public cListObject {
-private:
-  char *title;
-  char *url;
-public:
-  cRssItem(void);
-  virtual ~cRssItem();
-  bool Parse(const char *s);
-  const char *Title(void) { return title; }
-  const char *Url(void) { return url; }
-};
-
-class cRssItems : public cConfig<cRssItem> {
-public:
-  virtual bool Load(const char *filename);
-};
-
-extern cRssItems RssItems;
-
-// --- cRssMenuItem --------------------------------------------------------
-
-class cRssMenuItem : public cOsdMenu {
-private:
-  char *text;
-public:
-  cRssMenuItem(const char *Date, const char *Title, const char *Link, const char *Description);
-  virtual ~cRssMenuItem();
-  virtual void Display(void);
-  virtual eOSState ProcessKey(eKeys Key);
-  };
-
-// --- cRssItemsMenu -------------------------------------------------------
-
-class cRssItemsMenu: public cOsdMenu {
-private:
-  eOSState ShowDetails(void);
-public:
-  cRssItemsMenu(void);
-  virtual eOSState ProcessKey(eKeys Key);
-};
-
-// --- cRssStreamsMenu -----------------------------------------------------
-
-class cRssStreamsMenu: public cOsdMenu {
-public:
-  cRssStreamsMenu();
-  virtual eOSState ProcessKey(eKeys Key);
-  virtual eOSState Select(void);
-};
-
-#endif // __RSSREADER_MENU_H
diff -Naur rssreader-1.1.2-orig/.svn/text-base/parser.c.svn-base rssreader/.svn/text-base/parser.c.svn-base
--- rssreader-1.1.2-orig/.svn/text-base/parser.c.svn-base	2008-01-14 20:30:46.000000000 +0100
+++ rssreader/.svn/text-base/parser.c.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,332 +0,0 @@
-/*
- * parser.c: RSS Reader plugin for the Video Disk Recorder
- *
- * See the README file for copyright information and how to reach the author.
- *
- * $Id$
- */
-
-#include <stack>
-#include <curl/curl.h>
-#include <curl/types.h>
-#include <curl/easy.h>
-#include <vdr/config.h>
-#include "common.h"
-#include "config.h"
-#include "tools.h"
-#include "parser.h"
-
-#include <expat.h>
-#define LIBEXPAT_VERSION(a,b,c) (((a) << 16) + ((b) << 8) + (c))
-#if LIBEXPAT_VERSION(XML_MAJOR_VERSION, XML_MINOR_VERSION, XML_MICRO_VERSION) < LIBEXPAT_VERSION(1, 95, 8)
-#warning "Expat XML parser library 1.95.8 or newer required!"
-#endif
-
-// --- Globals ----------------------------------------------------------
-
-cParser Parser;
-
-// --- cItem(s) ---------------------------------------------------------
-
-cItem::cItem()
-: conv("UTF-8", cCharSetConv::SystemCharacterTable())
-{
-  strcpy(date, "");
-  strcpy(title, "");
-  strcpy(link, "");
-  strcpy(description, "");
-}
-
-
-void cItem::Clear(void)
-{
-  strcpy(date, "");
-  strcpy(title, "");
-  strcpy(link, "");
-  strcpy(description, "");
-}
-
-void cItem::SetDate(const char *str)
-{
-  Utf8Strn0Cpy(date, str, sizeof(date));
-  compactspace(date);
-  Utf8Strn0Cpy(date, conv.Convert(date), sizeof(date));
-}
-
-void cItem::SetTitle(const char *str)
-{
-  Utf8Strn0Cpy(title, str, sizeof(title));
-  compactspace(title);
-  striphtml(title);
-  Utf8Strn0Cpy(title, conv.Convert(title), sizeof(title));
-}
-
-void cItem::SetLink(const char *str)
-{
-  Utf8Strn0Cpy(link, str, sizeof(link));
-  compactspace(link);
-  Utf8Strn0Cpy(link, conv.Convert(link), sizeof(link));
-}
-
-void cItem::SetDescription(const char *str)
-{
-  Utf8Strn0Cpy(description, str, sizeof(description));
-  compactspace(description);
-  striphtml(description);
-  Utf8Strn0Cpy(description, conv.Convert(description), sizeof(description));
-}
-
-// --- Parse RSS  -------------------------------------------------------
-
-struct XmlNode {
-  char nodename[SHORT_TEXT_LEN];
-  int  depth;
-};
-
-cItem *item = NULL;
-int depth = 0;
-char data_string[LONG_TEXT_LEN];
-std::stack<struct XmlNode> nodestack;
-
-static int XMLCALL UnknownEncodingHandler(void *data,const XML_Char *encoding, XML_Encoding *info)
-{
-  if (strcmp(encoding, "iso-8859-15") == 0) {
-     int i;
-     for (i = 0; i < 256; ++i)
-        info->map[i] = i;
-     info->data = NULL;
-     info->convert = NULL;
-     info->release = NULL;
-     return XML_STATUS_OK;
-     }
-  return XML_STATUS_ERROR;
-}
-
-static void XMLCALL StartHandler(void *data, const char *el, const char **attr)
-{
-  XmlNode node;
-
-  strn0cpy(node.nodename, el, sizeof(node.nodename));
-  node.depth = depth;
-  nodestack.push(node);
-
-  if (!strncmp(el, "item", 4)) {
-     cItem *tmpitem = new cItem;
-     item = tmpitem;
-     item->Clear();
-     }
-  depth++;
-}
-
-static void XMLCALL EndHandler(void *data, const char *el)
-{
-  char parent[SHORT_TEXT_LEN];
-  
-  if (nodestack.size() > 1) {
-     nodestack.pop();
-     } 
-  else {
-     nodestack.pop();
-     return;
-     }
-  strn0cpy(parent, (nodestack.top()).nodename, sizeof((nodestack.top()).nodename));
-  // No need to free the node
-  
-  depth--;
-  if (!strncmp(el, "item", 4)) {
-     // End of the current item
-     if (*item->GetTitle())
-        Parser.Items.Add(item);
-     }
-  else if (!strncmp(el, "title", 5)) {
-     if (!strncmp(parent, "item", 4)) {
-        item->SetTitle(data_string);
-        }
-     else if (!strncmp(parent, "channel", 7)) {
-        debug("cParser::EndHandler(): RSS title '%s'", data_string);
-        }
-     }
-  else if (!strncmp(el, "link", 4)) {
-     if (!strncmp(parent, "item", 4)) {
-        item->SetLink(data_string);
-        }
-     else if (!strncmp(parent, "channel", 7)) {
-        debug("cParser::EndHandler(): RSS link '%s'", data_string);
-        }
-     }
-  else if (!strncmp(el, "pubDate", 7)) {
-     if (!strncmp(parent, "item", 4)) {
-        item->SetDate(data_string);
-        }
-     else if (!strncmp(parent, "channel", 7)) {
-        debug("cParser::EndHandler(): RSS date '%s'", data_string);
-        }
-     }
-  else if (!strncmp(el, "description", 11)) {
-     if (!strncmp(parent, "item", 4)) {
-        item->SetDescription(data_string);
-        }
-     else if (!strncmp(parent, "channel", 7)) {
-        debug("cParser::EndHandler(): RSS description '%s'", data_string);
-        }
-     }
-  else if (!strncmp(el, "content:encoded", 15)) {
-     if (!strncmp(parent, "item", 4)) {
-        item->SetDescription(data_string); // overdrive description with content:encoded !
-        }
-     else if (!strncmp(parent, "channel", 7)) {
-        debug("cParser::EndHandler(): RSS content '%s'", data_string);
-        }
-     }
-  strcpy(data_string, "");
-}
-
-static void DataHandler(void *user_data, const XML_Char *s, int len)
-{
-  /* Only until the maximum size of the buffer */
-  if (strlen(data_string) + len <= LONG_TEXT_LEN)
-     strncat(data_string, s, len);
-}
-
-static size_t WriteMemoryCallback(void *ptr, size_t size, size_t nmemb, void *data)
-{
-  size_t realsize = size * nmemb;
-  struct MemoryStruct *mem = (struct MemoryStruct *)data;
-
-  mem->memory = (char *)myrealloc(mem->memory, mem->size + realsize + 1);
-  if (mem->memory) {
-     memcpy(&(mem->memory[mem->size]), ptr, realsize);
-     mem->size += realsize;
-     mem->memory[mem->size] = 0;
-     }
-  return realsize;
-}
-
-cParser::cParser()
-{
-  data.memory = NULL;
-  data.size = 0;
-}
-
-cParser::~cParser()
-{
-  if (data.memory) {
-     free(data.memory);
-     data.memory = NULL;
-     data.size = 0;
-     }
-}
-
-int cParser::DownloadAndParse(const char *url)
-{
-  CURL *curl_handle;
-
-  // Clear Items list and initialize depth
-  Items.Clear();
-  depth = 0;
-  if (data.memory)
-     free(data.memory);
-  data.memory = NULL;
-  data.size = 0;
-
-  // Init the curl session
-  curl_global_init(CURL_GLOBAL_ALL);
-  curl_handle = curl_easy_init();
-
-  // Specify URL to get
-  curl_easy_setopt(curl_handle, CURLOPT_URL, url);
-
-  // Specify HTTP proxy: my.proxy.com:80
-  if (RssConfig.useproxy) {
-     curl_easy_setopt(curl_handle, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);
-     curl_easy_setopt(curl_handle, CURLOPT_PROXY, RssConfig.httpproxy);
-     }
-
-  // Send all data to this function
-  curl_easy_setopt(curl_handle, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);
-
-  // Set maximum file size to get (bytes)
-  curl_easy_setopt(curl_handle, CURLOPT_MAXFILESIZE, 1048576);
-
-  // No progress meter
-  curl_easy_setopt(curl_handle, CURLOPT_NOPROGRESS, 1);
-
-  // No signaling
-  curl_easy_setopt(curl_handle, CURLOPT_NOSIGNAL, 1);
-
-  // Set timeout to 30 seconds
-  curl_easy_setopt(curl_handle, CURLOPT_TIMEOUT, 30);
-
-  // Pass our 'data' struct to the callback function
-  curl_easy_setopt(curl_handle, CURLOPT_WRITEDATA, (void *)&data);
-
-  // Some servers don't like requests that are made without a user-agent field
-  curl_easy_setopt(curl_handle, CURLOPT_USERAGENT, RSSREADER_USERAGENT);
-
-  // Get it!
-  if (curl_easy_perform(curl_handle) != 0) {
-     // Cleanup curl stuff
-     curl_easy_cleanup(curl_handle);
-     // Free allocated memory
-     if (data.memory) {
-        free(data.memory);
-        data.memory = NULL;
-        data.size = 0;
-        }
-     error("cParser::DownloadAndParse(): couldn't download the stream");
-     return (RSS_DOWNLOAD_ERROR);
-     }
-
-  if (data.size) {
-#ifdef DEBUG
-     // Only for debug dump
-     FILE *fp = fopen("/tmp/rssreader.vdr", "w");
-     if (fp) {
-        fwrite(data.memory, 1, data.size, fp);
-        fclose(fp);
-        }
-#endif
-     // Setup expat
-     XML_Parser p = XML_ParserCreate(NULL);
-     if (!p) {
-        // Cleanup curl stuff
-        curl_easy_cleanup(curl_handle);
-        // Free allocated memory
-        if (data.memory) {
-           free(data.memory);
-           data.memory = NULL;
-           data.size = 0;
-           }
-        error("cParser::DownloadAndParse(): couldn't allocate memory for parser");
-        return (RSS_UNKNOWN_ERROR);
-        }
-     XML_SetElementHandler(p, StartHandler, EndHandler);
-     XML_SetCharacterDataHandler(p, DataHandler);
-     XML_SetUnknownEncodingHandler(p, UnknownEncodingHandler, NULL);
-
-     if (XML_Parse(p, data.memory, data.size, 1) == XML_STATUS_ERROR) {
-        // Cleanup curl stuff
-        curl_easy_cleanup(curl_handle);
-        // Free allocated memory
-        if (data.memory) {
-           free(data.memory);
-           data.memory = NULL;
-           data.size = 0;
-           }
-        error("cParser::DownloadAndParse(): Parse error at line %ld:\n%s\n", XML_GetCurrentLineNumber(p), XML_ErrorString(XML_GetErrorCode(p)));
-        return (RSS_PARSING_ERROR);
-        }
-     }
-
-  // Cleanup curl stuff
-  curl_easy_cleanup(curl_handle);
-  // Free allocated memory
-  if (data.memory) {
-     free(data.memory);
-     data.memory = NULL;
-     data.size = 0;
-     }
-
-  return (RSS_PARSING_OK);
-}
-
diff -Naur rssreader-1.1.2-orig/.svn/text-base/parser.h.svn-base rssreader/.svn/text-base/parser.h.svn-base
--- rssreader-1.1.2-orig/.svn/text-base/parser.h.svn-base	2008-01-14 20:30:46.000000000 +0100
+++ rssreader/.svn/text-base/parser.h.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,71 +0,0 @@
-/*
- * parser.h: RSS Reader plugin for the Video Disk Recorder
- *
- * See the README file for copyright information and how to reach the author.
- *
- * $Id$
- */
-
-#ifndef __RSSREADER_PARSER_H
-#define __RSSREADER_PARSER_H
-
-#include "common.h"
-
-// --- Defines ----------------------------------------------------------
-
-#define SHORT_TEXT_LEN 2048
-#define LONG_TEXT_LEN  16384
-
-// --- cItem(s) ---------------------------------------------------------
-
-class cItem : public cListObject {
-private:
-  cCharSetConv conv;
-  char date[SHORT_TEXT_LEN];
-  char title[SHORT_TEXT_LEN];
-  char link[SHORT_TEXT_LEN];
-  char description[LONG_TEXT_LEN];
-public:
-  cItem();
-  void Clear(void);
-  char *GetDate(void) { return date; }
-  char *GetTitle(void) { return title; }
-  char *GetLink(void) { return link; }
-  char *GetDescription(void)  { return description; }
-  void SetDate(const char *str);
-  void SetTitle(const char *str);
-  void SetLink(const char *str);
-  void SetDescription(const char *str);
-};
-
-class cItems : public cList<cItem> {
-private:
-  cItem *current;
-};
-
-// --- cParser ----------------------------------------------------------
-
-struct MemoryStruct {
-  char   *memory;
-  size_t size;
-};
-
-class cParser {
-private:
-  struct MemoryStruct data;
-public:
-  enum {
-    RSS_PARSING_OK     =  0,
-    RSS_UNKNOWN_ERROR  = -1,
-    RSS_DOWNLOAD_ERROR = -2,
-    RSS_PARSING_ERROR  = -3
-  } eRssError;
-  cParser();
-  ~cParser();
-  int DownloadAndParse(const char *url);
-  cItems Items;
-  };
-
-extern cParser Parser;
-
-#endif // __RSSREADER_PARSER_H
diff -Naur rssreader-1.1.2-orig/.svn/text-base/README.svn-base rssreader/.svn/text-base/README.svn-base
--- rssreader-1.1.2-orig/.svn/text-base/README.svn-base	2008-01-14 20:30:46.000000000 +0100
+++ rssreader/.svn/text-base/README.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,48 +0,0 @@
-This is an RSS Reader for the Video Disk Recorder (VDR).
-
-Written by:                  Rolf Ahrenberg
-                             < R o l f . A h r e n b e r g @ s c i .f i >
-
-Project's homepage:          http://www.saunalahti.fi/~rahrenbe/vdr/rssreader/
-
-Latest version available at:  http://www.saunalahti.fi/~rahrenbe/vdr/rssreader/
-
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 2 of the License, or
-(at your option) any later version.
-See the file COPYING for license information.
-
-Requirements:
-
-- Expat XML Parser library version 1.95.8 or newer (http://expat.sourceforge.net/)
-- CURL library 7.15.1 or newer (http://curl.haxx.se/)
-
-Description:
-
-The RSS Reader plugin provides a simple OSD menu based user interface
-for reading user-defined RSS streams.
-
-The current code is heavily reusing the VOD plugin by Olivier Jacques.
-Huge thanks to the original author!
-
-Installation:
-
-cd /put/your/path/here/VDR/PLUGINS/src
-tar -xzf /put/your/path/here/vdr-rssreader-X.Y.Z.tgz
-ln -s rssreader-X.Y.Z rssreader
-cp rssreader/example/rssreader.conf /path/to/vdrconf/plugins/
-cd /put/your/path/here/VDR
-make
-make plugins
-./vdr -P rssreader
-
-Configuration:
-
-RSS streams are defined in rssreader.conf located in VDR's configuration
-directory for plugins. Check the configuration file under "example"
-subdirectory for further information.
-
-Notes:
-
-- No news is good news.
diff -Naur rssreader-1.1.2-orig/.svn/text-base/rssreader.c.svn-base rssreader/.svn/text-base/rssreader.c.svn-base
--- rssreader-1.1.2-orig/.svn/text-base/rssreader.c.svn-base	2008-01-14 20:30:46.000000000 +0100
+++ rssreader/.svn/text-base/rssreader.c.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,191 +0,0 @@
-/*
- * rssreader.c: A plugin for the Video Disk Recorder
- *
- * $Id$
- */
-
-#include <getopt.h>
-#include <vdr/config.h>
-#include <vdr/plugin.h>
-
-#include "menu.h"
-#include "config.h"
-#include "common.h"
-
-#if defined(APIVERSNUM) && APIVERSNUM < 10508
-#error "VDR-1.5.8 API version or greater is required!"
-#endif
-
-static const char VERSION[]       = "1.1.2";
-static const char DESCRIPTION[]   = trNOOP("RSS Reader for OSD");
-static const char MAINMENUENTRY[] = trNOOP("RSS Reader");
-
-class cPluginRssReader : public cPlugin {
-private:
-  // Add any member variables or functions you may need here.
-public:
-  cPluginRssReader(void);
-  virtual ~cPluginRssReader();
-  virtual const char *Version(void) { return VERSION; }
-  virtual const char *Description(void) { return tr(DESCRIPTION); }
-  virtual const char *CommandLineHelp(void);
-  virtual bool ProcessArgs(int argc, char *argv[]);
-  virtual bool Initialize(void);
-  virtual bool Start(void);
-  virtual void Stop(void);
-  virtual void Housekeeping(void);
-  virtual void MainThreadHook(void) {}
-  virtual cString Active(void) { return NULL; }
-  virtual const char *MainMenuEntry(void) { return (RssConfig.hidemenu ? NULL : tr(MAINMENUENTRY)); }
-  virtual cOsdObject *MainMenuAction(void);
-  virtual cMenuSetupPage *SetupMenu(void);
-  virtual bool SetupParse(const char *Name, const char *Value);
-  virtual bool Service(const char *Id, void *Data = NULL);
-  virtual const char **SVDRPHelpPages(void);
-  virtual cString SVDRPCommand(const char *Command, const char *Option, int &ReplyCode);
-  };
-
-class cPluginRssReaderSetup : public cMenuSetupPage
-{
-private:
-  cRssReaderConfig data;
-  virtual void Setup(void);
-protected:
-  virtual eOSState ProcessKey(eKeys Key);
-  virtual void Store(void);
-public:
-  cPluginRssReaderSetup(void);
-};
-
-cPluginRssReader::cPluginRssReader(void)
-{
-  // Initialize any member variables here.
-  // DON'T DO ANYTHING ELSE THAT MAY HAVE SIDE EFFECTS, REQUIRE GLOBAL
-  // VDR OBJECTS TO EXIST OR PRODUCE ANY OUTPUT!
-}
-
-cPluginRssReader::~cPluginRssReader()
-{
-  // Clean up after yourself!
-}
-
-const char *cPluginRssReader::CommandLineHelp(void)
-{
-  // Return a string that describes all known command line options.
-  return NULL;
-}
-
-bool cPluginRssReader::ProcessArgs(int argc, char *argv[])
-{
-  // Implement command line argument processing here if applicable.
-  return true;
-}
-
-bool cPluginRssReader::Initialize(void)
-{
-  // Initialize any background activities the plugin shall perform.
-  return true;
-}
-
-bool cPluginRssReader::Start(void)
-{
-  // Start any background activities the plugin shall perform.
-  if (!RssItems.Load(AddDirectory(ConfigDirectory(), "rssreader.conf")))
-     error("configuration file 'rssreader.conf' not found!");
-  return true;
-}
-
-void cPluginRssReader::Stop(void)
-{
-  // Stop any background activities the plugin shall perform.
-}
-
-void cPluginRssReader::Housekeeping(void)
-{
-  // Perform any cleanup or other regular tasks.
-}
-
-cOsdObject *cPluginRssReader::MainMenuAction(void)
-{
-  // Perform the action when selected from the main VDR menu.
-  return new cRssStreamsMenu();
-}
-
-cMenuSetupPage *cPluginRssReader::SetupMenu(void)
-{
-  // Return a setup menu in case the plugin supports one.
-  return new cPluginRssReaderSetup();
-}
-
-bool cPluginRssReader::SetupParse(const char *Name, const char *Value)
-{
-  // Parse your own setup parameters and store their values.
-  if      (!strcasecmp(Name, "HideMenu"))  RssConfig.hidemenu = atoi(Value);
-  else if (!strcasecmp(Name, "HideElem"))  RssConfig.hideelem = atoi(Value);
-  else if (!strcasecmp(Name, "UseProxy"))  RssConfig.useproxy = atoi(Value);
-  else if (!strcasecmp(Name, "HttpProxy")) strn0cpy(RssConfig.httpproxy, Value, sizeof(RssConfig.httpproxy));
-  else return false;
-
-  return true;
-}
-
-bool cPluginRssReader::Service(const char *Id, void *Data)
-{
-  // Handle custom service requests from other plugins
-  return false;
-}
-
-const char **cPluginRssReader::SVDRPHelpPages(void)
-{
-  // Return help text for SVDRP commands this plugin implements
-  return NULL;
-}
-
-cString cPluginRssReader::SVDRPCommand(const char *Command, const char *Option, int &ReplyCode)
-{
-  // Process SVDRP commands this plugin implements
-  return NULL;
-}
-
-cPluginRssReaderSetup::cPluginRssReaderSetup(void)
-{
-  data = RssConfig;
-  Setup();
-}
-
-void cPluginRssReaderSetup::Setup(void)
-{
-  int current = Current();
-
-  Clear();
-
-  Add(new cMenuEditBoolItem(tr("Hide main menu entry"),       &data.hidemenu));
-  Add(new cMenuEditBoolItem(tr("Hide non-existent elements"), &data.hideelem));
-  Add(new cMenuEditBoolItem(tr("Use HTTP proxy server"),      &data.useproxy));
-  if (data.useproxy)
-     Add(new cMenuEditStrItem( tr("HTTP proxy server"),       data.httpproxy, sizeof(data.httpproxy), tr(FileNameChars)));
-
-  SetCurrent(Get(current));
-  Display();
-}
-
-eOSState cPluginRssReaderSetup::ProcessKey(eKeys Key)
-{
-  int olduseproxy = data.useproxy;
-  eOSState state = cMenuSetupPage::ProcessKey(Key);
-  if (Key != kNone && (data.useproxy != olduseproxy)) {
-     Setup();
-     }
-  return state;
-}
-
-void cPluginRssReaderSetup::Store(void)
-{
-  RssConfig = data;
-  SetupStore("HideMenu",  RssConfig.hidemenu);
-  SetupStore("HideElem",  RssConfig.hideelem);
-  SetupStore("UseProxy",  RssConfig.useproxy);
-  SetupStore("HttpProxy", RssConfig.httpproxy);
-}
-
-VDRPLUGINCREATOR(cPluginRssReader); // Don't touch this!
diff -Naur rssreader-1.1.2-orig/.svn/text-base/tools.c.svn-base rssreader/.svn/text-base/tools.c.svn-base
--- rssreader-1.1.2-orig/.svn/text-base/tools.c.svn-base	2008-01-14 20:30:46.000000000 +0100
+++ rssreader/.svn/text-base/tools.c.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,138 +0,0 @@
-/*
- * tools.c: RSS Reader plugin for the Video Disk Recorder
- *
- * See the README file for copyright information and how to reach the author.
- *
- * $Id$
- */
-
-#include "tools.h"
-#include "common.h"
-
-// --- Static -----------------------------------------------------------
-
-#define ELEMENTS(x) (sizeof(x) / sizeof(x[0]))
-
-struct conv_table {
-  char *from;
-  char *to;
-};
-
-static struct conv_table pre_conv_table[] =
-{
-  // 'to' field must be smaller than 'from'
-  {"<br />",   "\n"}
-};
-
-static struct conv_table post_conv_table[] =
-{
-  // 'to' field must be smaller than 'from'
-  {"&#228;",   "\xc3\xa4"},
-  {"&auml;",   "\xc3\xa4"},
-  {"&#196;",   "\xc3\x84"},
-  {"&Auml;",   "\xc3\x84"},
-  {"&#246;",   "\xc3\xb6"},
-  {"&ouml;",   "\xc3\xb6"},
-  {"&#214;",   "\xc3\x96"},
-  {"&Ouml;",   "\xc3\x96"},
-  {"&#229;",   "\xc3\xa5"},
-  {"&#197;",   "\xc3\x85"},
-  {"&#220;",   "\xc3\x9c"},
-  {"&Uuml;",   "\xc3\x9c"},
-  {"&#252;",   "\xc3\xbc"},
-  {"&uuml;",   "\xc3\xbc"},
-  {"&#223;",   "\xc3\x9f"},
-  {"&szlig;",  "\xc3\x9f"},
-  {"&#234;",   "\xc3\xaa"},
-  {"&#176;",   "\xc2\xb0"},
-  {"&#8211;",  "-"},
-  {"&ndash;",  "-"},
-  {"&#38;",    "&"},
-  {"&amp;",    "&"},
-  {"&#58;",    ":"},
-  {"&#91;",    "["},
-  {"&#93;",    "]"},
-  {"&#40;",    "'"},
-  {"&#41;",    "'"},
-  {"&#039;",   "'"},
-  {"&#180;",   "'"},
-  {"&acute;",  "'"},
-  {"&#8216;",  "'"},
-  {"&#8217;",  "'"},
-  {"&#231;",   "\xc3\xa7"},
-  {"&ccedil;", "\xc3\xa7"},
-  {"&#233;",   "\xc3\xa9"},
-  {"&eacute;", "\xc3\xa9"},
-  {"&#226;",   "\xc3\xa2"},
-  {"&acirc;",  "\xc3\xa2"},
-  {"&#8364;",  "\xe2\x82\xac"},
-  {"&euro;",   "\xe2\x82\xac"},
-  {"&quot;",   "\""},
-  {"&#8220;",  "\""},
-  {"&#8221;",  "\""},
-  {"&#8222;",  "\""},
-  {"&#160;",   " "},
-  {"&nbsp;",   " "},
-  {"&lt;",     "<"},
-  {"&gt;",     ">"},
-  {"\n\n",     "\n"}, // let's also strip multiple linefeeds
-};
-
-static char *htmlcharconv(char *str, struct conv_table *conv, unsigned int elem)
-{
-  if (str && conv) {
-     for (unsigned int i = 0; i < elem; ++i) {
-        char *ptr = strstr(str, conv[i].from);
-        while (ptr) {
-           int of = ptr - str;
-           int l  = strlen(str);
-           int l1 = strlen(conv[i].from);
-           int l2 = strlen(conv[i].to);
-           if (l2 > l1) {
-              error("htmlcharconv(): cannot reallocate string");
-              return str;
-              }
-           if (l2 != l1)
-              memmove(str + of + l2, str + of + l1, l - of - l1 + 1);
-           strncpy(str + of, conv[i].to, l2);
-           ptr = strstr(str, conv[i].from);
-           }
-        }
-     return str;
-     }
-  return NULL;
-}
-
-// --- General functions ------------------------------------------------
-
-char *striphtml(char *str)
-{
-  if (str) {
-     char *c, t = 0, *r;
-     str = htmlcharconv(str, pre_conv_table, ELEMENTS(pre_conv_table));
-     c = str;
-     r = str;
-     while (*str != '\0') {
-       if (*str == '<')
-          t++;
-       else if (*str == '>')
-          t--;
-       else if (t < 1)
-          *(c++) = *str;
-       str++;
-       }
-     *c = '\0';
-     return htmlcharconv(r, post_conv_table, ELEMENTS(post_conv_table));
-     }
-  return NULL;
-}
-
-void *myrealloc(void *ptr, size_t size)
-{
-  /* There might be a realloc() out there that doesn't like reallocing
-     NULL pointers, so we take care of it here */
-  if (ptr)
-     return realloc(ptr, size);
-  else
-     return malloc(size);
-}
diff -Naur rssreader-1.1.2-orig/.svn/text-base/tools.h.svn-base rssreader/.svn/text-base/tools.h.svn-base
--- rssreader-1.1.2-orig/.svn/text-base/tools.h.svn-base	2008-01-14 20:30:46.000000000 +0100
+++ rssreader/.svn/text-base/tools.h.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,18 +0,0 @@
-/*
- * tools.h: RSS Reader plugin for the Video Disk Recorder
- *
- * See the README file for copyright information and how to reach the author.
- *
- * $Id$
- */
-
-#ifndef __RSSREADER_TOOLS_H
-#define __RSSREADER_TOOLS_H
-
-#include <vdr/tools.h>
-
-char *striphtml(char *str);
-void *myrealloc(void *ptr, size_t size);
-
-#endif // __RSSREADER_TOOLS_H
-
diff -Naur rssreader-1.1.2-orig/tools.c rssreader/tools.c
--- rssreader-1.1.2-orig/tools.c	2008-01-14 20:30:47.000000000 +0100
+++ rssreader/tools.c	2008-01-14 18:55:01.000000000 +0100
@@ -6,8 +6,11 @@
  * $Id$
  */
 
+#include "compatibility.h"
+
 #include "tools.h"
 #include "common.h"
+#include <stdlib.h>
 
 // --- Static -----------------------------------------------------------
 
@@ -18,6 +21,7 @@
   char *to;
 };
 
+
 static struct conv_table pre_conv_table[] =
 {
   // 'to' field must be smaller than 'from'
@@ -27,74 +31,92 @@
 static struct conv_table post_conv_table[] =
 {
   // 'to' field must be smaller than 'from'
-  {"&#228;",   "\xc3\xa4"},
-  {"&auml;",   "\xc3\xa4"},
-  {"&#196;",   "\xc3\x84"},
-  {"&Auml;",   "\xc3\x84"},
-  {"&#246;",   "\xc3\xb6"},
-  {"&ouml;",   "\xc3\xb6"},
-  {"&#214;",   "\xc3\x96"},
-  {"&Ouml;",   "\xc3\x96"},
-  {"&#229;",   "\xc3\xa5"},
-  {"&#197;",   "\xc3\x85"},
-  {"&#220;",   "\xc3\x9c"},
-  {"&Uuml;",   "\xc3\x9c"},
-  {"&#252;",   "\xc3\xbc"},
-  {"&uuml;",   "\xc3\xbc"},
-  {"&#223;",   "\xc3\x9f"},
-  {"&szlig;",  "\xc3\x9f"},
-  {"&#234;",   "\xc3\xaa"},
-  {"&#176;",   "\xc2\xb0"},
-  {"&#8211;",  "-"},
-  {"&ndash;",  "-"},
-  {"&#38;",    "&"},
-  {"&amp;",    "&"},
-  {"&#58;",    ":"},
-  {"&#91;",    "["},
-  {"&#93;",    "]"},
-  {"&#40;",    "'"},
-  {"&#41;",    "'"},
-  {"&#039;",   "'"},
-  {"&#180;",   "'"},
-  {"&acute;",  "'"},
-  {"&#8216;",  "'"},
-  {"&#8217;",  "'"},
-  {"&#231;",   "\xc3\xa7"},
-  {"&ccedil;", "\xc3\xa7"},
-  {"&#233;",   "\xc3\xa9"},
-  {"&eacute;", "\xc3\xa9"},
-  {"&#226;",   "\xc3\xa2"},
-  {"&acirc;",  "\xc3\xa2"},
-  {"&#8364;",  "\xe2\x82\xac"},
-  {"&euro;",   "\xe2\x82\xac"},
-  {"&quot;",   "\""},
-  {"&#8220;",  "\""},
-  {"&#8221;",  "\""},
-  {"&#8222;",  "\""},
-  {"&#160;",   " "},
-  {"&nbsp;",   " "},
-  {"&lt;",     "<"},
-  {"&gt;",     ">"},
-  {"\n\n",     "\n"}, // let's also strip multiple linefeeds
+  {"&#228;",   "\xc3\xa4"},
+  {"&auml;",   "\xc3\xa4"},
+  {"&#196;",   "\xc3\x84"},
+  {"&Auml;",   "\xc3\x84"},
+  {"&#246;",   "\xc3\xb6"},
+  {"&ouml;",   "\xc3\xb6"},
+  {"&#214;",   "\xc3\x96"},
+  {"&Ouml;",   "\xc3\x96"},
+  {"&#229;",   "\xc3\xa5"},
+  {"&#197;",   "\xc3\x85"},
+  {"&#220;",   "\xc3\x9c"},
+  {"&Uuml;",   "\xc3\x9c"},
+  {"&#252;",   "\xc3\xbc"},
+  {"&uuml;",   "\xc3\xbc"},
+  {"&#223;",   "\xc3\x9f"},
+  {"&szlig;",  "\xc3\x9f"},
+  {"&#234;",   "\xc3\xaa"},
+  {"&#176;",   "\xc2\xb0"},
+  {"&#8211;",  "-"},
+  {"&ndash;",  "-"},
+  {"&#38;",    "&"},
+  {"&amp;",    "&"},
+  {"&#58;",    ":"},
+  {"&#91;",    "["},
+  {"&#93;",    "]"},
+  {"&#40;",    "'"},
+  {"&#41;",    "'"},
+  {"&#039;",   "'"},
+  {"&#180;",   "'"},
+  {"&acute;",  "'"},
+  {"&#8216;",  "'"},
+  {"&#8217;",  "'"},
+  {"&#231;",   "\xc3\xa7"},
+  {"&ccedil;", "\xc3\xa7"},
+  {"&#233;",   "\xc3\xa9"},
+  {"&eacute;", "\xc3\xa9"},
+  {"&#226;",   "\xc3\xa2"},
+  {"&acirc;",  "\xc3\xa2"},
+  {"&#8364;",  "\xe2\x82\xac"},
+  {"&euro;",   "\xe2\x82\xac"},
+  {"&quot;",   "\""},
+  {"&#8220;",  "\""},
+  {"&#8221;",  "\""},
+  {"&#8222;",  "\""},
+  {"&#160;",   " "},
+  {"&nbsp;",   " "},
+  {"&lt;",     "<"},
+  {"&gt;",     ">"},
+  {"\n\n",     "\n"}, // let's also strip multiple linefeeds
+  {"&#225;","\xc3\xa1"},
+  {"&aacute;","\xc3\xa1"},
+  {"&#233;","\xc3\xa9"},
+  {"&#243;","\xc3\xb3"},
+  {"&#237;","\xc3\xad"},
+  {"&#250;","\xc3\xba"},
+  {"&#193;","\xc3\x81"},
+  {"&#201;","\xc3\x89"},
+  {"&#205;","\xc3\x8d"},
+  {"&#211;","\xc3\x93"},
+  {"&#218;","\xc3\x9a"},
+  {"&#241;","\xc3\xb1"},
+  {"&#209;","\xc3\x91"},  
+  {"&#171;","\xc2\xab"},
+  {"&#191;","\xc2\xbf"},  
+  {"&#187;","\xc2\xbb"},  
+   
 };
 
-static char *htmlcharconv(char *str, struct conv_table *conv, unsigned int elem)
+static char *htmlcharconv(char *str, struct conv_table *conv, unsigned int elem, cCharSetConv *convert)
 {
   if (str && conv) {
      for (unsigned int i = 0; i < elem; ++i) {
+        const char *to=convert->Convert(conv[i].to);
         char *ptr = strstr(str, conv[i].from);
         while (ptr) {
            int of = ptr - str;
            int l  = strlen(str);
            int l1 = strlen(conv[i].from);
-           int l2 = strlen(conv[i].to);
+           int l2 = strlen(to);
            if (l2 > l1) {
               error("htmlcharconv(): cannot reallocate string");
               return str;
               }
            if (l2 != l1)
               memmove(str + of + l2, str + of + l1, l - of - l1 + 1);
-           strncpy(str + of, conv[i].to, l2);
+           strncpy(str + of, to, l2);
            ptr = strstr(str, conv[i].from);
            }
         }
@@ -105,11 +127,12 @@
 
 // --- General functions ------------------------------------------------
 
-char *striphtml(char *str)
+char *striphtml(char *str,char *encoding)
 {
   if (str) {
      char *c, t = 0, *r;
-     str = htmlcharconv(str, pre_conv_table, ELEMENTS(pre_conv_table));
+     cCharSetConv conv ("UTF-8",encoding);
+     str = htmlcharconv(str, pre_conv_table, ELEMENTS(pre_conv_table),&conv);
      c = str;
      r = str;
      while (*str != '\0') {
@@ -122,7 +145,7 @@
        str++;
        }
      *c = '\0';
-     return htmlcharconv(r, post_conv_table, ELEMENTS(post_conv_table));
+     return htmlcharconv(r, post_conv_table, ELEMENTS(post_conv_table),&conv);
      }
   return NULL;
 }
diff -Naur rssreader-1.1.2-orig/tools.h rssreader/tools.h
--- rssreader-1.1.2-orig/tools.h	2008-01-14 20:30:47.000000000 +0100
+++ rssreader/tools.h	2008-01-14 18:24:52.000000000 +0100
@@ -11,7 +11,7 @@
 
 #include <vdr/tools.h>
 
-char *striphtml(char *str);
+char *striphtml(char *str,char *encoding);
 void *myrealloc(void *ptr, size_t size);
 
 #endif // __RSSREADER_TOOLS_H
