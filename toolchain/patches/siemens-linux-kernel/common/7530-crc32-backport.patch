CRC32 backport with shared and optimised functions from 2.6.31.5 kernel.
The CRC routines are used extensively in JFFS2 and its performance is
increased greatly.
---

diff -Naur slin_m740_orig/Documentation/Configure.help slin_m740/Documentation/Configure.help
--- slin_m740_orig/Documentation/Configure.help	2004-05-29 15:44:12.000000000 +0200
+++ slin_m740/Documentation/Configure.help	2009-11-10 12:37:45.000000000 +0100
@@ -26885,6 +26885,13 @@
 CONFIG_IPMI_WATCHDOG
   This enables the IPMI watchdog timer.
 
+CRC32 functions
+CONFIG_CRC32
+  This option is provided for the case where no in-kernel-tree
+  modules require CRC32 functions, but a module built outside the
+  kernel tree does. Such modules that use library CRC32 functions
+  require that you say M or Y here.
+
 #
 # A couple of things I keep forgetting:
 #   capitalize: AppleTalk, Ethernet, DOS, DMA, FAT, FTP, Internet,
diff -Naur slin_m740_orig/drivers/net/Makefile.lib slin_m740/drivers/net/Makefile.lib
--- slin_m740_orig/drivers/net/Makefile.lib	1970-01-01 01:00:00.000000000 +0100
+++ slin_m740/drivers/net/Makefile.lib	2009-11-10 18:10:16.277935508 +0100
@@ -0,0 +1,74 @@
+# These drivers all require crc32.o and bitrev.o
+obj-$(CONFIG_8139CP)		+= crc32.o bitrev.o
+obj-$(CONFIG_8139TOO)		+= crc32.o bitrev.o
+obj-$(CONFIG_A2065)		+= crc32.o bitrev.o
+obj-$(CONFIG_ADAPTEC_STARFIRE)	+= crc32.o bitrev.o
+obj-$(CONFIG_AMD8111_ETH)	+= crc32.o bitrev.o
+obj-$(CONFIG_ARM_AM79C961A)	+= crc32.o bitrev.o
+obj-$(CONFIG_AT1700)		+= crc32.o bitrev.o
+obj-$(CONFIG_ATP)		+= crc32.o bitrev.o
+obj-$(CONFIG_BMAC)		+= crc32.o bitrev.o
+obj-$(CONFIG_DE4X5)		+= crc32.o bitrev.o
+obj-$(CONFIG_DECLANCE)		+= crc32.o bitrev.o
+obj-$(CONFIG_DEPCA)		+= crc32.o bitrev.o
+obj-$(CONFIG_DL2K)		+= crc32.o bitrev.o
+obj-$(CONFIG_DM9102)		+= crc32.o bitrev.o
+obj-$(CONFIG_EPIC100)		+= crc32.o bitrev.o
+obj-$(CONFIG_EWRK3)		+= crc32.o bitrev.o
+obj-$(CONFIG_FEALNX)		+= crc32.o bitrev.o
+obj-$(CONFIG_GMAC)		+= crc32.o bitrev.o
+obj-$(CONFIG_HAPPYMEAL)		+= crc32.o bitrev.o
+obj-$(CONFIG_MACE)		+= crc32.o bitrev.o
+obj-$(CONFIG_MACMACE)		+= crc32.o bitrev.o
+obj-$(CONFIG_PCNET32)		+= crc32.o bitrev.o
+obj-$(CONFIG_R8169)		+= crc32.o bitrev.o
+obj-$(CONFIG_SGI_IOC3_ETH)	+= crc32.o bitrev.o
+obj-$(CONFIG_SIS900)		+= crc32.o bitrev.o
+obj-$(CONFIG_SMC9194)		+= crc32.o bitrev.o
+obj-$(CONFIG_SUNBMAC)		+= crc32.o bitrev.o
+obj-$(CONFIG_SUNDANCE)		+= crc32.o bitrev.o
+obj-$(CONFIG_SUNGEM)		+= crc32.o bitrev.o
+obj-$(CONFIG_SUNLANCE)		+= crc32.o bitrev.o
+obj-$(CONFIG_SUNQE)		+= crc32.o bitrev.o
+obj-$(CONFIG_TYPHOON)		+= crc32.o bitrev.o
+obj-$(CONFIG_VIA_RHINE)		+= crc32.o bitrev.o
+obj-$(CONFIG_WINBOND_840)	+= crc32.o bitrev.o
+obj-$(CONFIG_YELLOWFIN)		+= crc32.o bitrev.o
+
+# These rely on drivers/net/7990.o which requires crc32.o and bitrev.o
+obj-$(CONFIG_HPLANCE)		+= crc32.o bitrev.o	
+obj-$(CONFIG_MVME147_NET)	+= crc32.o bitrev.o	
+
+# These rely on drivers/net/8390.o which requires crc32.o and bitrev.o
+obj-$(CONFIG_OAKNET)		+= crc32.o bitrev.o
+obj-$(CONFIG_NE2K_PCI)		+= crc32.o bitrev.o
+obj-$(CONFIG_STNIC)		+= crc32.o bitrev.o
+obj-$(CONFIG_MAC8390)		+= crc32.o bitrev.o
+obj-$(CONFIG_APNE)		+= crc32.o bitrev.o
+obj-$(CONFIG_PCMCIA_PCNET)	+= crc32.o bitrev.o
+obj-$(CONFIG_ARM_ETHERH)	+= crc32.o bitrev.o
+obj-$(CONFIG_WD80x3)		+= crc32.o bitrev.o
+obj-$(CONFIG_EL2)		+= crc32.o bitrev.o
+obj-$(CONFIG_NE2000)		+= crc32.o bitrev.o
+obj-$(CONFIG_NE2_MCA)		+= crc32.o bitrev.o
+obj-$(CONFIG_HPLAN)		+= crc32.o bitrev.o
+obj-$(CONFIG_HPLAN_PLUS)	+= crc32.o bitrev.o
+obj-$(CONFIG_ULTRA)		+= crc32.o bitrev.o
+obj-$(CONFIG_ULTRAMCA)		+= crc32.o bitrev.o
+obj-$(CONFIG_ULTRA32)		+= crc32.o bitrev.o
+obj-$(CONFIG_E2100)		+= crc32.o bitrev.o
+obj-$(CONFIG_ES3210)		+= crc32.o bitrev.o
+obj-$(CONFIG_LNE390)		+= crc32.o bitrev.o
+obj-$(CONFIG_NE3210)		+= crc32.o bitrev.o
+obj-$(CONFIG_AC3200)		+= crc32.o bitrev.o
+obj-$(CONFIG_ARIADNE2)		+= crc32.o bitrev.o
+obj-$(CONFIG_HYDRA)		+= crc32.o bitrev.o
+
+# drivers/net/pcmcia
+obj-$(CONFIG_PCMCIA_FMVJ18X)	+= crc32.o bitrev.o
+obj-$(CONFIG_PCMCIA_SMC91C92)	+= crc32.o bitrev.o
+obj-$(CONFIG_PCMCIA_XIRTULIP)	+= crc32.o bitrev.o
+
+# drivers/net/tulip
+obj-$(CONFIG_TULIP)		+= crc32.o bitrev.o
+
diff -Naur slin_m740_orig/drivers/usb/Makefile.lib slin_m740/drivers/usb/Makefile.lib
--- slin_m740_orig/drivers/usb/Makefile.lib	2003-08-25 13:44:42.000000000 +0200
+++ slin_m740/drivers/usb/Makefile.lib	2009-11-11 08:55:13.206956617 +0100
@@ -1,4 +1,4 @@
-obj-$(CONFIG_USB_USBNET)		+= crc32.o
-obj-$(CONFIG_USB_CATC)			+= crc32.o
-obj-$(CONFIG_USB_SPEEDTOUCH)		+= crc32.o
+obj-$(CONFIG_USB_USBNET)		+= crc32.o bitrev.o
+obj-$(CONFIG_USB_CATC)			+= crc32.o bitrev.o
+obj-$(CONFIG_USB_SPEEDTOUCH)		+= crc32.o bitrev.o
 
diff -Naur slin_m740_orig/fs/jffs2/crc32.c slin_m740/fs/jffs2/crc32.c
--- slin_m740_orig/fs/jffs2/crc32.c	2004-05-29 15:45:42.000000000 +0200
+++ slin_m740/fs/jffs2/crc32.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,97 +0,0 @@
-/*
- *  COPYRIGHT (C) 1986 Gary S. Brown.  You may use this program, or
- *  code or tables extracted from it, as desired without restriction.
- *
- *  First, the polynomial itself and its table of feedback terms.  The
- *  polynomial is
- *  X^32+X^26+X^23+X^22+X^16+X^12+X^11+X^10+X^8+X^7+X^5+X^4+X^2+X^1+X^0
- *
- *  Note that we take it "backwards" and put the highest-order term in
- *  the lowest-order bit.  The X^32 term is "implied"; the LSB is the
- *  X^31 term, etc.  The X^0 term (usually shown as "+1") results in
- *  the MSB being 1
- *
- *  Note that the usual hardware shift register implementation, which
- *  is what we're using (we're merely optimizing it by doing eight-bit
- *  chunks at a time) shifts bits into the lowest-order term.  In our
- *  implementation, that means shifting towards the right.  Why do we
- *  do it this way?  Because the calculated CRC must be transmitted in
- *  order from highest-order term to lowest-order term.  UARTs transmit
- *  characters in order from LSB to MSB.  By storing the CRC this way
- *  we hand it to the UART in the order low-byte to high-byte; the UART
- *  sends each low-bit to hight-bit; and the result is transmission bit
- *  by bit from highest- to lowest-order term without requiring any bit
- *  shuffling on our part.  Reception works similarly
- *
- *  The feedback terms table consists of 256, 32-bit entries.  Notes
- *
- *      The table can be generated at runtime if desired; code to do so
- *      is shown later.  It might not be obvious, but the feedback
- *      terms simply represent the results of eight shift/xor opera
- *      tions for all combinations of data and CRC register values
- *
- *      The values must be right-shifted by eight bits by the "updcrc
- *      logic; the shift must be unsigned (bring in zeroes).  On some
- *      hardware you could probably optimize the shift in assembler by
- *      using byte-swap instructions
- *      polynomial $edb88320
- */
-
-/* $Id: crc32.c,v 1.3 2001/02/07 16:45:32 dwmw2 Exp $ */
-
-#include "crc32.h"
-
-const __u32 crc32_table[256] = {
-	0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL, 0x076dc419L,
-	0x706af48fL, 0xe963a535L, 0x9e6495a3L, 0x0edb8832L, 0x79dcb8a4L,
-	0xe0d5e91eL, 0x97d2d988L, 0x09b64c2bL, 0x7eb17cbdL, 0xe7b82d07L,
-	0x90bf1d91L, 0x1db71064L, 0x6ab020f2L, 0xf3b97148L, 0x84be41deL,
-	0x1adad47dL, 0x6ddde4ebL, 0xf4d4b551L, 0x83d385c7L, 0x136c9856L,
-	0x646ba8c0L, 0xfd62f97aL, 0x8a65c9ecL, 0x14015c4fL, 0x63066cd9L,
-	0xfa0f3d63L, 0x8d080df5L, 0x3b6e20c8L, 0x4c69105eL, 0xd56041e4L,
-	0xa2677172L, 0x3c03e4d1L, 0x4b04d447L, 0xd20d85fdL, 0xa50ab56bL,
-	0x35b5a8faL, 0x42b2986cL, 0xdbbbc9d6L, 0xacbcf940L, 0x32d86ce3L,
-	0x45df5c75L, 0xdcd60dcfL, 0xabd13d59L, 0x26d930acL, 0x51de003aL,
-	0xc8d75180L, 0xbfd06116L, 0x21b4f4b5L, 0x56b3c423L, 0xcfba9599L,
-	0xb8bda50fL, 0x2802b89eL, 0x5f058808L, 0xc60cd9b2L, 0xb10be924L,
-	0x2f6f7c87L, 0x58684c11L, 0xc1611dabL, 0xb6662d3dL, 0x76dc4190L,
-	0x01db7106L, 0x98d220bcL, 0xefd5102aL, 0x71b18589L, 0x06b6b51fL,
-	0x9fbfe4a5L, 0xe8b8d433L, 0x7807c9a2L, 0x0f00f934L, 0x9609a88eL,
-	0xe10e9818L, 0x7f6a0dbbL, 0x086d3d2dL, 0x91646c97L, 0xe6635c01L,
-	0x6b6b51f4L, 0x1c6c6162L, 0x856530d8L, 0xf262004eL, 0x6c0695edL,
-	0x1b01a57bL, 0x8208f4c1L, 0xf50fc457L, 0x65b0d9c6L, 0x12b7e950L,
-	0x8bbeb8eaL, 0xfcb9887cL, 0x62dd1ddfL, 0x15da2d49L, 0x8cd37cf3L,
-	0xfbd44c65L, 0x4db26158L, 0x3ab551ceL, 0xa3bc0074L, 0xd4bb30e2L,
-	0x4adfa541L, 0x3dd895d7L, 0xa4d1c46dL, 0xd3d6f4fbL, 0x4369e96aL,
-	0x346ed9fcL, 0xad678846L, 0xda60b8d0L, 0x44042d73L, 0x33031de5L,
-	0xaa0a4c5fL, 0xdd0d7cc9L, 0x5005713cL, 0x270241aaL, 0xbe0b1010L,
-	0xc90c2086L, 0x5768b525L, 0x206f85b3L, 0xb966d409L, 0xce61e49fL,
-	0x5edef90eL, 0x29d9c998L, 0xb0d09822L, 0xc7d7a8b4L, 0x59b33d17L,
-	0x2eb40d81L, 0xb7bd5c3bL, 0xc0ba6cadL, 0xedb88320L, 0x9abfb3b6L,
-	0x03b6e20cL, 0x74b1d29aL, 0xead54739L, 0x9dd277afL, 0x04db2615L,
-	0x73dc1683L, 0xe3630b12L, 0x94643b84L, 0x0d6d6a3eL, 0x7a6a5aa8L,
-	0xe40ecf0bL, 0x9309ff9dL, 0x0a00ae27L, 0x7d079eb1L, 0xf00f9344L,
-	0x8708a3d2L, 0x1e01f268L, 0x6906c2feL, 0xf762575dL, 0x806567cbL,
-	0x196c3671L, 0x6e6b06e7L, 0xfed41b76L, 0x89d32be0L, 0x10da7a5aL,
-	0x67dd4accL, 0xf9b9df6fL, 0x8ebeeff9L, 0x17b7be43L, 0x60b08ed5L,
-	0xd6d6a3e8L, 0xa1d1937eL, 0x38d8c2c4L, 0x4fdff252L, 0xd1bb67f1L,
-	0xa6bc5767L, 0x3fb506ddL, 0x48b2364bL, 0xd80d2bdaL, 0xaf0a1b4cL,
-	0x36034af6L, 0x41047a60L, 0xdf60efc3L, 0xa867df55L, 0x316e8eefL,
-	0x4669be79L, 0xcb61b38cL, 0xbc66831aL, 0x256fd2a0L, 0x5268e236L,
-	0xcc0c7795L, 0xbb0b4703L, 0x220216b9L, 0x5505262fL, 0xc5ba3bbeL,
-	0xb2bd0b28L, 0x2bb45a92L, 0x5cb36a04L, 0xc2d7ffa7L, 0xb5d0cf31L,
-	0x2cd99e8bL, 0x5bdeae1dL, 0x9b64c2b0L, 0xec63f226L, 0x756aa39cL,
-	0x026d930aL, 0x9c0906a9L, 0xeb0e363fL, 0x72076785L, 0x05005713L,
-	0x95bf4a82L, 0xe2b87a14L, 0x7bb12baeL, 0x0cb61b38L, 0x92d28e9bL,
-	0xe5d5be0dL, 0x7cdcefb7L, 0x0bdbdf21L, 0x86d3d2d4L, 0xf1d4e242L,
-	0x68ddb3f8L, 0x1fda836eL, 0x81be16cdL, 0xf6b9265bL, 0x6fb077e1L,
-	0x18b74777L, 0x88085ae6L, 0xff0f6a70L, 0x66063bcaL, 0x11010b5cL,
-	0x8f659effL, 0xf862ae69L, 0x616bffd3L, 0x166ccf45L, 0xa00ae278L,
-	0xd70dd2eeL, 0x4e048354L, 0x3903b3c2L, 0xa7672661L, 0xd06016f7L,
-	0x4969474dL, 0x3e6e77dbL, 0xaed16a4aL, 0xd9d65adcL, 0x40df0b66L,
-	0x37d83bf0L, 0xa9bcae53L, 0xdebb9ec5L, 0x47b2cf7fL, 0x30b5ffe9L,
-	0xbdbdf21cL, 0xcabac28aL, 0x53b39330L, 0x24b4a3a6L, 0xbad03605L,
-	0xcdd70693L, 0x54de5729L, 0x23d967bfL, 0xb3667a2eL, 0xc4614ab8L,
-	0x5d681b02L, 0x2a6f2b94L, 0xb40bbe37L, 0xc30c8ea1L, 0x5a05df1bL,
-	0x2d02ef8dL
-};
diff -Naur slin_m740_orig/fs/jffs2/crc32.h slin_m740/fs/jffs2/crc32.h
--- slin_m740_orig/fs/jffs2/crc32.h	2004-11-15 13:37:38.000000000 +0100
+++ slin_m740/fs/jffs2/crc32.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,21 +0,0 @@
-#ifndef CRC32_H
-#define CRC32_H
-
-/* $Id: crc32.h,v 1.3 2001/02/26 14:44:37 dwmw2 Exp $ */
-
-#include <linux/types.h>
-
-extern const __u32 crc32_table[256];
-
-/* Return a 32-bit CRC of the contents of the buffer. */
-
-static inline __u32 
-crc32(__u32 val, const void *ss, int len)
-{
-	const unsigned char *s = ss;
-        while (--len >= 0)
-                val = crc32_table[(val ^ *s++) & 0xff] ^ (val >> 8);
-        return val;
-}
-
-#endif
diff -Naur slin_m740_orig/fs/jffs2/dir.c slin_m740/fs/jffs2/dir.c
--- slin_m740_orig/fs/jffs2/dir.c	2004-05-29 15:45:42.000000000 +0200
+++ slin_m740/fs/jffs2/dir.c	2009-11-10 12:40:12.000000000 +0100
@@ -43,7 +43,7 @@
 #include <linux/jffs2_fs_i.h>
 #include <linux/jffs2_fs_sb.h>
 #include "nodelist.h"
-#include "crc32.h"
+#include <linux/crc32.h>
 
 static int jffs2_readdir (struct file *, void *, filldir_t);
 
diff -Naur slin_m740_orig/fs/jffs2/erase.c slin_m740/fs/jffs2/erase.c
--- slin_m740_orig/fs/jffs2/erase.c	2004-05-29 15:45:42.000000000 +0200
+++ slin_m740/fs/jffs2/erase.c	2009-11-10 12:39:14.000000000 +0100
@@ -40,7 +40,7 @@
 #include <linux/jffs2.h>
 #include <linux/interrupt.h>
 #include "nodelist.h"
-#include "crc32.h"
+#include <linux/crc32.h>
 
 struct erase_priv_struct {
 	struct jffs2_eraseblock *jeb;
diff -Naur slin_m740_orig/fs/jffs2/file.c slin_m740/fs/jffs2/file.c
--- slin_m740_orig/fs/jffs2/file.c	2004-05-29 15:45:42.000000000 +0200
+++ slin_m740/fs/jffs2/file.c	2009-11-10 12:40:18.000000000 +0100
@@ -42,7 +42,7 @@
 #include <linux/pagemap.h>
 #include <linux/jffs2.h>
 #include "nodelist.h"
-#include "crc32.h"
+#include <linux/crc32.h>
 
 extern int generic_file_open(struct inode *, struct file *) __attribute__((weak));
 extern loff_t generic_file_llseek(struct file *file, loff_t offset, int origin) __attribute__((weak));
diff -Naur slin_m740_orig/fs/jffs2/gc.c slin_m740/fs/jffs2/gc.c
--- slin_m740_orig/fs/jffs2/gc.c	2004-05-29 15:45:42.000000000 +0200
+++ slin_m740/fs/jffs2/gc.c	2009-11-10 12:40:24.000000000 +0100
@@ -43,7 +43,7 @@
 #include <linux/interrupt.h>
 #include <linux/pagemap.h>
 #include "nodelist.h"
-#include "crc32.h"
+#include <linux/crc32.h>
 
 static int jffs2_garbage_collect_metadata(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb, 
 					struct inode *inode, struct jffs2_full_dnode *fd);
diff -Naur slin_m740_orig/fs/jffs2/Makefile slin_m740/fs/jffs2/Makefile
--- slin_m740_orig/fs/jffs2/Makefile	2004-05-29 15:45:42.000000000 +0200
+++ slin_m740/fs/jffs2/Makefile	2009-11-10 12:40:34.000000000 +0100
@@ -12,7 +12,7 @@
 
 COMPR_OBJS	:= compr.o compr_rubin.o compr_rtime.o pushpull.o \
 			compr_zlib.o
-JFFS2_OBJS	:= crc32.o dir.o file.o ioctl.o nodelist.o malloc.o \
+JFFS2_OBJS	:= dir.o file.o ioctl.o nodelist.o malloc.o \
 	read.o nodemgmt.o readinode.o super.o write.o scan.o gc.o \
 	symlink.o build.o erase.o background.o
 
diff -Naur slin_m740_orig/fs/jffs2/read.c slin_m740/fs/jffs2/read.c
--- slin_m740_orig/fs/jffs2/read.c	2004-05-29 15:45:42.000000000 +0200
+++ slin_m740/fs/jffs2/read.c	2009-11-10 12:40:54.000000000 +0100
@@ -40,7 +40,7 @@
 #include <linux/jffs2.h>
 #include <linux/mtd/mtd.h>
 #include "nodelist.h"
-#include "crc32.h"
+#include <linux/crc32.h>
 
 int jffs2_read_dnode(struct jffs2_sb_info *c, struct jffs2_full_dnode *fd, unsigned char *buf, int ofs, int len)
 {
diff -Naur slin_m740_orig/fs/jffs2/readinode.c slin_m740/fs/jffs2/readinode.c
--- slin_m740_orig/fs/jffs2/readinode.c	2004-05-29 15:45:42.000000000 +0200
+++ slin_m740/fs/jffs2/readinode.c	2009-11-10 12:40:58.000000000 +0100
@@ -44,7 +44,7 @@
 #include <linux/mtd/mtd.h>
 #include <linux/jffs2.h>
 #include "nodelist.h"
-#include "crc32.h"
+#include <linux/crc32.h>
 
 
 D1(void jffs2_print_frag_list(struct jffs2_inode_info *f)
diff -Naur slin_m740_orig/fs/jffs2/scan.c slin_m740/fs/jffs2/scan.c
--- slin_m740_orig/fs/jffs2/scan.c	2004-05-29 15:45:42.000000000 +0200
+++ slin_m740/fs/jffs2/scan.c	2009-11-10 12:41:03.000000000 +0100
@@ -40,7 +40,7 @@
 #include <linux/mtd/mtd.h>
 #include <linux/pagemap.h>
 #include "nodelist.h"
-#include "crc32.h"
+#include <linux/crc32.h>
 
 
 #define DIRTY_SPACE(x) do { typeof(x) _x = (x); \
diff -Naur slin_m740_orig/fs/jffs2/write.c slin_m740/fs/jffs2/write.c
--- slin_m740_orig/fs/jffs2/write.c	2004-05-29 15:45:42.000000000 +0200
+++ slin_m740/fs/jffs2/write.c	2009-11-10 12:41:08.000000000 +0100
@@ -40,7 +40,7 @@
 #include <linux/jffs2.h>
 #include <linux/mtd/mtd.h>
 #include "nodelist.h"
-#include "crc32.h"
+#include <linux/crc32.h>
 
 /* jffs2_new_inode: allocate a new inode and inocache, add it to the hash,
    fill in the raw_inode while you're at it. */
diff -Naur slin_m740_orig/fs/Makefile.lib slin_m740/fs/Makefile.lib
--- slin_m740_orig/fs/Makefile.lib	1970-01-01 01:00:00.000000000 +0100
+++ slin_m740/fs/Makefile.lib	2009-11-10 18:10:54.377732762 +0100
@@ -0,0 +1,2 @@
+obj-$(CONFIG_JFFS2_FS)		+= crc32.o bitrev.o
+obj-$(CONFIG_EFI_PARTITION)	+= crc32.o bitrev.o
diff -Naur slin_m740_orig/fs/partitions/efi.c slin_m740/fs/partitions/efi.c
--- slin_m740_orig/fs/partitions/efi.c	2004-05-29 15:45:46.000000000 +0200
+++ slin_m740/fs/partitions/efi.c	2009-11-10 12:42:00.000000000 +0100
@@ -99,6 +99,7 @@
 #include <linux/slab.h>
 #include <linux/smp_lock.h>
 #include <linux/init.h>
+#include <linux/crc32.h>
 #include <asm/system.h>
 #include <asm/byteorder.h>
 #include "check.h"
@@ -138,73 +139,6 @@
 }
 __setup("gpt", force_gpt_fn);
 
-
-/*
- * There are multiple 16-bit CRC polynomials in common use, but this is
- * *the* standard CRC-32 polynomial, first popularized by Ethernet.
- * x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x^1+x^0
- */
-#define CRCPOLY_LE 0xedb88320
-/* How many bits at a time to use.  Requires a table of 4<<CRC_xx_BITS bytes. */
-/* For less performance-sensitive, use 4 */
-#define CRC_LE_BITS 8
-static u32 *crc32table_le;
-
-/**
- * crc32init_le() - allocate and initialize LE table data
- *
- * crc is the crc of the byte i; other entries are filled in based on the
- * fact that crctable[i^j] = crctable[i] ^ crctable[j].
- *
- */
-static int __init crc32init_le(void)
-{
-	unsigned i, j;
-	u32 crc = 1;
-
-	crc32table_le =
-	    kmalloc((1 << CRC_LE_BITS) * sizeof(u32), GFP_KERNEL);
-	if (!crc32table_le)
-		return 1;
-	crc32table_le[0] = 0;
-
-	for (i = 1 << (CRC_LE_BITS - 1); i; i >>= 1) {
-		crc = (crc >> 1) ^ ((crc & 1) ? CRCPOLY_LE : 0);
-		for (j = 0; j < 1 << CRC_LE_BITS; j += 2 * i)
-			crc32table_le[i + j] = crc ^ crc32table_le[j];
-	}
-	return 0;
-}
-
-/**
- * crc32cleanup_le(): free LE table data
- */
-static void __exit crc32cleanup_le(void)
-{
-	if (crc32table_le) kfree(crc32table_le);
-	crc32table_le = NULL;
-}
-
-__initcall(crc32init_le);
-__exitcall(crc32cleanup_le);
-
-/**
- * crc32_le() - Calculate bitwise little-endian Ethernet AUTODIN II CRC32
- * @crc - seed value for computation.  ~0 for Ethernet, sometimes 0 for
- *        other uses, or the previous crc32 value if computing incrementally.
- * @p   - pointer to buffer over which CRC is run
- * @len - length of buffer @p
- * 
- */
-static u32 crc32_le(u32 crc, unsigned char const *p, size_t len)
-{
-	while (len--) {
-		crc = (crc >> 8) ^ crc32table_le[(crc ^ *p++) & 255];
-	}
-	return crc;
-}
-
-
 /**
  * efi_crc32() - EFI version of crc32 function
  * @buf: buffer to calculate crc32 of
@@ -220,7 +154,7 @@
 static inline u32
 efi_crc32(const void *buf, unsigned long len)
 {
-	return (crc32_le(~0L, buf, len) ^ ~0L);
+	return (crc32(~0L, buf, len) ^ ~0L);
 }
 
 /**
diff -Naur slin_m740_orig/include/linux/bitrev.h slin_m740/include/linux/bitrev.h
--- slin_m740_orig/include/linux/bitrev.h	1970-01-01 01:00:00.000000000 +0100
+++ slin_m740/include/linux/bitrev.h	2009-10-23 00:57:56.000000000 +0200
@@ -0,0 +1,16 @@
+#ifndef _LINUX_BITREV_H
+#define _LINUX_BITREV_H
+
+#include <linux/types.h>
+
+extern u8 const byte_rev_table[256];
+
+static inline u8 bitrev8(u8 byte)
+{
+	return byte_rev_table[byte];
+}
+
+extern u16 bitrev16(u16 in);
+extern u32 bitrev32(u32 in);
+
+#endif /* _LINUX_BITREV_H */
diff -Naur slin_m740_orig/include/linux/crc32.h slin_m740/include/linux/crc32.h
--- slin_m740_orig/include/linux/crc32.h	2004-11-08 11:55:58.000000000 +0100
+++ slin_m740/include/linux/crc32.h	2009-10-23 00:57:56.000000000 +0200
@@ -1,49 +1,27 @@
 /*
- * crc32.h for early Linux 2.4.19pre kernel inclusion
- * This defines ether_crc_le() and ether_crc() as inline functions
- * This is slated to change to using the library crc32 functions
- * as kernel 2.5.2 included at some future date.
+ * crc32.h
+ * See linux/lib/crc32.c for license and changes
  */
 #ifndef _LINUX_CRC32_H
 #define _LINUX_CRC32_H
 
 #include <linux/types.h>
+#include <linux/bitrev.h>
 
-/* The little-endian AUTODIN II ethernet CRC calculation.
-   N.B. Do not use for bulk data, use a table-based routine instead.
-   This is common code and should be moved to net/core/crc.c */
-static unsigned const ethernet_polynomial_le = 0xedb88320U;
-static inline unsigned ether_crc_le(int length, unsigned char *data)
-{
-	unsigned int crc = 0xffffffff;	/* Initial value. */
-	while(--length >= 0) {
-		unsigned char current_octet = *data++;
-		int bit;
-		for (bit = 8; --bit >= 0; current_octet >>= 1) {
-			if ((crc ^ current_octet) & 1) {
-				crc >>= 1;
-				crc ^= ethernet_polynomial_le;
-			} else
-				crc >>= 1;
-		}
-	}
-	return crc;
-}
+extern u32  crc32_le(u32 crc, unsigned char const *p, size_t len);
+extern u32  crc32_be(u32 crc, unsigned char const *p, size_t len);
 
-static unsigned const ethernet_polynomial = 0x04c11db7U;
-static inline u32 ether_crc(int length, unsigned char *data)
-{
-	int crc = -1;
-	while (--length >= 0) {
-		unsigned char current_octet = *data++;
-		int bit;
-		for (bit = 0; bit < 8; bit++, current_octet >>= 1) {
-			crc = (crc << 1) ^
-				((crc < 0) ^ (current_octet & 1) ?
-				 ethernet_polynomial : 0);
-		}
-	}
-	return crc;
-}
+#define crc32(seed, data, length)  crc32_le(seed, (unsigned char const *)data, length)
+
+/*
+ * Helpers for hash table generation of ethernet nics:
+ *
+ * Ethernet sends the least significant bit of a byte first, thus crc32_le
+ * is used. The output of crc32_le is bit reversed [most significant bit
+ * is in bit nr 0], thus it must be reversed before use. Except for
+ * nics that bit swap the result internally...
+ */
+#define ether_crc(length, data)    bitrev32(crc32_le(~0, data, length))
+#define ether_crc_le(length, data) crc32_le(~0, data, length)
 
 #endif /* _LINUX_CRC32_H */
diff -Naur slin_m740_orig/kernel/ksyms.c slin_m740/kernel/ksyms.c
--- slin_m740_orig/kernel/ksyms.c	2004-05-29 15:46:28.000000000 +0200
+++ slin_m740/kernel/ksyms.c	2009-11-10 18:13:25.861692707 +0100
@@ -48,6 +48,8 @@
 #include <linux/completion.h>
 #include <linux/seq_file.h>
 #include <linux/dnotify.h>
+#include <linux/crc32.h>
+#include <linux/bitrev.h>
 #include <asm/checksum.h>
 
 #if defined(CONFIG_PROC_FS)
@@ -581,6 +583,17 @@
 EXPORT_SYMBOL(strspn);
 EXPORT_SYMBOL(strsep);
 
+#ifdef CONFIG_CRC32
+EXPORT_SYMBOL(crc32_le);
+EXPORT_SYMBOL(crc32_be);
+#endif
+
+#ifdef CONFIG_BITREVERSE
+EXPORT_SYMBOL_GPL(byte_rev_table);
+EXPORT_SYMBOL(bitrev16);
+EXPORT_SYMBOL(bitrev32);
+#endif
+
 /* software interrupts */
 EXPORT_SYMBOL(tasklet_hi_vec);
 EXPORT_SYMBOL(tasklet_vec);
diff -Naur slin_m740_orig/lib/bitrev.c slin_m740/lib/bitrev.c
--- slin_m740_orig/lib/bitrev.c	1970-01-01 01:00:00.000000000 +0100
+++ slin_m740/lib/bitrev.c	2009-11-10 18:14:01.982186097 +0100
@@ -0,0 +1,63 @@
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/bitrev.h>
+
+MODULE_AUTHOR("Akinobu Mita <akinobu.mita@gmail.com>");
+MODULE_DESCRIPTION("Bit ordering reversal functions");
+MODULE_LICENSE("GPL");
+
+const u8 byte_rev_table[256] = {
+	0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0,
+	0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0,
+	0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8,
+	0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8,
+	0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4,
+	0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4,
+	0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec,
+	0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc,
+	0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2,
+	0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2,
+	0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea,
+	0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa,
+	0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6,
+	0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6,
+	0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee,
+	0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe,
+	0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1,
+	0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1,
+	0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9,
+	0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9,
+	0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5,
+	0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5,
+	0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed,
+	0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd,
+	0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3,
+	0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3,
+	0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb,
+	0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb,
+	0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7,
+	0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7,
+	0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef,
+	0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff,
+};
+
+u16 bitrev16(u16 x)
+{
+	return (bitrev8(x & 0xff) << 8) | bitrev8(x >> 8);
+}
+
+/**
+ * bitrev32 - reverse the order of bits in a u32 value
+ * @x: value to be bit-reversed
+ */
+u32 bitrev32(u32 x)
+{
+	return (bitrev16(x & 0xffff) << 16) | bitrev16(x >> 16);
+}
+
+#ifdef MODULE /* These are exported from kernel/ksyms.c in the non-module
+		 case, to ensure that this file is pulled in from lib/lib.a */
+EXPORT_SYMBOL_GPL(byte_rev_table);
+EXPORT_SYMBOL(bitrev16);
+EXPORT_SYMBOL(bitrev32);
+#endif
diff -Naur slin_m740_orig/lib/Config.in slin_m740/lib/Config.in
--- slin_m740_orig/lib/Config.in	2004-05-29 15:46:30.000000000 +0200
+++ slin_m740/lib/Config.in	2009-11-10 16:16:18.117661558 +0100
@@ -4,6 +4,9 @@
 mainmenu_option next_comment
 comment 'Library routines'
 
+tristate 'CRC32 functions' CONFIG_CRC32
+define_tristate CONFIG_BITREVERSE $CONFIG_CRC32
+
 #
 # Do we need the compression support?
 #
diff -Naur slin_m740_orig/lib/crc32.c slin_m740/lib/crc32.c
--- slin_m740_orig/lib/crc32.c	1970-01-01 01:00:00.000000000 +0100
+++ slin_m740/lib/crc32.c	2009-11-10 12:20:17.000000000 +0100
@@ -0,0 +1,509 @@
+/*
+ * Oct 15, 2000 Matt Domsch <Matt_Domsch@dell.com>
+ * Nicer crc32 functions/docs submitted by linux@horizon.com.  Thanks!
+ * Code was from the public domain, copyright abandoned.  Code was
+ * subsequently included in the kernel, thus was re-licensed under the
+ * GNU GPL v2.
+ *
+ * Oct 12, 2000 Matt Domsch <Matt_Domsch@dell.com>
+ * Same crc32 function was used in 5 other places in the kernel.
+ * I made one version, and deleted the others.
+ * There are various incantations of crc32().  Some use a seed of 0 or ~0.
+ * Some xor at the end with ~0.  The generic crc32() function takes
+ * seed as an argument, and doesn't xor at the end.  Then individual
+ * users can do whatever they need.
+ *   drivers/net/smc9194.c uses seed ~0, doesn't xor with ~0.
+ *   fs/jffs2 uses seed 0, doesn't xor with ~0.
+ *   fs/partitions/efi.c uses seed ~0, xor's with ~0.
+ *
+ * This source code is licensed under the GNU General Public License,
+ * Version 2.  See the file COPYING for more details.
+ */
+
+#include <linux/crc32.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <asm/atomic.h>
+#include "crc32defs.h"
+#if CRC_LE_BITS == 8
+#define tole(x) __constant_cpu_to_le32(x)
+#define tobe(x) __constant_cpu_to_be32(x)
+#else
+#define tole(x) (x)
+#define tobe(x) (x)
+#endif
+#include "crc32table.h"
+
+#if __GNUC__ >= 3	/* 2.x has "attribute", but only 3.0 has "pure */
+#define attribute(x) __attribute__(x)
+#else
+#define attribute(x)
+#endif
+
+MODULE_AUTHOR("Matt Domsch <Matt_Domsch@dell.com>");
+MODULE_DESCRIPTION("Ethernet CRC32 calculations");
+MODULE_LICENSE("GPL");
+
+/**
+ * crc32_le() - Calculate bitwise little-endian Ethernet AUTODIN II CRC32
+ * @crc: seed value for computation.  ~0 for Ethernet, sometimes 0 for
+ *	other uses, or the previous crc32 value if computing incrementally.
+ * @p: pointer to buffer over which CRC is run
+ * @len: length of buffer @p
+ */
+u32 attribute((pure)) crc32_le(u32 crc, unsigned char const *p, size_t len);
+
+#if CRC_LE_BITS == 1
+/*
+ * In fact, the table-based code will work in this case, but it can be
+ * simplified by inlining the table in ?: form.
+ */
+
+u32 attribute((pure)) crc32_le(u32 crc, unsigned char const *p, size_t len)
+{
+	int i;
+	while (len--) {
+		crc ^= *p++;
+		for (i = 0; i < 8; i++)
+			crc = (crc >> 1) ^ ((crc & 1) ? CRCPOLY_LE : 0);
+	}
+	return crc;
+}
+#else				/* Table-based approach */
+
+u32 attribute((pure)) crc32_le(u32 crc, unsigned char const *p, size_t len)
+{
+# if CRC_LE_BITS == 8
+	const u32      *b =(u32 *)p;
+	const u32      *tab = crc32table_le;
+
+# ifdef __LITTLE_ENDIAN
+#  define DO_CRC(x) crc = tab[ (crc ^ (x)) & 255 ] ^ (crc>>8)
+# else
+#  define DO_CRC(x) crc = tab[ ((crc >> 24) ^ (x)) & 255] ^ (crc<<8)
+# endif
+
+	crc = __cpu_to_le32(crc);
+	/* Align it */
+	if(unlikely(((long)b)&3 && len)){
+		do {
+			u8 *p = (u8 *)b;
+			DO_CRC(*p++);
+			b = (void *)p;
+		} while ((--len) && ((long)b)&3 );
+	}
+	if(likely(len >= 4)){
+		/* load data 32 bits wide, xor data 32 bits wide. */
+		size_t save_len = len & 3;
+	        len = len >> 2;
+		--b; /* use pre increment below(*++b) for speed */
+		do {
+			crc ^= *++b;
+			DO_CRC(0);
+			DO_CRC(0);
+			DO_CRC(0);
+			DO_CRC(0);
+		} while (--len);
+		b++; /* point to next byte(s) */
+		len = save_len;
+	}
+	/* And the last few bytes */
+	if(len){
+		do {
+			u8 *p = (u8 *)b;
+			DO_CRC(*p++);
+			b = (void *)p;
+		} while (--len);
+	}
+
+	return __le32_to_cpu(crc);
+#undef ENDIAN_SHIFT
+#undef DO_CRC
+
+# elif CRC_LE_BITS == 4
+	while (len--) {
+		crc ^= *p++;
+		crc = (crc >> 4) ^ crc32table_le[crc & 15];
+		crc = (crc >> 4) ^ crc32table_le[crc & 15];
+	}
+	return crc;
+# elif CRC_LE_BITS == 2
+	while (len--) {
+		crc ^= *p++;
+		crc = (crc >> 2) ^ crc32table_le[crc & 3];
+		crc = (crc >> 2) ^ crc32table_le[crc & 3];
+		crc = (crc >> 2) ^ crc32table_le[crc & 3];
+		crc = (crc >> 2) ^ crc32table_le[crc & 3];
+	}
+	return crc;
+# endif
+}
+#endif
+
+/**
+ * crc32_be() - Calculate bitwise big-endian Ethernet AUTODIN II CRC32
+ * @crc: seed value for computation.  ~0 for Ethernet, sometimes 0 for
+ *	other uses, or the previous crc32 value if computing incrementally.
+ * @p: pointer to buffer over which CRC is run
+ * @len: length of buffer @p
+ */
+u32 attribute((pure)) crc32_be(u32 crc, unsigned char const *p, size_t len);
+
+#if CRC_BE_BITS == 1
+/*
+ * In fact, the table-based code will work in this case, but it can be
+ * simplified by inlining the table in ?: form.
+ */
+
+u32 attribute((pure)) crc32_be(u32 crc, unsigned char const *p, size_t len)
+{
+	int i;
+	while (len--) {
+		crc ^= *p++ << 24;
+		for (i = 0; i < 8; i++)
+			crc =
+			    (crc << 1) ^ ((crc & 0x80000000) ? CRCPOLY_BE :
+					  0);
+	}
+	return crc;
+}
+
+#else				/* Table-based approach */
+u32 attribute((pure)) crc32_be(u32 crc, unsigned char const *p, size_t len)
+{
+# if CRC_BE_BITS == 8
+	const u32      *b =(u32 *)p;
+	const u32      *tab = crc32table_be;
+
+# ifdef __LITTLE_ENDIAN
+#  define DO_CRC(x) crc = tab[ (crc ^ (x)) & 255 ] ^ (crc>>8)
+# else
+#  define DO_CRC(x) crc = tab[ ((crc >> 24) ^ (x)) & 255] ^ (crc<<8)
+# endif
+
+	crc = __cpu_to_be32(crc);
+	/* Align it */
+	if(unlikely(((long)b)&3 && len)){
+		do {
+			u8 *p = (u8 *)b;
+			DO_CRC(*p++);
+			b = (u32 *)p;
+		} while ((--len) && ((long)b)&3 );
+	}
+	if(likely(len >= 4)){
+		/* load data 32 bits wide, xor data 32 bits wide. */
+		size_t save_len = len & 3;
+	        len = len >> 2;
+		--b; /* use pre increment below(*++b) for speed */
+		do {
+			crc ^= *++b;
+			DO_CRC(0);
+			DO_CRC(0);
+			DO_CRC(0);
+			DO_CRC(0);
+		} while (--len);
+		b++; /* point to next byte(s) */
+		len = save_len;
+	}
+	/* And the last few bytes */
+	if(len){
+		do {
+			u8 *p = (u8 *)b;
+			DO_CRC(*p++);
+			b = (void *)p;
+		} while (--len);
+	}
+	return __be32_to_cpu(crc);
+#undef ENDIAN_SHIFT
+#undef DO_CRC
+
+# elif CRC_BE_BITS == 4
+	while (len--) {
+		crc ^= *p++ << 24;
+		crc = (crc << 4) ^ crc32table_be[crc >> 28];
+		crc = (crc << 4) ^ crc32table_be[crc >> 28];
+	}
+	return crc;
+# elif CRC_BE_BITS == 2
+	while (len--) {
+		crc ^= *p++ << 24;
+		crc = (crc << 2) ^ crc32table_be[crc >> 30];
+		crc = (crc << 2) ^ crc32table_be[crc >> 30];
+		crc = (crc << 2) ^ crc32table_be[crc >> 30];
+		crc = (crc << 2) ^ crc32table_be[crc >> 30];
+	}
+	return crc;
+# endif
+}
+#endif
+
+#ifdef MODULE /* These are exported from kernel/ksyms.c in the non-module
+		 case, to ensure that this file is pulled in from lib/lib.a */
+EXPORT_SYMBOL(crc32_le);
+EXPORT_SYMBOL(crc32_be);
+#endif
+
+/*
+ * A brief CRC tutorial.
+ *
+ * A CRC is a long-division remainder.  You add the CRC to the message,
+ * and the whole thing (message+CRC) is a multiple of the given
+ * CRC polynomial.  To check the CRC, you can either check that the
+ * CRC matches the recomputed value, *or* you can check that the
+ * remainder computed on the message+CRC is 0.  This latter approach
+ * is used by a lot of hardware implementations, and is why so many
+ * protocols put the end-of-frame flag after the CRC.
+ *
+ * It's actually the same long division you learned in school, except that
+ * - We're working in binary, so the digits are only 0 and 1, and
+ * - When dividing polynomials, there are no carries.  Rather than add and
+ *   subtract, we just xor.  Thus, we tend to get a bit sloppy about
+ *   the difference between adding and subtracting.
+ *
+ * A 32-bit CRC polynomial is actually 33 bits long.  But since it's
+ * 33 bits long, bit 32 is always going to be set, so usually the CRC
+ * is written in hex with the most significant bit omitted.  (If you're
+ * familiar with the IEEE 754 floating-point format, it's the same idea.)
+ *
+ * Note that a CRC is computed over a string of *bits*, so you have
+ * to decide on the endianness of the bits within each byte.  To get
+ * the best error-detecting properties, this should correspond to the
+ * order they're actually sent.  For example, standard RS-232 serial is
+ * little-endian; the most significant bit (sometimes used for parity)
+ * is sent last.  And when appending a CRC word to a message, you should
+ * do it in the right order, matching the endianness.
+ *
+ * Just like with ordinary division, the remainder is always smaller than
+ * the divisor (the CRC polynomial) you're dividing by.  Each step of the
+ * division, you take one more digit (bit) of the dividend and append it
+ * to the current remainder.  Then you figure out the appropriate multiple
+ * of the divisor to subtract to being the remainder back into range.
+ * In binary, it's easy - it has to be either 0 or 1, and to make the
+ * XOR cancel, it's just a copy of bit 32 of the remainder.
+ *
+ * When computing a CRC, we don't care about the quotient, so we can
+ * throw the quotient bit away, but subtract the appropriate multiple of
+ * the polynomial from the remainder and we're back to where we started,
+ * ready to process the next bit.
+ *
+ * A big-endian CRC written this way would be coded like:
+ * for (i = 0; i < input_bits; i++) {
+ * 	multiple = remainder & 0x80000000 ? CRCPOLY : 0;
+ * 	remainder = (remainder << 1 | next_input_bit()) ^ multiple;
+ * }
+ * Notice how, to get at bit 32 of the shifted remainder, we look
+ * at bit 31 of the remainder *before* shifting it.
+ *
+ * But also notice how the next_input_bit() bits we're shifting into
+ * the remainder don't actually affect any decision-making until
+ * 32 bits later.  Thus, the first 32 cycles of this are pretty boring.
+ * Also, to add the CRC to a message, we need a 32-bit-long hole for it at
+ * the end, so we have to add 32 extra cycles shifting in zeros at the
+ * end of every message,
+ *
+ * So the standard trick is to rearrage merging in the next_input_bit()
+ * until the moment it's needed.  Then the first 32 cycles can be precomputed,
+ * and merging in the final 32 zero bits to make room for the CRC can be
+ * skipped entirely.
+ * This changes the code to:
+ * for (i = 0; i < input_bits; i++) {
+ *      remainder ^= next_input_bit() << 31;
+ * 	multiple = (remainder & 0x80000000) ? CRCPOLY : 0;
+ * 	remainder = (remainder << 1) ^ multiple;
+ * }
+ * With this optimization, the little-endian code is simpler:
+ * for (i = 0; i < input_bits; i++) {
+ *      remainder ^= next_input_bit();
+ * 	multiple = (remainder & 1) ? CRCPOLY : 0;
+ * 	remainder = (remainder >> 1) ^ multiple;
+ * }
+ *
+ * Note that the other details of endianness have been hidden in CRCPOLY
+ * (which must be bit-reversed) and next_input_bit().
+ *
+ * However, as long as next_input_bit is returning the bits in a sensible
+ * order, we can actually do the merging 8 or more bits at a time rather
+ * than one bit at a time:
+ * for (i = 0; i < input_bytes; i++) {
+ * 	remainder ^= next_input_byte() << 24;
+ * 	for (j = 0; j < 8; j++) {
+ * 		multiple = (remainder & 0x80000000) ? CRCPOLY : 0;
+ * 		remainder = (remainder << 1) ^ multiple;
+ * 	}
+ * }
+ * Or in little-endian:
+ * for (i = 0; i < input_bytes; i++) {
+ * 	remainder ^= next_input_byte();
+ * 	for (j = 0; j < 8; j++) {
+ * 		multiple = (remainder & 1) ? CRCPOLY : 0;
+ * 		remainder = (remainder << 1) ^ multiple;
+ * 	}
+ * }
+ * If the input is a multiple of 32 bits, you can even XOR in a 32-bit
+ * word at a time and increase the inner loop count to 32.
+ *
+ * You can also mix and match the two loop styles, for example doing the
+ * bulk of a message byte-at-a-time and adding bit-at-a-time processing
+ * for any fractional bytes at the end.
+ *
+ * The only remaining optimization is to the byte-at-a-time table method.
+ * Here, rather than just shifting one bit of the remainder to decide
+ * in the correct multiple to subtract, we can shift a byte at a time.
+ * This produces a 40-bit (rather than a 33-bit) intermediate remainder,
+ * but again the multiple of the polynomial to subtract depends only on
+ * the high bits, the high 8 bits in this case.  
+ *
+ * The multiple we need in that case is the low 32 bits of a 40-bit
+ * value whose high 8 bits are given, and which is a multiple of the
+ * generator polynomial.  This is simply the CRC-32 of the given
+ * one-byte message.
+ *
+ * Two more details: normally, appending zero bits to a message which
+ * is already a multiple of a polynomial produces a larger multiple of that
+ * polynomial.  To enable a CRC to detect this condition, it's common to
+ * invert the CRC before appending it.  This makes the remainder of the
+ * message+crc come out not as zero, but some fixed non-zero value.
+ *
+ * The same problem applies to zero bits prepended to the message, and
+ * a similar solution is used.  Instead of starting with a remainder of
+ * 0, an initial remainder of all ones is used.  As long as you start
+ * the same way on decoding, it doesn't make a difference.
+ */
+
+#ifdef UNITTEST
+
+#include <stdlib.h>
+#include <stdio.h>
+
+#if 0				/*Not used at present */
+static void
+buf_dump(char const *prefix, unsigned char const *buf, size_t len)
+{
+	fputs(prefix, stdout);
+	while (len--)
+		printf(" %02x", *buf++);
+	putchar('\n');
+
+}
+#endif
+
+static void bytereverse(unsigned char *buf, size_t len)
+{
+	while (len--) {
+		unsigned char x = bitrev8(*buf);
+		*buf++ = x;
+	}
+}
+
+static void random_garbage(unsigned char *buf, size_t len)
+{
+	while (len--)
+		*buf++ = (unsigned char) random();
+}
+
+#if 0				/* Not used at present */
+static void store_le(u32 x, unsigned char *buf)
+{
+	buf[0] = (unsigned char) x;
+	buf[1] = (unsigned char) (x >> 8);
+	buf[2] = (unsigned char) (x >> 16);
+	buf[3] = (unsigned char) (x >> 24);
+}
+#endif
+
+static void store_be(u32 x, unsigned char *buf)
+{
+	buf[0] = (unsigned char) (x >> 24);
+	buf[1] = (unsigned char) (x >> 16);
+	buf[2] = (unsigned char) (x >> 8);
+	buf[3] = (unsigned char) x;
+}
+
+/*
+ * This checks that CRC(buf + CRC(buf)) = 0, and that
+ * CRC commutes with bit-reversal.  This has the side effect
+ * of bytewise bit-reversing the input buffer, and returns
+ * the CRC of the reversed buffer.
+ */
+static u32 test_step(u32 init, unsigned char *buf, size_t len)
+{
+	u32 crc1, crc2;
+	size_t i;
+
+	crc1 = crc32_be(init, buf, len);
+	store_be(crc1, buf + len);
+	crc2 = crc32_be(init, buf, len + 4);
+	if (crc2)
+		printf("\nCRC cancellation fail: 0x%08x should be 0\n",
+		       crc2);
+
+	for (i = 0; i <= len + 4; i++) {
+		crc2 = crc32_be(init, buf, i);
+		crc2 = crc32_be(crc2, buf + i, len + 4 - i);
+		if (crc2)
+			printf("\nCRC split fail: 0x%08x\n", crc2);
+	}
+
+	/* Now swap it around for the other test */
+
+	bytereverse(buf, len + 4);
+	init = bitrev32(init);
+	crc2 = bitrev32(crc1);
+	if (crc1 != bitrev32(crc2))
+		printf("\nBit reversal fail: 0x%08x -> 0x%08x -> 0x%08x\n",
+		       crc1, crc2, bitrev32(crc2));
+	crc1 = crc32_le(init, buf, len);
+	if (crc1 != crc2)
+		printf("\nCRC endianness fail: 0x%08x != 0x%08x\n", crc1,
+		       crc2);
+	crc2 = crc32_le(init, buf, len + 4);
+	if (crc2)
+		printf("\nCRC cancellation fail: 0x%08x should be 0\n",
+		       crc2);
+
+	for (i = 0; i <= len + 4; i++) {
+		crc2 = crc32_le(init, buf, i);
+		crc2 = crc32_le(crc2, buf + i, len + 4 - i);
+		if (crc2)
+			printf("\nCRC split fail: 0x%08x\n", crc2);
+	}
+
+	return crc1;
+}
+
+#define SIZE 64
+#define INIT1 0
+#define INIT2 0
+
+int main(void)
+{
+	unsigned char buf1[SIZE + 4];
+	unsigned char buf2[SIZE + 4];
+	unsigned char buf3[SIZE + 4];
+	int i, j;
+	u32 crc1, crc2, crc3;
+
+	for (i = 0; i <= SIZE; i++) {
+		printf("\rTesting length %d...", i);
+		fflush(stdout);
+		random_garbage(buf1, i);
+		random_garbage(buf2, i);
+		for (j = 0; j < i; j++)
+			buf3[j] = buf1[j] ^ buf2[j];
+
+		crc1 = test_step(INIT1, buf1, i);
+		crc2 = test_step(INIT2, buf2, i);
+		/* Now check that CRC(buf1 ^ buf2) = CRC(buf1) ^ CRC(buf2) */
+		crc3 = test_step(INIT1 ^ INIT2, buf3, i);
+		if (crc3 != (crc1 ^ crc2))
+			printf("CRC XOR fail: 0x%08x != 0x%08x ^ 0x%08x\n",
+			       crc3, crc1, crc2);
+	}
+	printf("\nAll test complete.  No failures expected.\n");
+	return 0;
+}
+
+#endif				/* UNITTEST */
diff -Naur slin_m740_orig/lib/crc32defs.h slin_m740/lib/crc32defs.h
--- slin_m740_orig/lib/crc32defs.h	1970-01-01 01:00:00.000000000 +0100
+++ slin_m740/lib/crc32defs.h	2009-11-10 12:43:26.000000000 +0100
@@ -0,0 +1,32 @@
+/*
+ * There are multiple 16-bit CRC polynomials in common use, but this is
+ * *the* standard CRC-32 polynomial, first popularized by Ethernet.
+ * x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x^1+x^0
+ */
+#define CRCPOLY_LE 0xedb88320
+#define CRCPOLY_BE 0x04c11db7
+
+/* How many bits at a time to use.  Requires a table of 4<<CRC_xx_BITS bytes. */
+/* For less performance-sensitive, use 4 */
+#ifndef CRC_LE_BITS 
+# define CRC_LE_BITS 8
+#endif
+#ifndef CRC_BE_BITS
+# define CRC_BE_BITS 8
+#endif
+
+/*
+ * Little-endian CRC computation.  Used with serial bit streams sent
+ * lsbit-first.  Be sure to use cpu_to_le32() to append the computed CRC.
+ */
+#if CRC_LE_BITS > 8 || CRC_LE_BITS < 1 || CRC_LE_BITS & CRC_LE_BITS-1
+# error CRC_LE_BITS must be a power of 2 between 1 and 8
+#endif
+
+/*
+ * Big-endian CRC computation.  Used with serial bit streams sent
+ * msbit-first.  Be sure to use cpu_to_be32() to append the computed CRC.
+ */
+#if CRC_BE_BITS > 8 || CRC_BE_BITS < 1 || CRC_BE_BITS & CRC_BE_BITS-1
+# error CRC_BE_BITS must be a power of 2 between 1 and 8
+#endif
diff -Naur slin_m740_orig/lib/gen_crc32table.c slin_m740/lib/gen_crc32table.c
--- slin_m740_orig/lib/gen_crc32table.c	1970-01-01 01:00:00.000000000 +0100
+++ slin_m740/lib/gen_crc32table.c	2009-10-23 00:57:56.000000000 +0200
@@ -0,0 +1,82 @@
+#include <stdio.h>
+#include "crc32defs.h"
+#include <inttypes.h>
+
+#define ENTRIES_PER_LINE 4
+
+#define LE_TABLE_SIZE (1 << CRC_LE_BITS)
+#define BE_TABLE_SIZE (1 << CRC_BE_BITS)
+
+static uint32_t crc32table_le[LE_TABLE_SIZE];
+static uint32_t crc32table_be[BE_TABLE_SIZE];
+
+/**
+ * crc32init_le() - allocate and initialize LE table data
+ *
+ * crc is the crc of the byte i; other entries are filled in based on the
+ * fact that crctable[i^j] = crctable[i] ^ crctable[j].
+ *
+ */
+static void crc32init_le(void)
+{
+	unsigned i, j;
+	uint32_t crc = 1;
+
+	crc32table_le[0] = 0;
+
+	for (i = 1 << (CRC_LE_BITS - 1); i; i >>= 1) {
+		crc = (crc >> 1) ^ ((crc & 1) ? CRCPOLY_LE : 0);
+		for (j = 0; j < LE_TABLE_SIZE; j += 2 * i)
+			crc32table_le[i + j] = crc ^ crc32table_le[j];
+	}
+}
+
+/**
+ * crc32init_be() - allocate and initialize BE table data
+ */
+static void crc32init_be(void)
+{
+	unsigned i, j;
+	uint32_t crc = 0x80000000;
+
+	crc32table_be[0] = 0;
+
+	for (i = 1; i < BE_TABLE_SIZE; i <<= 1) {
+		crc = (crc << 1) ^ ((crc & 0x80000000) ? CRCPOLY_BE : 0);
+		for (j = 0; j < i; j++)
+			crc32table_be[i + j] = crc ^ crc32table_be[j];
+	}
+}
+
+static void output_table(uint32_t table[], int len, char *trans)
+{
+	int i;
+
+	for (i = 0; i < len - 1; i++) {
+		if (i % ENTRIES_PER_LINE == 0)
+			printf("\n");
+		printf("%s(0x%8.8xL), ", trans, table[i]);
+	}
+	printf("%s(0x%8.8xL)\n", trans, table[len - 1]);
+}
+
+int main(int argc, char** argv)
+{
+	printf("/* this file is generated - do not edit */\n\n");
+
+	if (CRC_LE_BITS > 1) {
+		crc32init_le();
+		printf("static const u32 crc32table_le[] = {");
+		output_table(crc32table_le, LE_TABLE_SIZE, "tole");
+		printf("};\n");
+	}
+
+	if (CRC_BE_BITS > 1) {
+		crc32init_be();
+		printf("static const u32 crc32table_be[] = {");
+		output_table(crc32table_be, BE_TABLE_SIZE, "tobe");
+		printf("};\n");
+	}
+
+	return 0;
+}
diff -Naur slin_m740_orig/lib/Makefile slin_m740/lib/Makefile
--- slin_m740_orig/lib/Makefile	2004-05-29 15:46:30.000000000 +0200
+++ slin_m740/lib/Makefile	2009-11-10 13:00:13.000000000 +0100
@@ -8,7 +8,8 @@
 
 L_TARGET := lib.a
 
-export-objs := cmdline.o dec_and_lock.o rwsem-spinlock.o rwsem.o rbtree.o
+export-objs := cmdline.o dec_and_lock.o rwsem-spinlock.o rwsem.o \
+	       rbtree.o crc32.o bitrev.o
 
 obj-y := errno.o ctype.o string.o vsprintf.o brlock.o cmdline.o \
 	 bust_spinlocks.o rbtree.o dump_stack.o
@@ -20,10 +21,26 @@
   obj-y += dec_and_lock.o
 endif
 
+obj-$(CONFIG_CRC32)      += crc32.o
+obj-$(CONFIG_BITREVERSE) += bitrev.o
+
 subdir-$(CONFIG_ZLIB_INFLATE) += zlib_inflate
 subdir-$(CONFIG_ZLIB_DEFLATE) += zlib_deflate
 
+include $(TOPDIR)/drivers/net/Makefile.lib
+include $(TOPDIR)/drivers/usb/Makefile.lib
+include $(TOPDIR)/fs/Makefile.lib
+include $(TOPDIR)/net/bluetooth/bnep/Makefile.lib
+
 # Include the subdirs, if necessary.
 obj-y += $(join $(subdir-y),$(subdir-y:%=/%.o))
 
 include $(TOPDIR)/Rules.make
+
+crc32.o: crc32table.h
+
+gen_crc32table: gen_crc32table.c
+	$(HOSTCC) $(HOSTCCFLAGS) -o $@ $<
+
+crc32table.h: gen_crc32table
+	./$< > $@
diff -Naur slin_m740_orig/net/bluetooth/bnep/bnep.h slin_m740/net/bluetooth/bnep/bnep.h
--- slin_m740_orig/net/bluetooth/bnep/bnep.h	2004-05-29 15:46:38.000000000 +0200
+++ slin_m740/net/bluetooth/bnep/bnep.h	2009-11-10 12:44:09.000000000 +0100
@@ -26,7 +26,7 @@
 #include <linux/types.h>
 #include <net/bluetooth/bluetooth.h>
 
-#include "crc32.h"
+#include <linux/crc32.h>
 
 // Limits
 #define BNEP_MAX_PROTO_FILTERS     5
@@ -179,7 +179,7 @@
 
 static inline int bnep_mc_hash(__u8 *addr)
 {
-        return (bnep_crc32(~0, addr, ETH_ALEN) >> 26);
+        return (crc32_be(~0, addr, ETH_ALEN) >> 26);
 }
 
 #endif
diff -Naur slin_m740_orig/net/bluetooth/bnep/core.c slin_m740/net/bluetooth/bnep/core.c
--- slin_m740_orig/net/bluetooth/bnep/core.c	2004-05-29 15:46:38.000000000 +0200
+++ slin_m740/net/bluetooth/bnep/core.c	2009-11-10 12:44:13.000000000 +0100
@@ -680,7 +680,6 @@
 
 static int __init bnep_init_module(void)
 {
-	bnep_crc32_init();
 	bnep_sock_init();
 
 	BT_INFO("BlueZ BNEP ver %s", VERSION);
@@ -695,7 +694,6 @@
 static void __exit bnep_cleanup_module(void)
 {
 	bnep_sock_cleanup();
-	bnep_crc32_cleanup();
 }
 
 module_init(bnep_init_module);
diff -Naur slin_m740_orig/net/bluetooth/bnep/crc32.c slin_m740/net/bluetooth/bnep/crc32.c
--- slin_m740_orig/net/bluetooth/bnep/crc32.c	2004-05-29 15:46:38.000000000 +0200
+++ slin_m740/net/bluetooth/bnep/crc32.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,59 +0,0 @@
-/* 
- * Based on linux-2.5/lib/crc32 by Matt Domsch <Matt_Domsch@dell.com>
- *
- * FIXME: Remove in 2.5  
- */
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/types.h>
-#include <linux/slab.h>
-#include <linux/init.h>
-#include <asm/atomic.h>
-
-#include "crc32.h"
-
-#define CRCPOLY_BE 0x04c11db7
-#define CRC_BE_BITS 8
-
-static u32 *bnep_crc32_table;
-
-/*
- * This code is in the public domain; copyright abandoned.
- * Liability for non-performance of this code is limited to the amount
- * you paid for it.  Since it is distributed for free, your refund will
- * be very very small.  If it breaks, you get to keep both pieces.
- */
-u32 bnep_crc32(u32 crc, unsigned char const *p, size_t len)
-{
-	while (len--)
-		crc = (crc << 8) ^ bnep_crc32_table[(crc >> 24) ^ *p++];
-	
-	return crc;
-}
-
-int __init bnep_crc32_init(void)
-{
-	unsigned i, j;
-	u32 crc = 0x80000000;
-
-	bnep_crc32_table = kmalloc((1 << CRC_BE_BITS) * sizeof(u32), GFP_KERNEL);
-	if (!bnep_crc32_table)
-		return -ENOMEM;
-
-	bnep_crc32_table[0] = 0;
-
-	for (i = 1; i < 1 << CRC_BE_BITS; i <<= 1) {
-		crc = (crc << 1) ^ ((crc & 0x80000000) ? CRCPOLY_BE : 0);
-		for (j = 0; j < i; j++)
-			bnep_crc32_table[i + j] = crc ^ bnep_crc32_table[j];
-	}
-	return 0;
-}
-
-void __exit bnep_crc32_cleanup(void)
-{
-	if (bnep_crc32_table)
-		kfree(bnep_crc32_table);
-	bnep_crc32_table = NULL;
-}
diff -Naur slin_m740_orig/net/bluetooth/bnep/crc32.h slin_m740/net/bluetooth/bnep/crc32.h
--- slin_m740_orig/net/bluetooth/bnep/crc32.h	2004-05-29 15:46:38.000000000 +0200
+++ slin_m740/net/bluetooth/bnep/crc32.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,10 +0,0 @@
-/*
- * crc32.h
- * See crc32.c for license and changes
- *
- * FIXME: Remove in 2.5
- */
-
-int  bnep_crc32_init(void);
-void bnep_crc32_cleanup(void);
-u32  bnep_crc32(u32 crc, unsigned char const *p, size_t len);
diff -Naur slin_m740_orig/net/bluetooth/bnep/Makefile slin_m740/net/bluetooth/bnep/Makefile
--- slin_m740_orig/net/bluetooth/bnep/Makefile	2004-05-29 15:46:38.000000000 +0200
+++ slin_m740/net/bluetooth/bnep/Makefile	2009-11-10 12:44:17.000000000 +0100
@@ -4,7 +4,7 @@
 
 O_TARGET := bnep.o
 
-obj-y	 := core.o sock.o netdev.o crc32.o
+obj-y	 := core.o sock.o netdev.o
 obj-m    += $(O_TARGET)
 
 include $(TOPDIR)/Rules.make
diff -Naur slin_m740_orig/net/bluetooth/bnep/Makefile.lib slin_m740/net/bluetooth/bnep/Makefile.lib
--- slin_m740_orig/net/bluetooth/bnep/Makefile.lib	1970-01-01 01:00:00.000000000 +0100
+++ slin_m740/net/bluetooth/bnep/Makefile.lib	2009-11-10 18:11:23.925669888 +0100
@@ -0,0 +1 @@
+obj-$(CONFIG_BLUEZ_BNEP) += crc32.o bitrev.o
