diff -Naur a/extra/Configs/Config.in b/extra/Configs/Config.in
--- a/extra/Configs/Config.in	2014-09-17 20:50:35.000000000 +0200
+++ b/extra/Configs/Config.in	2014-10-11 12:45:33.804551576 +0200
@@ -1658,6 +1658,19 @@
 
 	  Most people will answer 9.
 
+
+config UCLIBC_HAS_SCANF_GLIBC_A_FLAG
+	bool "Support glibc's 'a' flag for scanf string conversions (not implemented)"
+	help
+	  NOTE!!!  Currently Not Implemented!!! Just A Place Holder!!  NOTE!!!
+	  NOTE!!!  Conflicts with an ANSI/ISO C99 scanf flag!!         NOTE!!!
+
+	  Answer Y to enable support for glibc's 'a' flag for the scanf string
+	  conversions '%s', '%[', '%ls', '%l[', and '%S'.  This is used to
+	  auto-allocate sufficient memory to hold the data retrieved.
+
+	  Most people will answer N.
+
 choice
 	prompt "Stdio buffer size"
 	default UCLIBC_HAS_STDIO_BUFSIZ_4096
diff -Naur a/libc/stdio/_scanf.c b/libc/stdio/_scanf.c
--- a/libc/stdio/_scanf.c	2014-09-17 20:50:35.000000000 +0200
+++ b/libc/stdio/_scanf.c	2014-10-11 12:53:28.257882504 +0200
@@ -76,6 +76,13 @@
 #include <bits/uClibc_fpmax.h>
 #endif /* __UCLIBC_HAS_FLOATS__ */
 
+#ifdef __UCLIBC_HAS_SCANF_GLIBC_A_FLAG__
+#ifdef L_vfwscanf
+#warning Forcing undef of __UCLIBC_HAS_SCANF_GLIBC_A_FLAG__ until implemented for wchar!
+#undef __UCLIBC_HAS_SCANF_GLIBC_A_FLAG__
+#endif
+#endif
+
 #undef __STDIO_HAS_VSSCANF
 #if defined(__STDIO_BUFFERS) || !defined(__UCLIBC_HAS_WCHAR__) || defined(__UCLIBC_HAS_GLIBC_CUSTOM_STREAMS__)
 #define __STDIO_HAS_VSSCANF 1
@@ -422,9 +429,8 @@
 
 
 /* float layout          0123456789012345678901  repeat n for "l[" */
-#define SPEC_CHARS		"npxXoudifFeEgGaACSnmcs["
-/*                       npxXoudif eEgG  CS  cs[ */
-/* NOTE: the 'm' flag must come before any convs that support it */
+#define SPEC_CHARS		"npxXoudifFeEgGaACSncs["
+/*                       npxXoudif eEgG  CS cs[ */
 
 /* NOTE: Ordering is important!  The CONV_{C,S,LEFTBRACKET} must map
    simply to their lowercase equivalents.  */
@@ -434,7 +440,7 @@
 	CONV_p,
 	CONV_x, CONV_X,	CONV_o,	CONV_u,	CONV_d,	CONV_i,
 	CONV_f, CONV_F, CONV_e, CONV_E, CONV_g, CONV_G, CONV_a, CONV_A,
-	CONV_C, CONV_S, CONV_LEFTBRACKET, CONV_m, CONV_c, CONV_s, CONV_leftbracket,
+	CONV_C, CONV_S, CONV_LEFTBRACKET, CONV_c, CONV_s, CONV_leftbracket,
 	CONV_percent, CONV_whitespace /* not in SPEC_* and no flags */
 };
 
@@ -464,7 +470,7 @@
 	FLAG_SURPRESS   =   0x10,	/* MUST BE 1ST!!  See DO_FLAGS. */
 	FLAG_THOUSANDS	=	0x20,
 	FLAG_I18N		=	0x40,	/* only works for d, i, u */
-	FLAG_MALLOC     =   0x80,	/* only works for c, s, S, and [ (and l[)*/
+	FLAG_MALLOC     =   0x80,	/* only works for s, S, and [ (and l[)*/
 };
 
 
@@ -481,7 +487,7 @@
 	/* fFeEgGaA */	(0x0c|FLAG_SURPRESS|FLAG_THOUSANDS|FLAG_I18N), \
 	/* C */			(   0|FLAG_SURPRESS), \
 	/* S and l[ */	(   0|FLAG_SURPRESS|FLAG_MALLOC), \
-	/* c */			(0x04|FLAG_SURPRESS|FLAG_MALLOC), \
+	/* c */			(0x04|FLAG_SURPRESS), \
 	/* s and [ */	(0x04|FLAG_SURPRESS|FLAG_MALLOC), \
 }
 
@@ -894,17 +900,16 @@
 		if (*psfs->fmt == *p) {
 			int p_m_spec_chars = p - spec_chars;
 
-			if (*p == 'm' &&
-				(psfs->fmt[1] == '[' || psfs->fmt[1] == 'c' ||
-				 /* Assumes ascii for 's' and 'S' test. */
-				 (psfs->fmt[1] | 0x20) == 's'))
-			{
-				if (psfs->store)
-					psfs->flags |= FLAG_MALLOC;
+#ifdef __UCLIBC_HAS_SCANF_GLIBC_A_FLAG__
+			if ((*p == 'a')
+				&& ((psfs->fmt[1] == '[') || ((psfs->fmt[1]|0x20) == 's'))
+				) {		/* Assumes ascii for 's' and 'S' test. */
+				psfs->flags |= FLAG_MALLOC;
 				++psfs->fmt;
 				++p;
-				continue; /* The related conversions follow 'm'. */
+				continue; /* The related conversions follow 'a'. */
 			}
+#endif /* __UCLIBC_HAS_SCANF_GLIBC_A_FLAG__ */
 
 			for (p = spec_ranges; p_m_spec_chars > *p ; ++p) {}
 			if (((psfs->dataargtype >> 8) | psfs->flags)
@@ -1137,6 +1142,12 @@
 	psfs_t psfs;
 	int i;
 
+#ifdef __UCLIBC_HAS_SCANF_GLIBC_A_FLAG__
+#define MALLOC_CHUNK_SIZE       64
+	unsigned int  alen, aoffset;
+	unsigned char *abuf;
+#endif
+
 #ifdef __UCLIBC_MJN3_ONLY__
 #warning TODO: Fix MAX_DIGITS.  We do not do binary, so...!
 #endif
@@ -1255,6 +1266,12 @@
 				while (*wf && __isascii(*wf) && (b < buf + sizeof(buf) - 1)) {
 					*b++ = *wf++;
 				}
+#ifdef __UCLIBC_HAS_SCANF_GLIBC_A_FLAG__
+#error this is wrong... we need to ched in __psfs_parse_spec instead since this checks last char in buffer and conversion my have stopped before it.
+				if ((*b == 'a') && ((*wf == '[') || ((*wf|0x20) == 's'))) {
+					goto DONE;	/* Spec was excessively long. */
+				}
+#endif /* __UCLIBC_HAS_SCANF_GLIBC_A_FLAG__ */
 				*b = 0;
 				if (b == buf) { /* Bad conversion specifier! */
 					goto DONE;
@@ -1355,12 +1372,32 @@
 				b = (psfs.store ? ((unsigned char *) psfs.cur_ptr) : buf);
 				fail = 1;
 
+#ifdef __UCLIBC_HAS_SCANF_GLIBC_A_FLAG__
+				if (psfs.flags & FLAG_MALLOC) {
+					alen = MALLOC_CHUNK_SIZE;
+					if ((abuf = (unsigned char *) malloc(alen)) == NULL) {
+						goto NEXT_FMT;
+					}
+					b = abuf;
+				}
+#endif
+
 				if (psfs.conv_num == CONV_c) {
 					if (sc.width == INT_MAX) {
 						sc.width = 1;
 					}
 
 					while (__scan_getc(&sc) >= 0) {
+#ifdef __UCLIBC_HAS_SCANF_GLIBC_A_FLAG__
+						aoffset = (unsigned int) b - (unsigned int) abuf;
+						if ((psfs.flags & FLAG_MALLOC) && ( aoffset + psfs.store >= alen)) {
+							alen += MALLOC_CHUNK_SIZE;
+							if ((abuf = (unsigned char *) realloc(abuf, alen)) == NULL) {
+								break;
+							}
+							b = abuf + aoffset;
+						}
+#endif
 						zero_conversions = 0;
 						*b = sc.cc;
 						b += psfs.store;
@@ -1374,36 +1411,24 @@
 				}
 
 				if (psfs.conv_num == CONV_s) {
-					/* We might have to handle the allocation ourselves */
-					int len;
-					/* With 'm', we actually got a pointer to a pointer */
-					unsigned char **ptr = (void *)b;
-
-					i = 0;
-					if (psfs.flags & FLAG_MALLOC) {
-						len = 0;
-						b = NULL;
-					} else
-						len = -1;
-
 					/* Yes, believe it or not, a %s conversion can store nuls. */
 					while ((__scan_getc(&sc) >= 0) && !isspace(sc.cc)) {
-						zero_conversions = 0;
-						if (i == len) {
-							/* Pick a size that won't trigger a lot of
-							 * mallocs early on ... */
-							len += 256;
-							b = realloc(b, len + 1);
+#ifdef __UCLIBC_HAS_SCANF_GLIBC_A_FLAG__
+						aoffset = (unsigned int) b - (unsigned int) abuf;
+						if ((psfs.flags & FLAG_MALLOC) && ( aoffset + psfs.store >= alen)) {
+							alen += MALLOC_CHUNK_SIZE;
+							if ((abuf = (unsigned char *) realloc(abuf, alen)) == NULL) {
+								fail = 1;
+								break;
+							}
+							b = abuf + aoffset;
 						}
-						b[i] = sc.cc;
-						i += psfs.store;
+#endif
+						zero_conversions = 0;
+						*b = sc.cc;
+						b += psfs.store;
 						fail = 0;
 					}
-
-					if (psfs.flags & FLAG_MALLOC)
-						*ptr = b;
-					/* The code below takes care of terminating NUL */
-					b += i;
 				} else {
 #ifdef __UCLIBC_HAS_WCHAR__
 					assert((psfs.conv_num == CONV_LEFTBRACKET) || \
@@ -1459,6 +1484,17 @@
 						if (!scanset[sc.cc]) {
 							break;
 						}
+#ifdef __UCLIBC_HAS_SCANF_GLIBC_A_FLAG__
+						aoffset = (unsigned int) b - (unsigned int) abuf;
+						if ((psfs.flags & FLAG_MALLOC) && ( aoffset + psfs.store >= alen)) {
+							alen += MALLOC_CHUNK_SIZE;
+							if ((abuf = (unsigned char *) realloc(abuf, alen)) == NULL) {
+								fail = 1;
+								break;
+							}
+							b = abuf + aoffset;
+						}
+#endif
 						*b = sc.cc;
 						b += psfs.store;
 						fail = 0;
@@ -1466,6 +1502,12 @@
 				}
 				/* Common tail for processing of %s and %[. */
 
+#ifdef __UCLIBC_HAS_SCANF_GLIBC_A_FLAG__
+				if (psfs.flags & FLAG_MALLOC) {
+					/* store the ptr to allocated string space, or even null */
+					* (unsigned char **) psfs.cur_ptr = abuf;
+				}
+#endif
 				__scan_ungetc(&sc);
 				if (fail) {	/* nothing stored! */
 					goto DONE;
