diff -Naur samba-2.2.12-orig/source/client/client.c samba-2.2.12/source/client/client.c
--- samba-2.2.12-orig/source/client/client.c	2011-03-04 13:51:44.000000000 +0100
+++ samba-2.2.12/source/client/client.c	2011-03-04 13:19:26.000000000 +0100
@@ -1348,81 +1348,7 @@
 }
 
 
-/****************************************************************************
-  cancel a print job
-  ****************************************************************************/
-static void do_cancel(int job)
-{
-	if (cli_printjob_del(cli, job)) {
-		printf("Job %d cancelled\n",job);
-	} else {
-		printf("Error cancelling job %d : %s\n",job,cli_errstr(cli));
-	}
-}
-
-
-/****************************************************************************
-  cancel a print job
-  ****************************************************************************/
-static void cmd_cancel(void)
-{
-	fstring buf;
-	int job; 
-
-	if (!next_token(NULL,buf,NULL,sizeof(buf))) {
-		printf("cancel <jobid> ...\n");
-		return;
-	}
-	do {
-		job = atoi(buf);
-		do_cancel(job);
-	} while (next_token(NULL,buf,NULL,sizeof(buf)));
-}
-
-
-/****************************************************************************
-  print a file
-  ****************************************************************************/
-static void cmd_print(void)
-{
-	pstring lname;
-	pstring rname;
-	char *p;
-
-	if (!next_token(NULL,lname,NULL, sizeof(lname))) {
-		ZERODEBUG(0,("print <filename>\n"));
-		return;
-	}
-
-	pstrcpy(rname,lname);
-	p = strrchr(rname,'/');
-	if (p) {
-		slprintf(rname, sizeof(rname)-1, "%s-%d", p+1, (int)sys_getpid());
-	}
-
-	if (strequal(lname,"-")) {
-		slprintf(rname, sizeof(rname)-1, "stdin-%d", (int)sys_getpid());
-	}
-
-	do_put(rname, lname);
-}
-
 
-/****************************************************************************
- show a print queue entry
-****************************************************************************/
-static void queue_fn(struct print_job_info *p)
-{
-	ZERODEBUG(0,("%-6d   %-9d    %s\n", (int)p->id, (int)p->size, p->name));
-}
-
-/****************************************************************************
- show a print queue
-****************************************************************************/
-static void cmd_queue(void)
-{
-	cli_print_queue(cli, queue_fn);  
-}
 
 /****************************************************************************
 delete some files
@@ -1745,40 +1671,6 @@
 }
 
 
-/****************************************************************************
-do a printmode command
-****************************************************************************/
-static void cmd_printmode(void)
-{
-	fstring buf;
-	fstring mode;
-
-	if (next_token(NULL,buf,NULL,sizeof(buf))) {
-		if (strequal(buf,"text")) {
-			printmode = 0;      
-		} else {
-			if (strequal(buf,"graphics"))
-				printmode = 1;
-			else
-				printmode = atoi(buf);
-		}
-	}
-
-	switch(printmode)
-		{
-		case 0: 
-			fstrcpy(mode,"text");
-			break;
-		case 1: 
-			fstrcpy(mode,"graphics");
-			break;
-		default: 
-			slprintf(mode,sizeof(mode)-1,"%d",printmode);
-			break;
-		}
-	
-	DEBUG(2,("the printmode is now %s\n",mode));
-}
 
 /****************************************************************************
 do the lcd command
@@ -1887,7 +1779,6 @@
   {"altname",cmd_altname,"<file> show alt name",{COMPL_NONE,COMPL_NONE}},
   {"archive",cmd_archive,"<level>\n0=ignore archive bit\n1=only get archive files\n2=only get archive files and reset archive bit\n3=get all files and reset archive bit",{COMPL_NONE,COMPL_NONE}},
   {"blocksize",cmd_block,"blocksize <number> (default 20)",{COMPL_NONE,COMPL_NONE}},
-  {"cancel",cmd_cancel,"<jobid> cancel a print queue entry",{COMPL_NONE,COMPL_NONE}},
   {"cd",cmd_cd,"[directory] change/report the remote directory",{COMPL_REMOTE,COMPL_NONE}},
   {"chmod",cmd_chmod,"<src> <mode> chmod a file using UNIX permission",{COMPL_REMOTE,COMPL_REMOTE}},
   {"chown",cmd_chown,"<src> <uid> <gid> chown a file using UNIX uids and gids",{COMPL_REMOTE,COMPL_REMOTE}},
@@ -1910,13 +1801,10 @@
   {"mput",cmd_mput,"<mask> put all matching files",{COMPL_REMOTE,COMPL_NONE}},
   {"newer",cmd_newer,"<file> only mget files newer than the specified local file",{COMPL_LOCAL,COMPL_NONE}},
   {"open",cmd_open,"<mask> open a file",{COMPL_REMOTE,COMPL_NONE}},
-  {"print",cmd_print,"<file name> print a file",{COMPL_NONE,COMPL_NONE}},
-  {"printmode",cmd_printmode,"<graphics or text> set the print mode",{COMPL_NONE,COMPL_NONE}},
   {"prompt",cmd_prompt,"toggle prompting for filenames for mget and mput",{COMPL_NONE,COMPL_NONE}},  
   {"put",cmd_put,"<local name> [remote name] put a file",{COMPL_LOCAL,COMPL_REMOTE}},
   {"pwd",cmd_pwd,"show current remote directory (same as 'cd' with no args)",{COMPL_NONE,COMPL_NONE}},
   {"q",cmd_quit,"logoff the server",{COMPL_NONE,COMPL_NONE}},
-  {"queue",cmd_queue,"show the print queue",{COMPL_NONE,COMPL_NONE}},
   {"quit",cmd_quit,"logoff the server",{COMPL_NONE,COMPL_NONE}},
   {"rd",cmd_rmdir,"<directory> remove a directory",{COMPL_NONE,COMPL_NONE}},
   {"recurse",cmd_recurse,"toggle directory recursion for mget and mput",{COMPL_NONE,COMPL_NONE}},  
diff -Naur samba-2.2.12-orig/source/client/smbspool.c samba-2.2.12/source/client/smbspool.c
--- samba-2.2.12-orig/source/client/smbspool.c	2004-08-12 20:24:36.000000000 +0200
+++ samba-2.2.12/source/client/smbspool.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,428 +0,0 @@
-/* 
-   Unix SMB/Netbios implementation.
-   Version 2.0.
-   SMB backend for the Common UNIX Printing System ("CUPS")
-   Copyright 1999 by Easy Software Products
-   Copyright Andrew Tridgell 1994-1998
-   
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2 of the License, or
-   (at your option) any later version.
-   
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-   
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-*/
-
-#define NO_SYSLOG
-
-#include "includes.h"
-
-/*
- * Globals...
- */
-
-extern BOOL		in_client;	/* Boolean for client library */
-
-
-/*
- * Local functions...
- */
-
-static void		list_devices(void);
-static struct cli_state	*smb_connect(char *, char *, char *, char *, char *);
-static int		smb_print(struct cli_state *, char *, FILE *);
-
-
-/*
- * 'main()' - Main entry for SMB backend.
- */
-
- int				/* O - Exit status */
- main(int  argc,			/* I - Number of command-line arguments */
-     char *argv[])		/* I - Command-line arguments */
-{
-  int		i;		/* Looping var */
-  int		copies;		/* Number of copies */
-  char		uri[1024],	/* URI */
-		*sep,		/* Pointer to separator */
-		*username,	/* Username */
-		*password,	/* Password */
-		*workgroup,	/* Workgroup */
-		*server,	/* Server name */
-		*printer;	/* Printer name */
-  FILE		*fp;		/* File to print */
-  int		status=0;		/* Status of LPD job */
-  struct cli_state *cli;	/* SMB interface */
-
-  /* we expect the URI in argv[0]. Detect the case where it is in argv[1] and cope */
-  if (argc > 2 && strncmp(argv[0],"smb://", 6) && !strncmp(argv[1],"smb://", 6)) {
-	  argv++;
-	  argc--;
-  }
-
-  if (argc == 1)
-  {
-   /*
-    * NEW!  In CUPS 1.1 the backends are run with no arguments to list the
-    *       available devices.  These can be devices served by this backend
-    *       or any other backends (i.e. you can have an SNMP backend that
-    *       is only used to enumerate the available network printers... :)
-    */
-
-    list_devices();
-    return (0);
-  }
-
-  if (argc < 6 || argc > 7)
-  {
-    fprintf(stderr, "Usage: %s [DEVICE_URI] job-id user title copies options [file]\n",
-            argv[0]);
-    fputs("       The DEVICE_URI environment variable can also contain the\n", stderr);
-    fputs("       destination printer:\n", stderr);
-    fputs("\n", stderr);
-    fputs("           smb://[username:password@][workgroup/]server/printer\n", stderr);
-    return (1);
-  }
-
- /*
-  * If we have 7 arguments, print the file named on the command-line.
-  * Otherwise, print data from stdin...
-  */
-
-  if (argc == 6)
-  {
-   /*
-    * Print from Copy stdin to a temporary file...
-    */
-
-    fp     = stdin;
-    copies = 1;
-  }
-  else if ((fp = fopen(argv[6], "rb")) == NULL)
-  {
-    perror("ERROR: Unable to open print file");
-    return (1);
-  }
-  else
-    copies = atoi(argv[4]);
-
- /*
-  * Find the URI...
-  */
-
-  if (strncmp(argv[0], "smb://", 6) == 0)
-    strncpy(uri, argv[0], sizeof(uri) - 1);
-  else if (getenv("DEVICE_URI") != NULL)
-    strncpy(uri, getenv("DEVICE_URI"), sizeof(uri) - 1);
-  else
-  {
-    fputs("ERROR: No device URI found in argv[0] or DEVICE_URI environment variable!\n", stderr);
-    return (1);
-  }
-
-  uri[sizeof(uri) - 1] = '\0';
-
- /*
-  * Extract the destination from the URI...
-  */
-
-  if ((sep = strrchr(uri, '@')) != NULL)
-  {
-    username = uri + 6;
-    *sep++ = '\0';
-
-    server = sep;
-
-   /*
-    * Extract password as needed...
-    */
-
-    if ((password = strchr(username, ':')) != NULL)
-      *password++ = '\0';
-    else
-      password = "";
-  }
-  else
-  {
-    username = "";
-    password = "";
-    server   = uri + 6;
-  }
-
-  if ((sep = strchr(server, '/')) == NULL)
-  {
-    fputs("ERROR: Bad URI - need printer name!\n", stderr);
-    return (1);
-  }
-
-  *sep++ = '\0';
-  printer = sep;
-
-  if ((sep = strchr(printer, '/')) != NULL)
-  {
-   /*
-    * Convert to smb://[username:password@]workgroup/server/printer...
-    */
-
-    *sep++ = '\0';
-
-    workgroup = server;
-    server    = printer;
-    printer   = sep;
-  }
-  else
-    workgroup = NULL;
-
- /*
-  * Setup the SAMBA server state...
-  */
-
-  setup_logging("smbspool", True);
-
-  TimeInit();
-  charset_initialise();
-
-  in_client = True;   /* Make sure that we tell lp_load we are */
-
-  if (!lp_load(CONFIGFILE, True, False, False))
-  {
-    fprintf(stderr, "ERROR: Can't load %s - run testparm to debug it\n", CONFIGFILE);
-    return (1);
-  }
-
-  if (workgroup == NULL)
-    workgroup = lp_workgroup();
-
-  codepage_initialise(lp_client_code_page());
-
-  load_interfaces();
-
-  do
-  {
-    if ((cli = smb_connect(workgroup, server, printer, username, password)) == NULL)
-    {
-      if (getenv("CLASS") == NULL)
-      {
-        fprintf(stderr, "ERROR: Unable to connect to SAMBA host, will retry in 60 seconds...");
-        sleep (60);
-      }
-      else
-      {
-        fprintf(stderr, "ERROR: Unable to connect to SAMBA host, trying next printer...");
-        return (1);
-      }
-    }
-  }
-  while (cli == NULL);
-
- /*
-  * Now that we are connected to the server, ignore SIGTERM so that we
-  * can finish out any page data the driver sends (e.g. to eject the
-  * current page...  Only ignore SIGTERM if we are printing data from
-  * stdin (otherwise you can't cancel raw jobs...)
-  */
-
-  if (argc < 7)
-    CatchSignal(SIGTERM, SIG_IGN);
-
- /*
-  * Queue the job...
-  */
-
-  for (i = 0; i < copies; i ++)
-    if ((status = smb_print(cli, argv[3] /* title */, fp)) != 0)
-      break;
-
-  cli_shutdown(cli);
-
- /*
-  * Return the queue status...
-  */
-
-  return (status);
-}
-
-
-/*
- * 'list_devices()' - List the available printers seen on the network...
- */
-
-static void
-list_devices(void)
-{
- /*
-  * Eventually, search the local workgroup for available hosts and printers.
-  */
-
-  puts("network smb \"Unknown\" \"Windows Printer via SAMBA\"");
-}
-
-
-/*
- * 'smb_connect()' - Return a connection to a server.
- */
-
-static struct cli_state *		/* O - SMB connection */
-smb_connect(char *workgroup,		/* I - Workgroup */
-            char *server,		/* I - Server */
-            char *share,		/* I - Printer */
-            char *username,		/* I - Username */
-            char *password)		/* I - Password */
-{
-  struct cli_state	*c;		/* New connection */
-  struct nmb_name	called,		/* NMB name of server */
-			calling;	/* NMB name of client */
-  struct in_addr	ip;		/* IP address of server */
-  pstring		myname;		/* Client name */
-
-
- /*
-  * Get the names and addresses of the client and server...
-  */
-
-  get_myname(myname);  
-
-  zero_ip(&ip);
-
-  make_nmb_name(&calling, myname, 0x0);
-  make_nmb_name(&called, server, 0x20);
-
- /*
-  * Open a new connection to the SMB server...
-  */
-
-  if ((c = cli_initialise(NULL)) == NULL)
-  {
-    fputs("ERROR: cli_initialise() failed...\n", stderr);
-    return (NULL);
-  }
-
-  if (!cli_set_port(c, SMB_PORT))
-  {
-    fputs("ERROR: cli_set_port() failed...\n", stderr);
-    cli_shutdown(c);
-    return (NULL);
-  }
-
-  if (!cli_connect(c, server, &ip))
-  {
-    fputs("ERROR: cli_connect() failed...\n", stderr);
-    cli_shutdown(c);
-    return (NULL);
-  }
-
-  if (!cli_session_request(c, &calling, &called))
-  {
-    fputs("ERROR: cli_session_request() failed...\n", stderr);
-    cli_shutdown(c);
-    return (NULL);
-  }
-
-  if (!cli_negprot(c))
-  {
-    fputs("ERROR: SMB protocol negotiation failed\n", stderr);
-    cli_shutdown(c);
-    return (NULL);
-  }
-
- /*
-  * Do password stuff...
-  */
-
-  if (!cli_session_setup(c, username, 
-			 password, strlen(password),
-			 password, strlen(password),
-			 workgroup))
-  {
-    fprintf(stderr, "ERROR: SMB session setup failed: %s\n", cli_errstr(c));
-    cli_shutdown(c);
-    return (NULL);
-  }
-
-  if (!cli_send_tconX(c, share, "?????",
-		      password, strlen(password)+1))
-  {
-    fprintf(stderr, "ERROR: SMB tree connect failed: %s\n", cli_errstr(c));
-    cli_shutdown(c);
-    return (NULL);
-  }
-
- /*
-  * Return the new connection...
-  */
-
-  return (c);
-}
-
-
-/*
- * 'smb_print()' - Queue a job for printing using the SMB protocol.
- */
-
-static int				/* O - 0 = success, non-0 = failure */
-smb_print(struct cli_state *cli,	/* I - SMB connection */
-          char             *title,	/* I - Title/job name */
-          FILE             *fp)		/* I - File to print */
-{
-  int	fnum;		/* File number */
-  int	nbytes,		/* Number of bytes read */
-	tbytes;		/* Total bytes read */
-  char	buffer[8192],	/* Buffer for copy */
-	*ptr;		/* Pointer into tile */
-
-
- /*
-  * Sanitize the title...
-  */
-
-  for (ptr = title; *ptr; ptr ++)
-    if (!isalnum((int)*ptr) && !isspace((int)*ptr))
-      *ptr = '_';
-
- /*
-  * Open the printer device...
-  */
-
-  if ((fnum = cli_open(cli, title, O_RDWR | O_CREAT | O_TRUNC, DENY_NONE)) == -1)
-  {
-    fprintf(stderr, "ERROR: %s opening remote file %s\n",
-            cli_errstr(cli), title);
-    return (1);
-  }
-
- /*
-  * Copy the file to the printer...
-  */
-
-  if (fp != stdin)
-    rewind(fp);
-
-  tbytes = 0;
-
-  while ((nbytes = fread(buffer, 1, sizeof(buffer), fp)) > 0)
-  {
-    if (cli_write(cli, fnum, 0, buffer, tbytes, nbytes) != nbytes)
-    {
-      fprintf(stderr, "ERROR: Error writing file: %s\n", cli_errstr(cli));
-      break;
-    }
-
-    tbytes += nbytes;
-  } 
-
-  if (!cli_close(cli, fnum))
-  {
-    fprintf(stderr, "ERROR: %s closing remote file %s\n",
-            cli_errstr(cli), title);
-    return (1);
-  }
-  else
-    return (0);
-}
diff -Naur samba-2.2.12-orig/source/include/libsmbclient.h samba-2.2.12/source/include/libsmbclient.h
--- samba-2.2.12-orig/source/include/libsmbclient.h	2004-08-12 20:24:29.000000000 +0200
+++ samba-2.2.12/source/include/libsmbclient.h	2011-03-04 12:58:15.000000000 +0100
@@ -119,37 +119,6 @@
 #ifndef _CLIENT_H
 typedef unsigned short uint16;
 
-/**@ingroup structure
- * Structure that represents a print job.
- *
- */
-struct print_job_info 
-{
-	/** numeric ID of the print job
-	 */
-	uint16 id;
-    
-	/** represents print job priority (lower numbers mean higher priority)
-	 */
-	uint16 priority;
-    
-	/** Size of the print job
-	 */
-	size_t size;
-    
-	/** Name of the user that owns the print job
-	 */
-	char user[128];
-  
-	/** Name of the print job. This will have no name if an anonymous print
-	 *  file was opened. Ie smb://server/printer
-	 */
-	char name[128];
-
-	/** Time the print job was spooled
-	 */
-	time_t t;
-};
 #endif
 
 
@@ -189,14 +158,6 @@
                                       char *pw, int pwlen);
 
 
-/**@ingroup structure
- * Print job info callback function type.
- *
- * @param i         pointer to print job information structure
- *
- */ 
-typedef void (*smbc_get_print_job_info)(struct print_job_info *i);
-
 
 /**@ingroup misc
  * Initialize the samba client library.
@@ -728,64 +689,4 @@
 int smbc_chmod(const char *url, mode_t mode);
 
 
-/**@ingroup print
- * Print a file given the name in fname. It would be a URL ...
- * 
- * @param fname     The URL of a file on a remote SMB server that the
- *                  caller wants printed
- *
- * @param printq    The URL of the print share to print the file to.
- *
- * @return          0 on success, < 0 on error with errno set:         
- *
- *                  - EINVAL fname or printq was NULL or smbc_init not
- * 		      not called.
- *                  and errors returned by smbc_open
- *
- */                                     
-int smbc_print_file(const char *fname, const char *printq);
-
-/**@ingroup print
- * Open a print file that can be written to by other calls. This simply
- * does an smbc_open call after checking if there is a file name on the
- * URI. If not, a temporary name is added ...
- *
- * @param fname     The URL of the print share to print to?
- *
- * @returns         A file handle for the print file if successful.
- *                  Returns -1 if an error ocurred and errno has the values
- *                  - EINVAL fname was NULL or smbc_init not called.
- *                  - all errors returned by smbc_open
- *
- */
-int smbc_open_print_job(const char *fname);
-
-/**@ingroup print
- * List the print jobs on a print share, for the moment, pass a callback 
- *
- * @param purl      The url of the print share to list the jobs of
- * 
- * @param fn        Callback function the receives printjob info
- * 
- * @return          0 on success, < 0 on error with errno set: 
- *                  - EINVAL fname was NULL or smbc_init not called
- *                  - EACCES ???
- */
-int smbc_list_print_jobs(const char *purl, smbc_get_print_job_info fn);
-
-/**@ingroup print
- * Delete a print job 
- *
- * @param purl      Url of the print share
- *
- * @param id        The id of the job to delete
- *
- * @return          0 on success, < 0 on error with errno set: 
- *                  - EINVAL fname was NULL or smbc_init not called
- *
- * @todo    what errno values are possible here?
- */
-int smbc_unlink_print_job(const char *purl, int id);
-
-
 #endif /* SMBCLIENT_H_INCLUDED */
diff -Naur samba-2.2.12-orig/source/include/ntdomain.h samba-2.2.12/source/include/ntdomain.h
--- samba-2.2.12-orig/source/include/ntdomain.h	2004-08-12 20:24:29.000000000 +0200
+++ samba-2.2.12/source/include/ntdomain.h	2011-03-04 12:58:15.000000000 +0100
@@ -271,8 +271,7 @@
 
 #define PRINT_INFO_FN(fn)\
         void (*fn)(const char*, uint32, uint32, void  *const *const)
-#define JOB_INFO_FN(fn)\
-        void (*fn)(const char*, const char*, uint32, uint32, void *const *const)
+
 
 /* end higher order functions */
 
@@ -287,7 +286,6 @@
 #include "rpc_samr.h"
 #include "rpc_srvsvc.h"
 #include "rpc_wkssvc.h"
-#include "rpc_spoolss.h"
 #include "rpc_dfs.h"
 #include "sids.h"
 
diff -Naur samba-2.2.12-orig/source/include/nt_printing.h samba-2.2.12/source/include/nt_printing.h
--- samba-2.2.12-orig/source/include/nt_printing.h	2004-08-12 20:24:29.000000000 +0200
+++ samba-2.2.12/source/include/nt_printing.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,337 +0,0 @@
-/*
-   Unix SMB/Netbios implementation.
-   Version 1.9.
-   SMB parameters and setup
-   Copyright (C) Andrew Tridgell              1992-2000,
-   Copyright (C) Jean Francois Micouleau      1998-2000.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2 of the License, or
-   (at your option) any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-*/
-
-#ifndef NT_PRINTING_H_
-#define NT_PRINTING_H_
-
-#define ORIENTATION      0x00000001L
-#define PAPERSIZE        0x00000002L
-#define PAPERLENGTH      0x00000004L
-#define PAPERWIDTH       0x00000008L
-#define SCALE            0x00000010L
-#define COPIES           0x00000100L
-#define DEFAULTSOURCE    0x00000200L
-#define PRINTQUALITY     0x00000400L
-#define COLOR            0x00000800L
-#define DUPLEX           0x00001000L
-#define YRESOLUTION      0x00002000L
-#define TTOPTION         0x00004000L
-#define COLLATE          0x00008000L
-#define FORMNAME         0x00010000L
-#define LOGPIXELS        0x00020000L
-#define BITSPERPEL       0x00040000L
-#define PELSWIDTH        0x00080000L
-#define PELSHEIGHT       0x00100000L
-#define DISPLAYFLAGS     0x00200000L
-#define DISPLAYFREQUENCY 0x00400000L
-#define PANNINGWIDTH     0x00800000L
-#define PANNINGHEIGHT    0x01000000L
-
-#define ORIENT_PORTRAIT   1
-#define ORIENT_LANDSCAPE  2
-
-#define PAPER_FIRST                PAPER_LETTER
-#define PAPER_LETTER               1  /* Letter 8 1/2 x 11 in               */
-#define PAPER_LETTERSMALL          2  /* Letter Small 8 1/2 x 11 in         */
-#define PAPER_TABLOID              3  /* Tabloid 11 x 17 in                 */
-#define PAPER_LEDGER               4  /* Ledger 17 x 11 in                  */
-#define PAPER_LEGAL                5  /* Legal 8 1/2 x 14 in                */
-#define PAPER_STATEMENT            6  /* Statement 5 1/2 x 8 1/2 in         */
-#define PAPER_EXECUTIVE            7  /* Executive 7 1/4 x 10 1/2 in        */
-#define PAPER_A3                   8  /* A3 297 x 420 mm                    */
-#define PAPER_A4                   9  /* A4 210 x 297 mm                    */
-#define PAPER_A4SMALL             10  /* A4 Small 210 x 297 mm              */
-#define PAPER_A5                  11  /* A5 148 x 210 mm                    */
-#define PAPER_B4                  12  /* B4 (JIS) 250 x 354                 */
-#define PAPER_B5                  13  /* B5 (JIS) 182 x 257 mm              */
-#define PAPER_FOLIO               14  /* Folio 8 1/2 x 13 in                */
-#define PAPER_QUARTO              15  /* Quarto 215 x 275 mm                */
-#define PAPER_10X14               16  /* 10x14 in                           */
-#define PAPER_11X17               17  /* 11x17 in                           */
-#define PAPER_NOTE                18  /* Note 8 1/2 x 11 in                 */
-#define PAPER_ENV_9               19  /* Envelope #9 3 7/8 x 8 7/8          */
-#define PAPER_ENV_10              20  /* Envelope #10 4 1/8 x 9 1/2         */
-#define PAPER_ENV_11              21  /* Envelope #11 4 1/2 x 10 3/8        */
-#define PAPER_ENV_12              22  /* Envelope #12 4 \276 x 11           */
-#define PAPER_ENV_14              23  /* Envelope #14 5 x 11 1/2            */
-#define PAPER_CSHEET              24  /* C size sheet                       */
-#define PAPER_DSHEET              25  /* D size sheet                       */
-#define PAPER_ESHEET              26  /* E size sheet                       */
-#define PAPER_ENV_DL              27  /* Envelope DL 110 x 220mm            */
-#define PAPER_ENV_C5              28  /* Envelope C5 162 x 229 mm           */
-#define PAPER_ENV_C3              29  /* Envelope C3  324 x 458 mm          */
-#define PAPER_ENV_C4              30  /* Envelope C4  229 x 324 mm          */
-#define PAPER_ENV_C6              31  /* Envelope C6  114 x 162 mm          */
-#define PAPER_ENV_C65             32  /* Envelope C65 114 x 229 mm          */
-#define PAPER_ENV_B4              33  /* Envelope B4  250 x 353 mm          */
-#define PAPER_ENV_B5              34  /* Envelope B5  176 x 250 mm          */
-#define PAPER_ENV_B6              35  /* Envelope B6  176 x 125 mm          */
-#define PAPER_ENV_ITALY           36  /* Envelope 110 x 230 mm              */
-#define PAPER_ENV_MONARCH         37  /* Envelope Monarch 3.875 x 7.5 in    */
-#define PAPER_ENV_PERSONAL        38  /* 6 3/4 Envelope 3 5/8 x 6 1/2 in    */
-#define PAPER_FANFOLD_US          39  /* US Std Fanfold 14 7/8 x 11 in      */
-#define PAPER_FANFOLD_STD_GERMAN  40  /* German Std Fanfold 8 1/2 x 12 in   */
-#define PAPER_FANFOLD_LGL_GERMAN  41  /* German Legal Fanfold 8 1/2 x 13 in */
-
-#define PAPER_LAST                PAPER_FANFOLD_LGL_GERMAN
-#define PAPER_USER                256
-
-#define BIN_FIRST         BIN_UPPER
-#define BIN_UPPER         1
-#define BIN_ONLYONE       1
-#define BIN_LOWER         2
-#define BIN_MIDDLE        3
-#define BIN_MANUAL        4
-#define BIN_ENVELOPE      5
-#define BIN_ENVMANUAL     6
-#define BIN_AUTO          7
-#define BIN_TRACTOR       8
-#define BIN_SMALLFMT      9
-#define BIN_LARGEFMT      10
-#define BIN_LARGECAPACITY 11
-#define BIN_CASSETTE      14
-#define BIN_FORMSOURCE    15
-#define BIN_LAST          BIN_FORMSOURCE
-
-#define BIN_USER          256     /* device specific bins start here */
-
-#define RES_DRAFT         (-1)
-#define RES_LOW           (-2)
-#define RES_MEDIUM        (-3)
-#define RES_HIGH          (-4)
-
-#define COLOR_MONOCHROME  1
-#define COLOR_COLOR       2
-
-#define DUP_SIMPLEX    1
-#define DUP_VERTICAL   2
-#define DUP_HORIZONTAL 3
-
-#define TT_BITMAP     1       /* print TT fonts as graphics */
-#define TT_DOWNLOAD   2       /* download TT fonts as soft fonts */
-#define TT_SUBDEV     3       /* substitute device fonts for TT fonts */
-
-#define COLLATE_FALSE  0
-#define COLLATE_TRUE   1
-
-typedef struct nt_printer_driver_info_level_3
-{
-	uint32 cversion;
-
-	fstring name;
-	fstring environment;
-	fstring driverpath;
-	fstring datafile;
-	fstring configfile;
-	fstring helpfile;
-	fstring monitorname;
-	fstring defaultdatatype;
-	fstring *dependentfiles;
-} NT_PRINTER_DRIVER_INFO_LEVEL_3;
-
-/* SPOOL_PRINTER_DRIVER_INFO_LEVEL_6 structure */
-typedef struct {
-	uint32	version;
-	fstring	name;
-	fstring	environment;
-	fstring	driverpath;
-	fstring	datafile;
-	fstring	configfile;
-	fstring	helpfile;
-	fstring	monitorname;
-	fstring	defaultdatatype;
-	fstring	mfgname;
-	fstring	oemurl;
-	fstring	hardwareid;
-	fstring	provider;
-	fstring *dependentfiles;
-	fstring *previousnames;
-} NT_PRINTER_DRIVER_INFO_LEVEL_6;
-
-
-typedef struct nt_printer_driver_info_level
-{
-	NT_PRINTER_DRIVER_INFO_LEVEL_3 *info_3;
-	NT_PRINTER_DRIVER_INFO_LEVEL_6 *info_6;
-} NT_PRINTER_DRIVER_INFO_LEVEL;
-
-typedef struct nt_printer_param
-{
-	fstring value;
-	uint32 type;
-	uint8 *data;
-	int data_len;
-	struct nt_printer_param *next;
-} NT_PRINTER_PARAM;
-
-#define MAXDEVICENAME	32
-
-typedef struct ntdevicemode
-{
-	fstring	devicename;
-	fstring	formname;
-
-	uint16	specversion;
-	uint16	driverversion;
-	uint16	size;
-	uint16	driverextra;
-	uint16	orientation;
-	uint16	papersize;
-	uint16	paperlength;
-	uint16	paperwidth;
-	uint16	scale;
-	uint16	copies;
-	uint16	defaultsource;
-	uint16	printquality;
-	uint16	color;
-	uint16	duplex;
-	uint16	yresolution;
-	uint16	ttoption;
-	uint16	collate;
-	uint16	logpixels;
-
-	uint32	fields;
-	uint32	bitsperpel;
-	uint32	pelswidth;
-	uint32	pelsheight;
-	uint32	displayflags;
-	uint32	displayfrequency;
-	uint32	icmmethod;
-	uint32	icmintent;
-	uint32	mediatype;
-	uint32	dithertype;
-	uint32	reserved1;
-	uint32	reserved2;
-	uint32	panningwidth;
-	uint32	panningheight;
-	uint8 	*private;
-} NT_DEVICEMODE;
-
-typedef struct nt_printer_info_level_2
-{
-	uint32 attributes;
-	uint32 priority;
-	uint32 default_priority;
-	uint32 starttime;
-	uint32 untiltime;
-	uint32 status;
-	uint32 cjobs;
-	uint32 averageppm;
-	fstring servername;
-	fstring printername;
-	fstring sharename;
-	fstring portname;
-	fstring drivername;
-	pstring comment;
-	fstring location;
-	NT_DEVICEMODE *devmode;
-	fstring sepfile;
-	fstring printprocessor;
-	fstring datatype;
-	fstring parameters;
-	NT_PRINTER_PARAM *specific;
-	SEC_DESC_BUF *secdesc_buf;
-	/* not used but ... and how ??? */
-	uint32 changeid;
-	uint32 c_setprinter;
-	uint32 setuptime;	
-} NT_PRINTER_INFO_LEVEL_2;
-
-typedef struct nt_printer_info_level
-{
-	NT_PRINTER_INFO_LEVEL_2 *info_2;
-} NT_PRINTER_INFO_LEVEL;
-
-typedef struct
-{
-	fstring name;
-	uint32 flag;
-	uint32 width;
-	uint32 length;
-	uint32 left;
-	uint32 top;
-	uint32 right;
-	uint32 bottom;
-} nt_forms_struct;
-
-/*
-typedef struct _form
-{
-       uint32 flags;
-       uint32 name_ptr;
-       uint32 size_x;
-       uint32 size_y;
-       uint32 left;
-       uint32 top;
-       uint32 right;
-       uint32 bottom;
-       UNISTR2 name;
-} FORM;
-*/
-
-#ifndef SAMBA_PRINTER_PORT_NAME
-#define SAMBA_PRINTER_PORT_NAME "Samba Printer Port"
-#endif
-
-/* DOS header format */
-#define DOS_HEADER_SIZE                 64
-#define DOS_HEADER_MAGIC_OFFSET         0
-#define DOS_HEADER_MAGIC                0x5A4D
-#define DOS_HEADER_LFANEW_OFFSET        60
-
-/* New Executable format (Win or OS/2 1.x segmented) */
-#define NE_HEADER_SIZE                  64
-#define NE_HEADER_SIGNATURE_OFFSET      0
-#define NE_HEADER_SIGNATURE             0x454E
-#define NE_HEADER_TARGET_OS_OFFSET      54
-#define NE_HEADER_TARGOS_WIN            0x02
-#define NE_HEADER_MINOR_VER_OFFSET      62
-#define NE_HEADER_MAJOR_VER_OFFSET      63
-
-/* Portable Executable format */
-#define PE_HEADER_SIZE                  248
-#define PE_HEADER_SIGNATURE_OFFSET      0
-#define PE_HEADER_SIGNATURE             0x00004550
-#define PE_HEADER_MACHINE_OFFSET        4
-#define PE_HEADER_MACHINE_I386          0x14c
-#define PE_HEADER_NUMBER_OF_SECTIONS    6
-#define PE_HEADER_MAJOR_OS_VER_OFFSET   64
-#define PE_HEADER_MINOR_OS_VER_OFFSET   66
-#define PE_HEADER_MAJOR_IMG_VER_OFFSET  68
-#define PE_HEADER_MINOR_IMG_VER_OFFSET  70
-#define PE_HEADER_MAJOR_SS_VER_OFFSET   72
-#define PE_HEADER_MINOR_SS_VER_OFFSET   74
-#define PE_HEADER_SECT_HEADER_SIZE      40
-#define PE_HEADER_SECT_NAME_OFFSET      0
-#define PE_HEADER_SECT_SIZE_DATA_OFFSET 16
-#define PE_HEADER_SECT_PTR_DATA_OFFSET  20
-
-/* Microsoft file version format */
-#define VS_SIGNATURE                    "VS_VERSION_INFO"
-#define VS_MAGIC_VALUE                  0xfeef04bd
-#define VS_MAJOR_OFFSET					8
-#define VS_MINOR_OFFSET					12
-#define VS_VERSION_INFO_UNICODE_SIZE    (sizeof(VS_SIGNATURE)*2+4+VS_MINOR_OFFSET+4) /* not true size! */
-#define VS_VERSION_INFO_SIZE            (sizeof(VS_SIGNATURE)+4+VS_MINOR_OFFSET+4)   /* not true size! */
-#define VS_NE_BUF_SIZE                  4096  /* Must be > 2*VS_VERSION_INFO_SIZE */
-
-#endif /* NT_PRINTING_H_ */
diff -Naur samba-2.2.12-orig/source/include/printing.h samba-2.2.12/source/include/printing.h
--- samba-2.2.12-orig/source/include/printing.h	2004-08-12 20:24:29.000000000 +0200
+++ samba-2.2.12/source/include/printing.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,77 +0,0 @@
-#ifndef PRINTING_H_
-#define PRINTING_H_
-
-/* 
-   Unix SMB/Netbios implementation.
-   Version 3.0
-   printing definitions
-   Copyright (C) Andrew Tridgell 1992-2000
-   
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2 of the License, or
-   (at your option) any later version.
-   
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-   
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-*/
-
-#include "includes.h"
-
-/*
-   This file defines the low-level printing system interfaces used by the
-   SAMBA printing subsystem.
-*/
-
-/* Information for print jobs */
-struct printjob {
-	pid_t pid; /* which process launched the job */
-	int sysjob; /* the system (lp) job number */
-	int fd; /* file descriptor of open file if open */
-	time_t starttime; /* when the job started spooling */
-	int status; /* the status of this job */
-	size_t size; /* the size of the job so far */
-	int page_count;	/* then number of pages so far */
-	BOOL spooled; /* has it been sent to the spooler yet? */
-	BOOL smbjob; /* set if the job is a SMB job */
-	fstring filename; /* the filename used to spool the file */
-	fstring jobname; /* the job name given to us by the client */
-	fstring user; /* the user who started the job */
-	fstring queuename; /* service number of printer for this job */
-};
-
-/* Information for print interfaces */
-struct printif
-{
-  int (*queue_get)(int snum, print_queue_struct **q,
-                   print_status_struct *status);
-  int (*queue_pause)(int snum);
-  int (*queue_resume)(int snum);
-  int (*job_delete)(int snum, struct printjob *pjob);
-  int (*job_pause)(int snum, struct printjob *pjob);
-  int (*job_resume)(int snum, struct printjob *pjob);
-  int (*job_submit)(int snum, struct printjob *pjob);
-};
-
-extern struct printif	generic_printif;
-
-#ifdef HAVE_CUPS
-extern struct printif	cups_printif;
-#endif /* HAVE_CUPS */
-
-/* PRINT_MAX_JOBID is now defined in local.h */
-#define UNIX_JOB_START PRINT_MAX_JOBID
-#define NEXT_JOBID(j) ((j+1) % PRINT_MAX_JOBID > 0 ? (j+1) % PRINT_MAX_JOBID : 1)
-
-#define MAX_CACHE_VALID_TIME 3600
-
-#define PRINT_SPOOL_PREFIX "smbprn."
-#define PRINT_DATABASE_VERSION 4
-
-#endif /* PRINTING_H_ */
diff -Naur samba-2.2.12-orig/source/include/proto.h samba-2.2.12/source/include/proto.h
--- samba-2.2.12-orig/source/include/proto.h	2004-08-12 20:25:49.000000000 +0200
+++ samba-2.2.12/source/include/proto.h	2011-03-04 13:11:10.000000000 +0100
@@ -417,11 +417,6 @@
                                       struct ntuser_creds *creds);
 void cli_pipe_shutdown(struct cli_state *cli);
 
-/* The following definitions come from libsmb/cliprint.c  */
-
-int cli_print_queue(struct cli_state *cli, 
-		    void (*fn)(struct print_job_info *));
-int cli_printjob_del(struct cli_state *cli, int job);
 
 /* The following definitions come from libsmb/clirap.c  */
 
@@ -564,76 +559,6 @@
 			    TALLOC_CTX *mem_ctx);
 BOOL cli_set_secdesc(struct cli_state *cli, int fnum, SEC_DESC *sd);
 
-/* The following definitions come from libsmb/cli_spoolss.c  */
-
-struct cli_state *cli_spoolss_initialise(struct cli_state *cli, 
-					 char *system_name,
-					 struct ntuser_creds *creds);
-WERROR cli_spoolss_open_printer_ex(struct cli_state *cli, TALLOC_CTX *mem_ctx,
-				char *printername, const char *datatype, uint32 access_required,
-				char *station, char *username, POLICY_HND *pol);
-WERROR cli_spoolss_close_printer(struct cli_state *cli, TALLOC_CTX *mem_ctx,
-				POLICY_HND *pol);
-WERROR cli_spoolss_enum_printers(struct cli_state *cli, TALLOC_CTX *mem_ctx,
-				 uint32 offered, uint32 *needed,
-				 uint32 flags, uint32 level,
-				 uint32 *num_printers, PRINTER_INFO_CTR *ctr);
-WERROR cli_spoolss_enum_ports(struct cli_state *cli, TALLOC_CTX *mem_ctx,
-			      uint32 offered, uint32 *needed,
-			      uint32 level, int *num_ports, PORT_INFO_CTR *ctr);
-WERROR cli_spoolss_getprinter(struct cli_state *cli, TALLOC_CTX *mem_ctx,
-			      uint32 offered, uint32 *needed,
-			      POLICY_HND *pol, uint32 level, 
-			      PRINTER_INFO_CTR *ctr);
-WERROR cli_spoolss_setprinter(struct cli_state *cli, TALLOC_CTX *mem_ctx,
-			      POLICY_HND *pol, uint32 level, 
-			      PRINTER_INFO_CTR *ctr, uint32 command);
-WERROR cli_spoolss_getprinterdriver(struct cli_state *cli, 
-				    TALLOC_CTX *mem_ctx, 
-				    uint32 offered, uint32 *needed,
-				    POLICY_HND *pol, uint32 level, 
-				    const char *env, PRINTER_DRIVER_CTR *ctr);
-WERROR cli_spoolss_enumprinterdrivers (struct cli_state *cli, 
-				       TALLOC_CTX *mem_ctx,
-				       uint32 offered, uint32 *needed,
-				       uint32 level, const char *env,
-				       uint32 *num_drivers,
-				PRINTER_DRIVER_CTR *ctr);
-WERROR cli_spoolss_getprinterdriverdir (struct cli_state *cli, 
-					TALLOC_CTX *mem_ctx,
-					uint32 offered, uint32 *needed,
-					uint32 level, char *env,
-					DRIVER_DIRECTORY_CTR *ctr);
-WERROR cli_spoolss_addprinterdriver (struct cli_state *cli, 
-				     TALLOC_CTX *mem_ctx, uint32 level,
-				     PRINTER_DRIVER_CTR *ctr);
-WERROR cli_spoolss_addprinterex (struct cli_state *cli, TALLOC_CTX *mem_ctx,
-				 uint32 level, PRINTER_INFO_CTR*ctr);
-WERROR cli_spoolss_deleteprinterdriver (struct cli_state *cli, 
-					TALLOC_CTX *mem_ctx, const char *arch,
-					char *driver);
-WERROR cli_spoolss_getprintprocessordirectory(struct cli_state *cli,
-					      TALLOC_CTX *mem_ctx,
-					      uint32 offered, uint32 *needed,
-					      char *name, char *environment,
-					      fstring procdir);
-WERROR cli_spoolss_addform(struct cli_state *cli, TALLOC_CTX *mem_ctx,
-			   POLICY_HND *handle, uint32 level, FORM *form);
-WERROR cli_spoolss_setform(struct cli_state *cli, TALLOC_CTX *mem_ctx,
-			   POLICY_HND *handle, uint32 level, char *form_name,
-			   FORM *form);
-WERROR cli_spoolss_getform(struct cli_state *cli, TALLOC_CTX *mem_ctx,
-			   uint32 offered, uint32 *needed,
-			   POLICY_HND *handle, char *formname, uint32 level, 
-			   FORM_1 *form);
-WERROR cli_spoolss_deleteform(struct cli_state *cli, TALLOC_CTX *mem_ctx,
-			      POLICY_HND *handle, char *form_name);
-WERROR cli_spoolss_enumforms(struct cli_state *cli, TALLOC_CTX *mem_ctx,
-			     uint32 offered, uint32 *needed,
-			     POLICY_HND *handle, int level, uint32 *num_forms,
-			     FORM_1 **forms);
-WERROR cli_spoolss_setprinterdata (struct cli_state *cli, TALLOC_CTX *mem_ctx,
-					POLICY_HND *pol, char* valname, char* value);
 
 /* The following definitions come from libsmb/cli_srvsvc.c  */
 
@@ -1918,8 +1843,6 @@
 char *lp_serverstring(void);
 char *lp_printcapname(void);
 char *lp_enumports_cmd(void);
-char *lp_addprinter_cmd(void);
-char *lp_deleteprinter_cmd(void);
 char *lp_os2_driver_map(void);
 char *lp_lockdir(void);
 char *lp_piddir(void);
@@ -1992,14 +1915,12 @@
 BOOL lp_ssl_reqClientCert(void);
 BOOL lp_ssl_reqServerCert(void);
 BOOL lp_ssl_compatibility(void);
-BOOL lp_ms_add_printer_wizard(void);
 BOOL lp_dns_proxy(void);
 BOOL lp_wins_support(void);
 BOOL lp_we_are_a_wins_server(void);
 BOOL lp_wins_proxy(void);
 BOOL lp_local_master(void);
 BOOL lp_domain_logons(void);
-BOOL lp_load_printers(void);
 BOOL lp_use_rhosts(void);
 BOOL lp_readprediction(void);
 BOOL lp_readbmpx(void);
@@ -2054,7 +1975,6 @@
 int lp_lpqcachetime(void);
 int lp_max_smbd_processes(void);
 int lp_disable_spoolss(void);
-int lp_totalprintjobs(void);
 int lp_syslog(void);
 int lp_client_code_page(void);
 int lp_lm_announce(void);
@@ -2088,7 +2008,6 @@
 char *lp_queuepausecommand(int );
 char *lp_queueresumecommand(int );
 char *lp_driverfile(int );
-char *lp_printerdriver(int );
 char *lp_hostsallow(int );
 char *lp_hostsdeny(int );
 char *lp_magicscript(int );
@@ -2098,7 +2017,6 @@
 char *lp_force_group(int );
 char *lp_readlist(int );
 char *lp_writelist(int );
-char *lp_printer_admin(int );
 char *lp_fstype(int );
 char *lp_vfsobj(int );
 char *lp_vfs_options(int );
@@ -2178,7 +2096,6 @@
 BOOL lp_hide_local_users(void);
 BOOL lp_add_home(char *pszHomename, int iDefaultService, char *pszHomedir);
 int lp_add_service(char *pszService, int iDefaultService);
-BOOL lp_add_printer(char *pszPrintername, int iDefaultService);
 BOOL lp_file_list_changed(void);
 BOOL lp_winbind_uid(uid_t *low, uid_t *high);
 BOOL lp_winbind_gid(gid_t *low, gid_t *high);
@@ -2188,7 +2105,6 @@
 BOOL lp_is_default(int snum, struct parm_struct *parm);
 struct parm_struct *lp_next_parameter(int snum, int *i, int allparameters);
 BOOL lp_snum_ok(int iService);
-void lp_add_one_printer(char *name, char *comment);
 BOOL lp_loaded(void);
 void lp_killunused(BOOL (*snumused) (int));
 void lp_killservice(int iServiceIn);
@@ -2209,11 +2125,9 @@
 int lp_major_announce_version(void);
 int lp_minor_announce_version(void);
 void lp_set_name_resolve_order(char *new_order);
-char *lp_printername(int snum);
 void get_private_directory(pstring priv_dir);
 void lp_set_logfile(const char *name);
 const char *get_called_name(void);
-int lp_maxprintjobs(int snum);
 
 /* The following definitions come from param/params.c  */
 
@@ -2405,116 +2319,6 @@
 
 BOOL migrate_from_old_password_file(char *domain);
 
-/* The following definitions come from printing/load.c  */
-
-void add_all_printers(void);
-void load_printers(void);
-
-/* The following definitions come from printing/lpq_parse.c  */
-
-BOOL parse_lpq_entry(int snum,char *line,
-		     print_queue_struct *buf,
-		     print_status_struct *status,BOOL first);
-
-/* The following definitions come from printing/nt_printing.c  */
-
-BOOL nt_printing_init(void);
-uint32 update_c_setprinter(BOOL initialize);
-uint32 get_c_setprinter(void);
-int get_builtin_ntforms(nt_forms_struct **list);
-BOOL get_a_builtin_ntform(UNISTR2 *uni_formname,nt_forms_struct *form);
-int get_ntforms(nt_forms_struct **list);
-int write_ntforms(nt_forms_struct **list, int number);
-BOOL add_a_form(nt_forms_struct **list, const FORM *form, int *count);
-BOOL delete_a_form(nt_forms_struct **list, UNISTR2 *del_name, int *count, WERROR *ret);
-void update_a_form(nt_forms_struct **list, const FORM *form, int count);
-int get_ntdrivers(fstring **list, char *architecture, uint32 version);
-BOOL get_short_archi(char *short_archi, const char *long_archi);
-WERROR clean_up_driver_struct(NT_PRINTER_DRIVER_INFO_LEVEL driver_abstract,
-							  uint32 level, struct current_user *user);
-BOOL move_driver_to_download_area(NT_PRINTER_DRIVER_INFO_LEVEL driver_abstract, uint32 level, 
-				  struct current_user *user, WERROR *perr);
-uint32 get_a_printer_driver_9x_compatible(pstring line, const fstring model);
-uint32 del_a_printer(char *sharename);
-void add_a_specific_param(NT_PRINTER_INFO_LEVEL_2 *info_2, NT_PRINTER_PARAM **param);
-BOOL unlink_specific_param_if_exist(NT_PRINTER_INFO_LEVEL_2 *info_2, NT_PRINTER_PARAM *param);
-void free_nt_printer_param(NT_PRINTER_PARAM **param_ptr);
-NT_DEVICEMODE *construct_nt_devicemode(const fstring default_devicename);
-NT_DEVICEMODE *dup_nt_devicemode(NT_DEVICEMODE *nt_devicemode);
-void free_nt_devicemode(NT_DEVICEMODE **devmode_ptr);
-void get_printer_subst_params(int snum, fstring *printername, fstring *sharename, fstring *portname);
-WERROR mod_a_printer(NT_PRINTER_INFO_LEVEL printer, uint32 level);
-BOOL set_driver_init(NT_PRINTER_INFO_LEVEL *printer, uint32 level);
-BOOL del_driver_init(char *drivername);
-uint32 update_driver_init(NT_PRINTER_INFO_LEVEL printer, uint32 level);
-WERROR save_driver_init(NT_PRINTER_INFO_LEVEL *printer, uint32 level, NT_PRINTER_PARAM *param);
-WERROR get_a_printer(NT_PRINTER_INFO_LEVEL **pp_printer, uint32 level, fstring sharename);
-uint32 free_a_printer(NT_PRINTER_INFO_LEVEL **pp_printer, uint32 level);
-uint32 add_a_printer_driver(NT_PRINTER_DRIVER_INFO_LEVEL driver, uint32 level);
-WERROR get_a_printer_driver(NT_PRINTER_DRIVER_INFO_LEVEL *driver, uint32 level,
-                            fstring drivername, const fstring architecture, uint32 version);
-uint32 free_a_printer_driver(NT_PRINTER_DRIVER_INFO_LEVEL driver, uint32 level);
-BOOL printer_driver_in_use ( NT_PRINTER_DRIVER_INFO_LEVEL_3 *info_3 );
-WERROR delete_printer_driver( NT_PRINTER_DRIVER_INFO_LEVEL_3 *info_3, struct current_user *user,
-                              uint32 version, BOOL delete_files );
-BOOL get_specific_param_by_index(NT_PRINTER_INFO_LEVEL printer, uint32 level, uint32 param_index,
-                                 fstring value, uint8 **data, uint32 *type, uint32 *len);
-BOOL get_specific_param(NT_PRINTER_INFO_LEVEL printer, uint32 level,
-                        fstring value, uint8 **data, uint32 *type, uint32 *len);
-WERROR nt_printing_setsec(char *printername, SEC_DESC_BUF *secdesc_ctr);
-BOOL nt_printing_getsec(TALLOC_CTX *ctx, char *printername, SEC_DESC_BUF **secdesc_ctr);
-void map_printer_permissions(SEC_DESC *sd);
-BOOL print_access_check(struct current_user *user, int snum, int access_type);
-BOOL print_time_access_check(int snum);
-WERROR printer_write_default_dev(int snum, const PRINTER_DEFAULT *printer_default);
-
-/* The following definitions come from printing/pcap.c  */
-
-BOOL pcap_printername_ok(char *pszPrintername, const char *pszPrintcapname);
-void pcap_printer_fn(void (*fn)(char *, char *));
-
-/* The following definitions come from printing/print_cups.c  */
-
-void cups_printer_fn(void (*fn)(char *, char *));
-int cups_printername_ok(const char *name);
-
-/* The following definitions come from printing/printfsp.c  */
-
-files_struct *print_fsp_open(connection_struct *conn, char *fname);
-void print_fsp_end(files_struct *fsp, BOOL normal_close);
-
-/* The following definitions come from printing/print_generic.c  */
-
-
-/* The following definitions come from printing/printing.c  */
-
-BOOL print_backend_init(void);
-BOOL print_job_exists(int jobid);
-int print_job_snum(int jobid);
-int print_job_fd(int jobid);
-char *print_job_fname(int jobid);
-BOOL print_job_set_place(int jobid, int place);
-BOOL print_job_set_name(int jobid, char *name);
-BOOL print_job_delete(struct current_user *user, int jobid, WERROR *errcode);
-BOOL print_job_pause(struct current_user *user, int jobid, WERROR *errcode);
-BOOL print_job_resume(struct current_user *user, int jobid, WERROR *errcode);
-int print_job_write(int jobid, const char *buf, int size);
-int print_queue_length(int snum, print_status_struct *pstatus);
-int print_job_start(struct current_user *user, int snum, char *jobname);
-void print_job_endpage(int jobid);
-BOOL print_job_end(int jobid, BOOL normal_close);
-int print_queue_status(int snum, 
-		       print_queue_struct **queue,
-		       print_status_struct *status);
-int print_queue_snum(char *qname);
-BOOL print_queue_pause(struct current_user *user, int snum, WERROR *errcode);
-BOOL print_queue_resume(struct current_user *user, int snum, WERROR *errcode);
-BOOL print_queue_purge(struct current_user *user, int snum, WERROR *errcode);
-
-/* The following definitions come from printing/print_svid.c  */
-
-void sysv_printer_fn(void (*fn)(char *, char *));
-int sysv_printername_ok(char *name);
 
 /* The following definitions come from profile/profile.c  */
 
@@ -2555,20 +2359,6 @@
 BOOL cli_nt_session_open(struct cli_state *cli, const char *pipe_name);
 void cli_nt_session_close(struct cli_state *cli);
 
-/* The following definitions come from rpc_client/cli_spoolss_notify.c  */
-
-BOOL spoolss_disconnect_from_client( struct cli_state *cli);
-BOOL spoolss_connect_to_client( struct cli_state *cli, char *remote_machine);
-WERROR cli_spoolss_reply_open_printer(struct cli_state *cli, TALLOC_CTX *mem_ctx, 
-				char *printer, uint32 localprinter, uint32 type, 
-				POLICY_HND *handle);
-WERROR cli_spoolss_reply_close_printer(struct cli_state *cli, TALLOC_CTX *mem_ctx, 
-					POLICY_HND *handle);
-WERROR cli_spoolss_routerreplyprinter (struct cli_state *cli, TALLOC_CTX *mem_ctx,
-					POLICY_HND *pol, uint32 condition, uint32 changd_id);
-WERROR cli_spoolss_reply_rrpcn(struct cli_state *cli, TALLOC_CTX *mem_ctx, 
-					POLICY_HND *handle, PRINTER_MESSAGE_INFO *info,
-					NT_PRINTER_INFO_LEVEL *printer);
 
 /* The following definitions come from rpc_client/cli_trust.c  */
 
@@ -2592,7 +2382,6 @@
 /* The following definitions come from rpcclient/cmd_spoolss.c  */
 
 BOOL get_short_archi(char *short_archi, const char *long_archi);
-void set_drv_info_3_env (DRIVER_INFO_3 *info, const char *arch);
 
 /* The following definitions come from rpcclient/cmd_srvsvc.c  */
 
@@ -3594,288 +3383,6 @@
 SEC_DESC_BUF *dup_sec_desc_buf(TALLOC_CTX *ctx, SEC_DESC_BUF *src);
 BOOL sec_io_desc_buf(const char *desc, SEC_DESC_BUF **ppsdb, prs_struct *ps, int depth);
 
-/* The following definitions come from rpc_parse/parse_spoolss.c  */
-
-BOOL make_systemtime(SYSTEMTIME *systime, struct tm *unixtime);
-BOOL smb_io_notify_info_data_strings(const char *desc,SPOOL_NOTIFY_INFO_DATA *data,
-                                     prs_struct *ps, int depth);
-BOOL spoolss_io_devmode(const char *desc, prs_struct *ps, int depth, DEVICEMODE *devmode);
-BOOL make_spoolss_q_open_printer_ex(SPOOL_Q_OPEN_PRINTER_EX *q_u,
-		const fstring printername, 
-		const fstring datatype, 
-		uint32 access_required,
-		const fstring clientname,
-		const fstring user_name);
-BOOL make_spoolss_q_addprinterex(
-	TALLOC_CTX *mem_ctx,
-	SPOOL_Q_ADDPRINTEREX *q_u, 
-	const char *srv_name,
-	const char* clientname, 
-	const char* user_name,
-	uint32 level, 
-	PRINTER_INFO_CTR *ctr);
-BOOL make_spoolss_printer_info_2(TALLOC_CTX *mem_ctx, SPOOL_PRINTER_INFO_LEVEL_2 **spool_info2, 
-				PRINTER_INFO_2 *info);
-BOOL spoolss_io_q_open_printer(const char *desc, SPOOL_Q_OPEN_PRINTER *q_u, prs_struct *ps, int depth);
-BOOL spoolss_io_r_open_printer(const char *desc, SPOOL_R_OPEN_PRINTER *r_u, prs_struct *ps, int depth);
-BOOL spoolss_io_q_open_printer_ex(const char *desc, SPOOL_Q_OPEN_PRINTER_EX *q_u, prs_struct *ps, int depth);
-BOOL spoolss_io_r_open_printer_ex(const char *desc, SPOOL_R_OPEN_PRINTER_EX *r_u, prs_struct *ps, int depth);
-BOOL make_spoolss_q_deleteprinterdriver(
-	TALLOC_CTX *mem_ctx,
-	SPOOL_Q_DELETEPRINTERDRIVER *q_u, 
-	const char *server,
-	const char* arch, 
-	const char* driver 
-);
-BOOL make_spoolss_q_getprinterdata(SPOOL_Q_GETPRINTERDATA *q_u,
-                                const POLICY_HND *handle,
-                                UNISTR2 *valuename, uint32 size);
-BOOL spoolss_io_q_getprinterdata(const char *desc, SPOOL_Q_GETPRINTERDATA *q_u, prs_struct *ps, int depth);
-BOOL spoolss_io_q_deleteprinterdata(const char *desc, SPOOL_Q_DELETEPRINTERDATA *q_u, prs_struct *ps, int depth);
-BOOL spoolss_io_r_deleteprinterdata(const char *desc, SPOOL_R_DELETEPRINTERDATA *r_u, prs_struct *ps, int depth);
-BOOL spoolss_io_r_getprinterdata(const char *desc, SPOOL_R_GETPRINTERDATA *r_u, prs_struct *ps, int depth);
-BOOL make_spoolss_q_closeprinter(SPOOL_Q_CLOSEPRINTER *q_u, POLICY_HND *hnd);
-BOOL spoolss_io_q_abortprinter(const char *desc, SPOOL_Q_ABORTPRINTER *q_u, prs_struct *ps, int depth);
-BOOL spoolss_io_r_abortprinter(const char *desc, SPOOL_R_ABORTPRINTER *r_u, prs_struct *ps, int depth);
-BOOL spoolss_io_q_deleteprinter(const char *desc, SPOOL_Q_DELETEPRINTER *q_u, prs_struct *ps, int depth);
-BOOL spoolss_io_r_deleteprinter(const char *desc, SPOOL_R_DELETEPRINTER *r_u, prs_struct *ps, int depth);
-BOOL spoolss_io_q_deleteprinterdriver(const char *desc, SPOOL_Q_DELETEPRINTERDRIVER *q_u, prs_struct *ps, int depth);
-BOOL spoolss_io_r_deleteprinterdriver(const char *desc, SPOOL_R_DELETEPRINTERDRIVER *r_u, prs_struct *ps, int depth);
-BOOL spoolss_io_q_closeprinter(const char *desc, SPOOL_Q_CLOSEPRINTER *q_u, prs_struct *ps, int depth);
-BOOL spoolss_io_r_closeprinter(const char *desc, SPOOL_R_CLOSEPRINTER *r_u, prs_struct *ps, int depth);
-BOOL spoolss_io_q_startdocprinter(const char *desc, SPOOL_Q_STARTDOCPRINTER *q_u, prs_struct *ps, int depth);
-BOOL spoolss_io_r_startdocprinter(const char *desc, SPOOL_R_STARTDOCPRINTER *r_u, prs_struct *ps, int depth);
-BOOL spoolss_io_q_enddocprinter(const char *desc, SPOOL_Q_ENDDOCPRINTER *q_u, prs_struct *ps, int depth);
-BOOL spoolss_io_r_enddocprinter(const char *desc, SPOOL_R_ENDDOCPRINTER *r_u, prs_struct *ps, int depth);
-BOOL spoolss_io_q_startpageprinter(const char *desc, SPOOL_Q_STARTPAGEPRINTER *q_u, prs_struct *ps, int depth);
-BOOL spoolss_io_r_startpageprinter(const char *desc, SPOOL_R_STARTPAGEPRINTER *r_u, prs_struct *ps, int depth);
-BOOL spoolss_io_q_endpageprinter(const char *desc, SPOOL_Q_ENDPAGEPRINTER *q_u, prs_struct *ps, int depth);
-BOOL spoolss_io_r_endpageprinter(const char *desc, SPOOL_R_ENDPAGEPRINTER *r_u, prs_struct *ps, int depth);
-BOOL spoolss_io_q_writeprinter(const char *desc, SPOOL_Q_WRITEPRINTER *q_u, prs_struct *ps, int depth);
-BOOL spoolss_io_r_writeprinter(const char *desc, SPOOL_R_WRITEPRINTER *r_u, prs_struct *ps, int depth);
-BOOL spoolss_io_q_rffpcnex(const char *desc, SPOOL_Q_RFFPCNEX *q_u, prs_struct *ps, int depth);
-BOOL spoolss_io_r_rffpcnex(const char *desc, SPOOL_R_RFFPCNEX *r_u, prs_struct *ps, int depth);
-BOOL spoolss_io_q_rfnpcnex(const char *desc, SPOOL_Q_RFNPCNEX *q_u, prs_struct *ps, int depth);
-BOOL spoolss_io_r_rfnpcnex(const char *desc, SPOOL_R_RFNPCNEX *r_u, prs_struct *ps, int depth);
-BOOL smb_io_printer_info_0(const char *desc, NEW_BUFFER *buffer, PRINTER_INFO_0 *info, int depth);
-BOOL smb_io_printer_info_1(const char *desc, NEW_BUFFER *buffer, PRINTER_INFO_1 *info, int depth);
-BOOL smb_io_printer_info_2(const char *desc, NEW_BUFFER *buffer, PRINTER_INFO_2 *info, int depth);
-BOOL smb_io_printer_info_3(const char *desc, NEW_BUFFER *buffer, PRINTER_INFO_3 *info, int depth);
-BOOL smb_io_printer_info_4(const char *desc, NEW_BUFFER *buffer, PRINTER_INFO_4 *info, int depth);
-BOOL smb_io_printer_info_5(const char *desc, NEW_BUFFER *buffer, PRINTER_INFO_5 *info, int depth);
-BOOL smb_io_port_info_1(const char *desc, NEW_BUFFER *buffer, PORT_INFO_1 *info, int depth);
-BOOL smb_io_port_info_2(const char *desc, NEW_BUFFER *buffer, PORT_INFO_2 *info, int depth);
-BOOL smb_io_printer_driver_info_1(const char *desc, NEW_BUFFER *buffer, DRIVER_INFO_1 *info, int depth) ;
-BOOL smb_io_printer_driver_info_2(const char *desc, NEW_BUFFER *buffer, DRIVER_INFO_2 *info, int depth) ;
-BOOL smb_io_printer_driver_info_3(const char *desc, NEW_BUFFER *buffer, DRIVER_INFO_3 *info, int depth);
-BOOL smb_io_printer_driver_info_6(const char *desc, NEW_BUFFER *buffer, DRIVER_INFO_6 *info, int depth);
-BOOL smb_io_job_info_1(const char *desc, NEW_BUFFER *buffer, JOB_INFO_1 *info, int depth);
-BOOL smb_io_job_info_2(const char *desc, NEW_BUFFER *buffer, JOB_INFO_2 *info, int depth);
-BOOL smb_io_form_1(const char *desc, NEW_BUFFER *buffer, FORM_1 *info, int depth);
-void spoolss_move_buffer(NEW_BUFFER *src, NEW_BUFFER **dest);
-uint32 new_get_buffer_size(NEW_BUFFER *buffer);
-BOOL smb_io_driverdir_1(const char *desc, NEW_BUFFER *buffer, DRIVER_DIRECTORY_1 *info, int depth);
-BOOL smb_io_port_1(const char *desc, NEW_BUFFER *buffer, PORT_INFO_1 *info, int depth);
-BOOL smb_io_port_2(const char *desc, NEW_BUFFER *buffer, PORT_INFO_2 *info, int depth);
-BOOL smb_io_printprocessor_info_1(const char *desc, NEW_BUFFER *buffer, PRINTPROCESSOR_1 *info, int depth);
-BOOL smb_io_printprocdatatype_info_1(const char *desc, NEW_BUFFER *buffer, PRINTPROCDATATYPE_1 *info, int depth);
-BOOL smb_io_printmonitor_info_1(const char *desc, NEW_BUFFER *buffer, PRINTMONITOR_1 *info, int depth);
-BOOL smb_io_printmonitor_info_2(const char *desc, NEW_BUFFER *buffer, PRINTMONITOR_2 *info, int depth);
-uint32 spoolss_size_printer_info_0(PRINTER_INFO_0 *info);
-uint32 spoolss_size_printer_info_1(PRINTER_INFO_1 *info);
-uint32 spoolss_size_printer_info_2(PRINTER_INFO_2 *info);
-uint32 spoolss_size_printer_info_4(PRINTER_INFO_4 *info);
-uint32 spoolss_size_printer_info_5(PRINTER_INFO_5 *info);
-uint32 spoolss_size_printer_info_3(PRINTER_INFO_3 *info);
-uint32 spoolss_size_printer_driver_info_1(DRIVER_INFO_1 *info);
-uint32 spoolss_size_printer_driver_info_2(DRIVER_INFO_2 *info);
-uint32 spoolss_size_string_array(uint16 *string);
-uint32 spoolss_size_printer_driver_info_3(DRIVER_INFO_3 *info);
-uint32 spoolss_size_printer_driver_info_6(DRIVER_INFO_6 *info);
-uint32 spoolss_size_job_info_1(JOB_INFO_1 *info);
-uint32 spoolss_size_job_info_2(JOB_INFO_2 *info);
-uint32 spoolss_size_form_1(FORM_1 *info);
-uint32 spoolss_size_port_info_1(PORT_INFO_1 *info);
-uint32 spoolss_size_driverdir_info_1(DRIVER_DIRECTORY_1 *info);
-uint32 spoolss_size_printprocessordirectory_info_1(PRINTPROCESSOR_DIRECTORY_1 *info);
-uint32 spoolss_size_port_info_2(PORT_INFO_2 *info);
-uint32 spoolss_size_printprocessor_info_1(PRINTPROCESSOR_1 *info);
-uint32 spoolss_size_printprocdatatype_info_1(PRINTPROCDATATYPE_1 *info);
-uint32 spoolss_size_printer_enum_values(PRINTER_ENUM_VALUES *p);
-uint32 spoolss_size_printmonitor_info_1(PRINTMONITOR_1 *info);
-uint32 spoolss_size_printmonitor_info_2(PRINTMONITOR_2 *info);
-BOOL make_spoolss_q_getprinterdriver2(SPOOL_Q_GETPRINTERDRIVER2 *q_u, 
-			       const POLICY_HND *hnd,
-			       const fstring architecture,
-			       uint32 level, uint32 clientmajor, uint32 clientminor,
-			       NEW_BUFFER *buffer, uint32 offered);
-BOOL spoolss_io_q_getprinterdriver2(const char *desc, SPOOL_Q_GETPRINTERDRIVER2 *q_u, prs_struct *ps, int depth);
-BOOL spoolss_io_r_getprinterdriver2(const char *desc, SPOOL_R_GETPRINTERDRIVER2 *r_u, prs_struct *ps, int depth);
-BOOL make_spoolss_q_enumprinters(
-	SPOOL_Q_ENUMPRINTERS *q_u, 
-	uint32 flags, 
-	fstring servername, 
-	uint32 level, 
-	NEW_BUFFER *buffer, 
-	uint32 offered
-);
-BOOL make_spoolss_q_enumports(SPOOL_Q_ENUMPORTS *q_u, 
-				fstring servername, uint32 level, 
-				NEW_BUFFER *buffer, uint32 offered);
-BOOL spoolss_io_q_enumprinters(const char *desc, SPOOL_Q_ENUMPRINTERS *q_u, prs_struct *ps, int depth);
-BOOL spoolss_io_r_enumprinters(const char *desc, SPOOL_R_ENUMPRINTERS *r_u, prs_struct *ps, int depth);
-BOOL spoolss_io_r_getprinter(const char *desc, SPOOL_R_GETPRINTER *r_u, prs_struct *ps, int depth);
-BOOL spoolss_io_q_getprinter(const char *desc, SPOOL_Q_GETPRINTER *q_u, prs_struct *ps, int depth);
-BOOL make_spoolss_q_getprinter(
-	TALLOC_CTX *mem_ctx,
-	SPOOL_Q_GETPRINTER *q_u, 
-	const POLICY_HND *hnd, 
-	uint32 level, 
-	NEW_BUFFER *buffer, 
-	uint32 offered
-);
-BOOL make_spoolss_q_setprinter(TALLOC_CTX *mem_ctx, SPOOL_Q_SETPRINTER *q_u, 
-				const POLICY_HND *hnd, uint32 level, PRINTER_INFO_CTR *info, 
-				uint32 command);
-BOOL spoolss_io_r_setprinter(const char *desc, SPOOL_R_SETPRINTER *r_u, prs_struct *ps, int depth);
-BOOL spoolss_io_q_setprinter(const char *desc, SPOOL_Q_SETPRINTER *q_u, prs_struct *ps, int depth);
-BOOL spoolss_io_r_fcpn(const char *desc, SPOOL_R_FCPN *r_u, prs_struct *ps, int depth);
-BOOL spoolss_io_q_fcpn(const char *desc, SPOOL_Q_FCPN *q_u, prs_struct *ps, int depth);
-BOOL spoolss_io_r_addjob(const char *desc, SPOOL_R_ADDJOB *r_u, prs_struct *ps, int depth);
-BOOL spoolss_io_q_addjob(const char *desc, SPOOL_Q_ADDJOB *q_u, prs_struct *ps, int depth);
-BOOL spoolss_io_r_enumjobs(const char *desc, SPOOL_R_ENUMJOBS *r_u, prs_struct *ps, int depth);
-BOOL make_spoolss_q_enumjobs(SPOOL_Q_ENUMJOBS *q_u, const POLICY_HND *hnd,
-				uint32 firstjob,
-				uint32 numofjobs,
-				uint32 level,
-				NEW_BUFFER *buffer,
-				uint32 offered);
-BOOL spoolss_io_q_enumjobs(const char *desc, SPOOL_Q_ENUMJOBS *q_u, prs_struct *ps, int depth);
-BOOL spoolss_io_r_schedulejob(const char *desc, SPOOL_R_SCHEDULEJOB *r_u, prs_struct *ps, int depth);
-BOOL spoolss_io_q_schedulejob(const char *desc, SPOOL_Q_SCHEDULEJOB *q_u, prs_struct *ps, int depth);
-BOOL spoolss_io_r_setjob(const char *desc, SPOOL_R_SETJOB *r_u, prs_struct *ps, int depth);
-BOOL spoolss_io_q_setjob(const char *desc, SPOOL_Q_SETJOB *q_u, prs_struct *ps, int depth);
-BOOL spoolss_io_r_enumprinterdrivers(const char *desc, SPOOL_R_ENUMPRINTERDRIVERS *r_u, prs_struct *ps, int depth);
-BOOL make_spoolss_q_enumprinterdrivers(SPOOL_Q_ENUMPRINTERDRIVERS *q_u,
-                                const char *name,
-                                const char *environment,
-                                uint32 level,
-                                NEW_BUFFER *buffer, uint32 offered);
-BOOL spoolss_io_q_enumprinterdrivers(const char *desc, SPOOL_Q_ENUMPRINTERDRIVERS *q_u, prs_struct *ps, int depth);
-BOOL spoolss_io_q_enumforms(const char *desc, SPOOL_Q_ENUMFORMS *q_u, prs_struct *ps, int depth);
-BOOL spoolss_io_r_enumforms(const char *desc, SPOOL_R_ENUMFORMS *r_u, prs_struct *ps, int depth);
-BOOL spoolss_io_q_getform(const char *desc, SPOOL_Q_GETFORM *q_u, prs_struct *ps, int depth);
-BOOL spoolss_io_r_getform(const char *desc, SPOOL_R_GETFORM *r_u, prs_struct *ps, int depth);
-BOOL spoolss_io_r_enumports(const char *desc, SPOOL_R_ENUMPORTS *r_u, prs_struct *ps, int depth);
-BOOL spoolss_io_q_enumports(const char *desc, SPOOL_Q_ENUMPORTS *q_u, prs_struct *ps, int depth);
-BOOL spool_io_printer_info_level_1(const char *desc, SPOOL_PRINTER_INFO_LEVEL_1 *il, prs_struct *ps, int depth);
-BOOL spool_io_printer_info_level_3(const char *desc, SPOOL_PRINTER_INFO_LEVEL_3 *il, prs_struct *ps, int depth);
-BOOL spool_io_printer_info_level_2(const char *desc, SPOOL_PRINTER_INFO_LEVEL_2 *il, prs_struct *ps, int depth);
-BOOL spool_io_printer_info_level(const char *desc, SPOOL_PRINTER_INFO_LEVEL *il, prs_struct *ps, int depth);
-BOOL spoolss_io_q_addprinterex(const char *desc, SPOOL_Q_ADDPRINTEREX *q_u, prs_struct *ps, int depth);
-BOOL spoolss_io_r_addprinterex(const char *desc, SPOOL_R_ADDPRINTEREX *r_u, 
-			       prs_struct *ps, int depth);
-BOOL spool_io_printer_driver_info_level_3(const char *desc, SPOOL_PRINTER_DRIVER_INFO_LEVEL_3 **q_u, 
-                                          prs_struct *ps, int depth);
-BOOL spool_io_printer_driver_info_level_6(const char *desc, SPOOL_PRINTER_DRIVER_INFO_LEVEL_6 **q_u, 
-                                          prs_struct *ps, int depth);
-BOOL smb_io_unibuffer(const char *desc, UNISTR2 *buffer, prs_struct *ps, int depth);
-BOOL spool_io_printer_driver_info_level(const char *desc, SPOOL_PRINTER_DRIVER_INFO_LEVEL *il, prs_struct *ps, int depth);
-BOOL make_spoolss_q_addprinterdriver(TALLOC_CTX *mem_ctx,
-				SPOOL_Q_ADDPRINTERDRIVER *q_u, const char* srv_name, 
-				uint32 level, PRINTER_DRIVER_CTR *info);
-BOOL make_spoolss_driver_info_3(TALLOC_CTX *mem_ctx, 
-				SPOOL_PRINTER_DRIVER_INFO_LEVEL_3 **spool_drv_info,
-				DRIVER_INFO_3 *info3);
-BOOL make_spoolss_buffer5(TALLOC_CTX *mem_ctx, BUFFER5 *buf5, uint32 len, uint16 *src);
-BOOL spoolss_io_q_addprinterdriver(const char *desc, SPOOL_Q_ADDPRINTERDRIVER *q_u, prs_struct *ps, int depth);
-BOOL spoolss_io_r_addprinterdriver(const char *desc, SPOOL_R_ADDPRINTERDRIVER *q_u, prs_struct *ps, int depth);
-BOOL uni_2_asc_printer_driver_3(SPOOL_PRINTER_DRIVER_INFO_LEVEL_3 *uni,
-                                NT_PRINTER_DRIVER_INFO_LEVEL_3 **asc);
-BOOL uni_2_asc_printer_driver_6(SPOOL_PRINTER_DRIVER_INFO_LEVEL_6 *uni,
-                                NT_PRINTER_DRIVER_INFO_LEVEL_6 **asc);
-BOOL uni_2_asc_printer_info_2(const SPOOL_PRINTER_INFO_LEVEL_2 *uni,
-                              NT_PRINTER_INFO_LEVEL_2  **asc);
-BOOL make_spoolss_q_getprinterdriverdir(SPOOL_Q_GETPRINTERDRIVERDIR *q_u,
-                                fstring servername, fstring env_name, uint32 level,
-                                NEW_BUFFER *buffer, uint32 offered);
-BOOL spoolss_io_q_getprinterdriverdir(const char *desc, SPOOL_Q_GETPRINTERDRIVERDIR *q_u, prs_struct *ps, int depth);
-BOOL spoolss_io_r_getprinterdriverdir(const char *desc, SPOOL_R_GETPRINTERDRIVERDIR *r_u, prs_struct *ps, int depth);
-BOOL spoolss_io_r_enumprintprocessors(const char *desc, SPOOL_R_ENUMPRINTPROCESSORS *r_u, prs_struct *ps, int depth);
-BOOL spoolss_io_q_enumprintprocessors(const char *desc, SPOOL_Q_ENUMPRINTPROCESSORS *q_u, prs_struct *ps, int depth);
-BOOL spoolss_io_q_addprintprocessor(const char *desc, SPOOL_Q_ADDPRINTPROCESSOR *q_u, prs_struct *ps, int depth);
-BOOL spoolss_io_r_addprintprocessor(const char *desc, SPOOL_R_ADDPRINTPROCESSOR *r_u, prs_struct *ps, int depth);
-BOOL spoolss_io_r_enumprintprocdatatypes(const char *desc, SPOOL_R_ENUMPRINTPROCDATATYPES *r_u, prs_struct *ps, int depth);
-BOOL spoolss_io_q_enumprintprocdatatypes(const char *desc, SPOOL_Q_ENUMPRINTPROCDATATYPES *q_u, prs_struct *ps, int depth);
-BOOL spoolss_io_q_enumprintmonitors(const char *desc, SPOOL_Q_ENUMPRINTMONITORS *q_u, prs_struct *ps, int depth);
-BOOL spoolss_io_r_enumprintmonitors(const char *desc, SPOOL_R_ENUMPRINTMONITORS *r_u, prs_struct *ps, int depth);
-BOOL spoolss_io_r_enumprinterdata(const char *desc, SPOOL_R_ENUMPRINTERDATA *r_u, prs_struct *ps, int depth);
-BOOL spoolss_io_q_enumprinterdata(const char *desc, SPOOL_Q_ENUMPRINTERDATA *q_u, prs_struct *ps, int depth);
-BOOL make_spoolss_q_enumprinterdata(SPOOL_Q_ENUMPRINTERDATA *q_u,
-		const POLICY_HND *hnd,
-		uint32 idx, uint32 valuelen, uint32 datalen);
-BOOL make_spoolss_q_setprinterdata(SPOOL_Q_SETPRINTERDATA *q_u, TALLOC_CTX *ctx, const POLICY_HND *hnd,
-				char* value, char* data);
-BOOL spoolss_io_q_setprinterdata(const char *desc, SPOOL_Q_SETPRINTERDATA *q_u, prs_struct *ps, int depth);
-BOOL spoolss_io_r_setprinterdata(const char *desc, SPOOL_R_SETPRINTERDATA *r_u, prs_struct *ps, int depth);
-BOOL spoolss_io_q_resetprinter(const char *desc, SPOOL_Q_RESETPRINTER *q_u, prs_struct *ps, int depth);
-BOOL spoolss_io_r_resetprinter(const char *desc, SPOOL_R_RESETPRINTER *r_u, prs_struct *ps, int depth);
-BOOL convert_specific_param(NT_PRINTER_PARAM **param, const UNISTR2 *value,
-				uint32 type, const uint8 *data, uint32 len);
-BOOL spoolss_io_q_deleteform(const char *desc, SPOOL_Q_DELETEFORM *q_u, prs_struct *ps, int depth);
-BOOL spoolss_io_r_deleteform(const char *desc, SPOOL_R_DELETEFORM *r_u, prs_struct *ps, int depth);
-BOOL spoolss_io_q_addform(const char *desc, SPOOL_Q_ADDFORM *q_u, prs_struct *ps, int depth);
-BOOL spoolss_io_r_addform(const char *desc, SPOOL_R_ADDFORM *r_u, prs_struct *ps, int depth);
-BOOL spoolss_io_q_setform(const char *desc, SPOOL_Q_SETFORM *q_u, prs_struct *ps, int depth);
-BOOL spoolss_io_r_setform(const char *desc, SPOOL_R_SETFORM *r_u, prs_struct *ps, int depth);
-BOOL spoolss_io_r_getjob(const char *desc, SPOOL_R_GETJOB *r_u, prs_struct *ps, int depth);
-BOOL spoolss_io_q_getjob(const char *desc, SPOOL_Q_GETJOB *q_u, prs_struct *ps, int depth);
-void free_devmode(DEVICEMODE *devmode);
-void free_printer_info_1(PRINTER_INFO_1 *printer);
-void free_printer_info_2(PRINTER_INFO_2 *printer);
-void free_printer_info_3(PRINTER_INFO_3 *printer);
-void free_printer_info_4(PRINTER_INFO_4 *printer);
-void free_printer_info_5(PRINTER_INFO_5 *printer);
-void free_job_info_2(JOB_INFO_2 *job);
-BOOL make_spoolss_q_replyopenprinter(SPOOL_Q_REPLYOPENPRINTER *q_u, 
-			       const fstring string, uint32 printer, uint32 type);
-BOOL spoolss_io_q_replyopenprinter(const char *desc, SPOOL_Q_REPLYOPENPRINTER *q_u, prs_struct *ps, int depth);
-BOOL spoolss_io_r_replyopenprinter(const char *desc, SPOOL_R_REPLYOPENPRINTER *r_u, prs_struct *ps, int depth);
-BOOL make_spoolss_q_routerreplyprinter(SPOOL_Q_ROUTERREPLYPRINTER *q_u, POLICY_HND *hnd, 
-					uint32 condition, uint32 change_id);
-BOOL spoolss_io_q_routerreplyprinter (const char *desc, SPOOL_Q_ROUTERREPLYPRINTER *q_u, prs_struct *ps, int depth);
-BOOL spoolss_io_r_routerreplyprinter (const char *desc, SPOOL_R_ROUTERREPLYPRINTER *r_u, prs_struct *ps, int depth);
-BOOL make_spoolss_q_reply_closeprinter(SPOOL_Q_REPLYCLOSEPRINTER *q_u, POLICY_HND *hnd);
-BOOL spoolss_io_q_replycloseprinter(const char *desc, SPOOL_Q_REPLYCLOSEPRINTER *q_u, prs_struct *ps, int depth);
-BOOL spoolss_io_r_replycloseprinter(const char *desc, SPOOL_R_REPLYCLOSEPRINTER *r_u, prs_struct *ps, int depth);
-BOOL make_spoolss_q_reply_rrpcn(SPOOL_Q_REPLY_RRPCN *q_u, POLICY_HND *hnd,
-			        uint32 change_low, uint32 change_high,
-				SPOOL_NOTIFY_INFO *info);
-BOOL spoolss_io_q_reply_rrpcn(const char *desc, SPOOL_Q_REPLY_RRPCN *q_u, prs_struct *ps, int depth);
-BOOL spoolss_io_r_reply_rrpcn(const char *desc, SPOOL_R_REPLY_RRPCN *r_u, prs_struct *ps, int depth);
-BOOL spoolss_io_q_getprinterdataex(const char *desc, SPOOL_Q_GETPRINTERDATAEX *q_u, prs_struct *ps, int depth);
-BOOL spoolss_io_r_getprinterdataex(const char *desc, SPOOL_R_GETPRINTERDATAEX *r_u, prs_struct *ps, int depth);
-BOOL spoolss_io_q_setprinterdataex(const char *desc, SPOOL_Q_SETPRINTERDATAEX *q_u, prs_struct *ps, int depth);
-BOOL spoolss_io_r_setprinterdataex(const char *desc, SPOOL_R_SETPRINTERDATAEX *r_u, prs_struct *ps, int depth);
-BOOL spoolss_io_q_enumprinterkey(const char *desc, SPOOL_Q_ENUMPRINTERKEY *q_u, prs_struct *ps, int depth);
-BOOL spoolss_io_r_enumprinterkey(const char *desc, SPOOL_R_ENUMPRINTERKEY *r_u, prs_struct *ps, int depth);
-BOOL spoolss_io_q_enumprinterdataex(const char *desc, SPOOL_Q_ENUMPRINTERDATAEX *q_u, prs_struct *ps, int depth);
-BOOL spoolss_io_r_enumprinterdataex(const char *desc, SPOOL_R_ENUMPRINTERDATAEX *r_u, prs_struct *ps, int depth);
-BOOL make_spoolss_q_getprintprocessordirectory(SPOOL_Q_GETPRINTPROCESSORDIRECTORY *q_u, const char *name, char *environment, int level, NEW_BUFFER *buffer, uint32 offered);
-BOOL spoolss_io_q_getprintprocessordirectory(const char *desc, SPOOL_Q_GETPRINTPROCESSORDIRECTORY *q_u, prs_struct *ps, int depth);
-BOOL spoolss_io_r_getprintprocessordirectory(const char *desc, SPOOL_R_GETPRINTPROCESSORDIRECTORY *r_u, prs_struct *ps, int depth);
-BOOL smb_io_printprocessordirectory_1(const char *desc, NEW_BUFFER *buffer, PRINTPROCESSOR_DIRECTORY_1 *info, int depth);
-BOOL make_spoolss_q_addform(SPOOL_Q_ADDFORM *q_u, POLICY_HND *handle, 
-			    int level, FORM *form);
-BOOL make_spoolss_q_setform(SPOOL_Q_SETFORM *q_u, POLICY_HND *handle, 
-			    int level, char *form_name, FORM *form);
-BOOL make_spoolss_q_deleteform(SPOOL_Q_DELETEFORM *q_u, POLICY_HND *handle, char *form);
-BOOL make_spoolss_q_getform(SPOOL_Q_GETFORM *q_u, POLICY_HND *handle, 
-                            char *formname, uint32 level, NEW_BUFFER *buffer,
-			    uint32 offered);
-BOOL make_spoolss_q_enumforms(SPOOL_Q_ENUMFORMS *q_u, POLICY_HND *handle, 
-			      uint32 level, NEW_BUFFER *buffer,
-			      uint32 offered);
 
 /* The following definitions come from rpc_parse/parse_srv.c  */
 
@@ -4148,128 +3655,6 @@
 NTSTATUS _samr_open_group(pipes_struct *p, SAMR_Q_OPEN_GROUP *q_u, SAMR_R_OPEN_GROUP *r_u);
 NTSTATUS _samr_unknown_2d(pipes_struct *p, SAMR_Q_UNKNOWN_2D *q_u, SAMR_R_UNKNOWN_2D *r_u);
 
-/* The following definitions come from rpc_server/srv_spoolss.c  */
-
-BOOL api_spoolss_rpc(pipes_struct *p);
-
-/* The following definitions come from rpc_server/srv_spoolss_nt.c  */
-
-void do_drv_upgrade_printer(int msg_type, pid_t src, void *buf, size_t len);
-WERROR _spoolss_open_printer(pipes_struct *p, SPOOL_Q_OPEN_PRINTER *q_u, SPOOL_R_OPEN_PRINTER *r_u);
-WERROR _spoolss_open_printer_ex( pipes_struct *p, SPOOL_Q_OPEN_PRINTER_EX *q_u, SPOOL_R_OPEN_PRINTER_EX *r_u);
-BOOL convert_devicemode(const char *printername, const DEVICEMODE *devmode,
-				NT_DEVICEMODE **pp_nt_devmode);
-WERROR _spoolss_closeprinter(pipes_struct *p, SPOOL_Q_CLOSEPRINTER *q_u, SPOOL_R_CLOSEPRINTER *r_u);
-WERROR _spoolss_deleteprinter(pipes_struct *p, SPOOL_Q_DELETEPRINTER *q_u, SPOOL_R_DELETEPRINTER *r_u);
-WERROR _spoolss_deleteprinterdriver(pipes_struct *p, SPOOL_Q_DELETEPRINTERDRIVER *q_u, 
-				    SPOOL_R_DELETEPRINTERDRIVER *r_u);
-WERROR _spoolss_getprinterdata(pipes_struct *p, SPOOL_Q_GETPRINTERDATA *q_u, SPOOL_R_GETPRINTERDATA *r_u);
-WERROR _spoolss_rffpcnex(pipes_struct *p, SPOOL_Q_RFFPCNEX *q_u, SPOOL_R_RFFPCNEX *r_u);
-void spoolss_notify_server_name(int snum, 
-				       SPOOL_NOTIFY_INFO_DATA *data, 
-				       print_queue_struct *queue,
-				       NT_PRINTER_INFO_LEVEL *printer,
-				       TALLOC_CTX *mem_ctx) ;
-void spoolss_notify_printer_name(int snum, 
-					SPOOL_NOTIFY_INFO_DATA *data, 
-					print_queue_struct *queue,
-					NT_PRINTER_INFO_LEVEL *printer,
-					TALLOC_CTX *mem_ctx);
-void spoolss_notify_share_name(int snum, 
-				      SPOOL_NOTIFY_INFO_DATA *data, 
-				      print_queue_struct *queue,
-				      NT_PRINTER_INFO_LEVEL *printer,
-				      TALLOC_CTX *mem_ctx);
-void spoolss_notify_port_name(int snum, 
-				     SPOOL_NOTIFY_INFO_DATA *data, 
-				     print_queue_struct *queue,
-				     NT_PRINTER_INFO_LEVEL *printer,
-				     TALLOC_CTX *mem_ctx);
-void spoolss_notify_driver_name(int snum, 
-				       SPOOL_NOTIFY_INFO_DATA *data,
-				       print_queue_struct *queue,
-				       NT_PRINTER_INFO_LEVEL *printer,
-				       TALLOC_CTX *mem_ctx);
-void spoolss_notify_comment(int snum, 
-				   SPOOL_NOTIFY_INFO_DATA *data,
-				   print_queue_struct *queue,
-				   NT_PRINTER_INFO_LEVEL *printer,
-				   TALLOC_CTX *mem_ctx);
-void spoolss_notify_location(int snum, 
-				    SPOOL_NOTIFY_INFO_DATA *data,
-				    print_queue_struct *queue,
-				    NT_PRINTER_INFO_LEVEL *printer,
-				    TALLOC_CTX *mem_ctx);
-void spoolss_notify_sepfile(int snum, 
-				   SPOOL_NOTIFY_INFO_DATA *data, 
-				   print_queue_struct *queue,
-				   NT_PRINTER_INFO_LEVEL *printer,
-				   TALLOC_CTX *mem_ctx);
-void spoolss_notify_print_processor(int snum, 
-					   SPOOL_NOTIFY_INFO_DATA *data,
-					   print_queue_struct *queue,
-					   NT_PRINTER_INFO_LEVEL *printer,
-					   TALLOC_CTX *mem_ctx);
-void spoolss_notify_parameters(int snum, 
-				      SPOOL_NOTIFY_INFO_DATA *data,
-				      print_queue_struct *queue,
-				      NT_PRINTER_INFO_LEVEL *printer,
-				      TALLOC_CTX *mem_ctx);
-void spoolss_notify_datatype(int snum, 
-				    SPOOL_NOTIFY_INFO_DATA *data,
-				    print_queue_struct *queue,
-				    NT_PRINTER_INFO_LEVEL *printer,
-				    TALLOC_CTX *mem_ctx);
-void spoolss_notify_attributes(int snum, 
-				      SPOOL_NOTIFY_INFO_DATA *data,
-				      print_queue_struct *queue,
-				      NT_PRINTER_INFO_LEVEL *printer,
-				      TALLOC_CTX *mem_ctx);
-void spoolss_notify_cjobs(int snum, 
-				 SPOOL_NOTIFY_INFO_DATA *data,
-				 print_queue_struct *queue,
-				 NT_PRINTER_INFO_LEVEL *printer, 
-				 TALLOC_CTX *mem_ctx);
-void construct_info_data(SPOOL_NOTIFY_INFO_DATA *info_data, uint16 type, uint16 field, int id);
-WERROR _spoolss_rfnpcnex( pipes_struct *p, SPOOL_Q_RFNPCNEX *q_u, SPOOL_R_RFNPCNEX *r_u);
-WERROR _spoolss_enumprinters( pipes_struct *p, SPOOL_Q_ENUMPRINTERS *q_u, SPOOL_R_ENUMPRINTERS *r_u);
-WERROR _spoolss_getprinter(pipes_struct *p, SPOOL_Q_GETPRINTER *q_u, SPOOL_R_GETPRINTER *r_u);
-WERROR _spoolss_getprinterdriver2(pipes_struct *p, SPOOL_Q_GETPRINTERDRIVER2 *q_u, SPOOL_R_GETPRINTERDRIVER2 *r_u);
-WERROR _spoolss_startpageprinter(pipes_struct *p, SPOOL_Q_STARTPAGEPRINTER *q_u, SPOOL_R_STARTPAGEPRINTER *r_u);
-WERROR _spoolss_endpageprinter(pipes_struct *p, SPOOL_Q_ENDPAGEPRINTER *q_u, SPOOL_R_ENDPAGEPRINTER *r_u);
-WERROR _spoolss_startdocprinter(pipes_struct *p, SPOOL_Q_STARTDOCPRINTER *q_u, SPOOL_R_STARTDOCPRINTER *r_u);
-WERROR _spoolss_enddocprinter(pipes_struct *p, SPOOL_Q_ENDDOCPRINTER *q_u, SPOOL_R_ENDDOCPRINTER *r_u);
-WERROR _spoolss_writeprinter(pipes_struct *p, SPOOL_Q_WRITEPRINTER *q_u, SPOOL_R_WRITEPRINTER *r_u);
-WERROR _spoolss_abortprinter(pipes_struct *p, SPOOL_Q_ABORTPRINTER *q_u, SPOOL_R_ABORTPRINTER *r_u);
-WERROR _spoolss_setprinter(pipes_struct *p, SPOOL_Q_SETPRINTER *q_u, SPOOL_R_SETPRINTER *r_u);
-WERROR _spoolss_fcpn(pipes_struct *p, SPOOL_Q_FCPN *q_u, SPOOL_R_FCPN *r_u);
-WERROR _spoolss_addjob(pipes_struct *p, SPOOL_Q_ADDJOB *q_u, SPOOL_R_ADDJOB *r_u);
-WERROR _spoolss_enumjobs( pipes_struct *p, SPOOL_Q_ENUMJOBS *q_u, SPOOL_R_ENUMJOBS *r_u);
-WERROR _spoolss_schedulejob( pipes_struct *p, SPOOL_Q_SCHEDULEJOB *q_u, SPOOL_R_SCHEDULEJOB *r_u);
-WERROR _spoolss_setjob(pipes_struct *p, SPOOL_Q_SETJOB *q_u, SPOOL_R_SETJOB *r_u);
-WERROR _spoolss_enumprinterdrivers( pipes_struct *p, SPOOL_Q_ENUMPRINTERDRIVERS *q_u, SPOOL_R_ENUMPRINTERDRIVERS *r_u);
-WERROR _spoolss_enumforms(pipes_struct *p, SPOOL_Q_ENUMFORMS *q_u, SPOOL_R_ENUMFORMS *r_u);
-WERROR _spoolss_getform(pipes_struct *p, SPOOL_Q_GETFORM *q_u, SPOOL_R_GETFORM *r_u);
-WERROR _spoolss_enumports( pipes_struct *p, SPOOL_Q_ENUMPORTS *q_u, SPOOL_R_ENUMPORTS *r_u);
-WERROR _spoolss_addprinterex( pipes_struct *p, SPOOL_Q_ADDPRINTEREX *q_u, SPOOL_R_ADDPRINTEREX *r_u);
-WERROR _spoolss_addprinterdriver(pipes_struct *p, SPOOL_Q_ADDPRINTERDRIVER *q_u, SPOOL_R_ADDPRINTERDRIVER *r_u);
-WERROR _spoolss_getprinterdriverdirectory(pipes_struct *p, SPOOL_Q_GETPRINTERDRIVERDIR *q_u, SPOOL_R_GETPRINTERDRIVERDIR *r_u);
-WERROR _spoolss_enumprinterdata(pipes_struct *p, SPOOL_Q_ENUMPRINTERDATA *q_u, SPOOL_R_ENUMPRINTERDATA *r_u);
-WERROR _spoolss_setprinterdata( pipes_struct *p, SPOOL_Q_SETPRINTERDATA *q_u, SPOOL_R_SETPRINTERDATA *r_u);
-WERROR _spoolss_resetprinter(pipes_struct *p, SPOOL_Q_RESETPRINTER *q_u, SPOOL_R_RESETPRINTER *r_u);
-WERROR _spoolss_deleteprinterdata(pipes_struct *p, SPOOL_Q_DELETEPRINTERDATA *q_u, SPOOL_R_DELETEPRINTERDATA *r_u);
-WERROR _spoolss_addform( pipes_struct *p, SPOOL_Q_ADDFORM *q_u, SPOOL_R_ADDFORM *r_u);
-WERROR _spoolss_deleteform( pipes_struct *p, SPOOL_Q_DELETEFORM *q_u, SPOOL_R_DELETEFORM *r_u);
-WERROR _spoolss_setform(pipes_struct *p, SPOOL_Q_SETFORM *q_u, SPOOL_R_SETFORM *r_u);
-WERROR _spoolss_enumprintprocessors(pipes_struct *p, SPOOL_Q_ENUMPRINTPROCESSORS *q_u, SPOOL_R_ENUMPRINTPROCESSORS *r_u);
-WERROR _spoolss_enumprintprocdatatypes(pipes_struct *p, SPOOL_Q_ENUMPRINTPROCDATATYPES *q_u, SPOOL_R_ENUMPRINTPROCDATATYPES *r_u);
-WERROR _spoolss_enumprintmonitors(pipes_struct *p, SPOOL_Q_ENUMPRINTMONITORS *q_u, SPOOL_R_ENUMPRINTMONITORS *r_u);
-WERROR _spoolss_getjob( pipes_struct *p, SPOOL_Q_GETJOB *q_u, SPOOL_R_GETJOB *r_u);
-WERROR _spoolss_getprinterdataex(pipes_struct *p, SPOOL_Q_GETPRINTERDATAEX *q_u, SPOOL_R_GETPRINTERDATAEX *r_u);
-WERROR _spoolss_setprinterdataex(pipes_struct *p, SPOOL_Q_SETPRINTERDATAEX *q_u, SPOOL_R_SETPRINTERDATAEX *r_u);
-WERROR _spoolss_enumprinterkey(pipes_struct *p, SPOOL_Q_ENUMPRINTERKEY *q_u, SPOOL_R_ENUMPRINTERKEY *r_u);
-WERROR _spoolss_enumprinterdataex(pipes_struct *p, SPOOL_Q_ENUMPRINTERDATAEX *q_u, SPOOL_R_ENUMPRINTERDATAEX *r_u);
-WERROR _spoolss_getprintprocessordirectory(pipes_struct *p, SPOOL_Q_GETPRINTPROCESSORDIRECTORY *q_u, SPOOL_R_GETPRINTPROCESSORDIRECTORY *r_u);
 
 /* The following definitions come from rpc_server/srv_srvsvc.c  */
 
@@ -4969,8 +4354,6 @@
 		 uint16 *mode, size_t *size, 
 		 time_t *c_time, time_t *a_time, time_t *m_time,
 		 SMB_INO_T *ino);
-int smbw_stat_printjob(struct smbw_server *srv,char *path,
-		       size_t *size, time_t *m_time);
 int smbw_fstat(int fd, struct stat *st);
 int smbw_stat(const char *fname, struct stat *st);
 
diff -Naur samba-2.2.12-orig/source/include/rpc_client_proto.h samba-2.2.12/source/include/rpc_client_proto.h
--- samba-2.2.12-orig/source/include/rpc_client_proto.h	2004-08-12 20:24:29.000000000 +0200
+++ samba-2.2.12/source/include/rpc_client_proto.h	2011-03-04 12:41:32.000000000 +0100
@@ -165,14 +165,6 @@
 				POLICY_HND *pol, uint16 switch_value, void* usr);
 BOOL do_samr_close(struct cli_state *cli, POLICY_HND *hnd);
 
-/*The following definitions come from  rpc_client/cli_spoolss_notify.c  */
-
-BOOL spoolss_disconnect_from_client( struct cli_state *cli);
-BOOL spoolss_connect_to_client( struct cli_state *cli, char *remote_machine);
-BOOL cli_spoolss_reply_open_printer(struct cli_state *cli, char *printer, uint32 localprinter, uint32 type, uint32 *status, POLICY_HND *handle);
-BOOL cli_spoolss_reply_rrpcn(struct cli_state *cli, POLICY_HND *handle, 
-			     uint32 change_low, uint32 change_high, uint32 *status);
-BOOL cli_spoolss_reply_close_printer(struct cli_state *cli, POLICY_HND *handle, uint32 *status);
 
 /*The following definitions come from  rpc_client/cli_srvsvc.c  */
 
diff -Naur samba-2.2.12-orig/source/include/rpc_spoolss.h samba-2.2.12/source/include/rpc_spoolss.h
--- samba-2.2.12-orig/source/include/rpc_spoolss.h	2004-08-12 20:24:29.000000000 +0200
+++ samba-2.2.12/source/include/rpc_spoolss.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,2121 +0,0 @@
-/* 
-   Unix SMB/Netbios implementation.
-   Version 1.9.
-   SMB parameters and setup
-   Copyright (C) Andrew Tridgell              1992-2000,
-   Copyright (C) Luke Kenneth Casson Leighton 1996-2000,
-   Copyright (C) Jean Francois Micouleau      1998-2000.
-   Copyright (C) Gerald Carter                2001-2002.
-   
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2 of the License, or
-   (at your option) any later version.
-   
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-   
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-*/
-
-#ifndef _RPC_SPOOLSS_H		/* _RPC_SPOOLSS_H */
-#define _RPC_SPOOLSS_H
-
-#define INTEGER 1
-#define STRING 2
-
-/* spoolss pipe: this are the calls which are not implemented ...
-#define SPOOLSS_GETPRINTERDRIVER			0x0b
-#define SPOOLSS_READPRINTER				0x16
-#define SPOOLSS_WAITFORPRINTERCHANGE			0x1c
-#define SPOOLSS_ADDPORT					0x25
-#define SPOOLSS_CONFIGUREPORT				0x26
-#define SPOOLSS_DELETEPORT				0x27
-#define SPOOLSS_CREATEPRINTERIC				0x28
-#define SPOOLSS_PLAYGDISCRIPTONPRINTERIC		0x29
-#define SPOOLSS_DELETEPRINTERIC				0x2a
-#define SPOOLSS_ADDPRINTERCONNECTION			0x2b
-#define SPOOLSS_DELETEPRINTERCONNECTION			0x2c
-#define SPOOLSS_PRINTERMESSAGEBOX			0x2d
-#define SPOOLSS_ADDMONITOR				0x2e
-#define SPOOLSS_DELETEMONITOR				0x2f
-#define SPOOLSS_DELETEPRINTPROCESSOR			0x30
-#define SPOOLSS_ADDPRINTPROVIDOR			0x31
-#define SPOOLSS_DELETEPRINTPROVIDOR			0x32
-#define SPOOLSS_FINDFIRSTPRINTERCHANGENOTIFICATION	0x36
-#define SPOOLSS_FINDNEXTPRINTERCHANGENOTIFICATION	0x37
-#define SPOOLSS_ROUTERFINDFIRSTPRINTERNOTIFICATIONOLD	0x39
-#define SPOOLSS_ADDPORTEX				0x3d
-#define SPOOLSS_REMOTEFINDFIRSTPRINTERCHANGENOTIFICATION0x3e
-#define SPOOLSS_SPOOLERINIT				0x3f
-#define SPOOLSS_RESETPRINTEREX				0x40
-#define SPOOLSS_DELETEPRINTERDATAEX			0x51
-#define SPOOLSS_DELETEPRINTERDRIVEREX			0x54
-#define SPOOLSS_ADDPRINTERDRIVEREX			0x59
-*/
-
-/* those are implemented */
-#define SPOOLSS_ENUMPRINTERS				0x00
-#define SPOOLSS_OPENPRINTER				0x01
-#define SPOOLSS_SETJOB					0x02
-#define SPOOLSS_GETJOB					0x03
-#define SPOOLSS_ENUMJOBS				0x04
-#define SPOOLSS_ADDPRINTER				0x05
-#define SPOOLSS_DELETEPRINTER				0x06
-#define SPOOLSS_SETPRINTER				0x07
-#define SPOOLSS_GETPRINTER				0x08
-#define SPOOLSS_ADDPRINTERDRIVER			0x09
-#define SPOOLSS_ENUMPRINTERDRIVERS			0x0a
-#define SPOOLSS_GETPRINTERDRIVERDIRECTORY		0x0c
-#define SPOOLSS_DELETEPRINTERDRIVER			0x0d
-#define SPOOLSS_ADDPRINTPROCESSOR			0x0e
-#define SPOOLSS_ENUMPRINTPROCESSORS			0x0f
-#define SPOOLSS_GETPRINTPROCESSORDIRECTORY		0x10
-#define SPOOLSS_STARTDOCPRINTER				0x11
-#define SPOOLSS_STARTPAGEPRINTER			0x12
-#define SPOOLSS_WRITEPRINTER				0x13
-#define SPOOLSS_ENDPAGEPRINTER				0x14
-#define SPOOLSS_ABORTPRINTER				0x15
-#define SPOOLSS_ENDDOCPRINTER				0x17
-#define SPOOLSS_ADDJOB					0x18
-#define SPOOLSS_SCHEDULEJOB				0x19
-#define SPOOLSS_GETPRINTERDATA				0x1a
-#define SPOOLSS_SETPRINTERDATA				0x1b
-#define SPOOLSS_CLOSEPRINTER				0x1d
-#define SPOOLSS_ADDFORM					0x1e
-#define SPOOLSS_DELETEFORM				0x1f
-#define SPOOLSS_GETFORM					0x20
-#define SPOOLSS_SETFORM					0x21
-#define SPOOLSS_ENUMFORMS				0x22
-#define SPOOLSS_ENUMPORTS				0x23
-#define SPOOLSS_ENUMMONITORS				0x24
-#define SPOOLSS_ENUMPRINTPROCDATATYPES			0x33
-#define SPOOLSS_RESETPRINTER				0x34
-#define SPOOLSS_GETPRINTERDRIVER2			0x35
-#define SPOOLSS_FCPN					0x38	/* FindClosePrinterNotify */
-#define SPOOLSS_REPLYOPENPRINTER			0x3a
-#define SPOOLSS_ROUTERREPLYPRINTER			0x3b
-#define SPOOLSS_REPLYCLOSEPRINTER			0x3c
-#define SPOOLSS_RFFPCNEX				0x41	/* RemoteFindFirstPrinterChangeNotifyEx */
-#define SPOOLSS_RRPCN					0x42	/* RouteRefreshPrinterChangeNotification */
-#define SPOOLSS_RFNPCNEX				0x43	/* RemoteFindNextPrinterChangeNotifyEx */
-#define SPOOLSS_OPENPRINTEREX				0x45
-#define SPOOLSS_ADDPRINTEREX				0x46
-#define SPOOLSS_ENUMPRINTERDATA				0x48
-#define SPOOLSS_DELETEPRINTERDATA			0x49
-#define SPOOLSS_SETPRINTERDATAEX			0x4d
-#define SPOOLSS_GETPRINTERDATAEX			0x4e
-#define SPOOLSS_ENUMPRINTERDATAEX			0x4f
-#define SPOOLSS_ENUMPRINTERKEY				0x50
-
-
-#define PRINTER_CONTROL_UNPAUSE		0x00000000
-#define PRINTER_CONTROL_PAUSE		0x00000001
-#define PRINTER_CONTROL_RESUME		0x00000002
-#define PRINTER_CONTROL_PURGE		0x00000003
-#define PRINTER_CONTROL_SET_STATUS	0x00000004
-
-#define PRINTER_STATUS_PAUSED		0x00000001
-#define PRINTER_STATUS_ERROR		0x00000002
-#define PRINTER_STATUS_PENDING_DELETION	0x00000004
-#define PRINTER_STATUS_PAPER_JAM	0x00000008
-
-#define PRINTER_STATUS_PAPER_OUT	0x00000010
-#define PRINTER_STATUS_MANUAL_FEED	0x00000020
-#define PRINTER_STATUS_PAPER_PROBLEM	0x00000040
-#define PRINTER_STATUS_OFFLINE		0x00000080
-
-#define PRINTER_STATUS_IO_ACTIVE	0x00000100
-#define PRINTER_STATUS_BUSY		0x00000200
-#define PRINTER_STATUS_PRINTING		0x00000400
-#define PRINTER_STATUS_OUTPUT_BIN_FULL	0x00000800
-
-#define PRINTER_STATUS_NOT_AVAILABLE	0x00001000
-#define PRINTER_STATUS_WAITING		0x00002000
-#define PRINTER_STATUS_PROCESSING	0x00004000
-#define PRINTER_STATUS_INITIALIZING	0x00008000
-
-#define PRINTER_STATUS_WARMING_UP	0x00010000
-#define PRINTER_STATUS_TONER_LOW	0x00020000
-#define PRINTER_STATUS_NO_TONER		0x00040000
-#define PRINTER_STATUS_PAGE_PUNT	0x00080000
-
-#define PRINTER_STATUS_USER_INTERVENTION	0x00100000
-#define PRINTER_STATUS_OUT_OF_MEMORY	0x00200000
-#define PRINTER_STATUS_DOOR_OPEN	0x00400000
-#define PRINTER_STATUS_SERVER_UNKNOWN	0x00800000
-
-#define PRINTER_STATUS_POWER_SAVE	0x01000000
-
-#define SERVER_ACCESS_ADMINISTER	0x00000001
-#define SERVER_ACCESS_ENUMERATE		0x00000002
-#define PRINTER_ACCESS_ADMINISTER	0x00000004
-#define PRINTER_ACCESS_USE		0x00000008
-#define JOB_ACCESS_ADMINISTER		0x00000010
-
-/* JOB status codes. */
-
-#define JOB_STATUS_PAUSED		0x001
-#define JOB_STATUS_ERROR		0x002
-#define JOB_STATUS_DELETING		0x004
-#define JOB_STATUS_SPOOLING		0x008
-#define JOB_STATUS_PRINTING		0x010
-#define JOB_STATUS_OFFLINE		0x020
-#define JOB_STATUS_PAPEROUT		0x040
-#define JOB_STATUS_PRINTED		0x080
-#define JOB_STATUS_DELETED		0x100
-#define JOB_STATUS_BLOCKED		0x200
-#define JOB_STATUS_USER_INTERVENTION	0x400
-
-/* ACE masks for the various print permissions */
-
-#define PRINTER_ACE_FULL_CONTROL      GENERIC_ALL_ACCESS
-#define PRINTER_ACE_MANAGE_DOCUMENTS  READ_CONTROL_ACCESS
-#define PRINTER_ACE_PRINT             \
-    (GENERIC_READ_ACCESS | GENERIC_WRITE_ACCESS | GENERIC_EXECUTE_ACCESS)
-
-/* Access rights for print servers */
-#define SERVER_ALL_ACCESS	STANDARD_RIGHTS_REQUIRED_ACCESS|SERVER_ACCESS_ADMINISTER|SERVER_ACCESS_ENUMERATE
-#define SERVER_READ		STANDARD_RIGHTS_READ_ACCESS|SERVER_ACCESS_ENUMERATE
-#define SERVER_WRITE		STANDARD_RIGHTS_WRITE_ACCESS|SERVER_ACCESS_ADMINISTER|SERVER_ACCESS_ENUMERATE
-#define SERVER_EXECUTE		STANDARD_RIGHTS_EXECUTE_ACCESS|SERVER_ACCESS_ENUMERATE
-
-/* Access rights for printers */
-#define PRINTER_ALL_ACCESS	STANDARD_RIGHTS_REQUIRED_ACCESS|PRINTER_ACCESS_ADMINISTER|PRINTER_ACCESS_USE
-#define PRINTER_READ          STANDARD_RIGHTS_READ_ACCESS|PRINTER_ACCESS_USE
-#define PRINTER_WRITE         STANDARD_RIGHTS_WRITE_ACCESS|PRINTER_ACCESS_USE
-#define PRINTER_EXECUTE       STANDARD_RIGHTS_EXECUTE_ACCESS|PRINTER_ACCESS_USE
-
-/* Access rights for jobs */
-#define JOB_ALL_ACCESS	STANDARD_RIGHTS_REQUIRED_ACCESS|JOB_ACCESS_ADMINISTER
-#define JOB_READ	STANDARD_RIGHTS_READ_ACCESS|JOB_ACCESS_ADMINISTER
-#define JOB_WRITE	STANDARD_RIGHTS_WRITE_ACCESS|JOB_ACCESS_ADMINISTER
-#define JOB_EXECUTE	STANDARD_RIGHTS_EXECUTE_ACCESS|JOB_ACCESS_ADMINISTER
-
-#define ONE_VALUE 1
-#define TWO_VALUE 2
-#define POINTER   3
-
-#define PRINTER_NOTIFY_TYPE 0x00
-#define JOB_NOTIFY_TYPE     0x01
-
-#define MAX_PRINTER_NOTIFY 26
-#define MAX_JOB_NOTIFY 24
-
-#define MAX_NOTIFY_TYPE_FOR_NOW 26
-
-#define PRINTER_NOTIFY_SERVER_NAME		0x00
-#define PRINTER_NOTIFY_PRINTER_NAME		0x01
-#define PRINTER_NOTIFY_SHARE_NAME		0x02
-#define PRINTER_NOTIFY_PORT_NAME		0x03
-#define PRINTER_NOTIFY_DRIVER_NAME		0x04
-#define PRINTER_NOTIFY_COMMENT			0x05
-#define PRINTER_NOTIFY_LOCATION			0x06
-#define PRINTER_NOTIFY_DEVMODE			0x07
-#define PRINTER_NOTIFY_SEPFILE			0x08
-#define PRINTER_NOTIFY_PRINT_PROCESSOR		0x09
-#define PRINTER_NOTIFY_PARAMETERS		0x0A
-#define PRINTER_NOTIFY_DATATYPE			0x0B
-#define PRINTER_NOTIFY_SECURITY_DESCRIPTOR	0x0C
-#define PRINTER_NOTIFY_ATTRIBUTES		0x0D
-#define PRINTER_NOTIFY_PRIORITY			0x0E
-#define PRINTER_NOTIFY_DEFAULT_PRIORITY		0x0F
-#define PRINTER_NOTIFY_START_TIME		0x10
-#define PRINTER_NOTIFY_UNTIL_TIME		0x11
-#define PRINTER_NOTIFY_STATUS			0x12
-#define PRINTER_NOTIFY_STATUS_STRING		0x13
-#define PRINTER_NOTIFY_CJOBS			0x14
-#define PRINTER_NOTIFY_AVERAGE_PPM		0x15
-#define PRINTER_NOTIFY_TOTAL_PAGES		0x16
-#define PRINTER_NOTIFY_PAGES_PRINTED		0x17
-#define PRINTER_NOTIFY_TOTAL_BYTES		0x18
-#define PRINTER_NOTIFY_BYTES_PRINTED		0x19
-
-#define JOB_NOTIFY_PRINTER_NAME			0x00
-#define JOB_NOTIFY_MACHINE_NAME			0x01
-#define JOB_NOTIFY_PORT_NAME			0x02
-#define JOB_NOTIFY_USER_NAME			0x03
-#define JOB_NOTIFY_NOTIFY_NAME			0x04
-#define JOB_NOTIFY_DATATYPE			0x05
-#define JOB_NOTIFY_PRINT_PROCESSOR		0x06
-#define JOB_NOTIFY_PARAMETERS			0x07
-#define JOB_NOTIFY_DRIVER_NAME			0x08
-#define JOB_NOTIFY_DEVMODE			0x09
-#define JOB_NOTIFY_STATUS			0x0A
-#define JOB_NOTIFY_STATUS_STRING		0x0B
-#define JOB_NOTIFY_SECURITY_DESCRIPTOR		0x0C
-#define JOB_NOTIFY_DOCUMENT			0x0D
-#define JOB_NOTIFY_PRIORITY			0x0E
-#define JOB_NOTIFY_POSITION			0x0F
-#define JOB_NOTIFY_SUBMITTED			0x10
-#define JOB_NOTIFY_START_TIME			0x11
-#define JOB_NOTIFY_UNTIL_TIME			0x12
-#define JOB_NOTIFY_TIME				0x13
-#define JOB_NOTIFY_TOTAL_PAGES			0x14
-#define JOB_NOTIFY_PAGES_PRINTED		0x15
-#define JOB_NOTIFY_TOTAL_BYTES			0x16
-#define JOB_NOTIFY_BYTES_PRINTED		0x17
-
-#define PRINTER_NOTIFY_OPTIONS_REFRESH  	0x01
-
-#define PRINTER_CHANGE_ADD_PRINTER			0x00000001
-#define PRINTER_CHANGE_SET_PRINTER			0x00000002
-#define PRINTER_CHANGE_DELETE_PRINTER			0x00000004
-#define PRINTER_CHANGE_FAILED_CONNECTION_PRINTER	0x00000008
-#define PRINTER_CHANGE_PRINTER	(PRINTER_CHANGE_ADD_PRINTER | \
-				 PRINTER_CHANGE_SET_PRINTER | \
-				 PRINTER_CHANGE_DELETE_PRINTER | \
-				 PRINTER_CHANGE_FAILED_CONNECTION_PRINTER )
-
-#define PRINTER_CHANGE_ADD_JOB				0x00000100
-#define PRINTER_CHANGE_SET_JOB				0x00000200
-#define PRINTER_CHANGE_DELETE_JOB			0x00000400
-#define PRINTER_CHANGE_WRITE_JOB			0x00000800
-#define PRINTER_CHANGE_JOB	(PRINTER_CHANGE_ADD_JOB | \
-				 PRINTER_CHANGE_SET_JOB | \
-				 PRINTER_CHANGE_DELETE_JOB | \
-				 PRINTER_CHANGE_WRITE_JOB )
-
-#define PRINTER_CHANGE_ADD_FORM				0x00010000
-#define PRINTER_CHANGE_SET_FORM				0x00020000
-#define PRINTER_CHANGE_DELETE_FORM			0x00040000
-#define PRINTER_CHANGE_FORM	(PRINTER_CHANGE_ADD_FORM | \
-				 PRINTER_CHANGE_SET_FORM | \
-				 PRINTER_CHANGE_DELETE_FORM )
-
-#define PRINTER_CHANGE_ADD_PORT				0x00100000
-#define PRINTER_CHANGE_CONFIGURE_PORT			0x00200000
-#define PRINTER_CHANGE_DELETE_PORT			0x00400000
-#define PRINTER_CHANGE_PORT	(PRINTER_CHANGE_ADD_PORT | \
-				 PRINTER_CHANGE_CONFIGURE_PORT | \
-				 PRINTER_CHANGE_DELETE_PORT )
-
-#define PRINTER_CHANGE_ADD_PRINT_PROCESSOR		0x01000000
-#define PRINTER_CHANGE_DELETE_PRINT_PROCESSOR		0x04000000
-#define PRINTER_CHANGE_PRINT_PROCESSOR	(PRINTER_CHANGE_ADD_PRINT_PROCESSOR | \
-					 PRINTER_CHANGE_DELETE_PRINT_PROCESSOR )
-
-#define PRINTER_CHANGE_ADD_PRINTER_DRIVER		0x10000000
-#define PRINTER_CHANGE_SET_PRINTER_DRIVER		0x20000000
-#define PRINTER_CHANGE_DELETE_PRINTER_DRIVER		0x40000000
-#define PRINTER_CHANGE_PRINTER_DRIVER	(PRINTER_CHANGE_ADD_PRINTER_DRIVER | \
-					 PRINTER_CHANGE_SET_PRINTER_DRIVER | \
-					 PRINTER_CHANGE_DELETE_PRINTER_DRIVER )
-
-#define PRINTER_CHANGE_TIMEOUT				0x80000000
-#define PRINTER_CHANGE_ALL	(PRINTER_CHANGE_JOB | \
-				 PRINTER_CHANGE_FORM | \
-				 PRINTER_CHANGE_PORT | \
-				 PRINTER_CHANGE_PRINT_PROCESSOR | \
-				 PRINTER_CHANGE_PRINTER_DRIVER )
-
-#define PRINTER_NOTIFY_INFO_DISCARDED	0x1
-
-/*
- * Set of macros for flagging what changed in the PRINTER_INFO_2 struct
- * when sending messages to other smbd's
- */
-#define PRINTER_MESSAGE_NULL            0x00000000
-#define PRINTER_MESSAGE_DRIVER		0x00000001
-#define PRINTER_MESSAGE_COMMENT		0x00000002
-#define PRINTER_MESSAGE_PRINTERNAME	0x00000004
-#define PRINTER_MESSAGE_LOCATION	0x00000008
-#define PRINTER_MESSAGE_DEVMODE		0x00000010	/* not curently supported */
-#define PRINTER_MESSAGE_SEPFILE		0x00000020
-#define PRINTER_MESSAGE_PRINTPROC	0x00000040
-#define PRINTER_MESSAGE_PARAMS		0x00000080
-#define PRINTER_MESSAGE_DATATYPE	0x00000100
-#define PRINTER_MESSAGE_SECDESC		0x00000200
-#define PRINTER_MESSAGE_CJOBS		0x00000400
-#define PRINTER_MESSAGE_PORT		0x00000800
-#define PRINTER_MESSAGE_SHARENAME	0x00001000
-#define PRINTER_MESSAGE_ATTRIBUTES	0x00002000
-
-typedef struct printer_message_info {
-	uint32 low;		/* PRINTER_CHANGE_XXX */
-	uint32 high;		/* PRINTER_CHANGE_XXX */
-	fstring printer_name;
-	uint32 flags;		/* PRINTER_MESSAGE_XXX */
-}
-PRINTER_MESSAGE_INFO;
-
-/*
- * The printer attributes.
- * I #defined all of them (grabbed form MSDN)
- * I'm only using:
- * ( SHARED | NETWORK | RAW_ONLY )
- * RAW_ONLY _MUST_ be present otherwise NT will send an EMF file
- */
-
-#define PRINTER_ATTRIBUTE_QUEUED		0x00000001
-#define PRINTER_ATTRIBUTE_DIRECT		0x00000002
-#define PRINTER_ATTRIBUTE_DEFAULT		0x00000004
-#define PRINTER_ATTRIBUTE_SHARED		0x00000008
-
-#define PRINTER_ATTRIBUTE_NETWORK		0x00000010
-#define PRINTER_ATTRIBUTE_HIDDEN		0x00000020
-#define PRINTER_ATTRIBUTE_LOCAL			0x00000040
-#define PRINTER_ATTRIBUTE_ENABLE_DEVQ		0x00000080
-
-#define PRINTER_ATTRIBUTE_KEEPPRINTEDJOBS	0x00000100
-#define PRINTER_ATTRIBUTE_DO_COMPLETE_FIRST	0x00000200
-#define PRINTER_ATTRIBUTE_WORK_OFFLINE		0x00000400
-#define PRINTER_ATTRIBUTE_ENABLE_BIDI		0x00000800
-
-#define PRINTER_ATTRIBUTE_RAW_ONLY		0x00001000
-
-#define NO_PRIORITY	 0
-#define MAX_PRIORITY	99
-#define MIN_PRIORITY	 1
-#define DEF_PRIORITY	 1
-
-/* the flags of the query */
-#define PRINTER_ENUM_DEFAULT		0x00000001
-#define PRINTER_ENUM_LOCAL		0x00000002
-#define PRINTER_ENUM_CONNECTIONS	0x00000004
-#define PRINTER_ENUM_FAVORITE		0x00000004
-#define PRINTER_ENUM_NAME		0x00000008
-#define PRINTER_ENUM_REMOTE		0x00000010
-#define PRINTER_ENUM_SHARED		0x00000020
-#define PRINTER_ENUM_NETWORK		0x00000040
-
-/* the flags of each printers */
-#define PRINTER_ENUM_UNKNOWN_8		0x00000008
-#define PRINTER_ENUM_EXPAND		0x00004000
-#define PRINTER_ENUM_CONTAINER		0x00008000
-#define PRINTER_ENUM_ICONMASK		0x00ff0000
-#define PRINTER_ENUM_ICON1		0x00010000
-#define PRINTER_ENUM_ICON2		0x00020000
-#define PRINTER_ENUM_ICON3		0x00040000
-#define PRINTER_ENUM_ICON4		0x00080000
-#define PRINTER_ENUM_ICON5		0x00100000
-#define PRINTER_ENUM_ICON6		0x00200000
-#define PRINTER_ENUM_ICON7		0x00400000
-#define PRINTER_ENUM_ICON8		0x00800000
-
-#define DRIVER_ANY_VERSION		0xffffffff
-#define DRIVER_MAX_VERSION		4
-/* this struct is undocumented */
-/* thanks to the ddk ... */
-typedef struct spool_user_1
-{
-	uint32 size;		/* length of user_name & client_name + 2? */
-	uint32 client_name_ptr;
-	uint32 user_name_ptr;
-	uint32 build;
-	uint32 major;
-	uint32 minor;
-	uint32 processor;
-	UNISTR2 client_name;
-	UNISTR2 user_name;
-}
-SPOOL_USER_1;
-
-typedef struct spool_user_ctr_info
-{
-	uint32 level;
-	uint32 ptr;
-	SPOOL_USER_1 user1;
-}
-SPOOL_USER_CTR;
-
-/*
- * various bits in the DEVICEMODE.fields member
- */
-
-#define DEVMODE_ORIENTATION		0x00000001
-#define DEVMODE_PAPERSIZE		0x00000002
-#define DEVMODE_PAPERLENGTH		0x00000004
-#define DEVMODE_PAPERWIDTH		0x00000008
-#define DEVMODE_SCALE			0x00000010
-#define DEVMODE_POSITION		0x00000020
-#define DEVMODE_NUP			0x00000040
-#define DEVMODE_COPIES			0x00000100
-#define DEVMODE_DEFAULTSOURCE		0x00000200
-#define DEVMODE_PRINTQUALITY		0x00000400
-#define DEVMODE_COLOR			0x00000800
-#define DEVMODE_DUPLEX			0x00001000
-#define DEVMODE_YRESOLUTION		0x00002000
-#define DEVMODE_TTOPTION		0x00004000
-#define DEVMODE_COLLATE			0x00008000
-#define DEVMODE_FORMNAME		0x00010000
-#define DEVMODE_LOGPIXELS		0x00020000
-#define DEVMODE_BITSPERPEL		0x00040000
-#define DEVMODE_PELSWIDTH		0x00080000
-#define DEVMODE_PELSHEIGHT		0x00100000
-#define DEVMODE_DISPLAYFLAGS		0x00200000
-#define DEVMODE_DISPLAYFREQUENCY	0x00400000
-#define DEVMODE_ICMMETHOD		0x00800000
-#define DEVMODE_ICMINTENT		0x01000000
-#define DEVMODE_MEDIATYPE		0x02000000
-#define DEVMODE_DITHERTYPE		0x04000000
-#define DEVMODE_PANNINGWIDTH		0x08000000
-#define DEVMODE_PANNINGHEIGHT		0x10000000
-
-
-/* 
- * Devicemode structure
- */
-
-typedef struct devicemode
-{
-	UNISTR devicename;
-	uint16 specversion;
-	uint16 driverversion;
-	uint16 size;
-	uint16 driverextra;
-	uint32 fields;
-	uint16 orientation;
-	uint16 papersize;
-	uint16 paperlength;
-	uint16 paperwidth;
-	uint16 scale;
-	uint16 copies;
-	uint16 defaultsource;
-	uint16 printquality;
-	uint16 color;
-	uint16 duplex;
-	uint16 yresolution;
-	uint16 ttoption;
-	uint16 collate;
-	UNISTR formname;
-	uint16 logpixels;
-	uint32 bitsperpel;
-	uint32 pelswidth;
-	uint32 pelsheight;
-	uint32 displayflags;
-	uint32 displayfrequency;
-	uint32 icmmethod;
-	uint32 icmintent;
-	uint32 mediatype;
-	uint32 dithertype;
-	uint32 reserved1;
-	uint32 reserved2;
-	uint32 panningwidth;
-	uint32 panningheight;
-	uint8 *private;
-}
-DEVICEMODE;
-
-typedef struct _devmode_cont
-{
-	uint32 size;
-	uint32 devmode_ptr;
-	DEVICEMODE *devmode;
-}
-DEVMODE_CTR;
-
-typedef struct _printer_default
-{
-	uint32 datatype_ptr;
-	UNISTR2 datatype;
-	DEVMODE_CTR devmode_cont;
-	uint32 access_required;
-}
-PRINTER_DEFAULT;
-
-/* SPOOL_Q_OPEN_PRINTER request to open a printer */
-typedef struct spool_q_open_printer
-{
-	uint32 printername_ptr;
-	UNISTR2 printername;
-	PRINTER_DEFAULT printer_default;
-}
-SPOOL_Q_OPEN_PRINTER;
-
-/* SPOOL_R_OPEN_PRINTER reply to an open printer */
-typedef struct spool_r_open_printer
-{
-	POLICY_HND handle;	/* handle used along all transactions (20*uint8) */
-	WERROR status;
-}
-SPOOL_R_OPEN_PRINTER;
-
-/* SPOOL_Q_OPEN_PRINTER_EX request to open a printer */
-typedef struct spool_q_open_printer_ex
-{
-	uint32 printername_ptr;
-	UNISTR2 printername;
-	PRINTER_DEFAULT printer_default;
-	uint32 user_switch;
-	SPOOL_USER_CTR user_ctr;
-}
-SPOOL_Q_OPEN_PRINTER_EX;
-
-/* SPOOL_R_OPEN_PRINTER_EX reply to an open printer */
-typedef struct spool_r_open_printer_ex
-{
-	POLICY_HND handle;	/* handle used along all transactions (20*uint8) */
-	WERROR status;
-}
-SPOOL_R_OPEN_PRINTER_EX;
-
-typedef struct spool_notify_option_type
-{
-	uint16 type;
-	uint16 reserved0;
-	uint32 reserved1;
-	uint32 reserved2;
-	uint32 count;
-	uint32 fields_ptr;
-	uint32 count2;
-	uint16 fields[MAX_NOTIFY_TYPE_FOR_NOW];
-}
-SPOOL_NOTIFY_OPTION_TYPE;
-
-typedef struct spool_notify_option_type_ctr
-{
-	uint32 count;
-	SPOOL_NOTIFY_OPTION_TYPE *type;
-}
-SPOOL_NOTIFY_OPTION_TYPE_CTR;
-
-
-
-typedef struct s_header_type
-{
-	uint32 type;
-	union
-	{
-		uint32 value;
-		UNISTR string;
-	}
-	data;
-}
-HEADER_TYPE;
-
-typedef struct new_buffer
-{
-	uint32 ptr;
-	uint32 size;
-	prs_struct prs;
-	uint32 struct_start;
-	uint32 string_at_end;
-}
-NEW_BUFFER;
-
-typedef struct spool_q_getprinterdata
-{
-	POLICY_HND handle;
-	UNISTR2 valuename;
-	uint32 size;
-}
-SPOOL_Q_GETPRINTERDATA;
-
-typedef struct spool_r_getprinterdata
-{
-	uint32 type;
-	uint32 size;
-	uint8 *data;
-	uint32 needed;
-	WERROR status;
-}
-SPOOL_R_GETPRINTERDATA;
-
-typedef struct spool_q_deleteprinterdata
-{
-	POLICY_HND handle;
-	UNISTR2 valuename;
-}
-SPOOL_Q_DELETEPRINTERDATA;
-
-typedef struct spool_r_deleteprinterdata
-{
-	WERROR status;
-}
-SPOOL_R_DELETEPRINTERDATA;
-
-typedef struct spool_q_closeprinter
-{
-	POLICY_HND handle;
-}
-SPOOL_Q_CLOSEPRINTER;
-
-typedef struct spool_r_closeprinter
-{
-	POLICY_HND handle;
-	WERROR status;
-}
-SPOOL_R_CLOSEPRINTER;
-
-typedef struct spool_q_startpageprinter
-{
-	POLICY_HND handle;
-}
-SPOOL_Q_STARTPAGEPRINTER;
-
-typedef struct spool_r_startpageprinter
-{
-	WERROR status;
-}
-SPOOL_R_STARTPAGEPRINTER;
-
-typedef struct spool_q_endpageprinter
-{
-	POLICY_HND handle;
-}
-SPOOL_Q_ENDPAGEPRINTER;
-
-typedef struct spool_r_endpageprinter
-{
-	WERROR status;
-}
-SPOOL_R_ENDPAGEPRINTER;
-
-
-typedef struct spool_q_deleteprinterdriver
-{
-	uint32 server_ptr;
-	UNISTR2 server;
-	UNISTR2 arch;
-	UNISTR2 driver;
-}
-SPOOL_Q_DELETEPRINTERDRIVER;
-
-typedef struct spool_r_deleteprinterdriver
-{
-	WERROR status;
-}
-SPOOL_R_DELETEPRINTERDRIVER;
-
-
-typedef struct spool_doc_info_1
-{
-	uint32 p_docname;
-	uint32 p_outputfile;
-	uint32 p_datatype;
-	UNISTR2 docname;
-	UNISTR2 outputfile;
-	UNISTR2 datatype;
-}
-DOC_INFO_1;
-
-typedef struct spool_doc_info
-{
-	uint32 switch_value;
-	DOC_INFO_1 doc_info_1;
-}
-DOC_INFO;
-
-typedef struct spool_doc_info_container
-{
-	uint32 level;
-	DOC_INFO docinfo;
-}
-DOC_INFO_CONTAINER;
-
-typedef struct spool_q_startdocprinter
-{
-	POLICY_HND handle;
-	DOC_INFO_CONTAINER doc_info_container;
-}
-SPOOL_Q_STARTDOCPRINTER;
-
-typedef struct spool_r_startdocprinter
-{
-	uint32 jobid;
-	WERROR status;
-}
-SPOOL_R_STARTDOCPRINTER;
-
-typedef struct spool_q_enddocprinter
-{
-	POLICY_HND handle;
-}
-SPOOL_Q_ENDDOCPRINTER;
-
-typedef struct spool_r_enddocprinter
-{
-	WERROR status;
-}
-SPOOL_R_ENDDOCPRINTER;
-
-typedef struct spool_q_writeprinter
-{
-	POLICY_HND handle;
-	uint32 buffer_size;
-	uint8 *buffer;
-	uint32 buffer_size2;
-}
-SPOOL_Q_WRITEPRINTER;
-
-typedef struct spool_r_writeprinter
-{
-	uint32 buffer_written;
-	WERROR status;
-}
-SPOOL_R_WRITEPRINTER;
-
-typedef struct spool_notify_option
-{
-	uint32 version;
-	uint32 flags;
-	uint32 count;
-	uint32 option_type_ptr;
-	SPOOL_NOTIFY_OPTION_TYPE_CTR ctr;
-}
-SPOOL_NOTIFY_OPTION;
-
-typedef struct spool_notify_info_data
-{
-	uint16 type;
-	uint16 field;
-	uint32 reserved;
-	uint32 id;
-	union
-	{
-		uint32 value[2];
-		struct
-		{
-			uint32 length;
-			uint16 *string;
-		}
-		data;
-	}
-	notify_data;
-	uint32 size;
-	BOOL enc_type;
-} SPOOL_NOTIFY_INFO_DATA;
-
-typedef struct spool_notify_info
-{
-	uint32 version;
-	uint32 flags;
-	uint32 count;
-	SPOOL_NOTIFY_INFO_DATA *data;
-}
-SPOOL_NOTIFY_INFO;
-
-/* If the struct name looks obscure, yes it is ! */
-/* RemoteFindFirstPrinterChangeNotificationEx query struct */
-typedef struct spoolss_q_rffpcnex
-{
-	POLICY_HND handle;
-	uint32 flags;
-	uint32 options;
-	uint32 localmachine_ptr;
-	UNISTR2 localmachine;
-	uint32 printerlocal;
-	uint32 option_ptr;
-	SPOOL_NOTIFY_OPTION *option;
-}
-SPOOL_Q_RFFPCNEX;
-
-typedef struct spool_r_rffpcnex
-{
-	WERROR status;
-}
-SPOOL_R_RFFPCNEX;
-
-/* Remote Find Next Printer Change Notify Ex */
-typedef struct spool_q_rfnpcnex
-{
-	POLICY_HND handle;
-	uint32 change;
-	uint32 option_ptr;
-	SPOOL_NOTIFY_OPTION *option;
-}
-SPOOL_Q_RFNPCNEX;
-
-typedef struct spool_r_rfnpcnex
-{
-	uint32 info_ptr;
-	SPOOL_NOTIFY_INFO info;
-	WERROR status;
-}
-SPOOL_R_RFNPCNEX;
-
-/* Find Close Printer Notify */
-typedef struct spool_q_fcpn
-{
-	POLICY_HND handle;
-}
-SPOOL_Q_FCPN;
-
-typedef struct spool_r_fcpn
-{
-	WERROR status;
-}
-SPOOL_R_FCPN;
-
-
-typedef struct printer_info_0
-{
-	UNISTR printername;
-	UNISTR servername;
-	uint32 cjobs;
-	uint32 total_jobs;
-	uint32 total_bytes;
-	
-	uint16 year;
-	uint16 month;
-	uint16 dayofweek;
-	uint16 day;
-	uint16 hour;
-	uint16 minute;
-	uint16 second;
-	uint16 milliseconds;
-
-	uint32 global_counter;
-	uint32 total_pages;
-
-	uint16 major_version;
-	uint16 build_version;
-
-	uint32 unknown7;
-	uint32 unknown8;
-	uint32 unknown9;
-	uint32 session_counter;
-	uint32 unknown11;
-	uint32 printer_errors;
-	uint32 unknown13;
-	uint32 unknown14;
-	uint32 unknown15;
-	uint32 unknown16;
-	uint32 change_id;
-	uint32 unknown18;
-	uint32 status;
-	uint32 unknown20;
-	uint32 c_setprinter;
-
-	uint16 unknown22;
-	uint16 unknown23;
-	uint16 unknown24;
-	uint16 unknown25;
-	uint16 unknown26;
-	uint16 unknown27;
-	uint16 unknown28;
-	uint16 unknown29;
-} PRINTER_INFO_0;
-
-typedef struct printer_info_1
-{
-	uint32 flags;
-	UNISTR description;
-	UNISTR name;
-	UNISTR comment;
-}
-PRINTER_INFO_1;
-
-typedef struct printer_info_2
-{
-	UNISTR servername;
-	UNISTR printername;
-	UNISTR sharename;
-	UNISTR portname;
-	UNISTR drivername;
-	UNISTR comment;
-	UNISTR location;
-	DEVICEMODE *devmode;
-	UNISTR sepfile;
-	UNISTR printprocessor;
-	UNISTR datatype;
-	UNISTR parameters;
-	SEC_DESC *secdesc;
-	uint32 attributes;
-	uint32 priority;
-	uint32 defaultpriority;
-	uint32 starttime;
-	uint32 untiltime;
-	uint32 status;
-	uint32 cjobs;
-	uint32 averageppm;
-}
-PRINTER_INFO_2;
-
-typedef struct printer_info_3
-{
-	uint32 flags;
-	SEC_DESC *secdesc;
-}
-PRINTER_INFO_3;
-
-typedef struct printer_info_4
-{
-	UNISTR printername;
-	UNISTR servername;
-	uint32 attributes;
-}
-PRINTER_INFO_4;
-
-typedef struct printer_info_5
-{
-	UNISTR printername;
-	UNISTR portname;
-	uint32 attributes;
-	uint32 device_not_selected_timeout;
-	uint32 transmission_retry_timeout;
-}
-PRINTER_INFO_5;
-
-typedef struct spool_q_enumprinters
-{
-	uint32 flags;
-	uint32 servername_ptr;
-	UNISTR2 servername;
-	uint32 level;
-	NEW_BUFFER *buffer;
-	uint32 offered;
-}
-SPOOL_Q_ENUMPRINTERS;
-
-typedef struct printer_info_ctr_info
-{
-	PRINTER_INFO_0 *printers_0;
-	PRINTER_INFO_1 *printers_1;
-	PRINTER_INFO_2 *printers_2;
-	PRINTER_INFO_3 *printers_3;
-	PRINTER_INFO_4 *printers_4;
-	PRINTER_INFO_5 *printers_5;
-}
-PRINTER_INFO_CTR;
-
-typedef struct spool_r_enumprinters
-{
-	NEW_BUFFER *buffer;
-	uint32 needed;		/* bytes needed */
-	uint32 returned;	/* number of printers */
-	WERROR status;
-}
-SPOOL_R_ENUMPRINTERS;
-
-
-typedef struct spool_q_getprinter
-{
-	POLICY_HND handle;
-	uint32 level;
-	NEW_BUFFER *buffer;
-	uint32 offered;
-}
-SPOOL_Q_GETPRINTER;
-
-typedef struct printer_info_info
-{
-	union
-	{
-		PRINTER_INFO_0 *info0;
-		PRINTER_INFO_1 *info1;
-		PRINTER_INFO_2 *info2;
-		void *info;
-	} printer;
-} PRINTER_INFO;
-
-typedef struct spool_r_getprinter
-{
-	NEW_BUFFER *buffer;
-	uint32 needed;
-	WERROR status;
-} SPOOL_R_GETPRINTER;
-
-typedef struct driver_info_1
-{
-	UNISTR name;
-} DRIVER_INFO_1;
-
-typedef struct driver_info_2
-{
-	uint32 version;
-	UNISTR name;
-	UNISTR architecture;
-	UNISTR driverpath;
-	UNISTR datafile;
-	UNISTR configfile;
-} DRIVER_INFO_2;
-
-typedef struct driver_info_3
-{
-	uint32 version;
-	UNISTR name;
-	UNISTR architecture;
-	UNISTR driverpath;
-	UNISTR datafile;
-	UNISTR configfile;
-	UNISTR helpfile;
-	uint16 *dependentfiles;
-	UNISTR monitorname;
-	UNISTR defaultdatatype;
-}
-DRIVER_INFO_3;
-
-typedef struct driver_info_6
-{
-	uint32 version;
-	UNISTR name;
-	UNISTR architecture;
-	UNISTR driverpath;
-	UNISTR datafile;
-	UNISTR configfile;
-	UNISTR helpfile;
-	uint16 *dependentfiles;
-	UNISTR monitorname;
-	UNISTR defaultdatatype;
-	uint16* previousdrivernames;
-	NTTIME driver_date;
-	uint32 padding;
-	uint32 driver_version_low;
-	uint32 driver_version_high;
-	UNISTR mfgname;
-	UNISTR oem_url;
-	UNISTR hardware_id;
-	UNISTR provider;
-}
-DRIVER_INFO_6;
-
-typedef struct driver_info_info
-{
-	DRIVER_INFO_1 *info1;
-	DRIVER_INFO_2 *info2;
-	DRIVER_INFO_3 *info3;
-	DRIVER_INFO_6 *info6;
-}
-PRINTER_DRIVER_CTR;
-
-typedef struct spool_q_getprinterdriver2
-{
-	POLICY_HND handle;
-	uint32 architecture_ptr;
-	UNISTR2 architecture;
-	uint32 level;
-	NEW_BUFFER *buffer;
-	uint32 offered;
-	uint32 clientmajorversion;
-	uint32 clientminorversion;
-}
-SPOOL_Q_GETPRINTERDRIVER2;
-
-typedef struct spool_r_getprinterdriver2
-{
-	NEW_BUFFER *buffer;
-	uint32 needed;
-	uint32 servermajorversion;
-	uint32 serverminorversion;
-	WERROR status;
-}
-SPOOL_R_GETPRINTERDRIVER2;
-
-
-typedef struct add_jobinfo_1
-{
-	UNISTR path;
-	uint32 job_number;
-}
-ADD_JOBINFO_1;
-
-
-typedef struct spool_q_addjob
-{
-	POLICY_HND handle;
-	uint32 level;
-	NEW_BUFFER *buffer;
-	uint32 offered;
-}
-SPOOL_Q_ADDJOB;
-
-typedef struct spool_r_addjob
-{
-	NEW_BUFFER *buffer;
-	uint32 needed;
-	WERROR status;
-}
-SPOOL_R_ADDJOB;
-
-/*
- * I'm really wondering how many different time formats
- * I will have to cope with
- *
- * JFM, 09/13/98 In a mad mood ;-(
-*/
-typedef struct systemtime
-{
-	uint16 year;
-	uint16 month;
-	uint16 dayofweek;
-	uint16 day;
-	uint16 hour;
-	uint16 minute;
-	uint16 second;
-	uint16 milliseconds;
-}
-SYSTEMTIME;
-
-typedef struct s_job_info_1
-{
-	uint32 jobid;
-	UNISTR printername;
-	UNISTR machinename;
-	UNISTR username;
-	UNISTR document;
-	UNISTR datatype;
-	UNISTR text_status;
-	uint32 status;
-	uint32 priority;
-	uint32 position;
-	uint32 totalpages;
-	uint32 pagesprinted;
-	SYSTEMTIME submitted;
-}
-JOB_INFO_1;
-
-typedef struct s_job_info_2
-{
-	uint32 jobid;
-	UNISTR printername;
-	UNISTR machinename;
-	UNISTR username;
-	UNISTR document;
-	UNISTR notifyname;
-	UNISTR datatype;
-	UNISTR printprocessor;
-	UNISTR parameters;
-	UNISTR drivername;
-	DEVICEMODE *devmode;
-	UNISTR text_status;
-/*	SEC_DESC sec_desc;*/
-	uint32 status;
-	uint32 priority;
-	uint32 position;
-	uint32 starttime;
-	uint32 untiltime;
-	uint32 totalpages;
-	uint32 size;
-	SYSTEMTIME submitted;
-	uint32 timeelapsed;
-	uint32 pagesprinted;
-}
-JOB_INFO_2;
-
-typedef struct spool_q_enumjobs
-{
-	POLICY_HND handle;
-	uint32 firstjob;
-	uint32 numofjobs;
-	uint32 level;
-	NEW_BUFFER *buffer;
-	uint32 offered;
-}
-SPOOL_Q_ENUMJOBS;
-
-typedef struct job_info_ctr_info
-{
-	union
-	{
-		JOB_INFO_1 **job_info_1;
-		JOB_INFO_2 **job_info_2;
-		void *info;
-	} job;
-
-} JOB_INFO_CTR;
-
-typedef struct spool_r_enumjobs
-{
-	NEW_BUFFER *buffer;
-	uint32 needed;
-	uint32 returned;
-	WERROR status;
-}
-SPOOL_R_ENUMJOBS;
-
-typedef struct spool_q_schedulejob
-{
-	POLICY_HND handle;
-	uint32 jobid;
-}
-SPOOL_Q_SCHEDULEJOB;
-
-typedef struct spool_r_schedulejob
-{
-	WERROR status;
-}
-SPOOL_R_SCHEDULEJOB;
-
-typedef struct s_port_info_1
-{
-	UNISTR port_name;
-}
-PORT_INFO_1;
-
-typedef struct s_port_info_2
-{
-	UNISTR port_name;
-	UNISTR monitor_name;
-	UNISTR description;
-	uint32 port_type;
-	uint32 reserved;
-}
-PORT_INFO_2;
-
-typedef struct spool_q_enumports
-{
-	uint32 name_ptr;
-	UNISTR2 name;
-	uint32 level;
-	NEW_BUFFER *buffer;
-	uint32 offered;
-}
-SPOOL_Q_ENUMPORTS;
-
-typedef struct port_info_ctr_info
-{
-	union
-	{
-		PORT_INFO_1 *info_1;
-		PORT_INFO_2 *info_2;
-	}
-	port;
-
-}
-PORT_INFO_CTR;
-
-typedef struct spool_r_enumports
-{
-	NEW_BUFFER *buffer;
-	uint32 needed;		/* bytes needed */
-	uint32 returned;	/* number of printers */
-	WERROR status;
-}
-SPOOL_R_ENUMPORTS;
-
-#define JOB_CONTROL_PAUSE              1
-#define JOB_CONTROL_RESUME             2
-#define JOB_CONTROL_CANCEL             3
-#define JOB_CONTROL_RESTART            4
-#define JOB_CONTROL_DELETE             5
-
-typedef struct job_info_info
-{
-	union
-	{
-		JOB_INFO_1 job_info_1;
-		JOB_INFO_2 job_info_2;
-	}
-	job;
-
-}
-JOB_INFO;
-
-typedef struct spool_q_setjob
-{
-	POLICY_HND handle;
-	uint32 jobid;
-	uint32 level;
-	JOB_INFO ctr;
-	uint32 command;
-
-}
-SPOOL_Q_SETJOB;
-
-typedef struct spool_r_setjob
-{
-	WERROR status;
-
-}
-SPOOL_R_SETJOB;
-
-typedef struct spool_q_enumprinterdrivers
-{
-	uint32 name_ptr;
-	UNISTR2 name;
-	uint32 environment_ptr;
-	UNISTR2 environment;
-	uint32 level;
-	NEW_BUFFER *buffer;
-	uint32 offered;
-}
-SPOOL_Q_ENUMPRINTERDRIVERS;
-
-typedef struct spool_r_enumprinterdrivers
-{
-	NEW_BUFFER *buffer;
-	uint32 needed;
-	uint32 returned;
-	WERROR status;
-}
-SPOOL_R_ENUMPRINTERDRIVERS;
-
-#define FORM_USER    0
-#define FORM_BUILTIN 1
-#define FORM_PRINTER 2
-
-typedef struct spool_form_1
-{
-	uint32 flag;
-	UNISTR name;
-	uint32 width;
-	uint32 length;
-	uint32 left;
-	uint32 top;
-	uint32 right;
-	uint32 bottom;
-}
-FORM_1;
-
-typedef struct spool_q_enumforms
-{
-	POLICY_HND handle;
-	uint32 level;
-	NEW_BUFFER *buffer;
-	uint32 offered;
-}
-SPOOL_Q_ENUMFORMS;
-
-typedef struct spool_r_enumforms
-{
-	NEW_BUFFER *buffer;
-	uint32 needed;
-	uint32 numofforms;
-	WERROR status;
-}
-SPOOL_R_ENUMFORMS;
-
-typedef struct spool_q_getform
-{
-	POLICY_HND handle;
-	UNISTR2 formname;
-	uint32 level;
-	NEW_BUFFER *buffer;
-	uint32 offered;
-}
-SPOOL_Q_GETFORM;
-
-typedef struct spool_r_getform
-{
-	NEW_BUFFER *buffer;
-	uint32 needed;
-	WERROR status;
-}
-SPOOL_R_GETFORM;
-
-typedef struct spool_printer_info_level_1
-{
-	uint32 flags;
-	uint32 description_ptr;
-	uint32 name_ptr;
-	uint32 comment_ptr;
-	UNISTR2 description;
-	UNISTR2 name;
-	UNISTR2 comment;	
-} SPOOL_PRINTER_INFO_LEVEL_1;
-
-typedef struct spool_printer_info_level_2
-{
-	uint32 servername_ptr;
-	uint32 printername_ptr;
-	uint32 sharename_ptr;
-	uint32 portname_ptr;
-	uint32 drivername_ptr;
-	uint32 comment_ptr;
-	uint32 location_ptr;
-	uint32 devmode_ptr;
-	uint32 sepfile_ptr;
-	uint32 printprocessor_ptr;
-	uint32 datatype_ptr;
-	uint32 parameters_ptr;
-	uint32 secdesc_ptr;
-	uint32 attributes;
-	uint32 priority;
-	uint32 default_priority;
-	uint32 starttime;
-	uint32 untiltime;
-	uint32 status;
-	uint32 cjobs;
-	uint32 averageppm;
-	UNISTR2 servername;
-	UNISTR2 printername;
-	UNISTR2 sharename;
-	UNISTR2 portname;
-	UNISTR2 drivername;
-	UNISTR2 comment;
-	UNISTR2 location;
-	UNISTR2 sepfile;
-	UNISTR2 printprocessor;
-	UNISTR2 datatype;
-	UNISTR2 parameters;
-}
-SPOOL_PRINTER_INFO_LEVEL_2;
-
-typedef struct spool_printer_info_level_3
-{
-	uint32 secdesc_ptr;
-}
-SPOOL_PRINTER_INFO_LEVEL_3;
-
-typedef struct spool_printer_info_level
-{
-	uint32 level;
-	uint32 info_ptr;
-	SPOOL_PRINTER_INFO_LEVEL_1 *info_1;
-	SPOOL_PRINTER_INFO_LEVEL_2 *info_2;
-	SPOOL_PRINTER_INFO_LEVEL_3 *info_3;
-}
-SPOOL_PRINTER_INFO_LEVEL;
-
-typedef struct spool_printer_driver_info_level_3
-{
-	uint32 cversion;
-	uint32 name_ptr;
-	uint32 environment_ptr;
-	uint32 driverpath_ptr;
-	uint32 datafile_ptr;
-	uint32 configfile_ptr;
-	uint32 helpfile_ptr;
-	uint32 monitorname_ptr;
-	uint32 defaultdatatype_ptr;
-	uint32 dependentfilessize;
-	uint32 dependentfiles_ptr;
-
-	UNISTR2 name;
-	UNISTR2 environment;
-	UNISTR2 driverpath;
-	UNISTR2 datafile;
-	UNISTR2 configfile;
-	UNISTR2 helpfile;
-	UNISTR2 monitorname;
-	UNISTR2 defaultdatatype;
-	BUFFER5 dependentfiles;
-
-}
-SPOOL_PRINTER_DRIVER_INFO_LEVEL_3;
-
-/* SPOOL_PRINTER_DRIVER_INFO_LEVEL_6 structure */
-typedef struct {
-	uint32 version;
-	uint32 name_ptr;
-	uint32 environment_ptr;
-	uint32 driverpath_ptr;
-	uint32 datafile_ptr;
-	uint32 configfile_ptr;
-	uint32 helpfile_ptr;
-	uint32 monitorname_ptr;
-	uint32 defaultdatatype_ptr;
-	uint32 dependentfiles_len;
-	uint32 dependentfiles_ptr;
-	uint32 previousnames_len;
-	uint32 previousnames_ptr;
-	NTTIME	driverdate;
-	UINT64_S	driverversion;
-	uint32	dummy4;
-	uint32 mfgname_ptr;
-	uint32 oemurl_ptr;
-	uint32 hardwareid_ptr;
-	uint32 provider_ptr;
-	UNISTR2	name;
-	UNISTR2	environment;
-	UNISTR2	driverpath;
-	UNISTR2	datafile;
-	UNISTR2	configfile;
-	UNISTR2	helpfile;
-	UNISTR2	monitorname;
-	UNISTR2	defaultdatatype;
-	BUFFER5	dependentfiles;
-	BUFFER5	previousnames;
-	UNISTR2	mfgname;
-	UNISTR2	oemurl;
-	UNISTR2	hardwareid;
-	UNISTR2	provider;
-} SPOOL_PRINTER_DRIVER_INFO_LEVEL_6;
-
-
-typedef struct spool_printer_driver_info_level
-{
-	uint32 level;
-	uint32 ptr;
-	SPOOL_PRINTER_DRIVER_INFO_LEVEL_3 *info_3;
-	SPOOL_PRINTER_DRIVER_INFO_LEVEL_6 *info_6;
-}
-SPOOL_PRINTER_DRIVER_INFO_LEVEL;
-
-
-/* this struct is undocumented */
-/* thanks to the ddk ... */
-typedef struct spool_user_level_1
-{
-	uint32 size;
-	uint32 client_name_ptr;
-	uint32 user_name_ptr;
-	uint32 build;
-	uint32 major;
-	uint32 minor;
-	uint32 processor;
-	UNISTR2 client_name;
-	UNISTR2 user_name;
-}
-SPOOL_USER_LEVEL_1;
-
-typedef struct spool_user_level
-{
-	SPOOL_USER_LEVEL_1 *user_level_1;
-}
-SPOOL_USER_LEVEL;
-
-typedef struct spool_q_setprinter
-{
-	POLICY_HND handle;
-	uint32 level;
-	SPOOL_PRINTER_INFO_LEVEL info;
-	SEC_DESC_BUF *secdesc_ctr;
-	DEVMODE_CTR devmode_ctr;
-
-	uint32 command;
-
-}
-SPOOL_Q_SETPRINTER;
-
-typedef struct spool_r_setprinter
-{
-	WERROR status;
-}
-SPOOL_R_SETPRINTER;
-
-typedef struct spool_q_addprinter
-{
-	UNISTR2 server_name;
-	uint32 level;
-	SPOOL_PRINTER_INFO_LEVEL info;
-	DEVMODE_CTR devmode_ctr;
-	SEC_DESC_BUF *secdesc_ctr;
-	uint32 user_level;
-	SPOOL_USER_LEVEL user;
-}
-SPOOL_Q_ADDPRINTER;
-
-typedef struct spool_r_addprinter
-{
-	WERROR status;
-}
-SPOOL_R_ADDPRINTER;
-
-typedef struct spool_q_deleteprinter
-{
-	POLICY_HND handle;
-}
-SPOOL_Q_DELETEPRINTER;
-
-typedef struct spool_r_deleteprinter
-{
-	POLICY_HND handle;
-	WERROR status;
-}
-SPOOL_R_DELETEPRINTER;
-
-typedef struct spool_q_abortprinter
-{
-	POLICY_HND handle;
-}
-SPOOL_Q_ABORTPRINTER;
-
-typedef struct spool_r_abortprinter
-{
-	WERROR status;
-}
-SPOOL_R_ABORTPRINTER;
-
-
-typedef struct spool_q_addprinterex
-{
-	uint32 server_name_ptr;
-	UNISTR2 server_name;
-	uint32 level;
-	SPOOL_PRINTER_INFO_LEVEL info;
-	DEVMODE_CTR devmode_ctr;
-	SEC_DESC_BUF *secdesc_ctr;
-	uint32 user_switch;
-	SPOOL_USER_CTR user_ctr;
-}
-SPOOL_Q_ADDPRINTEREX;
-
-typedef struct spool_r_addprinterex
-{
-	POLICY_HND handle;
-	WERROR status;
-}
-SPOOL_R_ADDPRINTEREX;
-
-
-typedef struct spool_q_addprinterdriver
-{
-	uint32 server_name_ptr;
-	UNISTR2 server_name;
-	uint32 level;
-	SPOOL_PRINTER_DRIVER_INFO_LEVEL info;
-}
-SPOOL_Q_ADDPRINTERDRIVER;
-
-typedef struct spool_r_addprinterdriver
-{
-	WERROR status;
-}
-SPOOL_R_ADDPRINTERDRIVER;
-
-
-typedef struct driver_directory_1
-{
-	UNISTR name;
-}
-DRIVER_DIRECTORY_1;
-
-typedef struct driver_info_ctr_info
-{
-	DRIVER_DIRECTORY_1 *info1;
-}
-DRIVER_DIRECTORY_CTR;
-
-typedef struct spool_q_getprinterdriverdirectory
-{
-	uint32 name_ptr;
-	UNISTR2 name;
-	uint32 environment_ptr;
-	UNISTR2 environment;
-	uint32 level;
-	NEW_BUFFER *buffer;
-	uint32 offered;
-}
-SPOOL_Q_GETPRINTERDRIVERDIR;
-
-typedef struct spool_r_getprinterdriverdirectory
-{
-	NEW_BUFFER *buffer;
-	uint32 needed;
-	WERROR status;
-}
-SPOOL_R_GETPRINTERDRIVERDIR;
-
-typedef struct spool_q_addprintprocessor
-{
-	uint32 server_ptr;
-	UNISTR2 server;
-	UNISTR2 environment;
-	UNISTR2 path;
-	UNISTR2 name;
-}
-SPOOL_Q_ADDPRINTPROCESSOR;
-
-typedef struct spool_r_addprintprocessor
-{
-	WERROR status;
-}
-SPOOL_R_ADDPRINTPROCESSOR;
-
-
-typedef struct spool_q_enumprintprocessors
-{
-	uint32 name_ptr;
-	UNISTR2 name;
-	uint32 environment_ptr;
-	UNISTR2 environment;
-	uint32 level;
-	NEW_BUFFER *buffer;
-	uint32 offered;
-}
-SPOOL_Q_ENUMPRINTPROCESSORS;
-
-typedef struct printprocessor_1
-{
-	UNISTR name;
-}
-PRINTPROCESSOR_1;
-
-typedef struct spool_r_enumprintprocessors
-{
-	NEW_BUFFER *buffer;
-	uint32 needed;
-	uint32 returned;
-	WERROR status;
-}
-SPOOL_R_ENUMPRINTPROCESSORS;
-
-typedef struct spool_q_enumprintprocdatatypes
-{
-	uint32 name_ptr;
-	UNISTR2 name;
-	uint32 processor_ptr;
-	UNISTR2 processor;
-	uint32 level;
-	NEW_BUFFER *buffer;
-	uint32 offered;
-}
-SPOOL_Q_ENUMPRINTPROCDATATYPES;
-
-typedef struct ppdatatype_1
-{
-	UNISTR name;
-}
-PRINTPROCDATATYPE_1;
-
-typedef struct spool_r_enumprintprocdatatypes
-{
-	NEW_BUFFER *buffer;
-	uint32 needed;
-	uint32 returned;
-	WERROR status;
-}
-SPOOL_R_ENUMPRINTPROCDATATYPES;
-
-typedef struct printmonitor_1
-{
-	UNISTR name;
-}
-PRINTMONITOR_1;
-
-typedef struct printmonitor_2
-{
-	UNISTR name;
-	UNISTR environment;
-	UNISTR dll_name;
-}
-PRINTMONITOR_2;
-
-typedef struct spool_q_enumprintmonitors
-{
-	uint32 name_ptr;
-	UNISTR2 name;
-	uint32 level;
-	NEW_BUFFER *buffer;
-	uint32 offered;
-}
-SPOOL_Q_ENUMPRINTMONITORS;
-
-typedef struct spool_r_enumprintmonitors
-{
-	NEW_BUFFER *buffer;
-	uint32 needed;
-	uint32 returned;
-	WERROR status;
-}
-SPOOL_R_ENUMPRINTMONITORS;
-
-
-typedef struct spool_q_enumprinterdata
-{
-	POLICY_HND handle;
-	uint32 index;
-	uint32 valuesize;
-	uint32 datasize;
-}
-SPOOL_Q_ENUMPRINTERDATA;
-
-typedef struct spool_r_enumprinterdata
-{
-	uint32 valuesize;
-	uint16 *value;
-	uint32 realvaluesize;
-	uint32 type;
-	uint32 datasize;
-	uint8 *data;
-	uint32 realdatasize;
-	WERROR status;
-}
-SPOOL_R_ENUMPRINTERDATA;
-
-typedef struct spool_q_setprinterdata
-{
-	POLICY_HND handle;
-	UNISTR2 value;
-	uint32 type;
-	uint32 max_len;
-	uint8 *data;
-	uint32 real_len;
-	uint32 numeric_data;
-}
-SPOOL_Q_SETPRINTERDATA;
-
-typedef struct spool_r_setprinterdata
-{
-	WERROR status;
-}
-SPOOL_R_SETPRINTERDATA;
-
-typedef struct spool_q_resetprinter
-{
-	POLICY_HND handle;
-	uint32 datatype_ptr;
-	UNISTR2 datatype;
-	DEVMODE_CTR devmode_ctr;
-
-} SPOOL_Q_RESETPRINTER;
-
-typedef struct spool_r_resetprinter
-{
-	WERROR status;
-} 
-SPOOL_R_RESETPRINTER;
-
-
-
-typedef struct _form
-{
-	uint32 flags;
-	uint32 name_ptr;
-	uint32 size_x;
-	uint32 size_y;
-	uint32 left;
-	uint32 top;
-	uint32 right;
-	uint32 bottom;
-	UNISTR2 name;
-}
-FORM;
-
-typedef struct spool_q_addform
-{
-	POLICY_HND handle;
-	uint32 level;
-	uint32 level2;		/* This should really be part of the FORM structure */
-	FORM form;
-}
-SPOOL_Q_ADDFORM;
-
-typedef struct spool_r_addform
-{
-	WERROR status;
-}
-SPOOL_R_ADDFORM;
-
-typedef struct spool_q_setform
-{
-	POLICY_HND handle;
-	UNISTR2 name;
-	uint32 level;
-	uint32 level2;
-	FORM form;
-}
-SPOOL_Q_SETFORM;
-
-typedef struct spool_r_setform
-{
-	WERROR status;
-}
-SPOOL_R_SETFORM;
-
-typedef struct spool_q_deleteform
-{
-	POLICY_HND handle;
-	UNISTR2 name;
-}
-SPOOL_Q_DELETEFORM;
-
-typedef struct spool_r_deleteform
-{
-	WERROR status;
-}
-SPOOL_R_DELETEFORM;
-
-typedef struct spool_q_getjob
-{
-	POLICY_HND handle;
-	uint32 jobid;
-	uint32 level;
-	NEW_BUFFER *buffer;
-	uint32 offered;
-}
-SPOOL_Q_GETJOB;
-
-typedef struct pjob_info_info
-{
-	union
-	{
-		JOB_INFO_1 *job_info_1;
-		JOB_INFO_2 *job_info_2;
-		void *info;
-	}
-	job;
-
-}
-PJOB_INFO;
-
-typedef struct spool_r_getjob
-{
-	NEW_BUFFER *buffer;
-	uint32 needed;
-	WERROR status;
-}
-SPOOL_R_GETJOB;
-
-typedef struct spool_q_replyopenprinter
-{
-	UNISTR2 string;
-	uint32 printer;
-	uint32 type;
-	uint32 unknown0;
-	uint32 unknown1;
-}
-SPOOL_Q_REPLYOPENPRINTER;
-
-typedef struct spool_r_replyopenprinter
-{
-	POLICY_HND handle;
-	WERROR status;
-}
-SPOOL_R_REPLYOPENPRINTER;
-
-typedef struct spool_q_routerreplyprinter
-{
-	POLICY_HND handle;
-	uint32 condition;
-	uint32 unknown1;	/* 0x00000001 */
-	uint32 change_id;
-	uint8  unknown2[5];	/* 0x0000000001 */
-}
-SPOOL_Q_ROUTERREPLYPRINTER;
-
-typedef struct spool_r_routerreplyprinter
-{
-	WERROR status;
-}
-SPOOL_R_ROUTERREPLYPRINTER;
-
-typedef struct spool_q_replycloseprinter
-{
-	POLICY_HND handle;
-}
-SPOOL_Q_REPLYCLOSEPRINTER;
-
-typedef struct spool_r_replycloseprinter
-{
-	POLICY_HND handle;
-	WERROR status;
-}
-SPOOL_R_REPLYCLOSEPRINTER;
-
-typedef struct spool_q_rrpcn
-{
-	POLICY_HND handle;
-	uint32 change_low;
-	uint32 change_high;
-	uint32 unknown0;
-	uint32 unknown1;
-	uint32 info_ptr;
-	SPOOL_NOTIFY_INFO info;	
-}
-SPOOL_Q_REPLY_RRPCN;
-
-typedef struct spool_r_rrpcn
-{
-	uint32 unknown0;
-	WERROR status;
-}
-SPOOL_R_REPLY_RRPCN;
-
-typedef struct spool_q_getprinterdataex
-{
-	POLICY_HND handle;
-	UNISTR2 keyname;
-        UNISTR2 valuename;
-	uint32 size;
-}
-SPOOL_Q_GETPRINTERDATAEX;
-
-typedef struct spool_r_getprinterdataex
-{
-	uint32 type;
-	uint32 size;
-	uint8 *data;
-	uint32 needed;
-	WERROR status;
-}
-SPOOL_R_GETPRINTERDATAEX;
-
-typedef struct spool_q_setprinterdataex
-{
-	POLICY_HND handle;
-	UNISTR2 key;
-	UNISTR2 value;
-	uint32 type;
-	uint32 max_len;
-	uint8 *data;
-	uint32 real_len;
-	uint32 numeric_data;
-}
-SPOOL_Q_SETPRINTERDATAEX;
-
-typedef struct spool_r_setprinterdataex
-{
-	WERROR status;
-}
-SPOOL_R_SETPRINTERDATAEX;
-
-
-typedef struct spool_q_enumprinterkey
-{
-	POLICY_HND handle;
-	UNISTR2 key;
-	uint32 size;
-}
-SPOOL_Q_ENUMPRINTERKEY;
-
-typedef struct spool_r_enumprinterkey
-{
-	BUFFER5 keys;
-	uint32 needed;	/* in bytes */
-	WERROR status;
-}
-SPOOL_R_ENUMPRINTERKEY;
-
-typedef struct printer_enum_values
-{
-	UNISTR valuename;
-	uint32 value_len;
-	uint32 type;
-	uint8  *data;
-	uint32 data_len; 
-	
-}
-PRINTER_ENUM_VALUES;
-
-typedef struct printer_enum_values_ctr
-{
-	uint32 size;
-	uint32 size_of_array;
-	PRINTER_ENUM_VALUES *values;
-}
-PRINTER_ENUM_VALUES_CTR;
-
-typedef struct spool_q_enumprinterdataex
-{
-	POLICY_HND handle;
-	UNISTR2 key;
-	uint32 size;
-}
-SPOOL_Q_ENUMPRINTERDATAEX;
-
-typedef struct spool_r_enumprinterdataex
-{
-	PRINTER_ENUM_VALUES_CTR ctr;
-	uint32 needed;
-	uint32 returned;
-	WERROR status;
-}
-SPOOL_R_ENUMPRINTERDATAEX;
-
-typedef struct printprocessor_directory_1
-{
-	UNISTR name;
-}
-PRINTPROCESSOR_DIRECTORY_1;
-
-typedef struct spool_q_getprintprocessordirectory
-{
-	UNISTR2 name;
-	UNISTR2 environment;
-	uint32 level;
-	NEW_BUFFER *buffer;
-	uint32 offered;
-}
-SPOOL_Q_GETPRINTPROCESSORDIRECTORY;
-
-typedef struct spool_r_getprintprocessordirectory
-{
-	NEW_BUFFER *buffer;
-	uint32 needed;
-	WERROR status;
-}
-SPOOL_R_GETPRINTPROCESSORDIRECTORY;
-
-#define PRINTER_DRIVER_VERSION 2
-#define PRINTER_DRIVER_ARCHITECTURE "Windows NT x86"
-
-#endif /* _RPC_SPOOLSS_H */
-
diff -Naur samba-2.2.12-orig/source/include/smb.h samba-2.2.12/source/include/smb.h
--- samba-2.2.12-orig/source/include/smb.h	2004-08-12 20:24:30.000000000 +0200
+++ samba-2.2.12/source/include/smb.h	2011-03-04 13:47:54.000000000 +0100
@@ -534,26 +534,9 @@
 enum {LPQ_QUEUED=0,LPQ_PAUSED,LPQ_SPOOLING,LPQ_PRINTING,LPQ_ERROR,LPQ_DELETING,
       LPQ_OFFLINE,LPQ_PAPEROUT,LPQ_PRINTED,LPQ_DELETED,LPQ_BLOCKED,LPQ_USER_INTERVENTION};
 
-typedef struct _print_queue_struct
-{
-  int job;
-  int size;
-  int page_count;
-  int status;
-  int priority;
-  time_t time;
-  fstring fs_user;
-  fstring fs_file;
-} print_queue_struct;
 
 enum {LPSTAT_OK, LPSTAT_STOPPED, LPSTAT_ERROR};
 
-typedef struct
-{
-  fstring message;
-  int qcount;
-  int status;
-}  print_status_struct;
 
 /* used for server information: client, nameserv and ipc */
 struct server_info_struct
@@ -1621,7 +1604,6 @@
 #include "rpc_creds.h"
 #include "rpc_misc.h"
 #include "rpc_secdes.h"
-#include "nt_printing.h"
 
 typedef struct user_struct
 {
diff -Naur samba-2.2.12-orig/source/libsmb/cli_spoolss.c samba-2.2.12/source/libsmb/cli_spoolss.c
--- samba-2.2.12-orig/source/libsmb/cli_spoolss.c	2004-08-12 20:24:25.000000000 +0200
+++ samba-2.2.12/source/libsmb/cli_spoolss.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1538 +0,0 @@
-/* 
-   Unix SMB/CIFS implementation.
-   RPC pipe client
-
-   Copyright (C) Gerald Carter                2001-2002,
-   Copyright (C) Tim Potter                   2000-2002,
-   Copyright (C) Andrew Tridgell              1994-2000,
-   Copyright (C) Luke Kenneth Casson Leighton 1996-2000,
-   Copyright (C) Jean-Francois Micouleau      1999-2000.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2 of the License, or
-   (at your option) any later version.
-   
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-   
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-*/
-
-#include "includes.h"
-
-/** @defgroup spoolss SPOOLSS - NT printing routines
- *  @ingroup rpc_client
- *
- * @{
- **/
-
-/** Opens a SMB connection and connects to the SPOOLSS pipe.
- *
- * @param cli Uninitialised client handle.
- * @param system_name NETBIOS name of the machine to connect to.
- * @param creds User credentials to connect as.
- * @returns Initialised client handle.
- */
-struct cli_state *cli_spoolss_initialise(struct cli_state *cli, 
-					 char *system_name,
-					 struct ntuser_creds *creds)
-{
-        return cli_pipe_initialise(cli, system_name, PIPE_SPOOLSS, creds);
-}
-
-
-/**********************************************************************
- Initialize a new spoolss buff for use by a client rpc
-**********************************************************************/
-static void init_buffer(NEW_BUFFER *buffer, uint32 size, TALLOC_CTX *ctx)
-{
-	buffer->ptr = (size != 0);
-	buffer->size = size;
-	buffer->string_at_end = size;
-	prs_init(&buffer->prs, size, ctx, MARSHALL);
-	buffer->struct_start = prs_offset(&buffer->prs);
-}
-
-/********************************************************************* 
- Decode various spoolss rpc's and info levels 
- ********************************************************************/
-
-/**********************************************************************
-**********************************************************************/
-static void decode_printer_info_0(TALLOC_CTX *mem_ctx, NEW_BUFFER *buffer, 
-				uint32 returned, PRINTER_INFO_0 **info)
-{
-        uint32 i;
-        PRINTER_INFO_0  *inf;
-
-        inf=(PRINTER_INFO_0 *)talloc(mem_ctx, returned*sizeof(PRINTER_INFO_0));
-
-        buffer->prs.data_offset=0;
-
-        for (i=0; i<returned; i++) {
-                smb_io_printer_info_0("", buffer, &inf[i], 0);
-        }
-
-        *info=inf;
-}
-
-/**********************************************************************
-**********************************************************************/
-static void decode_printer_info_1(TALLOC_CTX *mem_ctx, NEW_BUFFER *buffer, 
-				uint32 returned, PRINTER_INFO_1 **info)
-{
-        uint32 i;
-        PRINTER_INFO_1  *inf;
-
-        inf=(PRINTER_INFO_1 *)talloc(mem_ctx, returned*sizeof(PRINTER_INFO_1));
-
-        buffer->prs.data_offset=0;
-
-        for (i=0; i<returned; i++) {
-                smb_io_printer_info_1("", buffer, &inf[i], 0);
-        }
-
-        *info=inf;
-}
-
-/**********************************************************************
-**********************************************************************/
-static void decode_printer_info_2(TALLOC_CTX *mem_ctx, NEW_BUFFER *buffer, 
-				uint32 returned, PRINTER_INFO_2 **info)
-{
-        uint32 i;
-        PRINTER_INFO_2  *inf;
-
-        inf=(PRINTER_INFO_2 *)talloc(mem_ctx, returned*sizeof(PRINTER_INFO_2));
-
-        buffer->prs.data_offset=0;
-
-        for (i=0; i<returned; i++) {
-		/* a little initialization as we go */
-		inf[i].secdesc = NULL;
-                smb_io_printer_info_2("", buffer, &inf[i], 0);
-        }
-
-        *info=inf;
-}
-
-/**********************************************************************
-**********************************************************************/
-static void decode_printer_info_3(TALLOC_CTX *mem_ctx, NEW_BUFFER *buffer, 
-				uint32 returned, PRINTER_INFO_3 **info)
-{
-        uint32 i;
-        PRINTER_INFO_3  *inf;
-
-        inf=(PRINTER_INFO_3 *)talloc(mem_ctx, returned*sizeof(PRINTER_INFO_3));
-
-        buffer->prs.data_offset=0;
-
-        for (i=0; i<returned; i++) {
-		inf[i].secdesc = NULL;
-                smb_io_printer_info_3("", buffer, &inf[i], 0);
-        }
-
-        *info=inf;
-}
-
-/**********************************************************************
-**********************************************************************/
-static void decode_port_info_1(TALLOC_CTX *mem_ctx, NEW_BUFFER *buffer, 
-			uint32 returned, PORT_INFO_1 **info)
-{
-        uint32 i;
-        PORT_INFO_1 *inf;
-
-        inf=(PORT_INFO_1*)talloc(mem_ctx, returned*sizeof(PORT_INFO_1));
-
-        prs_set_offset(&buffer->prs, 0);
-
-        for (i=0; i<returned; i++) {
-                smb_io_port_info_1("", buffer, &(inf[i]), 0);
-        }
-
-        *info=inf;
-}
-
-/**********************************************************************
-**********************************************************************/
-static void decode_port_info_2(TALLOC_CTX *mem_ctx, NEW_BUFFER *buffer, 
-			uint32 returned, PORT_INFO_2 **info)
-{
-        uint32 i;
-        PORT_INFO_2 *inf;
-
-        inf=(PORT_INFO_2*)talloc(mem_ctx, returned*sizeof(PORT_INFO_2));
-
-        prs_set_offset(&buffer->prs, 0);
-
-        for (i=0; i<returned; i++) {
-                smb_io_port_info_2("", buffer, &(inf[i]), 0);
-        }
-
-        *info=inf;
-}
-
-/**********************************************************************
-**********************************************************************/
-static void decode_printer_driver_1(TALLOC_CTX *mem_ctx, NEW_BUFFER *buffer, 
-			uint32 returned, DRIVER_INFO_1 **info)
-{
-        uint32 i;
-        DRIVER_INFO_1 *inf;
-
-        inf=(DRIVER_INFO_1 *)talloc(mem_ctx, returned*sizeof(DRIVER_INFO_1));
-
-        buffer->prs.data_offset=0;
-
-        for (i=0; i<returned; i++) {
-                smb_io_printer_driver_info_1("", buffer, &(inf[i]), 0);
-        }
-
-        *info=inf;
-}
-
-/**********************************************************************
-**********************************************************************/
-static void decode_printer_driver_2(TALLOC_CTX *mem_ctx, NEW_BUFFER *buffer, 
-			uint32 returned, DRIVER_INFO_2 **info)
-{
-        uint32 i;
-        DRIVER_INFO_2 *inf;
-
-        inf=(DRIVER_INFO_2 *)talloc(mem_ctx, returned*sizeof(DRIVER_INFO_2));
-
-        buffer->prs.data_offset=0;
-
-        for (i=0; i<returned; i++) {
-                smb_io_printer_driver_info_2("", buffer, &(inf[i]), 0);
-        }
-
-        *info=inf;
-}
-
-/**********************************************************************
-**********************************************************************/
-static void decode_printer_driver_3(TALLOC_CTX *mem_ctx, NEW_BUFFER *buffer, 
-			uint32 returned, DRIVER_INFO_3 **info)
-{
-        uint32 i;
-        DRIVER_INFO_3 *inf;
-
-        inf=(DRIVER_INFO_3 *)talloc(mem_ctx, returned*sizeof(DRIVER_INFO_3));
-
-        buffer->prs.data_offset=0;
-
-        for (i=0; i<returned; i++) {
-                smb_io_printer_driver_info_3("", buffer, &(inf[i]), 0);
-        }
-
-        *info=inf;
-}
-
-/**********************************************************************
-**********************************************************************/
-static void decode_printerdriverdir_1 (TALLOC_CTX *mem_ctx, NEW_BUFFER *buffer,
-			uint32 returned, DRIVER_DIRECTORY_1 **info
-)
-{
-	DRIVER_DIRECTORY_1 *inf;
- 
-        inf=(DRIVER_DIRECTORY_1 *)talloc(mem_ctx, sizeof(DRIVER_DIRECTORY_1));
-
-        prs_set_offset(&buffer->prs, 0);
-
-        smb_io_driverdir_1("", buffer, inf, 0);
- 
-	*info=inf;
-}
-
-/** Return a handle to the specified printer or print server.
- *
- * @param cli              Pointer to client state structure which is open
- * on the SPOOLSS pipe.
- *
- * @param mem_ctx          Pointer to an initialised talloc context.
- *
- * @param printername      The name of the printer or print server to be
- * opened in UNC format.
- *
- * @param datatype         Specifies the default data type for the printer.
- *
- * @param access_required  The access rights requested on the printer or
- * print server.
- *
- * @param station          The UNC name of the requesting workstation.
- *
- * @param username         The name of the user requesting the open.
- *
- * @param pol              Returned policy handle.
- */
-
-/*********************************************************************************
- Win32 API - OpenPrinter()
- ********************************************************************************/
- 
-WERROR cli_spoolss_open_printer_ex(struct cli_state *cli, TALLOC_CTX *mem_ctx,
-				char *printername, const char *datatype, uint32 access_required,
-				char *station, char *username, POLICY_HND *pol)
-{
-	prs_struct qbuf, rbuf;
-	SPOOL_Q_OPEN_PRINTER_EX q;
-	SPOOL_R_OPEN_PRINTER_EX r;
-	WERROR result = W_ERROR(ERRgeneral);
-
-	ZERO_STRUCT(q);
-	ZERO_STRUCT(r);
-
-	/* Initialise parse structures */
-
-	prs_init(&qbuf, MAX_PDU_FRAG_LEN, mem_ctx, MARSHALL);
-	prs_init(&rbuf, 0, mem_ctx, UNMARSHALL);
-
-	/* Initialise input parameters */
-
-        make_spoolss_q_open_printer_ex(&q, printername, datatype,
-                                       access_required, station, username);
-	
-	/* Marshall data and send request */
-
-	if (!spoolss_io_q_open_printer_ex("", &q, &qbuf, 0) ||
-	    !rpc_api_pipe_req(cli, SPOOLSS_OPENPRINTEREX, &qbuf, &rbuf))
-		goto done;
-
-	/* Unmarshall response */
-
-	if (!spoolss_io_r_open_printer_ex("", &r, &rbuf, 0))
-		goto done;
-
-	/* Return output parameters */
-
-	result = r.status;
-
-	if (W_ERROR_IS_OK(result))
-		*pol = r.handle;
-
- done:
-	prs_mem_free(&qbuf);
-	prs_mem_free(&rbuf);
-
-	return result;
-}
-
-/** Close a printer handle
- *
- * @param cli              Pointer to client state structure which is open
- * on the SPOOLSS pipe.
- *
- * @param mem_ctx          Pointer to an initialised talloc context.
- *
- * @param pol              Policy handle of printer or print server to close.
- */
-/*********************************************************************************
- Win32 API - ClosePrinter()
- ********************************************************************************/
-
-WERROR cli_spoolss_close_printer(struct cli_state *cli, TALLOC_CTX *mem_ctx,
-				POLICY_HND *pol)
-{
-	prs_struct qbuf, rbuf;
-	SPOOL_Q_CLOSEPRINTER q;
-	SPOOL_R_CLOSEPRINTER r;
-	WERROR result = W_ERROR(ERRgeneral);
-
-	ZERO_STRUCT(q);
-	ZERO_STRUCT(r);
-
-	/* Initialise parse structures */
-
-	prs_init(&qbuf, MAX_PDU_FRAG_LEN, mem_ctx, MARSHALL);
-	prs_init(&rbuf, 0, mem_ctx, UNMARSHALL);
-
-	/* Initialise input parameters */
-
-        make_spoolss_q_closeprinter(&q, pol);
-	
-	/* Marshall data and send request */
-
-	if (!spoolss_io_q_closeprinter("", &q, &qbuf, 0) ||
-	    !rpc_api_pipe_req(cli, SPOOLSS_CLOSEPRINTER, &qbuf, &rbuf))
-		goto done;
-
-	/* Unmarshall response */
-
-	if (!spoolss_io_r_closeprinter("", &r, &rbuf, 0))
-		goto done;
-
-	/* Return output parameters */
-
-	result = r.status;
-
-	if (W_ERROR_IS_OK(result))
-		*pol = r.handle;
-
- done:
-	prs_mem_free(&qbuf);
-	prs_mem_free(&rbuf);
-
-	return result;
-}
-
-/** Enumerate printers on a print server.
- *
- * @param cli              Pointer to client state structure which is open
- *                         on the SPOOLSS pipe.
- * @param mem_ctx          Pointer to an initialised talloc context.
- *
- * @param offered          Buffer size offered in the request.
- * @param needed           Number of bytes needed to complete the request.
- *                         may be NULL.
- *
- * @param flags            Selected from PRINTER_ENUM_* flags.
- * @param level            Request information level.
- *
- * @param num_printers     Pointer to number of printers returned.  May be
- *                         NULL.
- * @param ctr              Return structure for printer information.  May
- *                         be NULL.
- */
-/*********************************************************************************
- Win32 API - EnumPrinters()
- ********************************************************************************/
-
-WERROR cli_spoolss_enum_printers(struct cli_state *cli, TALLOC_CTX *mem_ctx,
-				 uint32 offered, uint32 *needed,
-				 uint32 flags, uint32 level,
-				 uint32 *num_printers, PRINTER_INFO_CTR *ctr)
-{
-	prs_struct qbuf, rbuf;
-	SPOOL_Q_ENUMPRINTERS q;
-        SPOOL_R_ENUMPRINTERS r;
-	NEW_BUFFER buffer;
-	WERROR result = W_ERROR(ERRgeneral);
-	fstring server;
-
-	ZERO_STRUCT(q);
-	ZERO_STRUCT(r);
-
-	fstrcpy (server, cli->desthost);
-	strupper (server);
-	
-		/* Initialise input parameters */
-
-	init_buffer(&buffer, offered, mem_ctx);
-
-		prs_init(&qbuf, MAX_PDU_FRAG_LEN, mem_ctx, MARSHALL);
-		prs_init(&rbuf, 0, mem_ctx, UNMARSHALL);
-
-		make_spoolss_q_enumprinters(&q, flags, server, level, &buffer, 
-				    offered);
-
-		/* Marshall data and send request */
-
-		if (!spoolss_io_q_enumprinters("", &q, &qbuf, 0) ||
-	    !rpc_api_pipe_req(cli, SPOOLSS_ENUMPRINTERS, &qbuf, &rbuf))
-			goto done;
-
-		/* Unmarshall response */
-
-		if (spoolss_io_r_enumprinters("", &r, &rbuf, 0)) {
-		if (needed)
-			*needed = r.needed;
-		}
-		
-	result = r.status;
-		
-	/* Return output parameters */
-
-	if (!W_ERROR_IS_OK(r.status))
-			goto done;
-	
-	if (num_printers)
-		*num_printers = r.returned;
-
-	if (!ctr)
-		goto done;
-
-			switch (level) {
-			case 0:
-				decode_printer_info_0(mem_ctx, r.buffer, r.returned, 
-						      &ctr->printers_0);
-				break;
-			case 1:
-				decode_printer_info_1(mem_ctx, r.buffer, r.returned, 
-						      &ctr->printers_1);
-				break;
-			case 2:
-				decode_printer_info_2(mem_ctx, r.buffer, r.returned, 
-						      &ctr->printers_2);
-				break;
-			case 3:
-				decode_printer_info_3(mem_ctx, r.buffer, r.returned, 
-						      &ctr->printers_3);
-				break;
-			}			
-
-	done:
-		prs_mem_free(&qbuf);
-		prs_mem_free(&rbuf);
-
-	return result;	
-}
-
-/*********************************************************************************
- Win32 API - EnumPorts()
- ********************************************************************************/
-/** Enumerate printer ports on a print server.
- *
- * @param cli              Pointer to client state structure which is open
- *                         on the SPOOLSS pipe.
- * @param mem_ctx          Pointer to an initialised talloc context.
- *
- * @param offered          Buffer size offered in the request.
- * @param needed           Number of bytes needed to complete the request.
- *                         May be NULL.
- *
- * @param level            Requested information level.
- *
- * @param num_ports        Pointer to number of ports returned.  May be NULL.
- * @param ctr              Pointer to structure holding port information.
- *                         May be NULL.
- */
-
-WERROR cli_spoolss_enum_ports(struct cli_state *cli, TALLOC_CTX *mem_ctx,
-			      uint32 offered, uint32 *needed,
-			      uint32 level, int *num_ports, PORT_INFO_CTR *ctr)
-{
-	prs_struct qbuf, rbuf;
-	SPOOL_Q_ENUMPORTS q;
-        SPOOL_R_ENUMPORTS r;
-	NEW_BUFFER buffer;
-	WERROR result = W_ERROR(ERRgeneral);
-	fstring server;
-
-	ZERO_STRUCT(q);
-	ZERO_STRUCT(r);
-
-        slprintf (server, sizeof(fstring)-1, "\\\\%s", cli->desthost);
-        strupper (server);
-
-		/* Initialise input parameters */
-
-	init_buffer(&buffer, offered, mem_ctx);
-
-		prs_init(&qbuf, MAX_PDU_FRAG_LEN, mem_ctx, MARSHALL);
-		prs_init(&rbuf, 0, mem_ctx, UNMARSHALL);
-
-	make_spoolss_q_enumports(&q, server, level, &buffer, offered);
-
-		/* Marshall data and send request */
-
-		if (!spoolss_io_q_enumports("", &q, &qbuf, 0) ||
-	    !rpc_api_pipe_req(cli, SPOOLSS_ENUMPORTS, &qbuf, &rbuf))
-			goto done;
-
-		/* Unmarshall response */
-
-		if (spoolss_io_r_enumports("", &r, &rbuf, 0)) {
-		if (needed)
-			*needed = r.needed;
-		}
-		
-	result = r.status;
-
-		/* Return output parameters */
-
-	if (!W_ERROR_IS_OK(result))
-		goto done;
-
-	if (num_ports)
-		*num_ports = r.returned;
-
-	if (!ctr)
-		goto done;
-
-			switch (level) {
-			case 1:
-				decode_port_info_1(mem_ctx, r.buffer, r.returned, 
-						   &ctr->port.info_1);
-				break;
-			case 2:
-				decode_port_info_2(mem_ctx, r.buffer, r.returned, 
-						   &ctr->port.info_2);
-				break;
-			}			
-
-	done:
-		prs_mem_free(&qbuf);
-		prs_mem_free(&rbuf);
-
-	return result;	
-}
-
-/*********************************************************************************
- Win32 API - GetPrinter()
- ********************************************************************************/
-
-WERROR cli_spoolss_getprinter(struct cli_state *cli, TALLOC_CTX *mem_ctx,
-			      uint32 offered, uint32 *needed,
-			      POLICY_HND *pol, uint32 level, 
-			      PRINTER_INFO_CTR *ctr)
-{
-	prs_struct qbuf, rbuf;
-	SPOOL_Q_GETPRINTER q;
-	SPOOL_R_GETPRINTER r;
-	NEW_BUFFER buffer;
-	WERROR result = W_ERROR(ERRgeneral);
-
-	ZERO_STRUCT(q);
-	ZERO_STRUCT(r);
-
-		/* Initialise input parameters */
-
-	init_buffer(&buffer, offered, mem_ctx);
-
-		prs_init(&qbuf, MAX_PDU_FRAG_LEN, mem_ctx, MARSHALL);
-		prs_init(&rbuf, 0, mem_ctx, UNMARSHALL);
-
-	make_spoolss_q_getprinter(mem_ctx, &q, pol, level, &buffer, offered);
-
-		/* Marshall data and send request */
-
-		if (!spoolss_io_q_getprinter("", &q, &qbuf, 0) ||
-		    !rpc_api_pipe_req(cli, SPOOLSS_GETPRINTER, &qbuf, &rbuf)) 
-			goto done;
-
-		/* Unmarshall response */
-
-	if (!spoolss_io_r_getprinter("", &r, &rbuf, 0))
-		goto done;
-
-	if (needed)
-		*needed = r.needed;
-		
-		/* Return output parameters */
-
-	result = r.status;
-		
-		if (NT_STATUS_IS_OK(result)) {
-			switch (level) {
-			case 0:
-				decode_printer_info_0(mem_ctx, r.buffer, 1, &ctr->printers_0);
-				break;
-			case 1:
-				decode_printer_info_1(mem_ctx, r.buffer, 1, &ctr->printers_1);
-				break;
-			case 2:
-				decode_printer_info_2(mem_ctx, r.buffer, 1, &ctr->printers_2);
-				break;
-			case 3:
-				decode_printer_info_3(mem_ctx, r.buffer, 1, &ctr->printers_3);
-				break;
-			}			
-		}
-
-	done:
-		prs_mem_free(&qbuf);
-		prs_mem_free(&rbuf);
-
-	return result;	
-}
-
-/*********************************************************************************
- Win32 API - SetPrinter()
- ********************************************************************************/
-/** Set printer info 
- *
- * @param cli              Pointer to client state structure which is open
- *                         on the SPOOLSS pipe.
- * @param mem_ctx          Pointer to an initialised talloc context.
- *
- * @param pol              Policy handle on printer to set info.
- * @param level            Information level to set.
- * @param ctr              Pointer to structure holding printer information.
- * @param command          Specifies the action performed.  See
- * http://msdn.microsoft.com/library/default.asp?url=/library/en-us/gdi/prntspol_13ua.asp 
- * for details.
- *
- */
- 
-WERROR cli_spoolss_setprinter(struct cli_state *cli, TALLOC_CTX *mem_ctx,
-			      POLICY_HND *pol, uint32 level, 
-			      PRINTER_INFO_CTR *ctr, uint32 command)
-{
-	prs_struct qbuf, rbuf;
-	SPOOL_Q_SETPRINTER q;
-	SPOOL_R_SETPRINTER r;
-	WERROR result = W_ERROR(ERRgeneral);
-
-	ZERO_STRUCT(q);
-	ZERO_STRUCT(r);
-
-	/* Initialise input parameters */
-	prs_init(&qbuf, MAX_PDU_FRAG_LEN, mem_ctx, MARSHALL);
-	prs_init(&rbuf, 0, mem_ctx, UNMARSHALL);
-		
-	make_spoolss_q_setprinter(mem_ctx, &q, pol, level, ctr, command);
-
-	/* Marshall data and send request */
-
-	if (!spoolss_io_q_setprinter("", &q, &qbuf, 0) ||
-	    !rpc_api_pipe_req(cli, SPOOLSS_SETPRINTER, &qbuf, &rbuf)) 
-		goto done;
-
-	/* Unmarshall response */
-
-	if (!spoolss_io_r_setprinter("", &r, &rbuf, 0)) 
-		goto done;
-	
-	result = r.status;
-		
-done:
-	prs_mem_free(&qbuf);
-	prs_mem_free(&rbuf);
-
-
-	return result;	
-}
-
-/*********************************************************************************
- Win32 API - GetPrinterDriver()
- ********************************************************************************/
-/** Get installed printer drivers for a given printer
- *
- * @param cli              Pointer to client state structure which is open
- * on the SPOOLSS pipe.
- *
- * @param mem_ctx          Pointer to an initialised talloc context.
- *
- * @param offered          Buffer size offered in the request.
- * @param needed           Number of bytes needed to complete the request.
- *                         may be NULL.
- *
- * @param pol              Pointer to an open policy handle for the printer
- *                         opened with cli_spoolss_open_printer_ex().
- * @param level            Requested information level.
- * @param env              The print environment or archictecture.  This is
- *                         "Windows NT x86" for NT4.
- * @param ctr              Returned printer driver information.
- */
-
-WERROR cli_spoolss_getprinterdriver(struct cli_state *cli, 
-				    TALLOC_CTX *mem_ctx, 
-				    uint32 offered, uint32 *needed,
-				    POLICY_HND *pol, uint32 level, 
-				    const char *env, PRINTER_DRIVER_CTR *ctr)
-{
-	prs_struct qbuf, rbuf;
-	SPOOL_Q_GETPRINTERDRIVER2 q;
-        SPOOL_R_GETPRINTERDRIVER2 r;
-	NEW_BUFFER buffer;
-	WERROR result = W_ERROR(ERRgeneral);
-	fstring server;
-
-	ZERO_STRUCT(q);
-	ZERO_STRUCT(r);
-
-	fstrcpy (server, cli->desthost);
-	strupper (server);
-
-		/* Initialise input parameters */
-
-	init_buffer(&buffer, offered, mem_ctx);
-
-		prs_init(&qbuf, MAX_PDU_FRAG_LEN, mem_ctx, MARSHALL);
-		prs_init(&rbuf, 0, mem_ctx, UNMARSHALL);
-
-	make_spoolss_q_getprinterdriver2(&q, pol, env, level, 2, 2,
-					 &buffer, offered);
-
-	/* Marshall data and send request */
-
-		if (!spoolss_io_q_getprinterdriver2 ("", &q, &qbuf, 0) ||
-		    !rpc_api_pipe_req (cli, SPOOLSS_GETPRINTERDRIVER2, &qbuf, &rbuf)) 
-			goto done;
-
-		/* Unmarshall response */
-
-	if (spoolss_io_r_getprinterdriver2 ("", &r, &rbuf, 0)) {
-		if (needed)
-			*needed = r.needed;
-		}
-		
-	result = r.status;
-
-		/* Return output parameters */
-		
-	if (!W_ERROR_IS_OK(result))
-		goto done;
-
-	if (!ctr)
-		goto done;
-
-	switch (level) {
-			case 1:
-				decode_printer_driver_1(mem_ctx, r.buffer, 1, &ctr->info1);
-				break;
-			case 2:
-				decode_printer_driver_2(mem_ctx, r.buffer, 1, &ctr->info2);
-				break;
-			case 3:
-				decode_printer_driver_3(mem_ctx, r.buffer, 1, &ctr->info3);
-				break;
-			}			
-
-	done:
-		prs_mem_free(&qbuf);
-		prs_mem_free(&rbuf);
-
-	return result;	
-}
-
-/*********************************************************************************
- Win32 API - EnumPrinterDrivers()
- ********************************************************************************/
-/**********************************************************************
- * Get installed printer drivers for a given printer
- */
-WERROR cli_spoolss_enumprinterdrivers (struct cli_state *cli, 
-				       TALLOC_CTX *mem_ctx,
-				       uint32 offered, uint32 *needed,
-				       uint32 level, const char *env,
-				       uint32 *num_drivers,
-				PRINTER_DRIVER_CTR *ctr)
-{
-	prs_struct 			qbuf, rbuf;
-	SPOOL_Q_ENUMPRINTERDRIVERS 	q;
-        SPOOL_R_ENUMPRINTERDRIVERS 	r;
-	NEW_BUFFER 			buffer;
-	WERROR result = W_ERROR(ERRgeneral);
-	fstring 			server;
-
-	ZERO_STRUCT(q);
-	ZERO_STRUCT(r);
-
-        slprintf (server, sizeof(fstring)-1, "\\\\%s", cli->desthost);
-        strupper (server);
-
-		/* Initialise input parameters */
-
-	init_buffer(&buffer, offered, mem_ctx);
-
-		prs_init(&qbuf, MAX_PDU_FRAG_LEN, mem_ctx, MARSHALL);
-		prs_init(&rbuf, 0, mem_ctx, UNMARSHALL);
-
-	/* Write the request */
-
-	make_spoolss_q_enumprinterdrivers(&q, server, env, level, &buffer, 
-					  offered);
-
-		/* Marshall data and send request */
-	
-		if (!spoolss_io_q_enumprinterdrivers ("", &q, &qbuf, 0) ||
-		    !rpc_api_pipe_req (cli, SPOOLSS_ENUMPRINTERDRIVERS, &qbuf, &rbuf)) 
-			goto done;
-
-		/* Unmarshall response */
-
-	if (!spoolss_io_r_enumprinterdrivers ("", &r, &rbuf, 0))
-		goto done;
-
-	if (needed)
-		*needed = r.needed;
-
-	if (num_drivers)
-		*num_drivers = r.returned;
-
-	result = r.status;
-		
-		/* Return output parameters */
-
-	if (W_ERROR_IS_OK(result) && (r.returned != 0)) {
-		*num_drivers = r.returned;
-
-		switch (level) {
-			case 1:
-				decode_printer_driver_1(mem_ctx, r.buffer, r.returned, &ctr->info1);
-				break;
-			case 2:
-				decode_printer_driver_2(mem_ctx, r.buffer, r.returned, &ctr->info2);
-				break;
-			case 3:
-				decode_printer_driver_3(mem_ctx, r.buffer, r.returned, &ctr->info3);
-				break;
-			}			
-		}
-
-	done:
-		prs_mem_free(&qbuf);
-		prs_mem_free(&rbuf);
-
-	return result;	
-}
-
-
-/*********************************************************************************
- Win32 API - GetPrinterDriverDirectory()
- ********************************************************************************/
-/**********************************************************************
- * Get installed printer drivers for a given printer
- */
-WERROR cli_spoolss_getprinterdriverdir (struct cli_state *cli, 
-					TALLOC_CTX *mem_ctx,
-					uint32 offered, uint32 *needed,
-					uint32 level, char *env,
-					DRIVER_DIRECTORY_CTR *ctr)
-{
-	prs_struct 			qbuf, rbuf;
-	SPOOL_Q_GETPRINTERDRIVERDIR 	q;
-        SPOOL_R_GETPRINTERDRIVERDIR 	r;
-	NEW_BUFFER 			buffer;
-	WERROR result = W_ERROR(ERRgeneral);
-	fstring 			server;
-
-	ZERO_STRUCT(q);
-	ZERO_STRUCT(r);
-
-        slprintf (server, sizeof(fstring)-1, "\\\\%s", cli->desthost);
-        strupper (server);
-
-		/* Initialise input parameters */
-
-	init_buffer(&buffer, offered, mem_ctx);
-
-		prs_init(&qbuf, MAX_PDU_FRAG_LEN, mem_ctx, MARSHALL);
-		prs_init(&rbuf, 0, mem_ctx, UNMARSHALL);
-
-	/* Write the request */
-
-	make_spoolss_q_getprinterdriverdir(&q, server, env, level, &buffer, 
-					   offered);
-
-		/* Marshall data and send request */
-
-		if (!spoolss_io_q_getprinterdriverdir ("", &q, &qbuf, 0) ||
-	    !rpc_api_pipe_req (cli, SPOOLSS_GETPRINTERDRIVERDIRECTORY,
-			       &qbuf, &rbuf)) 
-			goto done;
-
-		/* Unmarshall response */
-
-	if (spoolss_io_r_getprinterdriverdir ("", &r, &rbuf, 0)) {
-		if (needed)
-			*needed = r.needed;
-		}
-		
-		/* Return output parameters */
-
-	result = r.status;
-
-	if (W_ERROR_IS_OK(result)) {
-		switch (level) {
-			case 1:
-			decode_printerdriverdir_1(mem_ctx, r.buffer, 1, 
-						  &ctr->info1);
-				break;
-			}			
-		}
-
-	done:
-		prs_mem_free(&qbuf);
-		prs_mem_free(&rbuf);
-
-	return result;	
-}
-
-/*********************************************************************************
- Win32 API - AddPrinterDriver()
- ********************************************************************************/
-/**********************************************************************
- * Install a printer driver
- */
-WERROR cli_spoolss_addprinterdriver (struct cli_state *cli, 
-				     TALLOC_CTX *mem_ctx, uint32 level,
-				     PRINTER_DRIVER_CTR *ctr)
-{
-	prs_struct 			qbuf, rbuf;
-	SPOOL_Q_ADDPRINTERDRIVER 	q;
-        SPOOL_R_ADDPRINTERDRIVER 	r;
-	WERROR result = W_ERROR(ERRgeneral);
-	fstring 			server;
-
-	ZERO_STRUCT(q);
-	ZERO_STRUCT(r);
-	
-        slprintf (server, sizeof(fstring)-1, "\\\\%s", cli->desthost);
-        strupper (server);
-
-	/* Initialise input parameters */
-	prs_init(&qbuf, MAX_PDU_FRAG_LEN, mem_ctx, MARSHALL);
-	prs_init(&rbuf, 0, mem_ctx, UNMARSHALL);
-
-	/* Write the request */
-
-	make_spoolss_q_addprinterdriver (mem_ctx, &q, server, level, ctr);
-
-	/* Marshall data and send request */
-
-	if (!spoolss_io_q_addprinterdriver ("", &q, &qbuf, 0) ||
-	    !rpc_api_pipe_req (cli, SPOOLSS_ADDPRINTERDRIVER, &qbuf, &rbuf)) 
-		goto done;
-
-	/* Unmarshall response */
-		
-	if (!spoolss_io_r_addprinterdriver ("", &r, &rbuf, 0))
-		goto done;
-		
-	/* Return output parameters */
-
-	result = r.status;
-
-done:
-	prs_mem_free(&qbuf);
-	prs_mem_free(&rbuf);
-	
-	return result;	
-}
-
-/*********************************************************************************
- Win32 API - AddPrinter()
- ********************************************************************************/
-/**********************************************************************
- * Install a printer
- */
-WERROR cli_spoolss_addprinterex (struct cli_state *cli, TALLOC_CTX *mem_ctx,
-				 uint32 level, PRINTER_INFO_CTR*ctr)
-{
-	prs_struct 			qbuf, rbuf;
-	SPOOL_Q_ADDPRINTEREX 		q;
-        SPOOL_R_ADDPRINTEREX 		r;
-	WERROR result = W_ERROR(ERRgeneral);
-	fstring 			server,
-					client,
-					user;
-
-	ZERO_STRUCT(q);
-	ZERO_STRUCT(r);
-
-        slprintf (client, sizeof(fstring)-1, "\\\\%s", cli->desthost);
-        strupper (client);
-        slprintf (server, sizeof(fstring)-1, "\\\\%s", cli->desthost);
-        strupper (server);
-	fstrcpy  (user, cli->user_name);
-	
-	/* Initialise input parameters */
-
-	prs_init(&qbuf, MAX_PDU_FRAG_LEN, mem_ctx, MARSHALL);
-	prs_init(&rbuf, 0, mem_ctx, UNMARSHALL);
-
-	/* Write the request */
-
-	make_spoolss_q_addprinterex (mem_ctx, &q, server, client, user,
-				     level, ctr);
-
-	/* Marshall data and send request */
-
-	if (!spoolss_io_q_addprinterex ("", &q, &qbuf, 0) ||
-	    !rpc_api_pipe_req (cli, SPOOLSS_ADDPRINTEREX, &qbuf, &rbuf)) 
-		goto done;
-
-	/* Unmarshall response */
-		
-	if (!spoolss_io_r_addprinterex ("", &r, &rbuf, 0))
-		goto done;
-		
-	/* Return output parameters */
-
-	result = r.status;
-
- done:
-	prs_mem_free(&qbuf);
-	prs_mem_free(&rbuf);
-
-	return result;	
-}
-
-/*********************************************************************************
- Win32 API - DeltePrinterDriver()
- ********************************************************************************/
-/**********************************************************************
- * Delete a Printer Driver from the server (does not remove 
- * the driver files
- */
-WERROR cli_spoolss_deleteprinterdriver (struct cli_state *cli, 
-					TALLOC_CTX *mem_ctx, const char *arch,
-					char *driver)
-{
-	prs_struct 			qbuf, rbuf;
-	SPOOL_Q_DELETEPRINTERDRIVER	q;
-        SPOOL_R_DELETEPRINTERDRIVER	r;
-	WERROR result = W_ERROR(ERRgeneral);
-	fstring				server;
-
-	ZERO_STRUCT(q);
-	ZERO_STRUCT(r);
-
-
-	/* Initialise input parameters */
-	prs_init(&qbuf, MAX_PDU_FRAG_LEN, mem_ctx, MARSHALL);
-	prs_init(&rbuf, 0, mem_ctx, UNMARSHALL);
-
-        slprintf (server, sizeof(fstring)-1, "\\\\%s", cli->desthost);
-        strupper (server);
-
-	/* Write the request */
-
-	make_spoolss_q_deleteprinterdriver(mem_ctx, &q, server, arch, driver);
-
-	/* Marshall data and send request */
-
-	if (!spoolss_io_q_deleteprinterdriver ("", &q, &qbuf, 0) ||
-	    !rpc_api_pipe_req (cli,SPOOLSS_DELETEPRINTERDRIVER , &qbuf, &rbuf)) 
-		goto done;
-
-	/* Unmarshall response */
-		
-	if (!spoolss_io_r_deleteprinterdriver ("", &r, &rbuf, 0))
-		goto done;
-		
-	/* Return output parameters */
-
-	result = r.status;
-
- done:
-	prs_mem_free(&qbuf);
-	prs_mem_free(&rbuf);
-
-	return result;	
-}
-
-/*********************************************************************************
- Win32 API - GetPrinterProcessorDirectory()
- ********************************************************************************/
-
-WERROR cli_spoolss_getprintprocessordirectory(struct cli_state *cli,
-					      TALLOC_CTX *mem_ctx,
-					      uint32 offered, uint32 *needed,
-					      char *name, char *environment,
-					      fstring procdir)
-{
-	prs_struct qbuf, rbuf;
-	SPOOL_Q_GETPRINTPROCESSORDIRECTORY q;
-	SPOOL_R_GETPRINTPROCESSORDIRECTORY r;
-	int level = 1;
-	WERROR result = W_ERROR(ERRgeneral);
-	NEW_BUFFER buffer;
-
-	ZERO_STRUCT(q);
-	ZERO_STRUCT(r);
-
-	/* Initialise parse structures */
-
-	prs_init(&qbuf, MAX_PDU_FRAG_LEN, mem_ctx, MARSHALL);
-	prs_init(&rbuf, 0, mem_ctx, UNMARSHALL);
-
-	/* Initialise input parameters */
-
-	init_buffer(&buffer, offered, mem_ctx);
-
-	make_spoolss_q_getprintprocessordirectory(
-		&q, name, environment, level, &buffer, offered);
-
-	/* Marshall data and send request */
-
-	if (!spoolss_io_q_getprintprocessordirectory("", &q, &qbuf, 0) ||
-	    !rpc_api_pipe_req(cli, SPOOLSS_GETPRINTPROCESSORDIRECTORY,
-			      &qbuf, &rbuf))
-		goto done;
-		
-	/* Unmarshall response */
-		
-	if (!spoolss_io_r_getprintprocessordirectory("", &r, &rbuf, 0))
-		goto done;
-
-	/* Return output parameters */
-		
-	result = r.status;
-
-	if (needed)
-		*needed = r.needed;
-
-	if (W_ERROR_IS_OK(result))
-		fstrcpy(procdir, "Not implemented!");
-
- done:
-	prs_mem_free(&qbuf);
-	prs_mem_free(&rbuf);
-
-	return result;
-}
-
-/** Add a form to a printer.
- *
- * @param cli              Pointer to client state structure which is open
- *                         on the SPOOLSS pipe.
- * @param mem_ctx          Pointer to an initialised talloc context.
- *
- * @param handle           Policy handle opened with cli_spoolss_open_printer_ex
- *                         or cli_spoolss_addprinterex.
- * @param level            Form info level to add - should always be 1.
- * @param form             A pointer to the form to be added.
- *
- */
-
-WERROR cli_spoolss_addform(struct cli_state *cli, TALLOC_CTX *mem_ctx,
-			   POLICY_HND *handle, uint32 level, FORM *form)
-{
-	prs_struct qbuf, rbuf;
-	SPOOL_Q_ADDFORM q;
-	SPOOL_R_ADDFORM r;
-	WERROR result = W_ERROR(ERRgeneral);
-
-	ZERO_STRUCT(q);
-	ZERO_STRUCT(r);
-
-	/* Initialise parse structures */
-
-		prs_init(&qbuf, MAX_PDU_FRAG_LEN, mem_ctx, MARSHALL);
-		prs_init(&rbuf, 0, mem_ctx, UNMARSHALL);
-		
-	/* Initialise input parameters */
-
-        make_spoolss_q_addform(&q, handle, level, form);
-
-		/* Marshall data and send request */
-
-	if (!spoolss_io_q_addform("", &q, &qbuf, 0) ||
-	    !rpc_api_pipe_req(cli, SPOOLSS_ADDFORM, &qbuf, &rbuf))
-		goto done;
-
-	/* Unmarshall response */
-
-	if (!spoolss_io_r_addform("", &r, &rbuf, 0))
-			goto done;
-
-	/* Return output parameters */
-
-	result = r.status;
-
- done:
-	prs_mem_free(&qbuf);
-	prs_mem_free(&rbuf);
-
-	return result;
-}
-		
-/** Set a form on a printer.
- *
- * @param cli              Pointer to client state structure which is open
- *                         on the SPOOLSS pipe.
- * @param mem_ctx          Pointer to an initialised talloc context.
- *
- * @param handle           Policy handle opened with cli_spoolss_open_printer_ex 
- *                         or cli_spoolss_addprinterex.
- * @param level            Form info level to set - should always be 1.
- * @param form             A pointer to the form to be set.
- *
- */
-
-WERROR cli_spoolss_setform(struct cli_state *cli, TALLOC_CTX *mem_ctx,
-			   POLICY_HND *handle, uint32 level, char *form_name,
-			   FORM *form)
-{
-	prs_struct qbuf, rbuf;
-	SPOOL_Q_SETFORM q;
-	SPOOL_R_SETFORM r;
-	WERROR result = W_ERROR(ERRgeneral);
-
-	ZERO_STRUCT(q);
-	ZERO_STRUCT(r);
-
-	/* Initialise parse structures */
-
-	prs_init(&qbuf, MAX_PDU_FRAG_LEN, mem_ctx, MARSHALL);
-	prs_init(&rbuf, 0, mem_ctx, UNMARSHALL);
-
-	/* Initialise input parameters */
-
-        make_spoolss_q_setform(&q, handle, level, form_name, form);
-	
-	/* Marshall data and send request */
-
-	if (!spoolss_io_q_setform("", &q, &qbuf, 0) ||
-	    !rpc_api_pipe_req(cli, SPOOLSS_SETFORM, &qbuf, &rbuf))
-		goto done;
-
-		/* Unmarshall response */
-		
-	if (!spoolss_io_r_setform("", &r, &rbuf, 0))
-			goto done;
-
-	/* Return output parameters */
-
-	result = r.status;
-
-	if (!W_ERROR_IS_OK(result))
-		goto done;
-
-
-
- done:
-	prs_mem_free(&qbuf);
-	prs_mem_free(&rbuf);
-
-	return result;
-}
-
-/** Get a form on a printer.
- *
- * @param cli              Pointer to client state structure which is open
- *                         on the SPOOLSS pipe.
- * @param mem_ctx          Pointer to an initialised talloc context.
- *
- * @param handle           Policy handle opened with cli_spoolss_open_printer_ex 
- *                         or cli_spoolss_addprinterex.
- * @param formname         Name of the form to get
- * @param level            Form info level to get - should always be 1.
- *
- */
-
-WERROR cli_spoolss_getform(struct cli_state *cli, TALLOC_CTX *mem_ctx,
-			   uint32 offered, uint32 *needed,
-			   POLICY_HND *handle, char *formname, uint32 level, 
-			   FORM_1 *form)
-{
-	prs_struct qbuf, rbuf;
-	SPOOL_Q_GETFORM q;
-	SPOOL_R_GETFORM r;
-	WERROR result = W_ERROR(ERRgeneral);
-	NEW_BUFFER buffer;
-
-	ZERO_STRUCT(q);
-	ZERO_STRUCT(r);
-
-	/* Initialise parse structures */
-
-	init_buffer(&buffer, offered, mem_ctx);
-
-	prs_init(&qbuf, MAX_PDU_FRAG_LEN, mem_ctx, MARSHALL);
-	prs_init(&rbuf, 0, mem_ctx, UNMARSHALL);
-
-	/* Initialise input parameters */
-
-        make_spoolss_q_getform(&q, handle, formname, level, &buffer, offered);
-	
-	/* Marshall data and send request */
-
-	if (!spoolss_io_q_getform("", &q, &qbuf, 0) ||
-	    !rpc_api_pipe_req(cli, SPOOLSS_GETFORM, &qbuf, &rbuf))
-		goto done;
-
-	/* Unmarshall response */
-
-	if (!spoolss_io_r_getform("", &r, &rbuf, 0))
-		goto done;
-
-		/* Return output parameters */
-		
-	result = r.status;
-
-	if (needed)
-		*needed = r.needed;
-
-	if (W_ERROR_IS_OK(result)) 
-		smb_io_form_1("", r.buffer, form, 0);
-
- done:
-	prs_mem_free(&qbuf);
-	prs_mem_free(&rbuf);
-
-	return result;
-}
-
-/** Delete a form on a printer.
- *
- * @param cli              Pointer to client state structure which is open
- *                         on the SPOOLSS pipe.
- * @param mem_ctx          Pointer to an initialised talloc context.
- *
- * @param handle           Policy handle opened with cli_spoolss_open_printer_ex 
- *                         or cli_spoolss_addprinterex.
- * @param form             The name of the form to delete.
- *
- */
-
-WERROR cli_spoolss_deleteform(struct cli_state *cli, TALLOC_CTX *mem_ctx,
-			      POLICY_HND *handle, char *form_name)
-{
-	prs_struct qbuf, rbuf;
-	SPOOL_Q_DELETEFORM q;
-	SPOOL_R_DELETEFORM r;
-	WERROR result = W_ERROR(ERRgeneral);
-
-	ZERO_STRUCT(q);
-	ZERO_STRUCT(r);
-
-	/* Initialise parse structures */
-
-	prs_init(&qbuf, MAX_PDU_FRAG_LEN, mem_ctx, MARSHALL);
-	prs_init(&rbuf, 0, mem_ctx, UNMARSHALL);
-
-	/* Initialise input parameters */
-
-        make_spoolss_q_deleteform(&q, handle, form_name);
-	
-	/* Marshall data and send request */
-
-	if (!spoolss_io_q_deleteform("", &q, &qbuf, 0) ||
-	    !rpc_api_pipe_req(cli, SPOOLSS_DELETEFORM, &qbuf, &rbuf))
-		goto done;
-
-	/* Unmarshall response */
-
-	if (!spoolss_io_r_deleteform("", &r, &rbuf, 0))
-		goto done;
-
-	/* Return output parameters */
-
-	result = r.status;
-
- done:
-	prs_mem_free(&qbuf);
-	prs_mem_free(&rbuf);
-
-	return result;
-}
-
-static void decode_forms_1(TALLOC_CTX *mem_ctx, NEW_BUFFER *buffer, 
-			   uint32 num_forms, FORM_1 **forms)
-{
-	int i;
-
-	*forms = (FORM_1 *)talloc(mem_ctx, num_forms * sizeof(FORM_1));
-	buffer->prs.data_offset = 0;
-
-	for (i = 0; i < num_forms; i++)
-		smb_io_form_1("", buffer, &((*forms)[i]), 0);
-}
-
-/** Enumerate forms
- *
- * @param cli              Pointer to client state structure which is open
- *                         on the SPOOLSS pipe.
- * @param mem_ctx          Pointer to an initialised talloc context.
- *
- * @param offered          Buffer size offered in the request.
- * @param needed           Number of bytes needed to complete the request.
- *                         may be NULL.
- *                         or cli_spoolss_addprinterex.
- * @param level            Form info level to get - should always be 1.
- * @param handle           Open policy handle
- *
- */
-
-WERROR cli_spoolss_enumforms(struct cli_state *cli, TALLOC_CTX *mem_ctx,
-			     uint32 offered, uint32 *needed,
-			     POLICY_HND *handle, int level, uint32 *num_forms,
-			     FORM_1 **forms)
-{
-	prs_struct qbuf, rbuf;
-	SPOOL_Q_ENUMFORMS q;
-	SPOOL_R_ENUMFORMS r;
-	WERROR result = W_ERROR(ERRgeneral);
-	NEW_BUFFER buffer;
-
-	ZERO_STRUCT(q);
-	ZERO_STRUCT(r);
-
-	/* Initialise parse structures */
-
-	init_buffer(&buffer, offered, mem_ctx);
-
-	prs_init(&qbuf, MAX_PDU_FRAG_LEN, mem_ctx, MARSHALL);
-	prs_init(&rbuf, 0, mem_ctx, UNMARSHALL);
-
-	/* Initialise input parameters */
-
-        make_spoolss_q_enumforms(&q, handle, level, &buffer, offered);
-
-	/* Marshall data and send request */
-
-	if (!spoolss_io_q_enumforms("", &q, &qbuf, 0) ||
-	    !rpc_api_pipe_req(cli, SPOOLSS_ENUMFORMS, &qbuf, &rbuf))
-		goto done;
-
-	/* Unmarshall response */
-
-	if (!spoolss_io_r_enumforms("", &r, &rbuf, 0))
-		goto done;
-
-	/* Return output parameters */
-
-	result = r.status;
-
-	if (needed)
-		*needed = r.needed;
-
-	if (num_forms)
-		*num_forms = r.numofforms;
-
-	decode_forms_1(mem_ctx, r.buffer, *num_forms, forms);
-
- done:
-	prs_mem_free(&qbuf);
-	prs_mem_free(&rbuf);
-
-	return result;
-}
-
-/*********************************************************************************
- Win32 API - SetPrinterData()
- ********************************************************************************/
-
-WERROR cli_spoolss_setprinterdata (struct cli_state *cli, TALLOC_CTX *mem_ctx,
-					POLICY_HND *pol, char* valname, char* value)
-{
-	prs_struct qbuf, rbuf;
-	SPOOL_Q_SETPRINTERDATA q;
-        SPOOL_R_SETPRINTERDATA r;
-	WERROR result = W_ERROR(ERRgeneral);
-
-	ZERO_STRUCT(q);
-	ZERO_STRUCT(r);
-
-	/* Initialise input parameters */
-
-	prs_init(&qbuf, MAX_PDU_FRAG_LEN, mem_ctx, MARSHALL);
-	prs_init(&rbuf, 0, mem_ctx, UNMARSHALL);
-
-
-	/* write the request */
-	make_spoolss_q_setprinterdata(&q, mem_ctx, pol, valname, value);
-
-	/* Marshall data and send request */
-	if (!spoolss_io_q_setprinterdata ("", &q, &qbuf, 0) ||
-	    !rpc_api_pipe_req (cli, SPOOLSS_SETPRINTERDATA, &qbuf, &rbuf)) 
-		goto done;
-
-	/* Unmarshall response */
-	if (spoolss_io_r_setprinterdata ("", &r, &rbuf, 0))
-		goto done;
-		
-	result = r.status;
-		
-done:
-	prs_mem_free(&qbuf);
-	prs_mem_free(&rbuf);
-
-	return result;	
-}
-
-
-/** @} **/
diff -Naur samba-2.2.12-orig/source/libsmb/libsmbclient.c samba-2.2.12/source/libsmb/libsmbclient.c
--- samba-2.2.12-orig/source/libsmb/libsmbclient.c	2011-03-04 13:51:44.000000000 +0100
+++ samba-2.2.12/source/libsmb/libsmbclient.c	2011-03-04 12:51:24.000000000 +0100
@@ -2395,219 +2395,3 @@
 
 }
 
-/*
- * Routine to print a file on a remote server ...
- *
- * We open the file, which we assume to be on a remote server, and then
- * copy it to a print file on the share specified by printq.
- */
-
-int smbc_print_file(const char *fname, const char *printq)
-{
-	int fid1, fid2, bytes, saverr, tot_bytes = 0;
-	char buf[4096];
-
-	if (!smbc_initialized) {
-
-		errno = EINVAL;
-		return -1;
-
-	}
-
-	if (!fname && !printq) {
-
-		errno = EINVAL;
-		return -1;
-
-	}
-
-	/* Try to open the file for reading ... */
-
-	if ((fid1 = smbc_open(fname, O_RDONLY, 0666)) < 0) {
-		
-		DEBUG(3, ("Error, fname=%s, errno=%i\n", fname, errno));
-		return -1;  /* smbc_open sets errno */
-		
-	}
-
-	/* Now, try to open the printer file for writing */
-
-	if ((fid2 = smbc_open_print_job(printq)) < 0) {
-
-		saverr = errno;  /* Save errno */
-		smbc_close(fid1);
-		errno = saverr;
-		return -1;
-
-	}
-
-	while ((bytes = smbc_read(fid1, buf, sizeof(buf))) > 0) {
-
-		tot_bytes += bytes;
-
-		if ((smbc_write(fid2, buf, bytes)) < 0) {
-
-			saverr = errno;
-			smbc_close(fid1);
-			smbc_close(fid2);
-			errno = saverr;
-
-		}
-
-	}
-
-	saverr = errno;
-
-	smbc_close(fid1);  /* We have to close these anyway */
-	smbc_close(fid2);
-
-	if (bytes < 0) {
-
-		errno = saverr;
-		return -1;
-
-	}
-
-	return tot_bytes;
-
-}
-
-/*
- * Open a print file to be written to by other calls
- */
-
-int smbc_open_print_job(const char *fname)
-{
-	fstring server, share, user, password;
-	pstring path;
-	
-	if (!smbc_initialized) {
-
-		errno = EINVAL;
-		return -1;
-    
-	}
-
-	if (!fname) {
-
-		errno = EINVAL;
-		return -1;
-
-	}
-  
-	DEBUG(4, ("smbc_open_print_job(%s)\n", fname));
-
-	smbc_parse_path(fname, server, share, path, user, password); /*FIXME, errors*/
-
-	/* What if the path is empty, or the file exists? */
-
-	return smbc_open(fname, O_WRONLY, 666);
-
-}
-
-/*
- * Routine to list print jobs on a printer share ...
- */
-
-int smbc_list_print_jobs(const char *fname, void (*fn)(struct print_job_info *))
-{
-	struct smbc_server *srv;
-	fstring server, share, user, password, workgroup;
-	pstring path;
-
-	if (!smbc_initialized) {
-
-		errno = EINVAL;
-		return -1;
-
-	}
-
-	if (!fname) {
-		
-		errno = EINVAL;
-		return -1;
-
-	}
-  
-	DEBUG(4, ("smbc_list_print_jobs(%s)\n", fname));
-
-	smbc_parse_path(fname, server, share, path, user, password); /*FIXME, errors*/
-
-	if (user[0] == (char)0) pstrcpy(user, smbc_user);
-	
-	pstrcpy(workgroup, lp_workgroup());
-
-	srv = smbc_server(server, share, workgroup, user, password);
-
-	if (!srv) {
-
-		return -1;  /* errno set by smbc_server */
-
-	}
-
-	if (cli_print_queue(&srv->cli, fn) < 0) {
-
-		errno = smbc_errno(&srv->cli);
-		return -1;
-
-	}
-	
-	return 0;
-
-}
-
-/*
- * Delete a print job from a remote printer share
- */
-
-int smbc_unlink_print_job(const char *fname, int id)
-{
-	struct smbc_server *srv;
-	fstring server, share, user, password, workgroup;
-	pstring path;
-	int err;
-
-	if (!smbc_initialized) {
-
-		errno = EINVAL;
-		return -1;
-
-	}
-
-	if (!fname) {
-
-		errno = EINVAL;
-		return -1;
-
-	}
-  
-	DEBUG(4, ("smbc_unlink_print_job(%s)\n", fname));
-
-	smbc_parse_path(fname, server, share, path, user, password); /*FIXME, errors*/
-
-	if (user[0] == (char)0) pstrcpy(user, smbc_user);
-
-	pstrcpy(workgroup, lp_workgroup());
-
-	srv = smbc_server(server, share, workgroup, user, password);
-
-	if (!srv) {
-
-		return -1;  /* errno set by smbc_server */
-
-	}
-
-	if ((err = cli_printjob_del(&srv->cli, id)) != 0) {
-
-		if (err < 0)
-			errno = smbc_errno(&srv->cli);
-		else if (err == ERRnosuchprintjob)
-			errno = EINVAL;
-		return -1;
-
-	}
-
-	return 0;
-
-}
-
diff -Naur samba-2.2.12-orig/source/param/loadparm.c samba-2.2.12/source/param/loadparm.c
--- samba-2.2.12-orig/source/param/loadparm.c	2011-03-04 13:51:45.000000000 +0100
+++ samba-2.2.12/source/param/loadparm.c	2011-03-04 12:58:15.000000000 +0100
@@ -3899,15 +3899,3 @@
 	return local_machine;
 }
 
-/*******************************************************************
- Return the max print jobs per queue.
-********************************************************************/
-
-int lp_maxprintjobs(int snum)
-{
-	int maxjobs = LP_SNUM_OK(snum) ? ServicePtrs[snum]->iMaxPrintJobs : sDefault.iMaxPrintJobs;
-	if (maxjobs <= 0 || maxjobs >= PRINT_MAX_JOBID)
-		maxjobs = PRINT_MAX_JOBID - 1;
-
-	return maxjobs;
-}
diff -Naur samba-2.2.12-orig/source/printing/load.c samba-2.2.12/source/printing/load.c
--- samba-2.2.12-orig/source/printing/load.c	2004-08-12 20:24:21.000000000 +0200
+++ samba-2.2.12/source/printing/load.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,74 +0,0 @@
-/* 
-   Unix SMB/Netbios implementation.
-   Version 3.0
-   load printer lists
-   Copyright (C) Andrew Tridgell 1992-2000
-   
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2 of the License, or
-   (at your option) any later version.
-   
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-   
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-*/
-
-#include "includes.h"
-
-
-/***************************************************************************
-auto-load printer services
-***************************************************************************/
-void add_all_printers(void)
-{
-	int printers = lp_servicenumber(PRINTERS_NAME);
-
-	if (printers < 0) return;
-
-	pcap_printer_fn(lp_add_one_printer);
-}
-
-/***************************************************************************
-auto-load some homes and printer services
-***************************************************************************/
-static void add_auto_printers(void)
-{
-	char *p;
-	int printers;
-	char *str = strdup(lp_auto_services());
-
-	if (!str) return;
-
-	printers = lp_servicenumber(PRINTERS_NAME);
-
-	if (printers < 0) {
-        SAFE_FREE(str);
-        return;
-    }
-	
-	for (p=strtok(str,LIST_SEP);p;p=strtok(NULL,LIST_SEP)) {
-		if (lp_servicenumber(p) >= 0) continue;
-		
-		if (pcap_printername_ok(p,NULL)) {
-			lp_add_printer(p,printers);
-		}
-	}
-
-    SAFE_FREE(str);
-}
-
-/***************************************************************************
-load automatic printer services
-***************************************************************************/
-void load_printers(void)
-{
-	add_auto_printers();
-	if (lp_load_printers())
-		add_all_printers();
-}
diff -Naur samba-2.2.12-orig/source/printing/lpq_parse.c samba-2.2.12/source/printing/lpq_parse.c
--- samba-2.2.12-orig/source/printing/lpq_parse.c	2004-08-12 20:24:22.000000000 +0200
+++ samba-2.2.12/source/printing/lpq_parse.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1101 +0,0 @@
-/* 
-   Unix SMB/Netbios implementation.
-   Version 3.0
-   lpq parsing routines
-   Copyright (C) Andrew Tridgell 2000
-   Copyright (C) 2002 by Martin Pool 
-   
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2 of the License, or
-   (at your option) any later version.
-   
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-   
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-*/
-
-#include "includes.h"
-
-
-static const char *Months[13] = { "Jan", "Feb", "Mar", "Apr", "May", "Jun",
-			      "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", "Err"};
-
-
-/*******************************************************************
-process time fields
-********************************************************************/
-static time_t EntryTime(fstring tok[], int ptr, int count, int minimum)
-{
-  time_t jobtime,jobtime1;
-
-  jobtime = time(NULL);		/* default case: take current time */
-  if (count >= minimum) {
-    struct tm *t;
-    int i, day, hour, min, sec;
-    char   *c;
-
-    for (i=0; i<13; i++) if (!strncmp(tok[ptr], Months[i],3)) break; /* Find month */
-    if (i<12) {
-      t = localtime(&jobtime);
-      day = atoi(tok[ptr+1]);
-      c=(char *)(tok[ptr+2]);
-      *(c+2)=0;
-      hour = atoi(c);
-      *(c+5)=0;
-      min = atoi(c+3);
-      if(*(c+6) != 0)sec = atoi(c+6);
-      else  sec=0;
-
-      if ((t->tm_mon < i)||
-	  ((t->tm_mon == i)&&
-	   ((t->tm_mday < day)||
-	    ((t->tm_mday == day)&&
-	     (t->tm_hour*60+t->tm_min < hour*60+min)))))
-	t->tm_year--;		/* last year's print job */
-
-      t->tm_mon = i;
-      t->tm_mday = day;
-      t->tm_hour = hour;
-      t->tm_min = min;
-      t->tm_sec = sec;
-      jobtime1 = mktime(t);
-      if (jobtime1 != (time_t)-1)
-	jobtime = jobtime1;
-    }
-  }
-  return jobtime;
-}
-
-
-/****************************************************************************
-parse a lpq line
-
-here is an example of lpq output under bsd
-
-Warning: no daemon present
-Rank   Owner      Job  Files                                 Total Size
-1st    tridge     148  README                                8096 bytes
-
-here is an example of lpq output under osf/1
-
-Warning: no daemon present
-Rank   Pri Owner      Job  Files                             Total Size
-1st    0   tridge     148  README                            8096 bytes
-
-
-<allan@umich.edu> June 30, 1998.
-Modified to handle file names with spaces, like the parse_lpq_lprng code
-further below.
-****************************************************************************/
-static BOOL parse_lpq_bsd(char *line,print_queue_struct *buf,BOOL first)
-{
-#ifdef	OSF1
-#define	RANKTOK	0
-#define	PRIOTOK 1
-#define	USERTOK 2
-#define	JOBTOK	3
-#define	FILETOK	4
-#define	TOTALTOK (count - 2)
-#define	NTOK	6
-#define	MAXTOK	128
-#else	/* OSF1 */
-#define	RANKTOK	0
-#define	USERTOK 1
-#define	JOBTOK	2
-#define	FILETOK	3
-#define	TOTALTOK (count - 2)
-#define	NTOK	5
-#define	MAXTOK	128
-#endif	/* OSF1 */
-
-  char *tok[MAXTOK];
-  int  count = 0;
-  pstring line2;
-
-  pstrcpy(line2,line);
-
-#ifdef	OSF1
-  {
-    size_t length;
-    length = strlen(line2);
-    if (line2[length-3] == ':')
-      return(False);
-  }
-#endif	/* OSF1 */
-
-  tok[0] = strtok(line2," \t");
-  count++;
-
-  while (((tok[count] = strtok(NULL," \t")) != NULL) && (count < MAXTOK)) {
-    count++;
-  }
-
-  /* we must get at least NTOK tokens */
-  if (count < NTOK)
-    return(False);
-
-  /* the Job and Total columns must be integer */
-  if (!isdigit((int)*tok[JOBTOK]) || !isdigit((int)*tok[TOTALTOK])) return(False);
-
-  buf->job = atoi(tok[JOBTOK]);
-  buf->size = atoi(tok[TOTALTOK]);
-  buf->status = strequal(tok[RANKTOK],"active")?LPQ_PRINTING:LPQ_QUEUED;
-  buf->time = time(NULL);
-  fstrcpy(buf->fs_user,tok[USERTOK]);
-  fstrcpy(buf->fs_file,tok[FILETOK]);
-
-  if ((FILETOK + 1) != TOTALTOK) {
-    int i;
-
-    for (i = (FILETOK + 1); i < TOTALTOK; i++) {
-      /* FIXME: Using fstrcat rather than other means is a bit
-       * inefficient; this might be a problem for enormous queues with
-       * many fields. */
-      fstrcat(buf->fs_file, " ");
-      fstrcat(buf->fs_file, tok[i]);
-    }
-    /* Ensure null termination. */
-    fstrterminate(buf->fs_file);
-  }
-
-#ifdef PRIOTOK
-  buf->priority = atoi(tok[PRIOTOK]);
-#else
-  buf->priority = 1;
-#endif
-  return(True);
-}
-
-/*
-<magnus@hum.auc.dk>
-LPRng_time modifies the current date by inserting the hour and minute from
-the lpq output.  The lpq time looks like "23:15:07"
-
-<allan@umich.edu> June 30, 1998.
-Modified to work with the re-written parse_lpq_lprng routine.
-
-<J.P.M.v.Itegem@tue.nl> Dec 17,1999
-Modified to work with lprng 3.16
-With lprng 3.16 The lpq time looks like
-                       "23:15:07"
-                       "23:15:07.100"
-                       "1999-12-16-23:15:07"
-                       "1999-12-16-23:15:07.100"
-
-*/
-static time_t LPRng_time(char *time_string)
-{
-	time_t jobtime;
-	struct tm t;
-
-	jobtime = time(NULL);         /* default case: take current time */
-	t = *localtime(&jobtime);
-
-	if ( atoi(time_string) < 24 ){
-		t.tm_hour = atoi(time_string);
-		t.tm_min = atoi(time_string+3);
-		t.tm_sec = atoi(time_string+6);
-	} else {
-		t.tm_year = atoi(time_string)-1900;
-		t.tm_mon = atoi(time_string+5)-1;
-		t.tm_mday = atoi(time_string+8);
-		t.tm_hour = atoi(time_string+11);
-		t.tm_min = atoi(time_string+14);
-		t.tm_sec = atoi(time_string+17);
-	}    
-	jobtime = mktime(&t);
-
-	return jobtime;
-}
-
-
-/****************************************************************************
-  parse a lprng lpq line
-  <allan@umich.edu> June 30, 1998.
-  Re-wrote this to handle file names with spaces, multiple file names on one
-  lpq line, etc;
-****************************************************************************/
-static BOOL parse_lpq_lprng(char *line,print_queue_struct *buf,BOOL first)
-{
-#define	LPRNG_RANKTOK	0
-#define	LPRNG_USERTOK	1
-#define	LPRNG_PRIOTOK	2
-#define	LPRNG_JOBTOK	3
-#define	LPRNG_FILETOK	4
-#define	LPRNG_TOTALTOK	(num_tok - 2)
-#define	LPRNG_TIMETOK	(num_tok - 1)
-#define	LPRNG_NTOK	7
-#define	LPRNG_MAXTOK	128 /* PFMA just to keep us from running away. */
-
-  fstring tokarr[LPRNG_MAXTOK];
-  const char *cptr;
-  char *ptr;
-  int  num_tok = 0;
-
-  cptr = line;
-  while(next_token( &cptr, tokarr[num_tok], " \t", sizeof(fstring)) && (num_tok < LPRNG_MAXTOK))
-    num_tok++;
-
-  /* We must get at least LPRNG_NTOK tokens. */
-  if (num_tok < LPRNG_NTOK) {
-    return(False);
-  }
-
-  if (!isdigit((int)*tokarr[LPRNG_JOBTOK]) || !isdigit((int)*tokarr[LPRNG_TOTALTOK])) {
-    return(False);
-  }
-
-  buf->job  = atoi(tokarr[LPRNG_JOBTOK]);
-  buf->size = atoi(tokarr[LPRNG_TOTALTOK]);
-
-  if (strequal(tokarr[LPRNG_RANKTOK],"active")) {
-    buf->status = LPQ_PRINTING;
-  } else if (strequal(tokarr[LPRNG_RANKTOK],"done")) {
-    buf->status = LPQ_PRINTED;
-  } else if (isdigit((int)*tokarr[LPRNG_RANKTOK])) {
-    buf->status = LPQ_QUEUED;
-  } else {
-    buf->status = LPQ_PAUSED;
-  }
-
-  buf->priority = *tokarr[LPRNG_PRIOTOK] -'A';
-
-  buf->time = LPRng_time(tokarr[LPRNG_TIMETOK]);
-
-  fstrcpy(buf->fs_user,tokarr[LPRNG_USERTOK]);
-
-  /* The '@hostname' prevents windows from displaying the printing icon
-   * for the current user on the taskbar.  Plop in a null.
-   */
-
-  if ((ptr = strchr(buf->fs_user,'@')) != NULL) {
-    *ptr = '\0';
-  }
-
-  fstrcpy(buf->fs_file,tokarr[LPRNG_FILETOK]);
-
-  if ((LPRNG_FILETOK + 1) != LPRNG_TOTALTOK) {
-    int i;
-
-    for (i = (LPRNG_FILETOK + 1); i < LPRNG_TOTALTOK; i++) {
-      /* FIXME: Using fstrcat rather than other means is a bit
-       * inefficient; this might be a problem for enormous queues with
-       * many fields. */
-      fstrcat(buf->fs_file, " ");
-      fstrcat(buf->fs_file, tokarr[i]);
-    }
-    /* Ensure null termination. */
-    fstrterminate(buf->fs_file);
-  }
-
-  return(True);
-}
-
-
-
-/*******************************************************************
-parse lpq on an aix system
-
-Queue   Dev   Status    Job Files              User         PP %   Blks  Cp Rnk
-------- ----- --------- --- ------------------ ---------- ---- -- ----- --- ---
-lazer   lazer READY
-lazer   lazer RUNNING   537 6297doc.A          kvintus@IE    0 10  2445   1   1
-              QUEUED    538 C.ps               root@IEDVB           124   1   2
-              QUEUED    539 E.ps               root@IEDVB            28   1   3
-              QUEUED    540 L.ps               root@IEDVB           172   1   4
-              QUEUED    541 P.ps               root@IEDVB            22   1   5
-********************************************************************/
-static BOOL parse_lpq_aix(char *line,print_queue_struct *buf,BOOL first)
-{
-  fstring tok[11];
-  int count=0;
-  const char *cline = line;
-
-  /* handle the case of "(standard input)" as a filename */
-  pstring_sub(line,"standard input","STDIN");
-  all_string_sub(line,"(","\"",0);
-  all_string_sub(line,")","\"",0);
-
-  for (count=0; 
-       count<10 && 
-	       next_token(&cline,tok[count],NULL, sizeof(tok[count])); 
-       count++) ;
-
-  /* we must get 6 tokens */
-  if (count < 10)
-  {
-      if ((count == 7) && ((strcmp(tok[0],"QUEUED") == 0) || (strcmp(tok[0],"HELD") == 0)))
-      {
-          /* the 2nd and 5th columns must be integer */
-          if (!isdigit((int)*tok[1]) || !isdigit((int)*tok[4])) return(False);
-          buf->size = atoi(tok[4]) * 1024;
-          /* if the fname contains a space then use STDIN */
-          if (strchr(tok[2],' '))
-            fstrcpy(tok[2],"STDIN");
-
-          /* only take the last part of the filename */
-          {
-            fstring tmp;
-            char *p = strrchr(tok[2],'/');
-            if (p)
-              {
-                fstrcpy(tmp,p+1);
-                fstrcpy(tok[2],tmp);
-              }
-          }
-
-
-          buf->job = atoi(tok[1]);
-          buf->status = strequal(tok[0],"HELD")?LPQ_PAUSED:LPQ_QUEUED;
-	  buf->priority = 0;
-          buf->time = time(NULL);
-          fstrcpy(buf->fs_user, tok[3]);
-          fstrcpy(buf->fs_file, tok[2]);
-      }
-      else
-      {
-          DEBUG(6,("parse_lpq_aix count=%d\n", count));
-          return(False);
-      }
-  }
-  else
-  {
-      /* the 4th and 9th columns must be integer */
-      if (!isdigit((int)*tok[3]) || !isdigit((int)*tok[8])) return(False);
-      buf->size = atoi(tok[8]) * 1024;
-      /* if the fname contains a space then use STDIN */
-      if (strchr(tok[4],' '))
-        fstrcpy(tok[4],"STDIN");
-
-      /* only take the last part of the filename */
-      {
-        fstring tmp;
-        char *p = strrchr(tok[4],'/');
-        if (p)
-          {
-            fstrcpy(tmp,p+1);
-            fstrcpy(tok[4],tmp);
-          }
-      }
-
-
-      buf->job = atoi(tok[3]);
-      buf->status = strequal(tok[2],"RUNNING")?LPQ_PRINTING:LPQ_QUEUED;
-      buf->priority = 0;
-      buf->time = time(NULL);
-      fstrcpy(buf->fs_user, tok[5]);
-      fstrcpy(buf->fs_file, tok[4]);
-  }
-
-
-  return(True);
-}
-
-
-/****************************************************************************
-parse a lpq line
-here is an example of lpq output under hpux; note there's no space after -o !
-$> lpstat -oljplus
-ljplus-2153         user           priority 0  Jan 19 08:14 on ljplus
-      util.c                                  125697 bytes
-      server.c				      110712 bytes
-ljplus-2154         user           priority 0  Jan 19 08:14 from client
-      (standard input)                          7551 bytes
-****************************************************************************/
-static BOOL parse_lpq_hpux(char * line, print_queue_struct *buf, BOOL first)
-{
-  /* must read two lines to process, therefore keep some values static */
-  static BOOL header_line_ok=False, base_prio_reset=False;
-  static fstring jobuser;
-  static int jobid;
-  static int jobprio;
-  static time_t jobtime;
-  static int jobstat=LPQ_QUEUED;
-  /* to store minimum priority to print, lpstat command should be invoked
-     with -p option first, to work */
-  static int base_prio;
- 
-  int count;
-  char htab = '\011';  
-  const char *cline = line;
-  fstring tok[12];
-
-  /* If a line begins with a horizontal TAB, it is a subline type */
-  
-  if (line[0] == htab) { /* subline */
-    /* check if it contains the base priority */
-    if (!strncmp(line,"\tfence priority : ",18)) {
-       base_prio=atoi(&line[18]);
-       DEBUG(4, ("fence priority set at %d\n", base_prio));
-    }
-    if (!header_line_ok) return (False); /* incorrect header line */
-    /* handle the case of "(standard input)" as a filename */
-    pstring_sub(line,"standard input","STDIN");
-    all_string_sub(line,"(","\"",0);
-    all_string_sub(line,")","\"",0);
-    
-    for (count=0; count<2 && next_token(&cline,tok[count],NULL,sizeof(tok[count])); count++) ;
-    /* we must get 2 tokens */
-    if (count < 2) return(False);
-    
-    /* the 2nd column must be integer */
-    if (!isdigit((int)*tok[1])) return(False);
-    
-    /* if the fname contains a space then use STDIN */
-    if (strchr(tok[0],' '))
-      fstrcpy(tok[0],"STDIN");
-    
-    buf->size = atoi(tok[1]);
-    fstrcpy(buf->fs_file,tok[0]);
-    
-    /* fill things from header line */
-    buf->time = jobtime;
-    buf->job = jobid;
-    buf->status = jobstat;
-    buf->priority = jobprio;
-    fstrcpy(buf->fs_user, jobuser);
-    
-    return(True);
-  }
-  else { /* header line */
-    header_line_ok=False; /* reset it */
-    if (first) {
-       if (!base_prio_reset) {
-	  base_prio=0; /* reset it */
-	  base_prio_reset=True;
-       }
-    }
-    else if (base_prio) base_prio_reset=False;
-    
-    /* handle the dash in the job id */
-    pstring_sub(line,"-"," ");
-    
-    for (count=0; count<12 && next_token(&cline,tok[count],NULL,sizeof(tok[count])); count++) ;
-      
-    /* we must get 8 tokens */
-    if (count < 8) return(False);
-    
-    /* first token must be printer name (cannot check ?) */
-    /* the 2nd, 5th & 7th column must be integer */
-    if (!isdigit((int)*tok[1]) || !isdigit((int)*tok[4]) || !isdigit((int)*tok[6])) return(False);
-    jobid = atoi(tok[1]);
-    fstrcpy(jobuser, tok[2]);
-    jobprio = atoi(tok[4]);
-    
-    /* process time */
-    jobtime=EntryTime(tok, 5, count, 8);
-    if (jobprio < base_prio) {
-       jobstat = LPQ_PAUSED;
-       DEBUG (4, ("job %d is paused: prio %d < %d; jobstat=%d\n", jobid, jobprio, base_prio, jobstat));
-    }
-    else {
-       jobstat = LPQ_QUEUED;
-       if ((count >8) && (((strequal(tok[8],"on")) ||
-			   ((strequal(tok[8],"from")) && 
-			    ((count > 10)&&(strequal(tok[10],"on")))))))
-	 jobstat = LPQ_PRINTING;
-    }
-    
-    header_line_ok=True; /* information is correct */
-    return(False); /* need subline info to include into queuelist */
-  }
-}
-
-
-/****************************************************************************
-parse a lpstat line
-
-here is an example of "lpstat -o dcslw" output under sysv
-
-dcslw-896               tridge            4712   Dec 20 10:30:30 on dcslw
-dcslw-897               tridge            4712   Dec 20 10:30:30 being held
-
-****************************************************************************/
-static BOOL parse_lpq_sysv(char *line,print_queue_struct *buf,BOOL first)
-{
-  fstring tok[9];
-  int count=0;
-  char *p;
-  const char *cline = line;
-  
-  /* 
-   * Handle the dash in the job id, but make sure that we skip over
-   * the printer name in case we have a dash in that.
-   * Patch from Dom.Mitchell@palmerharvey.co.uk.
-   */
-
-  /*
-   * Move to the first space.
-   */
-  for (p = line ; !isspace(*p) && *p; p++)
-    ;
-
-  /*
-   * Back up until the last '-' character or
-   * start of line.
-   */
-  for (; (p >= line) && (*p != '-'); p--)
-    ;
-
-  if((p >= line) && (*p == '-'))
-    *p = ' ';
-
-  for (count=0; count<9 && next_token(&cline,tok[count],NULL,sizeof(tok[count])); count++)
-    ;
-
-  /* we must get 7 tokens */
-  if (count < 7)
-    return(False);
-
-  /* the 2nd and 4th, 6th columns must be integer */
-  if (!isdigit((int)*tok[1]) || !isdigit((int)*tok[3]))
-    return(False);
-  if (!isdigit((int)*tok[5]))
-    return(False);
-
-  /* if the user contains a ! then trim the first part of it */  
-  if ((p=strchr(tok[2],'!'))) {
-      fstring tmp;
-      fstrcpy(tmp,p+1);
-      fstrcpy(tok[2],tmp);
-  }
-
-  buf->job = atoi(tok[1]);
-  buf->size = atoi(tok[3]);
-  if (count > 7 && strequal(tok[7],"on"))
-    buf->status = LPQ_PRINTING;
-  else if (count > 8 && strequal(tok[7],"being") && strequal(tok[8],"held"))
-    buf->status = LPQ_PAUSED;
-  else
-    buf->status = LPQ_QUEUED;
-  buf->priority = 0;
-  buf->time = EntryTime(tok, 4, count, 7);
-  fstrcpy(buf->fs_user, tok[2]);
-  fstrcpy(buf->fs_file, tok[2]);
-  return(True);
-}
-
-/****************************************************************************
-parse a lpq line
-
-here is an example of lpq output under qnx
-Spooler: /qnx/spooler, on node 1
-Printer: txt        (ready) 
-0000:     root	[job #1    ]   active 1146 bytes	/etc/profile
-0001:     root	[job #2    ]    ready 2378 bytes	/etc/install
-0002:     root	[job #3    ]    ready 1146 bytes	-- standard input --
-****************************************************************************/
-static BOOL parse_lpq_qnx(char *line,print_queue_struct *buf,BOOL first)
-{
-  fstring tok[7];
-  int count=0;
-  const char *cline = line;
-
-  DEBUG(4,("antes [%s]\n", line));
-
-  /* handle the case of "-- standard input --" as a filename */
-  pstring_sub(line,"standard input","STDIN");
-  DEBUG(4,("despues [%s]\n", line));
-  all_string_sub(line,"-- ","\"",0);
-  all_string_sub(line," --","\"",0);
-  DEBUG(4,("despues 1 [%s]\n", line));
-
-  pstring_sub(line,"[job #","");
-  pstring_sub(line,"]","");
-  DEBUG(4,("despues 2 [%s]\n", line));
-  
-  for (count=0; count<7 && next_token(&cline,tok[count],NULL,sizeof(tok[count])); count++) ;
-
-  /* we must get 7 tokens */
-  if (count < 7)
-    return(False);
-
-  /* the 3rd and 5th columns must be integer */
-  if (!isdigit((int)*tok[2]) || !isdigit((int)*tok[4])) return(False);
-
-  /* only take the last part of the filename */
-  {
-    fstring tmp;
-    char *p = strrchr(tok[6],'/');
-    if (p)
-      {
-	fstrcpy(tmp,p+1);
-	fstrcpy(tok[6],tmp);
-      }
-  }
-	
-
-  buf->job = atoi(tok[2]);
-  buf->size = atoi(tok[4]);
-  buf->status = strequal(tok[3],"active")?LPQ_PRINTING:LPQ_QUEUED;
-  buf->priority = 0;
-  buf->time = time(NULL);
-  fstrcpy(buf->fs_user,tok[1]);
-  fstrcpy(buf->fs_file,tok[6]);
-  return(True);
-}
-
-
-/****************************************************************************
-  parse a lpq line for the plp printing system
-  Bertrand Wallrich <Bertrand.Wallrich@loria.fr>
-
-redone by tridge. Here is a sample queue:
-
-Local  Printer 'lp2' (fjall):
-  Printing (started at Jun 15 13:33:58, attempt 1).
-    Rank Owner       Pr Opt  Job Host        Files           Size     Date
-  active tridge      X  -    6   fjall       /etc/hosts      739      Jun 15 13:33
-     3rd tridge      X  -    7   fjall       /etc/hosts      739      Jun 15 13:33
-
-****************************************************************************/
-static BOOL parse_lpq_plp(char *line,print_queue_struct *buf,BOOL first)
-{
-  fstring tok[11];
-  int count=0;
-  const char *cline = line;
-
-  /* handle the case of "(standard input)" as a filename */
-  pstring_sub(line,"stdin","STDIN");
-  all_string_sub(line,"(","\"",0);
-  all_string_sub(line,")","\"",0);
-  
-  for (count=0; count<11 && next_token(&cline,tok[count],NULL,sizeof(tok[count])); count++) ;
-
-  /* we must get 11 tokens */
-  if (count < 11)
-    return(False);
-
-  /* the first must be "active" or begin with an integer */
-  if (strcmp(tok[0],"active") && !isdigit((int)tok[0][0]))
-    return(False);
-
-  /* the 5th and 8th must be integer */
-  if (!isdigit((int)*tok[4]) || !isdigit((int)*tok[7])) 
-    return(False);
-
-  /* if the fname contains a space then use STDIN */
-  if (strchr(tok[6],' '))
-    fstrcpy(tok[6],"STDIN");
-
-  /* only take the last part of the filename */
-  {
-    fstring tmp;
-    char *p = strrchr(tok[6],'/');
-    if (p)
-      {
-        fstrcpy(tmp,p+1);
-        fstrcpy(tok[6],tmp);
-      }
-  }
-
-
-  buf->job = atoi(tok[4]);
-
-  buf->size = atoi(tok[7]);
-  if (strchr(tok[7],'K'))
-    buf->size *= 1024;
-  if (strchr(tok[7],'M'))
-    buf->size *= 1024*1024;
-
-  buf->status = strequal(tok[0],"active")?LPQ_PRINTING:LPQ_QUEUED;
-  buf->priority = 0;
-  buf->time = time(NULL);
-  fstrcpy(buf->fs_user,tok[1]);
-  fstrcpy(buf->fs_file,tok[6]);
-  return(True);
-}
-
-/****************************************************************************
-parse a qstat line
-
-here is an example of "qstat -l -d qms" output under softq
-
-Queue qms: 2 jobs; daemon active (313); enabled; accepting;
- job-ID   submission-time     pri     size owner      title 
-205980: H 98/03/09 13:04:05     0    15733 stephenf   chap1.ps
-206086:>  98/03/12 17:24:40     0      659 chris      -
-206087:   98/03/12 17:24:45     0     4876 chris      -
-Total:      21268 bytes in queue
-
-
-****************************************************************************/
-static BOOL parse_lpq_softq(char *line,print_queue_struct *buf,BOOL first)
-{
-  fstring tok[10];
-  int count=0;
-  const char *cline = line;
-
-  /* mung all the ":"s to spaces*/
-  pstring_sub(line,":"," ");
-  
-  for (count=0; count<10 && next_token(&cline,tok[count],NULL,sizeof(tok[count])); count++) ;
-
-  /* we must get 9 tokens */
-  if (count < 9)
-    return(False);
-
-  /* the 1st and 7th columns must be integer */
-  if (!isdigit((int)*tok[0]) || !isdigit((int)*tok[6]))  return(False);
-  /* if the 2nd column is either '>' or 'H' then the 7th and 8th must be
-   * integer, else it's the 6th and 7th that must be
-   */
-  if (*tok[1] == 'H' || *tok[1] == '>')
-    {
-      if (!isdigit((int)*tok[7]))
-        return(False);
-      buf->status = *tok[1] == '>' ? LPQ_PRINTING : LPQ_PAUSED;
-      count = 1;
-    }
-  else
-    {
-      if (!isdigit((int)*tok[5]))
-        return(False);
-      buf->status = LPQ_QUEUED;
-      count = 0;
-    }
-	
-
-  buf->job = atoi(tok[0]);
-  buf->size = atoi(tok[count+6]);
-  buf->priority = atoi(tok[count+5]);
-  fstrcpy(buf->fs_user,tok[count+7]);
-  fstrcpy(buf->fs_file,tok[count+8]);
-  buf->time = time(NULL);		/* default case: take current time */
-  {
-    time_t jobtime;
-    struct tm *t;
-
-    t = localtime(&buf->time);
-    t->tm_mday = atoi(tok[count+2]+6);
-    t->tm_mon  = atoi(tok[count+2]+3);
-    switch (*tok[count+2])
-    {
-    case 7: case 8: case 9: t->tm_year = atoi(tok[count+2]); break;
-    default:                t->tm_year = atoi(tok[count+2]); break;
-    }
-
-    t->tm_hour = atoi(tok[count+3]);
-    t->tm_min = atoi(tok[count+4]);
-    t->tm_sec = atoi(tok[count+5]);
-    jobtime = mktime(t);
-    if (jobtime != (time_t)-1)
-      buf->time = jobtime; 
-  }
-
-  return(True);
-}
-
-/*******************************************************************
-parse lpq on an NT system
-
-                         Windows 2000 LPD Server
-                              Printer \\10.0.0.2\NP17PCL (Paused)
-
-Owner       Status         Jobname          Job-Id    Size   Pages  Priority
-----------------------------------------------------------------------------
-root (9.99. Printing  /usr/lib/rhs/rhs-pr      3       625      0      1
-root (9.99. Paused    /usr/lib/rhs/rhs-pr      4       625      0      1
-jmcd        Waiting   Re: Samba Open Sour     26     32476      1      1
-
-********************************************************************/
-static BOOL parse_lpq_nt(char *line,print_queue_struct *buf,BOOL first)
-{
-#define LPRNT_OWNSIZ 11
-#define LPRNT_STATSIZ 9
-#define LPRNT_JOBSIZ 19
-#define LPRNT_IDSIZ 6
-#define LPRNT_SIZSIZ 9
-  typedef struct 
-  {
-    char owner[LPRNT_OWNSIZ];
-    char space1;
-    char status[LPRNT_STATSIZ];
-    char space2;
-    char jobname[LPRNT_JOBSIZ];
-    char space3;
-    char jobid[LPRNT_IDSIZ];
-    char space4;
-    char size[LPRNT_SIZSIZ];
-    char terminator;
-  } nt_lpq_line;
-
-  nt_lpq_line parse_line;
-#define LPRNT_PRINTING "Printing"
-#define LPRNT_WAITING "Waiting"
-#define LPRNT_PAUSED "Paused"
-
-  memset(&parse_line, '\0', sizeof(parse_line));
-  strncpy((char *) &parse_line, line, sizeof(parse_line) -1);
-
-  if (strlen((char *) &parse_line) != sizeof(parse_line) - 1)
-    return(False);
-
-  /* Just want the first word in the owner field - the username */
-  if (strchr(parse_line.owner, ' '))
-    *(strchr(parse_line.owner, ' ')) = '\0';
-  else
-    parse_line.space1 = '\0';
-
-  /* Make sure we have an owner */
-  if (!strlen(parse_line.owner))
-    return(False);
-
-  /* Make sure the status is valid */
-  parse_line.space2 = '\0';
-  trim_string(parse_line.status, NULL, " ");
-  if (!strequal(parse_line.status, LPRNT_PRINTING) &&
-      !strequal(parse_line.status, LPRNT_PAUSED) &&
-      !strequal(parse_line.status, LPRNT_WAITING))
-    return(False);
-  
-  parse_line.space3 = '\0';
-  trim_string(parse_line.jobname, NULL, " ");
-
-  buf->job = atoi(parse_line.jobid);
-  buf->priority = 0;
-  buf->size = atoi(parse_line.size);
-  buf->time = time(NULL);
-  fstrcpy(buf->fs_user, parse_line.owner);
-  fstrcpy(buf->fs_file, parse_line.jobname);
-  if (strequal(parse_line.status, LPRNT_PRINTING))
-    buf->status = LPQ_PRINTING;
-  else if (strequal(parse_line.status, LPRNT_PAUSED))
-    buf->status = LPQ_PAUSED;
-  else
-    buf->status = LPQ_QUEUED;
-
-  return(True);
-}
-
-/*******************************************************************
-parse lpq on an OS2 system
-
-JobID  File Name          Rank      Size        Status          Comment       
------  ---------------    ------    --------    ------------    ------------  
-    3  Control                 1          68    Queued          root@psflinu  
-    4  /etc/motd               2       11666    Queued          root@psflinu  
-
-********************************************************************/
-static BOOL parse_lpq_os2(char *line,print_queue_struct *buf,BOOL first)
-{
-#define LPROS2_IDSIZ 5
-#define LPROS2_JOBSIZ 15
-#define LPROS2_SIZSIZ 8
-#define LPROS2_STATSIZ 12
-#define LPROS2_OWNSIZ 12
-  typedef struct 
-  {
-    char jobid[LPROS2_IDSIZ];
-    char space1[2];
-    char jobname[LPROS2_JOBSIZ];
-    char space2[14];
-    char size[LPROS2_SIZSIZ];
-    char space3[4];
-    char status[LPROS2_STATSIZ];
-    char space4[4];
-    char owner[LPROS2_OWNSIZ];
-    char terminator;
-  } os2_lpq_line;
-
-  os2_lpq_line parse_line;
-#define LPROS2_PRINTING "Printing"
-#define LPROS2_WAITING "Queued"
-#define LPROS2_PAUSED "Paused"
-
-  memset(&parse_line, '\0', sizeof(parse_line));
-  strncpy((char *) &parse_line, line, sizeof(parse_line) -1);
-
-  if (strlen((char *) &parse_line) != sizeof(parse_line) - 1)
-    return(False);
-
-  /* Get the jobid */
-  buf->job = atoi(parse_line.jobid);
-
-  /* Get the job name */
-  parse_line.space2[0] = '\0';
-  trim_string(parse_line.jobname, NULL, " ");
-  fstrcpy(buf->fs_file, parse_line.jobname);
-
-  buf->priority = 0;
-  buf->size = atoi(parse_line.size);
-  buf->time = time(NULL);
-
-  /* Make sure we have an owner */
-  if (!strlen(parse_line.owner))
-    return(False);
-
-  /* Make sure we have a valid status */
-  parse_line.space4[0] = '\0';
-  trim_string(parse_line.status, NULL, " ");
-  if (!strequal(parse_line.status, LPROS2_PRINTING) &&
-      !strequal(parse_line.status, LPROS2_PAUSED) &&
-      !strequal(parse_line.status, LPROS2_WAITING))
-    return(False);
-
-  fstrcpy(buf->fs_user, parse_line.owner);
-  if (strequal(parse_line.status, LPROS2_PRINTING))
-    buf->status = LPQ_PRINTING;
-  else if (strequal(parse_line.status, LPROS2_PAUSED))
-    buf->status = LPQ_PAUSED;
-  else
-    buf->status = LPQ_QUEUED;
-
-  return(True);
-}
-
-static const char *stat0_strings[] = { "enabled", "online", "idle", "no entries", "free", "ready", NULL };
-static const char *stat1_strings[] = { "offline", "disabled", "down", "off", "waiting", "no daemon", NULL };
-static const char *stat2_strings[] = { "jam", "paper", "error", "responding", "not accepting", "not running", "turned off", NULL };
-
-#ifdef DEVELOPER
-
-/****************************************************************************
-parse a vlp line
-****************************************************************************/
-static BOOL parse_lpq_vlp(char *line,print_queue_struct *buf,BOOL first)
-{
-	int toknum = 0;
-	fstring tok;
-  	const char *cline = line;
-
-	/* First line is printer status */
-
-	if (!isdigit(line[0])) return False;
-
-	/* Parse a print job entry */
-
-	while(next_token(&cline, tok, NULL, sizeof(fstring))) {
-		switch (toknum) {
-		case 0:
-			buf->job = atoi(tok);
-			break;
-		case 1:
-			buf->size = atoi(tok);
-			break;
-		case 2:
-			buf->status = atoi(tok);
-			break;
-		case 3:
-			buf->time = atoi(tok);
-			break;
-		case 4:
-			fstrcpy(buf->fs_user, tok);
-			break;
-		case 5:
-			fstrcpy(buf->fs_file, tok);
-			break;
-		}
-		toknum++;
-	}
-
-	return True;
-}
-
-#endif /* DEVELOPER */
-
-/****************************************************************************
-parse a lpq line. Choose printing style
-****************************************************************************/
-BOOL parse_lpq_entry(int snum,char *line,
-		     print_queue_struct *buf,
-		     print_status_struct *status,BOOL first)
-{
-  BOOL ret;
-
-  switch (lp_printing(snum))
-    {
-    case PRINT_SYSV:
-      ret = parse_lpq_sysv(line,buf,first);
-      break;
-    case PRINT_AIX:      
-      ret = parse_lpq_aix(line,buf,first);
-      break;
-    case PRINT_HPUX:
-      ret = parse_lpq_hpux(line,buf,first);
-      break;
-    case PRINT_QNX:
-      ret = parse_lpq_qnx(line,buf,first);
-      break;
-    case PRINT_LPRNG:
-      ret = parse_lpq_lprng(line,buf,first);
-      break;
-    case PRINT_PLP:
-      ret = parse_lpq_plp(line,buf,first);
-      break;
-    case PRINT_SOFTQ:
-      ret = parse_lpq_softq(line,buf,first);
-      break;
-    case PRINT_LPRNT:
-      ret = parse_lpq_nt(line,buf,first);
-      break;
-    case PRINT_LPROS2:
-      ret = parse_lpq_os2(line,buf,first);
-      break;
-#ifdef DEVELOPER
-    case PRINT_VLP:
-    case PRINT_TEST:
-	    ret = parse_lpq_vlp(line,buf,first);
-	    break;
-#endif /* DEVELOPER */
-    default:
-      ret = parse_lpq_bsd(line,buf,first);
-      break;
-    }
-
-  /* We don't want the newline in the status message. */
-  {
-    char *p = strchr(line,'\n');
-    if (p) *p = 0;
-  }
-
-  /* in the LPRNG case, we skip lines starting by a space.*/
-  if (line && !ret && (lp_printing(snum)==PRINT_LPRNG) )
-  {
-  	if (line[0]==' ')
-		return ret;
-  }
-
-
-  if (status && !ret)
-    {
-      /* a few simple checks to see if the line might be a
-         printer status line: 
-	 handle them so that most severe condition is shown */
-      int i;
-      strlower(line);
-      
-      switch (status->status) {
-      case LPSTAT_OK:
-	for (i=0; stat0_strings[i]; i++)
-	  if (strstr(line,stat0_strings[i])) {
-	    StrnCpy(status->message,line,sizeof(status->message)-1);
-	    status->status=LPSTAT_OK;
-	    return ret;
-	  }
-      case LPSTAT_STOPPED:
-	for (i=0; stat1_strings[i]; i++)
-	  if (strstr(line,stat1_strings[i])) {
-	    StrnCpy(status->message,line,sizeof(status->message)-1);
-	    status->status=LPSTAT_STOPPED;
-	    return ret;
-	  }
-      case LPSTAT_ERROR:
-	for (i=0; stat2_strings[i]; i++)
-	  if (strstr(line,stat2_strings[i])) {
-	    StrnCpy(status->message,line,sizeof(status->message)-1);
-	    status->status=LPSTAT_ERROR;
-	    return ret;
-	  }
-	break;
-      }
-    }
-
-  return(ret);
-}
diff -Naur samba-2.2.12-orig/source/printing/nt_printing.c samba-2.2.12/source/printing/nt_printing.c
--- samba-2.2.12-orig/source/printing/nt_printing.c	2011-03-04 13:51:45.000000000 +0100
+++ samba-2.2.12/source/printing/nt_printing.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,4175 +0,0 @@
-/*
- *  Unix SMB/CIFS implementation.
- *  RPC Pipe client / server routines
- *  Copyright (C) Andrew Tridgell              1992-2000,
- *  Copyright (C) Jean Franois Micouleau      1998-2000.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- */
-
-#include "includes.h"
-
-extern DOM_SID global_sid_World;
-
-static TDB_CONTEXT *tdb_forms; /* used for forms files */
-static TDB_CONTEXT *tdb_drivers; /* used for driver files */
-static TDB_CONTEXT *tdb_printers; /* used for printers files */
-
-#define FORMS_PREFIX "FORMS/"
-#define DRIVERS_PREFIX "DRIVERS/"
-#define DRIVER_INIT_PREFIX "DRIVER_INIT/"
-#define PRINTERS_PREFIX "PRINTERS/"
-#define SECDESC_PREFIX "SECDESC/"
-#define GLOBAL_C_SETPRINTER "GLOBALS/c_setprinter"
- 
-#define NTDRIVERS_DATABASE_VERSION_1 1
-#define NTDRIVERS_DATABASE_VERSION_2 2
-#define NTDRIVERS_DATABASE_VERSION_3 3 /* little endian version of v2 */
- 
-#define NTDRIVERS_DATABASE_VERSION NTDRIVERS_DATABASE_VERSION_3
-
-/* Map generic permissions to printer object specific permissions */
-
-GENERIC_MAPPING printer_generic_mapping = {
-	PRINTER_READ,
-	PRINTER_WRITE,
-	PRINTER_EXECUTE,
-	PRINTER_ALL_ACCESS
-};
-
-STANDARD_MAPPING printer_std_mapping = {
-	PRINTER_READ,
-	PRINTER_WRITE,
-	PRINTER_EXECUTE,
-	PRINTER_ALL_ACCESS
-};
-
-/* Map generic permissions to print server object specific permissions */
-
-GENERIC_MAPPING printserver_generic_mapping = {
-	SERVER_READ,
-	SERVER_WRITE,
-	SERVER_EXECUTE,
-	SERVER_ALL_ACCESS
-};
-
-STANDARD_MAPPING printserver_std_mapping = {
-	SERVER_READ,
-	SERVER_WRITE,
-	SERVER_EXECUTE,
-	SERVER_ALL_ACCESS
-};
-
-/* We need one default form to support our default printer. Msoft adds the
-forms it wants and in the ORDER it wants them (note: DEVMODE papersize is an
-array index). Letter is always first, so (for the current code) additions
-always put things in the correct order. */
-static nt_forms_struct default_forms[] = {
-	{"Letter",0x1,0x34b5c,0x44368,0x0,0x0,0x34b5c,0x44368},
-	{"Letter Small",0x1,0x34b5c,0x44368,0x0,0x0,0x34b5c,0x44368},
-	{"Tabloid",0x1,0x44368,0x696b8,0x0,0x0,0x44368,0x696b8},
-	{"Ledger",0x1,0x696b8,0x44368,0x0,0x0,0x696b8,0x44368},
-	{"Legal",0x1,0x34b5c,0x56d10,0x0,0x0,0x34b5c,0x56d10},
-	{"Statement",0x1,0x221b4,0x34b5c,0x0,0x0,0x221b4,0x34b5c},
-	{"Executive",0x1,0x2cf56,0x411cc,0x0,0x0,0x2cf56,0x411cc},
-	{"A3",0x1,0x48828,0x668a0,0x0,0x0,0x48828,0x668a0},
-	{"A4",0x1,0x33450,0x48828,0x0,0x0,0x33450,0x48828},
-	{"A4 Small",0x1,0x33450,0x48828,0x0,0x0,0x33450,0x48828},
-	{"A5",0x1,0x24220,0x33450,0x0,0x0,0x24220,0x33450},
-	{"B4 (JIS)",0x1,0x3ebe8,0x58de0,0x0,0x0,0x3ebe8,0x58de0},
-	{"B5 (JIS)",0x1,0x2c6f0,0x3ebe8,0x0,0x0,0x2c6f0,0x3ebe8},
-	{"Folio",0x1,0x34b5c,0x509d8,0x0,0x0,0x34b5c,0x509d8},
-	{"Quarto",0x1,0x347d8,0x43238,0x0,0x0,0x347d8,0x43238},
-	{"10x14",0x1,0x3e030,0x56d10,0x0,0x0,0x3e030,0x56d10},
-	{"11x17",0x1,0x44368,0x696b8,0x0,0x0,0x44368,0x696b8},
-	{"Note",0x1,0x34b5c,0x44368,0x0,0x0,0x34b5c,0x44368},
-	{"Envelope #9",0x1,0x18079,0x37091,0x0,0x0,0x18079,0x37091},
-	{"Envelope #10",0x1,0x19947,0x3ae94,0x0,0x0,0x19947,0x3ae94},
-	{"Envelope #11",0x1,0x1be7c,0x40565,0x0,0x0,0x1be7c,0x40565},
-	{"Envelope #12",0x1,0x1d74a,0x44368,0x0,0x0,0x1d74a,0x44368},
-	{"Envelope #14",0x1,0x1f018,0x47504,0x0,0x0,0x1f018,0x47504},
-	{"C size sheet",0x1,0x696b8,0x886d0,0x0,0x0,0x696b8,0x886d0},
-	{"D size sheet",0x1,0x886d0,0xd2d70,0x0,0x0,0x886d0,0xd2d70},
-	{"E size sheet",0x1,0xd2d70,0x110da0,0x0,0x0,0xd2d70,0x110da0},
-	{"Envelope DL",0x1,0x1adb0,0x35b60,0x0,0x0,0x1adb0,0x35b60},
-	{"Envelope C5",0x1,0x278d0,0x37e88,0x0,0x0,0x278d0,0x37e88},
-	{"Envelope C3",0x1,0x4f1a0,0x6fd10,0x0,0x0,0x4f1a0,0x6fd10},
-	{"Envelope C4",0x1,0x37e88,0x4f1a0,0x0,0x0,0x37e88,0x4f1a0},
-	{"Envelope C6",0x1,0x1bd50,0x278d0,0x0,0x0,0x1bd50,0x278d0},
-	{"Envelope C65",0x1,0x1bd50,0x37e88,0x0,0x0,0x1bd50,0x37e88},
-	{"Envelope B4",0x1,0x3d090,0x562e8,0x0,0x0,0x3d090,0x562e8},
-	{"Envelope B5",0x1,0x2af80,0x3d090,0x0,0x0,0x2af80,0x3d090},
-	{"Envelope B6",0x1,0x2af80,0x1e848,0x0,0x0,0x2af80,0x1e848},
-	{"Envelope",0x1,0x1adb0,0x38270,0x0,0x0,0x1adb0,0x38270},
-	{"Envelope Monarch",0x1,0x18079,0x2e824,0x0,0x0,0x18079,0x2e824},
-	{"6 3/4 Envelope",0x1,0x167ab,0x284ec,0x0,0x0,0x167ab,0x284ec},
-	{"US Std Fanfold",0x1,0x5c3e1,0x44368,0x0,0x0,0x5c3e1,0x44368},
-	{"German Std Fanfold",0x1,0x34b5c,0x4a6a0,0x0,0x0,0x34b5c,0x4a6a0},
-	{"German Legal Fanfold",0x1,0x34b5c,0x509d8,0x0,0x0,0x34b5c,0x509d8},
-	{"B4 (ISO)",0x1,0x3d090,0x562e8,0x0,0x0,0x3d090,0x562e8},
-	{"Japanese Postcard",0x1,0x186a0,0x24220,0x0,0x0,0x186a0,0x24220},
-	{"9x11",0x1,0x37cf8,0x44368,0x0,0x0,0x37cf8,0x44368},
-	{"10x11",0x1,0x3e030,0x44368,0x0,0x0,0x3e030,0x44368},
-	{"15x11",0x1,0x5d048,0x44368,0x0,0x0,0x5d048,0x44368},
-	{"Envelope Invite",0x1,0x35b60,0x35b60,0x0,0x0,0x35b60,0x35b60},
-	{"Reserved48",0x1,0x1,0x1,0x0,0x0,0x1,0x1},
-	{"Reserved49",0x1,0x1,0x1,0x0,0x0,0x1,0x1},
-	{"Letter Extra",0x1,0x3ae94,0x4a6a0,0x0,0x0,0x3ae94,0x4a6a0},
-	{"Legal Extra",0x1,0x3ae94,0x5d048,0x0,0x0,0x3ae94,0x5d048},
-	{"Tabloid Extra",0x1,0x4a6a0,0x6f9f0,0x0,0x0,0x4a6a0,0x6f9f0},
-	{"A4 Extra",0x1,0x397c2,0x4eb16,0x0,0x0,0x397c2,0x4eb16},
-	{"Letter Transverse",0x1,0x34b5c,0x44368,0x0,0x0,0x34b5c,0x44368},
-	{"A4 Transverse",0x1,0x33450,0x48828,0x0,0x0,0x33450,0x48828},
-	{"Letter Extra Transverse",0x1,0x3ae94,0x4a6a0,0x0,0x0,0x3ae94,0x4a6a0},
-	{"Super A",0x1,0x376b8,0x56ea0,0x0,0x0,0x376b8,0x56ea0},
-	{"Super B",0x1,0x4a768,0x76e58,0x0,0x0,0x4a768,0x76e58},
-	{"Letter Plus",0x1,0x34b5c,0x4eb16,0x0,0x0,0x34b5c,0x4eb16},
-	{"A4 Plus",0x1,0x33450,0x50910,0x0,0x0,0x33450,0x50910},
-	{"A5 Transverse",0x1,0x24220,0x33450,0x0,0x0,0x24220,0x33450},
-	{"B5 (JIS) Transverse",0x1,0x2c6f0,0x3ebe8,0x0,0x0,0x2c6f0,0x3ebe8},
-	{"A3 Extra",0x1,0x4e9d0,0x6ca48,0x0,0x0,0x4e9d0,0x6ca48},
-	{"A5 Extra",0x1,0x2a7b0,0x395f8,0x0,0x0,0x2a7b0,0x395f8},
-	{"B5 (ISO) Extra",0x1,0x31128,0x43620,0x0,0x0,0x31128,0x43620},
-	{"A2",0x1,0x668a0,0x91050,0x0,0x0,0x668a0,0x91050},
-	{"A3 Transverse",0x1,0x48828,0x668a0,0x0,0x0,0x48828,0x668a0},
-	{"A3 Extra Transverse",0x1,0x4e9d0,0x6ca48,0x0,0x0,0x4e9d0,0x6ca48},
-	{"Japanese Double Postcard",0x1,0x30d40,0x24220,0x0,0x0,0x30d40,0x24220},
-	{"A6",0x1,0x19a28,0x24220,0x0,0x0,0x19a28,0x24220},
-	{"Japanese Envelope Kaku #2",0x1,0x3a980,0x510e0,0x0,0x0,0x3a980,0x510e0},
-	{"Japanese Envelope Kaku #3",0x1,0x34bc0,0x43a08,0x0,0x0,0x34bc0,0x43a08},
-	{"Japanese Envelope Chou #3",0x1,0x1d4c0,0x395f8,0x0,0x0,0x1d4c0,0x395f8},
-	{"Japanese Envelope Chou #4",0x1,0x15f90,0x320c8,0x0,0x0,0x15f90,0x320c8},
-	{"Letter Rotated",0x1,0x44368,0x34b5c,0x0,0x0,0x44368,0x34b5c},
-	{"A3 Rotated",0x1,0x668a0,0x48828,0x0,0x0,0x668a0,0x48828},
-	{"A4 Rotated",0x1,0x48828,0x33450,0x0,0x0,0x48828,0x33450},
-	{"A5 Rotated",0x1,0x33450,0x24220,0x0,0x0,0x33450,0x24220},
-	{"B4 (JIS) Rotated",0x1,0x58de0,0x3ebe8,0x0,0x0,0x58de0,0x3ebe8},
-	{"B5 (JIS) Rotated",0x1,0x3ebe8,0x2c6f0,0x0,0x0,0x3ebe8,0x2c6f0},
-	{"Japanese Postcard Rotated",0x1,0x24220,0x186a0,0x0,0x0,0x24220,0x186a0},
-	{"Double Japan Postcard Rotated",0x1,0x24220,0x30d40,0x0,0x0,0x24220,0x30d40},
-	{"A6 Rotated",0x1,0x24220,0x19a28,0x0,0x0,0x24220,0x19a28},
-	{"Japan Envelope Kaku #2 Rotated",0x1,0x510e0,0x3a980,0x0,0x0,0x510e0,0x3a980},
-	{"Japan Envelope Kaku #3 Rotated",0x1,0x43a08,0x34bc0,0x0,0x0,0x43a08, 0x34bc0},
-	{"Japan Envelope Chou #3 Rotated",0x1,0x395f8,0x1d4c0,0x0,0x0,0x395f8,0x1d4c0},
-	{"Japan Envelope Chou #4 Rotated",0x1,0x320c8,0x15f90,0x0,0x0,0x320c8,0x15f90},
-	{"B6 (JIS)",0x1,0x1f400,0x2c6f0,0x0,0x0,0x1f400,0x2c6f0},
-	{"B6 (JIS) Rotated",0x1,0x2c6f0,0x1f400,0x0,0x0,0x2c6f0,0x1f400},
-	{"12x11",0x1,0x4a724,0x443e1,0x0,0x0,0x4a724,0x443e1},
-	{"Japan Envelope You #4",0x1,0x19a28,0x395f8,0x0,0x0,0x19a28,0x395f8},
-	{"Japan Envelope You #4 Rotated",0x1,0x395f8,0x19a28,0x0,0x0,0x395f8,0x19a28},
-	{"PRC 16K",0x1,0x2de60,0x3f7a0,0x0,0x0,0x2de60,0x3f7a0},
-	{"PRC 32K",0x1,0x1fbd0,0x2cec0,0x0,0x0,0x1fbd0,0x2cec0},
-	{"PRC 32K(Big)",0x1,0x222e0,0x318f8,0x0,0x0,0x222e0,0x318f8},
-	{"PRC Envelope #1",0x1,0x18e70,0x28488,0x0,0x0,0x18e70,0x28488},
-	{"PRC Envelope #2",0x1,0x18e70,0x2af80,0x0,0x0,0x18e70,0x2af80},
-	{"PRC Envelope #3",0x1,0x1e848,0x2af80,0x0,0x0,0x1e848,0x2af80},
-	{"PRC Envelope #4",0x1,0x1adb0,0x32c80,0x0,0x0,0x1adb0,0x32c80},
-	{"PRC Envelope #5",0x1,0x1adb0,0x35b60,0x0,0x0,0x1adb0,0x35b60},
-	{"PRC Envelope #6",0x1,0x1d4c0,0x38270,0x0,0x0,0x1d4c0,0x38270},
-	{"PRC Envelope #7",0x1,0x27100,0x38270,0x0,0x0,0x27100,0x38270},
-	{"PRC Envelope #8",0x1,0x1d4c0,0x4b708,0x0,0x0,0x1d4c0,0x4b708},
-	{"PRC Envelope #9",0x1,0x37e88,0x4f1a0,0x0,0x0,0x37e88,0x4f1a0},
-	{"PRC Envelope #10",0x1,0x4f1a0,0x6fd10,0x0,0x0,0x4f1a0,0x6fd10},
-	{"PRC 16K Rotated",0x1,0x3f7a0,0x2de60,0x0,0x0,0x3f7a0,0x2de60},
-	{"PRC 32K Rotated",0x1,0x2cec0,0x1fbd0,0x0,0x0,0x2cec0,0x1fbd0},
-	{"PRC 32K(Big) Rotated",0x1,0x318f8,0x222e0,0x0,0x0,0x318f8,0x222e0},
-	{"PRC Envelope #1 Rotated",0x1,0x28488,0x18e70,0x0,0x0,0x28488,0x18e70},
-	{"PRC Envelope #2 Rotated",0x1,0x2af80,0x18e70,0x0,0x0,0x2af80,0x18e70},
-	{"PRC Envelope #3 Rotated",0x1,0x2af80,0x1e848,0x0,0x0,0x2af80,0x1e848},
-	{"PRC Envelope #4 Rotated",0x1,0x32c80,0x1adb0,0x0,0x0,0x32c80,0x1adb0},
-	{"PRC Envelope #5 Rotated",0x1,0x35b60,0x1adb0,0x0,0x0,0x35b60,0x1adb0},
-	{"PRC Envelope #6 Rotated",0x1,0x38270,0x1d4c0,0x0,0x0,0x38270,0x1d4c0},
-	{"PRC Envelope #7 Rotated",0x1,0x38270,0x27100,0x0,0x0,0x38270,0x27100},
-	{"PRC Envelope #8 Rotated",0x1,0x4b708,0x1d4c0,0x0,0x0,0x4b708,0x1d4c0},
-	{"PRC Envelope #9 Rotated",0x1,0x4f1a0,0x37e88,0x0,0x0,0x4f1a0,0x37e88},
-	{"PRC Envelope #10 Rotated",0x1,0x6fd10,0x4f1a0,0x0,0x0,0x6fd10,0x4f1a0}
-};
-
-static BOOL upgrade_to_version_3(void)
-{
-	TDB_DATA kbuf, newkey, dbuf;
- 
-	ZERODEBUG(0,("upgrade_to_version_3: upgrading print tdb's to version 3\n"));
- 
-	for (kbuf = tdb_firstkey(tdb_drivers); kbuf.dptr;
-			newkey = tdb_nextkey(tdb_drivers, kbuf), safe_free(kbuf.dptr), kbuf=newkey) {
-
-		dbuf = tdb_fetch(tdb_drivers, kbuf);
-
-		if (strncmp(kbuf.dptr, FORMS_PREFIX, strlen(FORMS_PREFIX)) == 0) {
-			ZERODEBUG(0,("upgrade_to_version_3:moving form\n"));
-			if (tdb_store(tdb_forms, kbuf, dbuf, TDB_REPLACE) != 0) {
-				ZERODEBUG(0,("upgrade_to_version_3: failed to move form. Error (%s).\n", tdb_errorstr(tdb_forms)));
-				return False;
-			}
-			if (tdb_delete(tdb_drivers, kbuf) != 0) {
-				ZERODEBUG(0,("upgrade_to_version_3: failed to delete form. Error (%s)\n", tdb_errorstr(tdb_drivers)));
-				return False;
-			}
-		}
- 
-		if (strncmp(kbuf.dptr, PRINTERS_PREFIX, strlen(PRINTERS_PREFIX)) == 0) {
-			ZERODEBUG(0,("upgrade_to_version_3:moving printer\n"));
-			if (tdb_store(tdb_printers, kbuf, dbuf, TDB_REPLACE) != 0) {
-				ZERODEBUG(0,("upgrade_to_version_3: failed to move printer. Error (%s)\n", tdb_errorstr(tdb_printers)));
-				return False;
-			}
-			if (tdb_delete(tdb_drivers, kbuf) != 0) {
-				ZERODEBUG(0,("upgrade_to_version_3: failed to delete printer. Error (%s)\n", tdb_errorstr(tdb_drivers)));
-				return False;
-			}
-		}
- 
-		if (strncmp(kbuf.dptr, SECDESC_PREFIX, strlen(SECDESC_PREFIX)) == 0) {
-			ZERODEBUG(0,("upgrade_to_version_3:moving secdesc\n"));
-			if (tdb_store(tdb_printers, kbuf, dbuf, TDB_REPLACE) != 0) {
-				ZERODEBUG(0,("upgrade_to_version_3: failed to move secdesc. Error (%s)\n", tdb_errorstr(tdb_printers)));
-				return False;
-			}
-			if (tdb_delete(tdb_drivers, kbuf) != 0) {
-				ZERODEBUG(0,("upgrade_to_version_3: failed to delete secdesc. Error (%s)\n", tdb_errorstr(tdb_drivers)));
-				return False;
-			}
-		}
- 
-		SAFE_FREE(dbuf.dptr);
-	}
-
-	return True;
-}
-
-/****************************************************************************
- Open the NT printing tdb.
-****************************************************************************/
-
-BOOL nt_printing_init(void)
-{
-	static pid_t local_pid;
-	const char *vstring = "INFO/version";
-
-	if (tdb_drivers && tdb_printers && tdb_forms && local_pid == sys_getpid())
-		return True;
- 
-	tdb_drivers = tdb_open_log(lock_path("ntdrivers.tdb"), 0, TDB_DEFAULT, O_RDWR|O_CREAT, 0600);
-	if (!tdb_drivers) {
-		ZERODEBUG(0,("nt_printing_init: Failed to open nt drivers database %s (%s)\n",
-			lock_path("ntdrivers.tdb"), strerror(errno) ));
-		return False;
-	}
- 
-	tdb_printers = tdb_open_log(lock_path("ntprinters.tdb"), 0, TDB_DEFAULT, O_RDWR|O_CREAT, 0600);
-	if (!tdb_printers) {
-		ZERODEBUG(0,("nt_printing_init: Failed to open nt printers database %s (%s)\n",
-			lock_path("ntprinters.tdb"), strerror(errno) ));
-		return False;
-	}
- 
-	tdb_forms = tdb_open_log(lock_path("ntforms.tdb"), 0, TDB_DEFAULT, O_RDWR|O_CREAT, 0600);
-	if (!tdb_forms) {
-		ZERODEBUG(0,("nt_printing_init: Failed to open nt forms database %s (%s)\n",
-			lock_path("ntforms.tdb"), strerror(errno) ));
-		return False;
-	}
- 
-	local_pid = sys_getpid();
- 
-	/* handle a Samba upgrade */
-	tdb_lock_bystring(tdb_drivers, vstring,0);
-	{
-		int32 vers_id;
-
-		/* Cope with byte-reversed older versions of the db. */
-		vers_id = tdb_fetch_int32(tdb_drivers, vstring);
-		if ((vers_id == NTDRIVERS_DATABASE_VERSION_2) || (IREV(vers_id) == NTDRIVERS_DATABASE_VERSION_2)) {
-			/* Written on a bigendian machine with old fetch_int code. Save as le. */
-			/* The only upgrade between V2 and V3 is to save the version in little-endian. */
-			tdb_store_int32(tdb_drivers, vstring, NTDRIVERS_DATABASE_VERSION);
-			vers_id = NTDRIVERS_DATABASE_VERSION;
-		}
-
-		if (vers_id != NTDRIVERS_DATABASE_VERSION) {
-
-			if ((vers_id == NTDRIVERS_DATABASE_VERSION_1) || (IREV(vers_id) == NTDRIVERS_DATABASE_VERSION_1)) { 
-				if (!upgrade_to_version_3())
-					return False;
-			} else
-				tdb_traverse(tdb_drivers, tdb_traverse_delete_fn, NULL);
-			 
-			tdb_store_int32(tdb_drivers, vstring, NTDRIVERS_DATABASE_VERSION);
-		}
-	}
-	tdb_unlock_bystring(tdb_drivers, vstring);
-
-	update_c_setprinter(True);
-
-	/* 
-	 * register callback to handle updating printers as new
-  	 * drivers are installed
-	 */
-	message_register(MSG_PRINTER_DRVUPGRADE, do_drv_upgrade_printer);
-
-	return True;
-}
-
-/*******************************************************************
- tdb traversal function for counting printers.
-********************************************************************/
-
-static int traverse_counting_printers(TDB_CONTEXT *t, TDB_DATA key,
-                                      TDB_DATA data, void *context)
-{
-	int *printer_count = (int*)context;
- 
-	if (memcmp(PRINTERS_PREFIX, key.dptr, sizeof(PRINTERS_PREFIX)-1) == 0) {
-		(*printer_count)++;
-		DEBUG(10,("traverse_counting_printers: printer = [%s]  printer_count = %d\n", key.dptr, *printer_count));
-	}
- 
-	return 0;
-}
- 
-/*******************************************************************
- Update the spooler global c_setprinter. This variable is initialized
- when the parent smbd starts with the number of existing printers. It
- is monotonically increased by the current number of printers *after*
- each add or delete printer RPC. Only Microsoft knows why... JRR020119
-********************************************************************/
-
-uint32 update_c_setprinter(BOOL initialize)
-{
-	int32 c_setprinter;
-	int32 printer_count = 0;
- 
-	tdb_lock_bystring(tdb_printers, GLOBAL_C_SETPRINTER,0);
- 
-	/* Traverse the tdb, counting the printers */
-	tdb_traverse(tdb_printers, traverse_counting_printers, (void *)&printer_count);
- 
-	/* If initializing, set c_setprinter to current printers count
-	 * otherwise, bump it by the current printer count
-	 */
-	if (!initialize)
-		c_setprinter = tdb_fetch_int32(tdb_printers, GLOBAL_C_SETPRINTER) + printer_count;
-	else
-		c_setprinter = printer_count;
- 
-	DEBUG(10,("update_c_setprinter: c_setprinter = %u\n", (unsigned int)c_setprinter));
-	tdb_store_int32(tdb_printers, GLOBAL_C_SETPRINTER, c_setprinter);
- 
-	tdb_unlock_bystring(tdb_printers, GLOBAL_C_SETPRINTER);
- 
-	return (uint32)c_setprinter;
-}
-
-/*******************************************************************
- Get the spooler global c_setprinter, accounting for initialization.
-********************************************************************/
-
-uint32 get_c_setprinter(void)
-{
-	int32 c_setprinter = tdb_fetch_int32(tdb_printers, GLOBAL_C_SETPRINTER);
- 
-	if (c_setprinter == (int32)-1)
-		c_setprinter = update_c_setprinter(True);
- 
-	DEBUG(10,("get_c_setprinter: c_setprinter = %d\n", c_setprinter));
- 
-	return (uint32)c_setprinter;
-}
-
-/****************************************************************************
- Get builtin form struct list.
-****************************************************************************/
-
-int get_builtin_ntforms(nt_forms_struct **list)
-{
-	*list = (nt_forms_struct *)memdup(&default_forms[0], sizeof(default_forms));
-	return sizeof(default_forms) / sizeof(default_forms[0]);
-}
-
-/****************************************************************************
- get a builtin form struct
-****************************************************************************/
-
-BOOL get_a_builtin_ntform(UNISTR2 *uni_formname,nt_forms_struct *form)
-{
-	int i,count;
-	fstring form_name;
-	unistr2_to_dos(form_name, uni_formname, sizeof(form_name)-1);
-	DEBUGADD(6,("Looking for builtin form %s \n", form_name));
-	count = sizeof(default_forms) / sizeof(default_forms[0]);
-	for (i=0;i<count;i++) {
-		if (strequal(form_name,default_forms[i].name)) {
-			DEBUGADD(6,("Found builtin form %s \n", form_name));
-			memcpy(form,&default_forms[i],sizeof(*form));
-			break;
-		}
-	}
-
-	return (i !=count);
-}
-
-/****************************************************************************
-get a form struct list
-****************************************************************************/
-int get_ntforms(nt_forms_struct **list)
-{
-	TDB_DATA kbuf, newkey, dbuf;
-	nt_forms_struct *tl;
-	nt_forms_struct form;
-	int ret;
-	int i;
-	int n = 0;
-
-	for (kbuf = tdb_firstkey(tdb_forms);
-	     kbuf.dptr;
-	     newkey = tdb_nextkey(tdb_forms, kbuf), safe_free(kbuf.dptr), kbuf=newkey) {
-		if (strncmp(kbuf.dptr, FORMS_PREFIX, strlen(FORMS_PREFIX)) != 0) continue;
-		
-		dbuf = tdb_fetch(tdb_forms, kbuf);
-		if (!dbuf.dptr) continue;
-
-		fstrcpy(form.name, kbuf.dptr+strlen(FORMS_PREFIX));
-		ret = tdb_unpack(dbuf.dptr, dbuf.dsize, "dddddddd",
-				 &i, &form.flag, &form.width, &form.length, &form.left,
-				 &form.top, &form.right, &form.bottom);
-		SAFE_FREE(dbuf.dptr);
-		if (ret != dbuf.dsize) continue;
-
-		tl = Realloc(*list, sizeof(nt_forms_struct)*(n+1));
-		if (!tl) {
-			ZERODEBUG(0,("get_ntforms: Realloc fail.\n"));
-			return 0;
-		}
-        *list = tl;
-		(*list)[n] = form;
-		n++;
-	}
-	
-
-	return n;
-}
-
-/****************************************************************************
-write a form struct list
-****************************************************************************/
-int write_ntforms(nt_forms_struct **list, int number)
-{
-	pstring buf, key;
-	int len;
-	TDB_DATA kbuf,dbuf;
-	int i;
-
-	for (i=0;i<number;i++) {
-		/* save index, so list is rebuilt in correct order */
-		len = tdb_pack(buf, sizeof(buf), "dddddddd",
-			       i, (*list)[i].flag, (*list)[i].width, (*list)[i].length,
-			       (*list)[i].left, (*list)[i].top, (*list)[i].right,
-			       (*list)[i].bottom);
-		if (len > sizeof(buf)) break;
-		slprintf(key, sizeof(key)-1, "%s%s", FORMS_PREFIX, (*list)[i].name);
-        dos_to_unix(key);            /* Convert key to unix-codepage */
-		kbuf.dsize = strlen(key)+1;
-		kbuf.dptr = key;
-		dbuf.dsize = len;
-		dbuf.dptr = buf;
-		if (tdb_store(tdb_forms, kbuf, dbuf, TDB_REPLACE) != 0) break;
-       }
-
-       return i;
-}
-
-/****************************************************************************
-add a form struct at the end of the list
-****************************************************************************/
-BOOL add_a_form(nt_forms_struct **list, const FORM *form, int *count)
-{
-	int n=0;
-	BOOL update;
-	fstring form_name;
-	nt_forms_struct *tl;
-
-	/*
-	 * NT tries to add forms even when
-	 * they are already in the base
-	 * only update the values if already present
-	 */
-
-	update=False;
-	
-	unistr2_to_dos(form_name, &form->name, sizeof(form_name)-1);
-	for (n=0; n<*count; n++) {
-		if (!strncmp((*list)[n].name, form_name, strlen(form_name))) {
-			DEBUG(103, ("NT workaround, [%s] already exists\n", form_name));
-			update=True;
-			break;
-		}
-	}
-
-	if (update==False) {
-		if((tl=Realloc(*list, (n+1)*sizeof(nt_forms_struct))) == NULL) {
-			ZERODEBUG(0,("add_a_form: failed to enlarge forms list!\n"));
-			return False;
-		}
-		*list = tl;
-		unistr2_to_dos((*list)[n].name, &form->name, sizeof((*list)[n].name)-1);
-		(*count)++;
-	}
-	
-	(*list)[n].flag=form->flags;
-	(*list)[n].width=form->size_x;
-	(*list)[n].length=form->size_y;
-	(*list)[n].left=form->left;
-	(*list)[n].top=form->top;
-	(*list)[n].right=form->right;
-	(*list)[n].bottom=form->bottom;
-
-	return True;
-}
-
-/****************************************************************************
- delete a named form struct
-****************************************************************************/
-BOOL delete_a_form(nt_forms_struct **list, UNISTR2 *del_name, int *count, WERROR *ret)
-{
-	pstring key;
-	TDB_DATA kbuf;
-	int n=0;
-	fstring form_name;
-
-	*ret = WERR_OK;
-
-	unistr2_to_dos(form_name, del_name, sizeof(form_name)-1);
-
-	for (n=0; n<*count; n++) {
-		if (!strncmp((*list)[n].name, form_name, strlen(form_name))) {
-			DEBUG(103, ("delete_a_form, [%s] in list\n", form_name));
-			break;
-		}
-	}
-
-	if (n == *count) {
-		DEBUG(10,("delete_a_form, [%s] not found\n", form_name));
-		*ret = WERR_INVALID_PARAM;
-		return False;
-	}
-
-	slprintf(key, sizeof(key)-1, "%s%s", FORMS_PREFIX, (*list)[n].name);
-	dos_to_unix(key);                /* Convert key to unix-codepage */
-	kbuf.dsize = strlen(key)+1;
-	kbuf.dptr = key;
-	if (tdb_delete(tdb_forms, kbuf) != 0) {
-		*ret = WERR_NOMEM;
-		return False;
-	}
-
-	return True;
-}
-
-/****************************************************************************
-update a form struct
-****************************************************************************/
-void update_a_form(nt_forms_struct **list, const FORM *form, int count)
-{
-	int n=0;
-	fstring form_name;
-	unistr2_to_dos(form_name, &(form->name), sizeof(form_name)-1);
-
-	DEBUG(106, ("[%s]\n", form_name));
-	for (n=0; n<count; n++)
-	{
-		DEBUGADD(106, ("n [%d]:[%s]\n", n, (*list)[n].name));
-		if (!strncmp((*list)[n].name, form_name, strlen(form_name)))
-			break;
-	}
-
-	if (n==count) return;
-
-	(*list)[n].flag=form->flags;
-	(*list)[n].width=form->size_x;
-	(*list)[n].length=form->size_y;
-	(*list)[n].left=form->left;
-	(*list)[n].top=form->top;
-	(*list)[n].right=form->right;
-	(*list)[n].bottom=form->bottom;
-}
-
-/****************************************************************************
-get the nt drivers list
-
-traverse the database and look-up the matching names
-****************************************************************************/
-int get_ntdrivers(fstring **list, char *architecture, uint32 version)
-{
-	int total=0;
-	fstring short_archi;
-	fstring *fl;
-	pstring key;
-	TDB_DATA kbuf, newkey;
-
-	get_short_archi(short_archi, architecture);
-	slprintf(key, sizeof(key)-1, "%s%s/%d/", DRIVERS_PREFIX, short_archi, version);
-
-	for (kbuf = tdb_firstkey(tdb_drivers);
-	     kbuf.dptr;
-	     newkey = tdb_nextkey(tdb_drivers, kbuf), safe_free(kbuf.dptr), kbuf=newkey) {
-		if (strncmp(kbuf.dptr, key, strlen(key)) != 0) continue;
-		
-		if((fl = Realloc(*list, sizeof(fstring)*(total+1))) == NULL) {
-			ZERODEBUG(0,("get_ntdrivers: failed to enlarge list!\n"));
-			return -1;
-		}
-		else *list = fl;
-
-		fstrcpy((*list)[total], kbuf.dptr+strlen(key));
-		total++;
-	}
-
-	return(total);
-}
-
-/****************************************************************************
-function to do the mapping between the long architecture name and
-the short one.
-****************************************************************************/
-
-BOOL get_short_archi(char *short_archi, const char *long_archi)
-{
-	struct table {
-		const char *long_archi;
-		const char *short_archi;
-	};
-	
-	struct table archi_table[]=
-	{
-		{"Windows 4.0",          "WIN40"    },
-		{"Windows NT x86",       "W32X86"   },
-		{"Windows NT R4000",     "W32MIPS"  },
-		{"Windows NT Alpha_AXP", "W32ALPHA" },
-		{"Windows NT PowerPC",   "W32PPC"   },
-		{NULL,                   ""         }
-	};
-	
-	int i=-1;
-
-	DEBUG(107,("Getting architecture dependant directory\n"));
-
-	if (long_archi == NULL) {
-		DEBUGADD(107,("Bad long_archi param.!\n"));
-		return False;
-	}
-
-	do {
-		i++;
-	} while ( (archi_table[i].long_archi!=NULL ) &&
-	          StrCaseCmp(long_archi, archi_table[i].long_archi) );
-
-	if (archi_table[i].long_archi==NULL) {
-		DEBUGADD(107,("Unknown architecture [%s] !\n", long_archi));
-		return False;
-	}
-
-	StrnCpy (short_archi, archi_table[i].short_archi, strlen(archi_table[i].short_archi));
-
-	DEBUGADD(108,("index: [%d]\n", i));
-	DEBUGADD(108,("long architecture: [%s]\n", long_archi));
-	DEBUGADD(108,("short architecture: [%s]\n", short_archi));
-	
-	return True;
-}
-
-/****************************************************************************
- Version information in Microsoft files is held in a VS_VERSION_INFO structure.
- There are two case to be covered here: PE (Portable Executable) and NE (New
- Executable) files. Both files support the same INFO structure, but PE files
- store the signature in unicode, and NE files store it as !unicode.
- returns -1 on error, 1 on version info found, and 0 on no version info found.
-****************************************************************************/
-
-static int get_file_version(files_struct *fsp, char *fname,uint32 *major, uint32 *minor)
-{
-	int     i;
-	char    *buf;
-	ssize_t byte_count;
-
-	if ((buf=malloc(PE_HEADER_SIZE)) == NULL) {
-		ZERODEBUG(0,("get_file_version: PE file [%s] PE Header malloc failed bytes = %d\n",
-				fname, PE_HEADER_SIZE));
-		goto error_exit;
-	}
-
-	/* Note: DOS_HEADER_SIZE < malloc'ed PE_HEADER_SIZE */
-	if ((byte_count = vfs_read_data(fsp, buf, DOS_HEADER_SIZE)) < DOS_HEADER_SIZE) {
-		DEBUG(3,("get_file_version: File [%s] DOS header too short, bytes read = %d\n",
-				fname, byte_count));
-		goto no_version_info;
-	}
-
-	/* Is this really a DOS header? */
-	if (SVAL(buf,DOS_HEADER_MAGIC_OFFSET) != DOS_HEADER_MAGIC) {
-		DEBUG(6,("get_file_version: File [%s] bad DOS magic = 0x%x\n",
-				fname, SVAL(buf,DOS_HEADER_MAGIC_OFFSET)));
-		goto no_version_info;
-	}
-
-	/* Skip OEM header (if any) and the DOS stub to start of Windows header */
-	if (fsp->conn->vfs_ops.lseek(fsp, fsp->fd, SVAL(buf,DOS_HEADER_LFANEW_OFFSET), SEEK_SET) == (SMB_OFF_T)-1) {
-		DEBUG(3,("get_file_version: File [%s] too short, errno = %d\n",
-				fname, errno));
-		/* Assume this isn't an error... the file just looks sort of like a PE/NE file */
-		goto no_version_info;
-	}
-
-	if ((byte_count = vfs_read_data(fsp, buf, PE_HEADER_SIZE)) < PE_HEADER_SIZE) {
-		DEBUG(3,("get_file_version: File [%s] Windows header too short, bytes read = %d\n",
-				fname, byte_count));
-		/* Assume this isn't an error... the file just looks sort of like a PE/NE file */
-		goto no_version_info;
-	}
-
-	/* The header may be a PE (Portable Executable) or an NE (New Executable) */
-	if (IVAL(buf,PE_HEADER_SIGNATURE_OFFSET) == PE_HEADER_SIGNATURE) {
-		int num_sections;
-		int section_table_bytes;
-		
-		if (SVAL(buf,PE_HEADER_MACHINE_OFFSET) != PE_HEADER_MACHINE_I386) {
-			DEBUG(3,("get_file_version: PE file [%s] wrong machine = 0x%x\n",
-					fname, SVAL(buf,PE_HEADER_MACHINE_OFFSET)));
-			/* At this point, we assume the file is in error. It still could be somthing
-			 * else besides a PE file, but it unlikely at this point.
-			 */
-			goto error_exit;
-		}
-
-		/* get the section table */
-		num_sections        = SVAL(buf,PE_HEADER_NUMBER_OF_SECTIONS);
-		section_table_bytes = num_sections * PE_HEADER_SECT_HEADER_SIZE;
-		SAFE_FREE(buf);
-		if ((buf=malloc(section_table_bytes)) == NULL) {
-			ZERODEBUG(0,("get_file_version: PE file [%s] section table malloc failed bytes = %d\n",
-					fname, section_table_bytes));
-			goto error_exit;
-		}
-
-		if ((byte_count = vfs_read_data(fsp, buf, section_table_bytes)) < section_table_bytes) {
-			DEBUG(3,("get_file_version: PE file [%s] Section header too short, bytes read = %d\n",
-					fname, byte_count));
-			goto error_exit;
-		}
-
-		/* Iterate the section table looking for the resource section ".rsrc" */
-		for (i = 0; i < num_sections; i++) {
-			int sec_offset = i * PE_HEADER_SECT_HEADER_SIZE;
-
-			if (strcmp(".rsrc", &buf[sec_offset+PE_HEADER_SECT_NAME_OFFSET]) == 0) {
-				int section_pos   = IVAL(buf,sec_offset+PE_HEADER_SECT_PTR_DATA_OFFSET);
-				int section_bytes = IVAL(buf,sec_offset+PE_HEADER_SECT_SIZE_DATA_OFFSET);
-
-				SAFE_FREE(buf);
-				if ((buf=malloc(section_bytes)) == NULL) {
-					ZERODEBUG(0,("get_file_version: PE file [%s] version malloc failed bytes = %d\n",
-							fname, section_bytes));
-					goto error_exit;
-				}
-
-				/* Seek to the start of the .rsrc section info */
-				if (fsp->conn->vfs_ops.lseek(fsp, fsp->fd, section_pos, SEEK_SET) == (SMB_OFF_T)-1) {
-					DEBUG(3,("get_file_version: PE file [%s] too short for section info, errno = %d\n",
-							fname, errno));
-					goto error_exit;
-				}
-
-				if ((byte_count = vfs_read_data(fsp, buf, section_bytes)) < section_bytes) {
-					DEBUG(3,("get_file_version: PE file [%s] .rsrc section too short, bytes read = %d\n",
-							fname, byte_count));
-					goto error_exit;
-				}
-
-				for (i=0; i<section_bytes-VS_VERSION_INFO_UNICODE_SIZE; i++) {
-					/* Scan for 1st 3 unicoded bytes followed by word aligned magic value */
-					if (buf[i] == 'V' && buf[i+1] == '\0' && buf[i+2] == 'S') {
-						/* Align to next long address */
-						int pos = (i + sizeof(VS_SIGNATURE)*2 + 3) & 0xfffffffc;
-
-						if (IVAL(buf,pos) == VS_MAGIC_VALUE) {
-							*major = IVAL(buf,pos+VS_MAJOR_OFFSET);
-							*minor = IVAL(buf,pos+VS_MINOR_OFFSET);
-							
-							DEBUG(6,("get_file_version: PE file [%s] Version = %08x:%08x (%d.%d.%d.%d)\n",
-									  fname, *major, *minor,
-									  (*major>>16)&0xffff, *major&0xffff,
-									  (*minor>>16)&0xffff, *minor&0xffff));
-							SAFE_FREE(buf);
-							return 1;
-						}
-					}
-				}
-			}
-		}
-
-		/* Version info not found, fall back to origin date/time */
-		DEBUG(10,("get_file_version: PE file [%s] has no version info\n", fname));
-		SAFE_FREE(buf);
-		return 0;
-
-	} else if (SVAL(buf,NE_HEADER_SIGNATURE_OFFSET) == NE_HEADER_SIGNATURE) {
-		if (CVAL(buf,NE_HEADER_TARGET_OS_OFFSET) != NE_HEADER_TARGOS_WIN ) {
-			DEBUG(3,("get_file_version: NE file [%s] wrong target OS = 0x%x\n",
-					fname, CVAL(buf,NE_HEADER_TARGET_OS_OFFSET)));
-			/* At this point, we assume the file is in error. It still could be somthing
-			 * else besides a NE file, but it unlikely at this point. */
-			goto error_exit;
-		}
-
-		/* Allocate a bit more space to speed up things */
-		SAFE_FREE(buf);
-		if ((buf=malloc(VS_NE_BUF_SIZE)) == NULL) {
-			ZERODEBUG(0,("get_file_version: NE file [%s] malloc failed bytes  = %d\n",
-					fname, PE_HEADER_SIZE));
-			goto error_exit;
-		}
-
-		/* This is a HACK! I got tired of trying to sort through the messy
-		 * 'NE' file format. If anyone wants to clean this up please have at
-		 * it, but this works. 'NE' files will eventually fade away. JRR */
-		while((byte_count = vfs_read_data(fsp, buf, VS_NE_BUF_SIZE)) > 0) {
-			/* Cover case that should not occur in a well formed 'NE' .dll file */
-			if (byte_count-VS_VERSION_INFO_SIZE <= 0) break;
-
-			for(i=0; i<byte_count; i++) {
-				/* Fast skip past data that can't possibly match */
-				if (buf[i] != 'V') continue;
-
-				/* Potential match data crosses buf boundry, move it to beginning
-				 * of buf, and fill the buf with as much as it will hold. */
-				if (i>byte_count-VS_VERSION_INFO_SIZE) {
-					int bc;
-
-					memcpy(buf, &buf[i], byte_count-i);
-					if ((bc = vfs_read_data(fsp, &buf[byte_count-i], VS_NE_BUF_SIZE-
-								   (byte_count-i))) < 0) {
-
-						ZERODEBUG(0,("get_file_version: NE file [%s] Read error, errno=%d\n",
-								 fname, errno));
-						goto error_exit;
-					}
-
-					byte_count = bc + (byte_count - i);
-					if (byte_count<VS_VERSION_INFO_SIZE) break;
-
-					i = 0;
-				}
-
-				/* Check that the full signature string and the magic number that
-				 * follows exist (not a perfect solution, but the chances that this
-				 * occurs in code is, well, remote. Yes I know I'm comparing the 'V'
-				 * twice, as it is simpler to read the code. */
-				if (strcmp(&buf[i], VS_SIGNATURE) == 0) {
-					/* Compute skip alignment to next long address */
-					int skip = -(fsp->conn->vfs_ops.lseek(fsp, fsp->fd, 0, SEEK_CUR) - (byte_count - i) +
-								 sizeof(VS_SIGNATURE)) & 3;
-					if (IVAL(buf,i+sizeof(VS_SIGNATURE)+skip) != 0xfeef04bd) continue;
-
-					*major = IVAL(buf,i+sizeof(VS_SIGNATURE)+skip+VS_MAJOR_OFFSET);
-					*minor = IVAL(buf,i+sizeof(VS_SIGNATURE)+skip+VS_MINOR_OFFSET);
-					DEBUG(6,("get_file_version: NE file [%s] Version = %08x:%08x (%d.%d.%d.%d)\n",
-							  fname, *major, *minor,
-							  (*major>>16)&0xffff, *major&0xffff,
-							  (*minor>>16)&0xffff, *minor&0xffff));
-					SAFE_FREE(buf);
-					return 1;
-				}
-			}
-		}
-
-		/* Version info not found, fall back to origin date/time */
-		ZERODEBUG(0,("get_file_version: NE file [%s] Version info not found\n", fname));
-		SAFE_FREE(buf);
-		return 0;
-
-	} else
-		/* Assume this isn't an error... the file just looks sort of like a PE/NE file */
-		DEBUG(3,("get_file_version: File [%s] unknown file format, signature = 0x%x\n",
-				fname, IVAL(buf,PE_HEADER_SIGNATURE_OFFSET)));
-
-	no_version_info:
-		SAFE_FREE(buf);
-		return 0;
-
-	error_exit:
-		SAFE_FREE(buf);
-		return -1;
-}
-
-/****************************************************************************
-Drivers for Microsoft systems contain multiple files. Often, multiple drivers
-share one or more files. During the MS installation process files are checked
-to insure that only a newer version of a shared file is installed over an
-older version. There are several possibilities for this comparison. If there
-is no previous version, the new one is newer (obviously). If either file is
-missing the version info structure, compare the creation date (on Unix use
-the modification date). Otherwise chose the numerically larger version number.
-****************************************************************************/
-static int file_version_is_newer(connection_struct *conn, fstring new_file,
-								fstring old_file)
-{
-	BOOL   use_version = True;
-	pstring filepath;
-
-	uint32 new_major;
-	uint32 new_minor;
-	time_t new_create_time;
-
-	uint32 old_major;
-	uint32 old_minor;
-	time_t old_create_time;
-
-	int access_mode;
-	int action;
-	files_struct    *fsp = NULL;
-	SMB_STRUCT_STAT st;
-	SMB_STRUCT_STAT stat_buf;
-	BOOL bad_path;
-
-	ZERO_STRUCT(st);
-	ZERO_STRUCT(stat_buf);
-	new_create_time = (time_t)0;
-	old_create_time = (time_t)0;
-
-	/* Get file version info (if available) for previous file (if it exists) */
-	pstrcpy(filepath, old_file);
-
-	unix_convert(filepath,conn,NULL,&bad_path,&stat_buf);
-
-	fsp = open_file_shared(conn, filepath, &stat_buf,
-						   SET_OPEN_MODE(DOS_OPEN_RDONLY),
-						   (FILE_FAIL_IF_NOT_EXIST|FILE_EXISTS_OPEN),
-						   0, 0, &access_mode, &action);
-	if (!fsp) {
-		/* Old file not found, so by definition new file is in fact newer */
-		DEBUG(10,("file_version_is_newer: Can't open old file [%s], errno = %d\n",
-				filepath, errno));
-		return True;
-
-	} else {
-		int ret = get_file_version(fsp, old_file, &old_major, &old_minor);
-		if (ret == -1) goto error_exit;
-
-		if (!ret) {
-			DEBUG(6,("file_version_is_newer: Version info not found [%s], use mod time\n",
-					 old_file));
-			use_version = False;
-		}
-		if (fsp->conn->vfs_ops.fstat(fsp, fsp->fd, &st) == -1) goto error_exit;
-		old_create_time = st.st_mtime;
-		DEBUGADD(6,("file_version_is_newer: mod time = %ld sec\n", old_create_time));
-	}
-	close_file(fsp, True);
-
-	/* Get file version info (if available) for new file */
-	pstrcpy(filepath, new_file);
-	unix_convert(filepath,conn,NULL,&bad_path,&stat_buf);
-
-	fsp = open_file_shared(conn, filepath, &stat_buf,
-						   SET_OPEN_MODE(DOS_OPEN_RDONLY),
-						   (FILE_FAIL_IF_NOT_EXIST|FILE_EXISTS_OPEN),
-						   0, 0, &access_mode, &action);
-	if (!fsp) {
-		/* New file not found, this shouldn't occur if the caller did its job */
-		DEBUG(3,("file_version_is_newer: Can't open new file [%s], errno = %d\n",
-				filepath, errno));
-		goto error_exit;
-
-	} else {
-		int ret = get_file_version(fsp, new_file, &new_major, &new_minor);
-		if (ret == -1) goto error_exit;
-
-		if (!ret) {
-			DEBUG(6,("file_version_is_newer: Version info not found [%s], use mod time\n",
-					 new_file));
-			use_version = False;
-		}
-		if (fsp->conn->vfs_ops.fstat(fsp, fsp->fd, &st) == -1) goto error_exit;
-		new_create_time = st.st_mtime;
-		DEBUGADD(6,("file_version_is_newer: mod time = %ld sec\n", new_create_time));
-	}
-	close_file(fsp, True);
-
-	if (use_version && (new_major != old_major || new_minor != old_minor)) {
-		/* Compare versions and choose the larger version number */
-		if (new_major > old_major ||
-			(new_major == old_major && new_minor > old_minor)) {
-			
-			DEBUG(6,("file_version_is_newer: Replacing [%s] with [%s]\n", old_file, new_file));
-			return True;
-		}
-		else {
-			DEBUG(6,("file_version_is_newer: Leaving [%s] unchanged\n", old_file));
-			return False;
-		}
-
-	} else {
-		/* Compare modification time/dates and choose the newest time/date */
-		if (new_create_time > old_create_time) {
-			DEBUG(6,("file_version_is_newer: Replacing [%s] with [%s]\n", old_file, new_file));
-			return True;
-		}
-		else {
-			DEBUG(6,("file_version_is_newer: Leaving [%s] unchanged\n", old_file));
-			return False;
-		}
-	}
-
-	error_exit:
-		if(fsp)
-			close_file(fsp, True);
-		return -1;
-}
-
-/****************************************************************************
-Determine the correct cVersion associated with an architecture and driver
-****************************************************************************/
-static uint32 get_correct_cversion(fstring architecture, fstring driverpath_in,
-				   struct current_user *user, WERROR *perr)
-{
-	int               cversion;
-	int               access_mode;
-	int               action;
-	pstring           driverpath;
-	fstring           user_name;
-	fstring           null_pw;
-	fstring           dev;
-	fstring           sharename;
-	files_struct      *fsp = NULL;
-	BOOL              bad_path;
-	int	              ecode;
-	SMB_STRUCT_STAT   st;
-	struct passwd *pass;
-	connection_struct *conn;
-
-	ZERO_STRUCT(st);
-
-	*perr = WERR_INVALID_PARAM;
-
-	/* If architecture is Windows 95/98/ME, the version is always 0. */
-	if (strcmp(architecture, "WIN40") == 0) {
-		DEBUG(10,("get_correct_cversion: Driver is Win9x, cversion = 0\n"));
-		*perr = WERR_OK;
-		return 0;
-	}
-
-	become_root();
-	pass = sys_getpwuid(user->uid);
-	if(pass == NULL) {
-		ZERODEBUG(0,("get_correct_cversion: Unable to get passwd entry for uid %u\n",
-				(unsigned int)user->uid ));
-		unbecome_root();
-		*perr = WERR_ACCESS_DENIED;
-		return -1;
-	}
-
-	/*
-	 * Connect to the print$ share under the same account as the user connected
-	 * to the rpc pipe. Note we must still be root to do this.
-	 */
-
-	fstrcpy(user_name, pass->pw_name );
-	DEBUG(10,("get_correct_cversion: uid %d -> user %s\n", (int)user->uid, user_name));
-
-	/* Null password is ok - we are already an authenticated user... */
-	*null_pw = '\0';
-	fstrcpy(dev, "A:");
-	fstrcpy(sharename, "print$");
-	conn = make_connection(sharename, user_name, null_pw, 0, dev, user->vuid, &ecode);
-	unbecome_root();
-
-	if (conn == NULL) {
-		ZERODEBUG(0,("get_correct_cversion: Unable to connect\n"));
-		*perr = W_ERROR(ecode);
-		return -1;
-	}
-
-	/* We are temporarily becoming the connection user. */
-	if (!become_user(conn, conn->vuid)) {
-		ZERODEBUG(0,("get_correct_cversion: Can't become user!\n"));
-		*perr = WERR_ACCESS_DENIED;
-		return -1;
-	}
-
-	/* Open the driver file (Portable Executable format) and determine the
-	 * deriver the cversion. */
-	slprintf(driverpath, sizeof(driverpath)-1, "%s/%s", architecture, driverpath_in);
-
-	unix_convert(driverpath,conn,NULL,&bad_path,&st);
-
-	fsp = open_file_shared(conn, driverpath, &st,
-						   SET_OPEN_MODE(DOS_OPEN_RDONLY),
-						   (FILE_FAIL_IF_NOT_EXIST|FILE_EXISTS_OPEN),
-						   0, 0, &access_mode, &action);
-	if (!fsp) {
-		DEBUG(3,("get_correct_cversion: Can't open file [%s], errno = %d\n",
-				driverpath, errno));
-		*perr = WERR_ACCESS_DENIED;
-		goto error_exit;
-	}
-	else {
-		uint32 major;
-		uint32 minor;
-		int    ret = get_file_version(fsp, driverpath, &major, &minor);
-		if (ret == -1) goto error_exit;
-
-		if (!ret) {
-			DEBUG(6,("get_correct_cversion: Version info not found [%s]\n", driverpath));
-			goto error_exit;
-		}
-
-		/*
-		 * This is a Microsoft'ism. See references in MSDN to VER_FILEVERSION
-		 * for more details. Version in this case is not just the version of the 
-		 * file, but the version in the sense of kernal mode (2) vs. user mode
-		 * (3) drivers. Other bits of the version fields are the version info. 
-		 * JRR 010716
-		*/
-		cversion = major & 0x0000ffff;
-		switch (cversion) {
-			case 2: /* WinNT drivers */
-			case 3: /* Win2K drivers */
-				break;
-			
-			default:
-				DEBUG(6,("get_correct_cversion: cversion invalid [%s]  cversion = %d\n", 
-					driverpath, cversion));
-				goto error_exit;
-		}
-
-		DEBUG(10,("get_correct_cversion: Version info found [%s]  major = 0x%x  minor = 0x%x\n",
-				  driverpath, major, minor));
-	}
-
-    DEBUG(10,("get_correct_cversion: Driver file [%s] cversion = %d\n",
-			driverpath, cversion));
-
-	close_file(fsp, True);
-	close_cnum(conn, user->vuid);
-	unbecome_user();
-	*perr = WERR_OK;
-	return cversion;
-
-
-  error_exit:
-
-	if(fsp)
-		close_file(fsp, True);
-
-	close_cnum(conn, user->vuid);
-	unbecome_user();
-	return -1;
-}
-
-/****************************************************************************
-****************************************************************************/
-static WERROR clean_up_driver_struct_level_3(NT_PRINTER_DRIVER_INFO_LEVEL_3 *driver,
-											 struct current_user *user)
-{
-	fstring architecture;
-	fstring new_name;
-	char *p;
-	int i;
-	WERROR err;
-
-	/* clean up the driver name.
-	 * we can get .\driver.dll
-	 * or worse c:\windows\system\driver.dll !
-	 */
-	/* using an intermediate string to not have overlaping memcpy()'s */
-	if ((p = strrchr(driver->driverpath,'\\')) != NULL) {
-		fstrcpy(new_name, p+1);
-		fstrcpy(driver->driverpath, new_name);
-	}
-
-	if ((p = strrchr(driver->datafile,'\\')) != NULL) {
-		fstrcpy(new_name, p+1);
-		fstrcpy(driver->datafile, new_name);
-	}
-
-	if ((p = strrchr(driver->configfile,'\\')) != NULL) {
-		fstrcpy(new_name, p+1);
-		fstrcpy(driver->configfile, new_name);
-	}
-
-	if ((p = strrchr(driver->helpfile,'\\')) != NULL) {
-		fstrcpy(new_name, p+1);
-		fstrcpy(driver->helpfile, new_name);
-	}
-
-	if (driver->dependentfiles) {
-		for (i=0; *driver->dependentfiles[i]; i++) {
-			if ((p = strrchr(driver->dependentfiles[i],'\\')) != NULL) {
-				fstrcpy(new_name, p+1);
-				fstrcpy(driver->dependentfiles[i], new_name);
-			}
-		}
-	}
-
-	get_short_archi(architecture, driver->environment);
-	
-	/* jfm:7/16/2000 the client always sends the cversion=0.
-	 * The server should check which version the driver is by reading
-	 * the PE header of driver->driverpath.
-	 *
-	 * For Windows 95/98 the version is 0 (so the value sent is correct)
-	 * For Windows NT (the architecture doesn't matter)
-	 *	NT 3.1: cversion=0
-	 *	NT 3.5/3.51: cversion=1
-	 *	NT 4: cversion=2
-	 *	NT2K: cversion=3
-	 */
-	if ((driver->cversion = get_correct_cversion( architecture,
-									driver->driverpath, user, &err)) == -1)
-		return err;
-
-	return WERR_OK;
-}
-	
-/****************************************************************************
-****************************************************************************/
-static WERROR clean_up_driver_struct_level_6(NT_PRINTER_DRIVER_INFO_LEVEL_6 *driver,
-											 struct current_user *user)
-{
-	fstring architecture;
-	fstring new_name;
-	char *p;
-	int i;
-	WERROR err;
-
-	/* clean up the driver name.
-	 * we can get .\driver.dll
-	 * or worse c:\windows\system\driver.dll !
-	 */
-	/* using an intermediate string to not have overlaping memcpy()'s */
-	if ((p = strrchr(driver->driverpath,'\\')) != NULL) {
-		fstrcpy(new_name, p+1);
-		fstrcpy(driver->driverpath, new_name);
-	}
-
-	if ((p = strrchr(driver->datafile,'\\')) != NULL) {
-		fstrcpy(new_name, p+1);
-		fstrcpy(driver->datafile, new_name);
-	}
-
-	if ((p = strrchr(driver->configfile,'\\')) != NULL) {
-		fstrcpy(new_name, p+1);
-		fstrcpy(driver->configfile, new_name);
-	}
-
-	if ((p = strrchr(driver->helpfile,'\\')) != NULL) {
-		fstrcpy(new_name, p+1);
-		fstrcpy(driver->helpfile, new_name);
-	}
-
-	if (driver->dependentfiles) {
-		for (i=0; *driver->dependentfiles[i]; i++) {
-			if ((p = strrchr(driver->dependentfiles[i],'\\')) != NULL) {
-				fstrcpy(new_name, p+1);
-				fstrcpy(driver->dependentfiles[i], new_name);
-			}
-		}
-	}
-
-	get_short_archi(architecture, driver->environment);
-
-	/* jfm:7/16/2000 the client always sends the cversion=0.
-	 * The server should check which version the driver is by reading
-	 * the PE header of driver->driverpath.
-	 *
-	 * For Windows 95/98 the version is 0 (so the value sent is correct)
-	 * For Windows NT (the architecture doesn't matter)
-	 *	NT 3.1: cversion=0
-	 *	NT 3.5/3.51: cversion=1
-	 *	NT 4: cversion=2
-	 *	NT2K: cversion=3
-	 */
-	if ((driver->version = get_correct_cversion(architecture,
-									driver->driverpath, user, &err)) == -1)
-		return err;
-
-	return WERR_OK;
-}
-
-/****************************************************************************
-****************************************************************************/
-WERROR clean_up_driver_struct(NT_PRINTER_DRIVER_INFO_LEVEL driver_abstract,
-							  uint32 level, struct current_user *user)
-{
-	switch (level) {
-		case 3:
-		{
-			NT_PRINTER_DRIVER_INFO_LEVEL_3 *driver;
-			driver=driver_abstract.info_3;
-			return clean_up_driver_struct_level_3(driver, user);
-		}
-		case 6:
-		{
-			NT_PRINTER_DRIVER_INFO_LEVEL_6 *driver;
-			driver=driver_abstract.info_6;
-			return clean_up_driver_struct_level_6(driver, user);
-		}
-		default:
-			return WERR_INVALID_PARAM;
-	}
-}
-
-/****************************************************************************
- This function sucks and should be replaced. JRA.
-****************************************************************************/
-
-static void convert_level_6_to_level3(NT_PRINTER_DRIVER_INFO_LEVEL_3 *dst, NT_PRINTER_DRIVER_INFO_LEVEL_6 *src)
-{
-    dst->cversion  = src->version;
-
-    fstrcpy( dst->name, src->name);
-    fstrcpy( dst->environment, src->environment);
-    fstrcpy( dst->driverpath, src->driverpath);
-    fstrcpy( dst->datafile, src->datafile);
-    fstrcpy( dst->configfile, src->configfile);
-    fstrcpy( dst->helpfile, src->helpfile);
-    fstrcpy( dst->monitorname, src->monitorname);
-    fstrcpy( dst->defaultdatatype, src->defaultdatatype);
-    dst->dependentfiles = src->dependentfiles;
-}
-
-#if 0 /* Debugging function */
-
-static char* ffmt(unsigned char *c){
-	int i;
-	static char ffmt_str[17];
-
-	for (i=0; i<16; i++) {
-		if ((c[i] < ' ') || (c[i] > '~'))
-			ffmt_str[i]='.';
-		else
-			ffmt_str[i]=c[i];
-	}
-    ffmt_str[16]='\0';
-	return ffmt_str;
-}
-
-#endif
-
-/****************************************************************************
-****************************************************************************/
-BOOL move_driver_to_download_area(NT_PRINTER_DRIVER_INFO_LEVEL driver_abstract, uint32 level, 
-				  struct current_user *user, WERROR *perr)
-{
-	NT_PRINTER_DRIVER_INFO_LEVEL_3 *driver;
-	NT_PRINTER_DRIVER_INFO_LEVEL_3 converted_driver;
-	fstring architecture;
-	pstring new_dir;
-	pstring old_name;
-	pstring new_name;
-	fstring user_name;
-	fstring null_pw;
-	fstring dev;
-	fstring sharename;
-	connection_struct *conn;
-	pstring inbuf;
-	pstring outbuf;
-	struct passwd *pass;
-	int ecode;
-	int ver = 0;
-	int i;
-
-	memset(inbuf, '\0', sizeof(inbuf));
-	memset(outbuf, '\0', sizeof(outbuf));
-	*perr = WERR_OK;
-
-	if (level==3)
-		driver=driver_abstract.info_3;
-	else if (level==6) {
-		convert_level_6_to_level3(&converted_driver, driver_abstract.info_6);
-		driver = &converted_driver;
-	} else {
-		ZERODEBUG(0,("move_driver_to_download_area: Unknown info level (%u)\n", (unsigned int)level ));
-		return False;
-	}
-
-	get_short_archi(architecture, driver->environment);
-
-	become_root();
-	pass = sys_getpwuid(user->uid);
-	if(pass == NULL) {
-		ZERODEBUG(0,("move_driver_to_download_area: Unable to get passwd entry for uid %u\n",
-				(unsigned int)user->uid ));
-		unbecome_root();
-		return False;
-	}
-
-	/*
-	 * Connect to the print$ share under the same account as the user connected to the rpc pipe.
-	 * Note we must be root to do this.
-	 */
-
-	fstrcpy(user_name, pass->pw_name );
-	DEBUG(10,("move_driver_to_download_area: uid %d -> user %s\n", (int)user->uid, user_name));
-
-	/* Null password is ok - we are already an authenticated user... */
-	*null_pw = '\0';
-	fstrcpy(dev, "A:");
-	fstrcpy(sharename, "print$");
-	conn = make_connection(sharename, user_name, null_pw, 0, dev, user->vuid, &ecode);
-	unbecome_root();
-
-	if (conn == NULL) {
-		ZERODEBUG(0,("move_driver_to_download_area: Unable to connect\n"));
-		*perr = W_ERROR(ecode);
-		return False;
-	}
-
-	/*
-	 * Save who we are - we are temporarily becoming the connection user.
-	 */
-
-	if (!become_user(conn, conn->vuid)) {
-		ZERODEBUG(0,("move_driver_to_download_area: Can't become user %s\n", user_name ));
-		return False;
-	}
-
-	/*
-	 * make the directories version and version\driver_name
-	 * under the architecture directory.
-	 */
-	DEBUG(5,("Creating first directory\n"));
-	slprintf(new_dir, sizeof(new_dir)-1, "%s/%d", architecture, driver->cversion);
-	mkdir_internal(conn, new_dir);
-
-	/* For each driver file, archi\filexxx.yyy, if there is a duplicate file
-	 * listed for this driver which has already been moved, skip it (note:
-	 * drivers may list the same file name several times. Then check if the
-	 * file already exists in archi\cversion\, if so, check that the version
-	 * info (or time stamps if version info is unavailable) is newer (or the
-	 * date is later). If it is, move it to archi\cversion\filexxx.yyy.
-	 * Otherwise, delete the file.
-	 *
-	 * If a file is not moved to archi\cversion\ because of an error, all the
-	 * rest of the 'unmoved' driver files are removed from archi\. If one or
-	 * more of the driver's files was already moved to archi\cversion\, it
-	 * potentially leaves the driver in a partially updated state. Version
-	 * trauma will most likely occur if an client attempts to use any printer
-	 * bound to the driver. Perhaps a rewrite to make sure the moves can be
-	 * done is appropriate... later JRR
-	 */
-
-	DEBUG(5,("Moving files now !\n"));
-
-	if (driver->driverpath && strlen(driver->driverpath)) {
-		slprintf(new_name, sizeof(new_name)-1, "%s/%s", architecture, driver->driverpath);	
-		slprintf(old_name, sizeof(old_name)-1, "%s/%s", new_dir, driver->driverpath);	
-		if (ver != -1 && (ver=file_version_is_newer(conn, new_name, old_name)) > 0) {
-			NTSTATUS status;
-			status = rename_internals(conn, new_name, old_name, True);
-			if (!NT_STATUS_IS_OK(status)) {
-				ZERODEBUG(0,("move_driver_to_download_area: Unable to rename [%s] to [%s]\n",
-						new_name, old_name));
-				*perr = ntstatus_to_werror(status);
-				unlink_internals(conn, 0, new_name);
-				ver = -1;
-			}
-		}
-		else
-			unlink_internals(conn, 0, new_name);
-	}
-
-	if (driver->datafile && strlen(driver->datafile)) {
-		if (!strequal(driver->datafile, driver->driverpath)) {
-			slprintf(new_name, sizeof(new_name)-1, "%s/%s", architecture, driver->datafile);	
-			slprintf(old_name, sizeof(old_name)-1, "%s/%s", new_dir, driver->datafile);	
-			if (ver != -1 && (ver=file_version_is_newer(conn, new_name, old_name)) > 0) {
-				NTSTATUS status;
-				status = rename_internals(conn, new_name, old_name, True);
-				if (!NT_STATUS_IS_OK(status)) {
-					ZERODEBUG(0,("move_driver_to_download_area: Unable to rename [%s] to [%s]\n",
-							new_name, old_name));
-					*perr = ntstatus_to_werror(status);
-					unlink_internals(conn, 0, new_name);
-					ver = -1;
-				}
-			}
-			else
-				unlink_internals(conn, 0, new_name);
-		}
-	}
-
-	if (driver->configfile && strlen(driver->configfile)) {
-		if (!strequal(driver->configfile, driver->driverpath) &&
-			!strequal(driver->configfile, driver->datafile)) {
-			slprintf(new_name, sizeof(new_name)-1, "%s/%s", architecture, driver->configfile);	
-			slprintf(old_name, sizeof(old_name)-1, "%s/%s", new_dir, driver->configfile);	
-			if (ver != -1 && (ver=file_version_is_newer(conn, new_name, old_name)) > 0) {
-				NTSTATUS status;
-				status = rename_internals(conn, new_name, old_name, True);
-				if (!NT_STATUS_IS_OK(status)) {
-					ZERODEBUG(0,("move_driver_to_download_area: Unable to rename [%s] to [%s]\n",
-							new_name, old_name));
-					*perr = ntstatus_to_werror(status);
-					unlink_internals(conn, 0, new_name);
-					ver = -1;
-				}
-			}
-			else
-				unlink_internals(conn, 0, new_name);
-		}
-	}
-
-	if (driver->helpfile && strlen(driver->helpfile)) {
-		if (!strequal(driver->helpfile, driver->driverpath) &&
-			!strequal(driver->helpfile, driver->datafile) &&
-			!strequal(driver->helpfile, driver->configfile)) {
-			slprintf(new_name, sizeof(new_name)-1, "%s/%s", architecture, driver->helpfile);	
-			slprintf(old_name, sizeof(old_name)-1, "%s/%s", new_dir, driver->helpfile);	
-			if (ver != -1 && (ver=file_version_is_newer(conn, new_name, old_name)) > 0) {
-				NTSTATUS status;
-				status = rename_internals(conn, new_name, old_name, True);
-				if (!NT_STATUS_IS_OK(status)) {
-					ZERODEBUG(0,("move_driver_to_download_area: Unable to rename [%s] to [%s]\n",
-							new_name, old_name));
-					*perr = ntstatus_to_werror(status);
-					unlink_internals(conn, 0, new_name);
-					ver = -1;
-				}
-			}
-			else
-				unlink_internals(conn, 0, new_name);
-		}
-	}
-
-	if (driver->dependentfiles) {
-		for (i=0; *driver->dependentfiles[i]; i++) {
-			if (!strequal(driver->dependentfiles[i], driver->driverpath) &&
-				!strequal(driver->dependentfiles[i], driver->datafile) &&
-				!strequal(driver->dependentfiles[i], driver->configfile) &&
-				!strequal(driver->dependentfiles[i], driver->helpfile)) {
-				int j;
-				for (j=0; j < i; j++) {
-					if (strequal(driver->dependentfiles[i], driver->dependentfiles[j])) {
-						goto NextDriver;
-					}
-				}
-
-				slprintf(new_name, sizeof(new_name)-1, "%s/%s", architecture, driver->dependentfiles[i]);	
-				slprintf(old_name, sizeof(old_name)-1, "%s/%s", new_dir, driver->dependentfiles[i]);	
-				if (ver != -1 && (ver=file_version_is_newer(conn, new_name, old_name)) > 0) {
-					NTSTATUS status;
-					status = rename_internals(conn, new_name, old_name, True);
-					if (!NT_STATUS_IS_OK(status)) {
-						ZERODEBUG(0,("move_driver_to_download_area: Unable to rename [%s] to [%s]\n",
-								new_name, old_name));
-						*perr = ntstatus_to_werror(status);
-						unlink_internals(conn, 0, new_name);
-						ver = -1;
-					}
-				}
-				else
-					unlink_internals(conn, 0, new_name);
-			}
-		NextDriver: ;
-		}
-	}
-
-	close_cnum(conn, user->vuid);
-	unbecome_user();
-
-	return ver == -1 ? False : True;
-}
-
-/****************************************************************************
-****************************************************************************/
-static uint32 add_a_printer_driver_3(NT_PRINTER_DRIVER_INFO_LEVEL_3 *driver)
-{
-	int len, buflen;
-	fstring architecture;
-	pstring directory;
-	pstring temp_name;
-	pstring key;
-	char *buf;
-	int i, ret;
-	TDB_DATA kbuf, dbuf;
-
-	get_short_archi(architecture, driver->environment);
-
-	/* The names are relative. We store them in the form: \print$\arch\version\driver.xxx
-	 * \\server is added in the rpc server layer.
-	 * It does make sense to NOT store the server's name in the printer TDB.
-	 */
-
-	slprintf(directory, sizeof(directory)-1, "\\print$\\%s\\%d\\", architecture, driver->cversion);
-
-	/* .inf files do not always list a file for each of the four standard files. 
-	 * Don't prepend a path to a null filename, or client claims:
-	 *   "The server on which the printer resides does not have a suitable 
-	 *   <printer driver name> printer driver installed. Click OK if you 
-	 *   wish to install the driver on your local machine."
-	 */
-	if (strlen(driver->driverpath)) {
-		fstrcpy(temp_name, driver->driverpath);
-		slprintf(driver->driverpath, sizeof(driver->driverpath)-1, "%s%s", directory, temp_name);
-	}
-
-	if (strlen(driver->datafile)) {
-		fstrcpy(temp_name, driver->datafile);
-		slprintf(driver->datafile, sizeof(driver->datafile)-1, "%s%s", directory, temp_name);
-	}
-
-	if (strlen(driver->configfile)) {
-		fstrcpy(temp_name, driver->configfile);
-		slprintf(driver->configfile, sizeof(driver->configfile)-1, "%s%s", directory, temp_name);
-	}
-
-	if (strlen(driver->helpfile)) {
-		fstrcpy(temp_name, driver->helpfile);
-		slprintf(driver->helpfile, sizeof(driver->helpfile)-1, "%s%s", directory, temp_name);
-	}
-
-	if (driver->dependentfiles) {
-		for (i=0; *driver->dependentfiles[i]; i++) {
-			fstrcpy(temp_name, driver->dependentfiles[i]);
-			slprintf(driver->dependentfiles[i], sizeof(driver->dependentfiles[i])-1, "%s%s", directory, temp_name);
-		}
-	}
-
-	slprintf(key, sizeof(key)-1, "%s%s/%d/%s", DRIVERS_PREFIX, architecture, driver->cversion, driver->name);
-	dos_to_unix(key);                /* Convert key to unix-codepage */
-
-	DEBUG(5,("add_a_printer_driver_3: Adding driver with key %s\n", key ));
-
-	buf = NULL;
-	len = buflen = 0;
-
- again:
-	len = 0;
-	len += tdb_pack(buf+len, buflen-len, "dffffffff",
-			driver->cversion,
-			driver->name,
-			driver->environment,
-			driver->driverpath,
-			driver->datafile,
-			driver->configfile,
-			driver->helpfile,
-			driver->monitorname,
-			driver->defaultdatatype);
-
-	if (driver->dependentfiles) {
-		for (i=0; *driver->dependentfiles[i]; i++) {
-			len += tdb_pack(buf+len, buflen-len, "f",
-					driver->dependentfiles[i]);
-		}
-	}
-
-	if (len != buflen) {
-		char *tb;
-
-		tb = (char *)Realloc(buf, len);
-		if (!tb) {
-			ZERODEBUG(0,("add_a_printer_driver_3: failed to enlarge buffer\n!"));
-			ret = -1;
-			goto done;
-		}
-		else buf = tb;
-		buflen = len;
-		goto again;
-	}
-
-
-	kbuf.dptr = key;
-	kbuf.dsize = strlen(key)+1;
-	dbuf.dptr = buf;
-	dbuf.dsize = len;
-	
-	ret = tdb_store(tdb_drivers, kbuf, dbuf, TDB_REPLACE);
-
-done:
-	if (ret)
-		ZERODEBUG(0,("add_a_printer_driver_3: Adding driver with key %s failed.\n", key ));
-
-	SAFE_FREE(buf);
-	return ret;
-}
-
-/****************************************************************************
-****************************************************************************/
-static uint32 add_a_printer_driver_6(NT_PRINTER_DRIVER_INFO_LEVEL_6 *driver)
-{
-	NT_PRINTER_DRIVER_INFO_LEVEL_3 info3;
-
-	ZERO_STRUCT(info3);
-	info3.cversion = driver->version;
-	fstrcpy(info3.name,driver->name);
-	fstrcpy(info3.environment,driver->environment);
-	fstrcpy(info3.driverpath,driver->driverpath);
-	fstrcpy(info3.datafile,driver->datafile);
-	fstrcpy(info3.configfile,driver->configfile);
-	fstrcpy(info3.helpfile,driver->helpfile);
-	fstrcpy(info3.monitorname,driver->monitorname);
-	fstrcpy(info3.defaultdatatype,driver->defaultdatatype);
-	info3.dependentfiles = driver->dependentfiles;
-
-	return add_a_printer_driver_3(&info3);
-}
-
-
-/****************************************************************************
-****************************************************************************/
-static WERROR get_a_printer_driver_3_default(NT_PRINTER_DRIVER_INFO_LEVEL_3 **info_ptr, const fstring in_prt, const fstring in_arch)
-{
-	NT_PRINTER_DRIVER_INFO_LEVEL_3 info;
-
-	ZERO_STRUCT(info);
-
-	fstrcpy(info.name, in_prt);
-	fstrcpy(info.defaultdatatype, "RAW");
-	
-	fstrcpy(info.driverpath, "");
-	fstrcpy(info.datafile, "");
-	fstrcpy(info.configfile, "");
-	fstrcpy(info.helpfile, "");
-
-	if ((info.dependentfiles=(fstring *)malloc(2*sizeof(fstring))) == NULL)
-		return WERR_NOMEM;
-
-	memset(info.dependentfiles, '\0', 2*sizeof(fstring));
-	fstrcpy(info.dependentfiles[0], "");
-
-	*info_ptr = memdup(&info, sizeof(info));
-	
-	return WERR_OK;
-}
-
-/****************************************************************************
-****************************************************************************/
-static WERROR get_a_printer_driver_3(NT_PRINTER_DRIVER_INFO_LEVEL_3 **info_ptr, const fstring in_prt, const fstring in_arch, uint32 version)
-{
-	NT_PRINTER_DRIVER_INFO_LEVEL_3 driver;
-	TDB_DATA kbuf, dbuf;
-	fstring architecture;
-	int len = 0;
-	int i;
-	pstring key;
-
-	ZERO_STRUCT(driver);
-
-	get_short_archi(architecture, in_arch);
-
-	DEBUG(8,("get_a_printer_driver_3: [%s%s/%d/%s]\n", DRIVERS_PREFIX, architecture, version, in_prt));
-
-	slprintf(key, sizeof(key)-1, "%s%s/%d/%s", DRIVERS_PREFIX, architecture, version, in_prt);
-
-	kbuf.dptr = key;
-	kbuf.dsize = strlen(key)+1;
-	
-	dbuf = tdb_fetch(tdb_drivers, kbuf);
-	if (!dbuf.dptr) 
-		return WERR_UNKNOWN_PRINTER_DRIVER;
-
-	len += tdb_unpack(dbuf.dptr, dbuf.dsize, "dffffffff",
-			  &driver.cversion,
-			  driver.name,
-			  driver.environment,
-			  driver.driverpath,
-			  driver.datafile,
-			  driver.configfile,
-			  driver.helpfile,
-			  driver.monitorname,
-			  driver.defaultdatatype);
-
-	i=0;
-	while (len < dbuf.dsize) {
-		fstring *tddfs;
-
-		tddfs = (fstring *)Realloc(driver.dependentfiles,
-							 sizeof(fstring)*(i+2));
-		if (tddfs == NULL) {
-			ZERODEBUG(0,("get_a_printer_driver_3: failed to enlarge buffer!\n"));
-			break;
-		}
-		else driver.dependentfiles = tddfs;
-
-		len += tdb_unpack(dbuf.dptr+len, dbuf.dsize-len, "f",
-				  &driver.dependentfiles[i]);
-		i++;
-	}
-	if (driver.dependentfiles != NULL)
-		fstrcpy(driver.dependentfiles[i], "");
-
-	SAFE_FREE(dbuf.dptr);
-
-	if (len != dbuf.dsize) {
-			SAFE_FREE(driver.dependentfiles);
-
-		return get_a_printer_driver_3_default(info_ptr, in_prt, in_arch);
-	}
-
-	*info_ptr = (NT_PRINTER_DRIVER_INFO_LEVEL_3 *)memdup(&driver, sizeof(driver));
-
-	return WERR_OK;
-}
-
-/****************************************************************************
-****************************************************************************/
-uint32 get_a_printer_driver_9x_compatible(pstring line, const fstring model)
-{
-	NT_PRINTER_DRIVER_INFO_LEVEL_3 *info3;
-	TDB_DATA kbuf;
-	pstring key;
-	int i;
-	line[0] = '\0';
-
-	slprintf(key, sizeof(key)-1, "%s%s/%d/%s", DRIVERS_PREFIX, "WIN40", 0, model);
-	DEBUG(10,("driver key: [%s]\n", key));
-	
-	kbuf.dptr = key;
-	kbuf.dsize = strlen(key)+1;
-	if (!tdb_exists(tdb_drivers, kbuf))
-		return False;
-
-	ZERO_STRUCT(info3);
-	get_a_printer_driver_3(&info3, model, "Windows 4.0", 0);
-	
-	DEBUGADD(10,("info3->name            [%s]\n", info3->name));
-	DEBUGADD(10,("info3->datafile        [%s]\n", info3->datafile));
-	DEBUGADD(10,("info3->helpfile        [%s]\n", info3->helpfile));
-	DEBUGADD(10,("info3->monitorname     [%s]\n", info3->monitorname));
-	DEBUGADD(10,("info3->defaultdatatype [%s]\n", info3->defaultdatatype));
-	for (i=0; info3->dependentfiles && *info3->dependentfiles[i]; i++) {
-		DEBUGADD(10,("info3->dependentfiles  [%s]\n", info3->dependentfiles[i]));
-	}
-	DEBUGADD(10,("info3->environment     [%s]\n", info3->environment));
-	DEBUGADD(10,("info3->driverpath      [%s]\n", info3->driverpath));
-	DEBUGADD(10,("info3->configfile      [%s]\n", info3->configfile));
-
-	/*pstrcat(line, info3->name);             pstrcat(line, ":");*/
-	trim_string(info3->driverpath, "\\print$\\WIN40\\0\\", 0);
-	pstrcat(line, info3->driverpath);
-	pstrcat(line, ":");
-	trim_string(info3->datafile, "\\print$\\WIN40\\0\\", 0);
-	pstrcat(line, info3->datafile);
-	pstrcat(line, ":");
-	trim_string(info3->helpfile, "\\print$\\WIN40\\0\\", 0);
-	pstrcat(line, info3->helpfile);
-	pstrcat(line, ":");
-	trim_string(info3->monitorname, "\\print$\\WIN40\\0\\", 0);
-	pstrcat(line, info3->monitorname);
-	pstrcat(line, ":");
-	pstrcat(line, "RAW");                /*info3->defaultdatatype);*/
-	pstrcat(line, ":");
-
-	for (i=0; info3->dependentfiles && *info3->dependentfiles[i]; i++) {
-		if (i)
-			pstrcat(line, ",");               /* don't end in a "," */
-		trim_string(info3->dependentfiles[i], "\\print$\\WIN40\\0\\", 0);
-		pstrcat(line, info3->dependentfiles[i]);
-	}
-	
-	SAFE_FREE(info3);
-
-	return True;	
-}
-
-/****************************************************************************
- Debugging function, dump at level 6 the struct in the logs.
-****************************************************************************/
-
-static uint32 dump_a_printer_driver(NT_PRINTER_DRIVER_INFO_LEVEL driver, uint32 level)
-{
-	uint32 result;
-	NT_PRINTER_DRIVER_INFO_LEVEL_3 *info3;
-	int i;
-	
-	DEBUG(106,("Dumping printer driver at level [%d]\n", level));
-	
-	switch (level)
-	{
-		case 3:
-		{
-			if (driver.info_3 == NULL)
-				result=5;
-			else {
-				info3=driver.info_3;
-			
-				DEBUGADD(106,("version:[%d]\n",         info3->cversion));
-				DEBUGADD(106,("name:[%s]\n",            info3->name));
-				DEBUGADD(106,("environment:[%s]\n",     info3->environment));
-				DEBUGADD(106,("driverpath:[%s]\n",      info3->driverpath));
-				DEBUGADD(106,("datafile:[%s]\n",        info3->datafile));
-				DEBUGADD(106,("configfile:[%s]\n",      info3->configfile));
-				DEBUGADD(106,("helpfile:[%s]\n",        info3->helpfile));
-				DEBUGADD(106,("monitorname:[%s]\n",     info3->monitorname));
-				DEBUGADD(106,("defaultdatatype:[%s]\n", info3->defaultdatatype));
-				
-				for (i=0; info3->dependentfiles &&
-					  *info3->dependentfiles[i]; i++) {
-					DEBUGADD(106,("dependentfile:[%s]\n",
-						      info3->dependentfiles[i]));
-				}
-				result=0;
-			}
-			break;
-		}
-		default:
-			DEBUGADD(106,("dump_a_printer_driver: Level %u not implemented\n", (unsigned int)level));
-			result=1;
-			break;
-	}
-	
-	return result;
-}
-
-/****************************************************************************
-****************************************************************************/
-static int pack_devicemode(NT_DEVICEMODE *nt_devmode, char *buf, int buflen)
-{
-	int len = 0;
-
-	len += tdb_pack(buf+len, buflen-len, "p", nt_devmode);
-
-	if (!nt_devmode) return len;
-
-	len += tdb_pack(buf+len, buflen-len, "ffwwwwwwwwwwwwwwwwwwddddddddddddddp",
-			nt_devmode->devicename,
-			nt_devmode->formname,
-
-			nt_devmode->specversion,
-			nt_devmode->driverversion,
-			nt_devmode->size,
-			nt_devmode->driverextra,
-			nt_devmode->orientation,
-			nt_devmode->papersize,
-			nt_devmode->paperlength,
-			nt_devmode->paperwidth,
-			nt_devmode->scale,
-			nt_devmode->copies,
-			nt_devmode->defaultsource,
-			nt_devmode->printquality,
-			nt_devmode->color,
-			nt_devmode->duplex,
-			nt_devmode->yresolution,
-			nt_devmode->ttoption,
-			nt_devmode->collate,
-			nt_devmode->logpixels,
-			
-			nt_devmode->fields,
-			nt_devmode->bitsperpel,
-			nt_devmode->pelswidth,
-			nt_devmode->pelsheight,
-			nt_devmode->displayflags,
-			nt_devmode->displayfrequency,
-			nt_devmode->icmmethod,
-			nt_devmode->icmintent,
-			nt_devmode->mediatype,
-			nt_devmode->dithertype,
-			nt_devmode->reserved1,
-			nt_devmode->reserved2,
-			nt_devmode->panningwidth,
-			nt_devmode->panningheight,
-			nt_devmode->private);
-
-	
-	if (nt_devmode->private) {
-		len += tdb_pack(buf+len, buflen-len, "B",
-				nt_devmode->driverextra,
-				nt_devmode->private);
-	}
-
-	DEBUG(8,("Packed devicemode [%s]\n", nt_devmode->formname));
-
-	return len;
-}
-
-/****************************************************************************
-****************************************************************************/
-static int pack_specifics(NT_PRINTER_PARAM *param, char *buf, int buflen)
-{
-	int len = 0;
-
-	while (param != NULL) {
-		len += tdb_pack(buf+len, buflen-len, "pfdB",
-				param,
-				param->value,
-				param->type,
-				param->data_len,
-				param->data);
-		param=param->next;	
-	}
-
-	len += tdb_pack(buf+len, buflen-len, "p", param);
-
-	return len;
-}
-
-
-/****************************************************************************
- Delete a printer - this just deletes the printer info file, any open
- handles are not affected.
-****************************************************************************/
-
-uint32 del_a_printer(char *sharename)
-{
-	pstring key;
-	TDB_DATA kbuf;
-
-	slprintf(key, sizeof(key)-1, "%s%s", PRINTERS_PREFIX, sharename);
-	dos_to_unix(key);                /* Convert key to unix-codepage */
-
-	kbuf.dptr=key;
-	kbuf.dsize=strlen(key)+1;
-
-	tdb_delete(tdb_printers, kbuf);
-	return 0;
-}
-
-/* FIXME!!!  Reorder so this forward declaration is not necessary --jerry */
-static WERROR get_a_printer_2(NT_PRINTER_INFO_LEVEL_2 **, fstring);
-static void free_nt_printer_info_level_2(NT_PRINTER_INFO_LEVEL_2 **);
-/****************************************************************************
-****************************************************************************/
-static WERROR update_a_printer_2(NT_PRINTER_INFO_LEVEL_2 *info)
-{
-	pstring key;
-	char *buf;
-	int buflen, len;
-	WERROR ret;
-	TDB_DATA kbuf, dbuf;
-	
-	/*
-	 * in addprinter: no servername and the printer is the name
-	 * in setprinter: servername is \\server
-	 *                and printer is \\server\\printer
-	 *
-	 * Samba manages only local printers.
-	 * we currently don't support things like path=\\other_server\printer
-	 */
-
-	if (info->servername[0]!='\0') {
-		trim_string(info->printername, info->servername, NULL);
-		trim_string(info->printername, "\\", NULL);
-		info->servername[0]='\0';
-	}
-
-	/*
-	 * JFM: one day I'll forget.
-	 * below that's info->portname because that's the SAMBA sharename
-	 * and I made NT 'thinks' it's the portname
-	 * the info->sharename is the thing you can name when you add a printer
-	 * that's the short-name when you create shared printer for 95/98
-	 * So I've made a limitation in SAMBA: you can only have 1 printer model
-	 * behind a SAMBA share.
-	 */
-
-	buf = NULL;
-	buflen = 0;
-
- again:	
-	len = 0;
-	len += tdb_pack(buf+len, buflen-len, "dddddddddddfffffPfffff",
-			info->attributes,
-			info->priority,
-			info->default_priority,
-			info->starttime,
-			info->untiltime,
-			info->status,
-			info->cjobs,
-			info->averageppm,
-			info->changeid,
-			info->c_setprinter,
-			info->setuptime,
-			info->servername,
-			info->printername,
-			info->sharename,
-			info->portname,
-			info->drivername,
-			info->comment,
-			info->location,
-			info->sepfile,
-			info->printprocessor,
-			info->datatype,
-			info->parameters);
-
-	len += pack_devicemode(info->devmode, buf+len, buflen-len);
-	
-	len += pack_specifics(info->specific, buf+len, buflen-len);
-
-	if (buflen != len) {
-		char *tb;
-
-		tb = (char *)Realloc(buf, len);
-		if (!tb) {
-			ZERODEBUG(0,("update_a_printer_2: failed to enlarge buffer!\n"));
-			ret = WERR_NOMEM;
-			goto done;
-		}
-		else buf = tb;
-		buflen = len;
-		goto again;
-	}
-	
-
-	slprintf(key, sizeof(key)-1, "%s%s", PRINTERS_PREFIX, info->sharename);
-	dos_to_unix(key);                /* Convert key to unix-codepage */
-
-	kbuf.dptr = key;
-	kbuf.dsize = strlen(key)+1;
-	dbuf.dptr = buf;
-	dbuf.dsize = len;
-
-	ret = (tdb_store(tdb_printers, kbuf, dbuf, TDB_REPLACE) == 0? WERR_OK : WERR_NOMEM);
-
-done:
-	if (!W_ERROR_IS_OK(ret))
-		DEBUG(8, ("error updating printer to tdb on disk\n"));
-
-	SAFE_FREE(buf);
-
-	DEBUG(8,("packed printer [%s] with driver [%s] portname=[%s] len=%d\n",
-		 info->sharename, info->drivername, info->portname, len));
-
-	return ret;
-}
-
-
-/****************************************************************************
-****************************************************************************/
-void add_a_specific_param(NT_PRINTER_INFO_LEVEL_2 *info_2, NT_PRINTER_PARAM **param)
-{
-	NT_PRINTER_PARAM *current;
-	
-	DEBUG(108,("add_a_specific_param\n"));	
-
-	(*param)->next=NULL;
-	
-	if (info_2->specific == NULL)
-	{
-		info_2->specific=*param;
-	}
-	else
-	{
-		current=info_2->specific;		
-		while (current->next != NULL) {
-			current=current->next;
-		}		
-		current->next=*param;
-	}
-
-	*param = NULL;
-}
-
-/****************************************************************************
-****************************************************************************/
-BOOL unlink_specific_param_if_exist(NT_PRINTER_INFO_LEVEL_2 *info_2, NT_PRINTER_PARAM *param)
-{
-	NT_PRINTER_PARAM *current;
-	NT_PRINTER_PARAM *previous;
-	
-	current=info_2->specific;
-	previous=current;
-	
-	if (current==NULL) return (False);
-	
-	if ( !strcmp(current->value, param->value) &&
-	    (strlen(current->value)==strlen(param->value)) ) {
-		DEBUG(109,("deleting first value\n"));
-		info_2->specific=current->next;
-		SAFE_FREE(current->data);
-		SAFE_FREE(current);
-		DEBUG(109,("deleted first value\n"));
-		return (True);
-	}
-
-	current=previous->next;
-		
-	while ( current!=NULL ) {
-		if (!strcmp(current->value, param->value) &&
-		    strlen(current->value)==strlen(param->value) ) {
-			DEBUG(109,("deleting current value\n"));
-			previous->next=current->next;
-			SAFE_FREE(current->data);
-			SAFE_FREE(current);
-			DEBUG(109,("deleted current value\n"));
-			return(True);
-		}
-		
-		previous=previous->next;
-		current=current->next;
-	}
-	return (False);
-}
-
-/****************************************************************************
- Clean up and deallocate a (maybe partially) allocated NT_PRINTER_PARAM.
-****************************************************************************/
-void free_nt_printer_param(NT_PRINTER_PARAM **param_ptr)
-{
-	NT_PRINTER_PARAM *param = *param_ptr;
-
-	if(param == NULL)
-		return;
-
-	DEBUG(106,("free_nt_printer_param: deleting param [%s]\n", param->value));
-
-		SAFE_FREE(param->data);
-	SAFE_FREE(*param_ptr);
-}
-
-/****************************************************************************
- Malloc and return an NT devicemode.
-****************************************************************************/
-
-NT_DEVICEMODE *construct_nt_devicemode(const fstring default_devicename)
-{
-
-	char adevice[MAXDEVICENAME+1];
-	NT_DEVICEMODE *nt_devmode = (NT_DEVICEMODE *)malloc(sizeof(NT_DEVICEMODE));
-
-	if (nt_devmode == NULL) {
-		ZERODEBUG(0,("construct_nt_devicemode: malloc fail.\n"));
-		return NULL;
-	}
-
-	ZERO_STRUCTP(nt_devmode);
-
-	safe_strcpy(adevice, default_devicename, sizeof(adevice)-1);
-	fstrcpy(nt_devmode->devicename, adevice);	
-	
-	fstrcpy(nt_devmode->formname, "Letter");
-
-	nt_devmode->specversion      = 0x0401;
-	nt_devmode->driverversion    = 0x0400;
-	nt_devmode->size             = 0x00DC;
-	nt_devmode->driverextra      = 0x0000;
-	nt_devmode->fields           = FORMNAME | TTOPTION | PRINTQUALITY |
-				       DEFAULTSOURCE | COPIES | SCALE |
-				       PAPERSIZE | ORIENTATION;
-	nt_devmode->orientation      = 1;
-	nt_devmode->papersize        = PAPER_LETTER;
-	nt_devmode->paperlength      = 0;
-	nt_devmode->paperwidth       = 0;
-	nt_devmode->scale            = 0x64;
-	nt_devmode->copies           = 1;
-	nt_devmode->defaultsource    = BIN_FORMSOURCE;
-	nt_devmode->printquality     = RES_HIGH;           /* 0x0258 */
-	nt_devmode->color            = COLOR_MONOCHROME;
-	nt_devmode->duplex           = DUP_SIMPLEX;
-	nt_devmode->yresolution      = 0;
-	nt_devmode->ttoption         = TT_SUBDEV;
-	nt_devmode->collate          = COLLATE_FALSE;
-	nt_devmode->icmmethod        = 0;
-	nt_devmode->icmintent        = 0;
-	nt_devmode->mediatype        = 0;
-	nt_devmode->dithertype       = 0;
-
-	/* non utiliss par un driver d'imprimante */
-	nt_devmode->logpixels        = 0;
-	nt_devmode->bitsperpel       = 0;
-	nt_devmode->pelswidth        = 0;
-	nt_devmode->pelsheight       = 0;
-	nt_devmode->displayflags     = 0;
-	nt_devmode->displayfrequency = 0;
-	nt_devmode->reserved1        = 0;
-	nt_devmode->reserved2        = 0;
-	nt_devmode->panningwidth     = 0;
-	nt_devmode->panningheight    = 0;
-	
-	nt_devmode->private = NULL;
-	return nt_devmode;
-}
-
-/****************************************************************************
- Deepcopy an NT devicemode.
-****************************************************************************/
-
-NT_DEVICEMODE *dup_nt_devicemode(NT_DEVICEMODE *nt_devicemode)
-{
-	NT_DEVICEMODE *new_nt_devicemode = NULL;
-
-	if ((new_nt_devicemode = (NT_DEVICEMODE *)memdup(nt_devicemode, sizeof(NT_DEVICEMODE))) == NULL) {
-		ZERODEBUG(0,("dup_nt_devicemode: malloc fail.\n"));
-		return NULL;
-	}
-
-	new_nt_devicemode->private = NULL;
-	if (nt_devicemode->private != NULL) {
-		if ((new_nt_devicemode->private = memdup(nt_devicemode->private, nt_devicemode->driverextra)) == NULL) {
-			SAFE_FREE(new_nt_devicemode);
-			ZERODEBUG(0,("dup_nt_devicemode: malloc fail.\n"));
-			return NULL;
-        }
-	}
-
-	return new_nt_devicemode;
-}
-
-/****************************************************************************
- Clean up and deallocate a (maybe partially) allocated NT_DEVICEMODE.
-****************************************************************************/
-
-void free_nt_devicemode(NT_DEVICEMODE **devmode_ptr)
-{
-	NT_DEVICEMODE *nt_devmode = *devmode_ptr;
-
-	if(nt_devmode == NULL)
-		return;
-
-	DEBUG(106,("free_nt_devicemode: deleting DEVMODE\n"));
-
-		SAFE_FREE(nt_devmode->private);
-	SAFE_FREE(*devmode_ptr);
-}
-
-/****************************************************************************
- Clean up and deallocate a (maybe partially) allocated NT_PRINTER_INFO_LEVEL_2.
-****************************************************************************/
-static void free_nt_printer_info_level_2(NT_PRINTER_INFO_LEVEL_2 **info_ptr)
-{
-	NT_PRINTER_INFO_LEVEL_2 *info = *info_ptr;
-	NT_PRINTER_PARAM *param_ptr;
-
-	if(info == NULL)
-		return;
-
-	DEBUG(106,("free_nt_printer_info_level_2: deleting info\n"));
-
-	free_nt_devicemode(&info->devmode);
-
-	for(param_ptr = info->specific; param_ptr; ) {
-		NT_PRINTER_PARAM *tofree = param_ptr;
-
-		param_ptr = param_ptr->next;
-		free_nt_printer_param(&tofree);
-	}
-
-	SAFE_FREE(*info_ptr);
-}
-
-
-/****************************************************************************
-****************************************************************************/
-static int unpack_devicemode(NT_DEVICEMODE **nt_devmode, char *buf, int buflen)
-{
-	int len = 0;
-	int extra_len = 0;
-	NT_DEVICEMODE devmode;
-
-	ZERO_STRUCT(devmode);
-
-	len += tdb_unpack(buf+len, buflen-len, "p", nt_devmode);
-
-	if (!*nt_devmode) return len;
-
-	len += tdb_unpack(buf+len, buflen-len, "ffwwwwwwwwwwwwwwwwwwddddddddddddddp",
-			  devmode.devicename,
-			  devmode.formname,
-
-			  &devmode.specversion,
-			  &devmode.driverversion,
-			  &devmode.size,
-			  &devmode.driverextra,
-			  &devmode.orientation,
-			  &devmode.papersize,
-			  &devmode.paperlength,
-			  &devmode.paperwidth,
-			  &devmode.scale,
-			  &devmode.copies,
-			  &devmode.defaultsource,
-			  &devmode.printquality,
-			  &devmode.color,
-			  &devmode.duplex,
-			  &devmode.yresolution,
-			  &devmode.ttoption,
-			  &devmode.collate,
-			  &devmode.logpixels,
-			
-			  &devmode.fields,
-			  &devmode.bitsperpel,
-			  &devmode.pelswidth,
-			  &devmode.pelsheight,
-			  &devmode.displayflags,
-			  &devmode.displayfrequency,
-			  &devmode.icmmethod,
-			  &devmode.icmintent,
-			  &devmode.mediatype,
-			  &devmode.dithertype,
-			  &devmode.reserved1,
-			  &devmode.reserved2,
-			  &devmode.panningwidth,
-			  &devmode.panningheight,
-			  &devmode.private);
-	
-	if (devmode.private) {
-		/* the len in tdb_unpack is an int value and
-		 * devmode.driverextra is only a short
-		 */
-		len += tdb_unpack(buf+len, buflen-len, "B", &extra_len, &devmode.private);
-		devmode.driverextra=(uint16)extra_len;
-		
-		/* check to catch an invalid TDB entry so we don't segfault */
-		if (devmode.driverextra == 0) {
-			devmode.private = NULL;
-		}
-	}
-
-	*nt_devmode = (NT_DEVICEMODE *)memdup(&devmode, sizeof(devmode));
-
-	DEBUG(8,("Unpacked devicemode [%s](%s)\n", devmode.devicename, devmode.formname));
-	if (devmode.private)
-		DEBUG(8,("with a private section of %d bytes\n", devmode.driverextra));
-
-	return len;
-}
-
-/****************************************************************************
-****************************************************************************/
-static int unpack_specifics(NT_PRINTER_PARAM **list, char *buf, int buflen)
-{
-	int len = 0;
-	NT_PRINTER_PARAM param, *p;
-
-	*list = NULL;
-
-	while (1) {
-		len += tdb_unpack(buf+len, buflen-len, "p", &p);
-		if (!p) break;
-
-		len += tdb_unpack(buf+len, buflen-len, "fdB",
-				  param.value,
-				  &param.type,
-				  &param.data_len,
-				  &param.data);
-		param.next = *list;
-		*list = memdup(&param, sizeof(param));
-
-		DEBUG(8,("specific: [%s], len: %d\n", param.value, param.data_len));
-	}
-
-	return len;
-}
-
-static void map_to_os2_driver(fstring drivername)
-{
-	static BOOL initialised=False;
-	static fstring last_from,last_to;
-	char *mapfile = lp_os2_driver_map();
-	char **lines = NULL;
-	int numlines = 0;
-	int i;
-
-	if (!strlen(drivername))
-		return;
-
-	if (!*mapfile)
-		return;
-
-	if (!initialised) {
-		*last_from = *last_to = 0;
-		initialised = True;
-	}
-
-	if (strequal(drivername,last_from)) {
-		DEBUG(3,("Mapped Windows driver %s to OS/2 driver %s\n",drivername,last_to));
-		fstrcpy(drivername,last_to);
-		return;
-	}
-
-	lines = file_lines_load(mapfile, &numlines, True);
-	if (numlines == 0) {
-		ZERODEBUG(0,("No entries in OS/2 driver map %s\n",mapfile));
-		return;
-	}
-
-	DEBUG(4,("Scanning OS/2 driver map %s\n",mapfile));
-
-	for( i = 0; i < numlines; i++) {
-		char *nt_name = lines[i];
-		char *os2_name = strchr(nt_name,'=');
-
-		if (!os2_name)
-			continue;
-
-		*os2_name++ = 0;
-
-		while (isspace(*nt_name))
-			nt_name++;
-
-		if (!*nt_name || strchr("#;",*nt_name))
-			continue;
-
-		{
-			int l = strlen(nt_name);
-			while (l && isspace(nt_name[l-1])) {
-				nt_name[l-1] = 0;
-				l--;
-			}
-		}
-
-		while (isspace(*os2_name))
-			os2_name++;
-
-		{
-			int l = strlen(os2_name);
-			while (l && isspace(os2_name[l-1])) {
-				os2_name[l-1] = 0;
-				l--;
-			}
-		}
-
-		if (strequal(nt_name,drivername)) {
-			DEBUG(3,("Mapped windows driver %s to os2 driver%s\n",drivername,os2_name));
-			fstrcpy(last_from,drivername);
-			fstrcpy(last_to,os2_name);
-			fstrcpy(drivername,os2_name);
-			file_lines_free(lines);
-			return;
-		}
-	}
-
-	file_lines_free(lines);
-}
-
-/****************************************************************************
-get a default printer info 2 struct
-****************************************************************************/
-static WERROR get_a_printer_2_default(NT_PRINTER_INFO_LEVEL_2 **info_ptr, fstring sharename)
-{
-	int snum;
-	NT_PRINTER_INFO_LEVEL_2 info;
-
-	ZERO_STRUCT(info);
-
-	snum = lp_servicenumber(sharename);
-
-	slprintf(info.servername, sizeof(info.servername)-1, "\\\\%s", get_called_name());
-	slprintf(info.printername, sizeof(info.printername)-1, "\\\\%s\\%s", 
-		 get_called_name(), sharename);
-	fstrcpy(info.sharename, sharename);
-	fstrcpy(info.portname, SAMBA_PRINTER_PORT_NAME);
-	fstrcpy(info.drivername, lp_printerdriver(snum));
-
-	/* by setting the driver name to an empty string, a local NT admin
-	   can now run the **local** APW to install a local printer driver
- 	   for a Samba shared printer in 2.2.  Without this, drivers **must** be 
-	   installed on the Samba server for NT clients --jerry */
-#if 0	/* JERRY --do not uncomment-- */
-	if (!*info.drivername)
-		fstrcpy(info.drivername, "NO DRIVER AVAILABLE FOR THIS PRINTER");
-#endif
-
-
-	DEBUG(10,("get_a_printer_2_default: driver name set to [%s]\n", info.drivername));
-
-	pstrcpy(info.comment, "");
-	fstrcpy(info.printprocessor, "winprint");
-	fstrcpy(info.datatype, "RAW");
-
-	info.attributes = PRINTER_ATTRIBUTE_SHARED | PRINTER_ATTRIBUTE_NETWORK;      /* attributes */
-
-	info.starttime = 0; /* Minutes since 12:00am GMT */
-	info.untiltime = 0; /* Minutes since 12:00am GMT */
-	info.priority = 1;
-	info.default_priority = 1;
-	info.setuptime = (uint32)time(NULL);
-
-	/*
-	 * I changed this as I think it is better to have a generic
-	 * DEVMODE than to crash Win2k explorer.exe   --jerry
-	 * See the HP Deskjet 990c Win2k drivers for an example.
-	 *
-	 * However the default devmode appears to cause problems
-	 * with the HP CLJ 8500 PCL driver.  Hence the addition of
-	 * the "default devmode" parameter   --jerry 22/01/2002
-	 */
-
-	if (lp_default_devmode(snum)) {
-		if ((info.devmode = construct_nt_devicemode(info.printername)) == NULL)
-			goto fail;
-	}
-	else {
-		info.devmode = NULL;
-	}
-
-	/* This will get the current RPC talloc context, but we should be
-	   passing this as a parameter... fixme... JRA ! */
-
-	if (!nt_printing_getsec(get_talloc_ctx(), sharename, &info.secdesc_buf))
-		goto fail;
-
-	*info_ptr = (NT_PRINTER_INFO_LEVEL_2 *)memdup(&info, sizeof(info));
-	if (! *info_ptr) {
-		ZERODEBUG(0,("get_a_printer_2_default: malloc fail.\n"));
-		goto fail;
-	}
-
-	return WERR_OK;
-
-  fail:
-	if (info.devmode)
-		free_nt_devicemode(&info.devmode);
-	return WERR_ACCESS_DENIED;
-}
-
-/****************************************************************************
-****************************************************************************/
-static WERROR get_a_printer_2(NT_PRINTER_INFO_LEVEL_2 **info_ptr, fstring sharename)
-{
-	pstring key;
-	NT_PRINTER_INFO_LEVEL_2 info;
-	int 		len = 0;
-	TDB_DATA kbuf, dbuf;
-	fstring printername;
-		
-	ZERO_STRUCT(info);
-
-	slprintf(key, sizeof(key)-1, "%s%s", PRINTERS_PREFIX, sharename);
-	dos_to_unix(key);                /* Convert key to unix-codepage */
-
-	kbuf.dptr = key;
-	kbuf.dsize = strlen(key)+1;
-
-	dbuf = tdb_fetch(tdb_printers, kbuf);
-	if (!dbuf.dptr)
-		return get_a_printer_2_default(info_ptr, sharename);
-
-	len += tdb_unpack(dbuf.dptr+len, dbuf.dsize-len, "dddddddddddfffffPfffff",
-			&info.attributes,
-			&info.priority,
-			&info.default_priority,
-			&info.starttime,
-			&info.untiltime,
-			&info.status,
-			&info.cjobs,
-			&info.averageppm,
-			&info.changeid,
-			&info.c_setprinter,
-			&info.setuptime,
-			info.servername,
-			info.printername,
-			info.sharename,
-			info.portname,
-			info.drivername,
-			info.comment,
-			info.location,
-			info.sepfile,
-			info.printprocessor,
-			info.datatype,
-			info.parameters);
-
-	/* Samba has to have shared raw drivers. */
-	info.attributes |= (PRINTER_ATTRIBUTE_SHARED | PRINTER_ATTRIBUTE_NETWORK); 
-
-	/* Restore the stripped strings. */
-	slprintf(info.servername, sizeof(info.servername)-1, "\\\\%s", get_called_name());
-	slprintf(printername, sizeof(printername)-1, "\\\\%s\\%s", get_called_name(),
-			info.printername);
-	fstrcpy(info.printername, printername);
-	
-	len += unpack_devicemode(&info.devmode,dbuf.dptr+len, dbuf.dsize-len);
-
-	/*
-	 * Some client drivers freak out if there is a NULL devmode
-	 * (probably the driver is not checking before accessing 
-	 * the devmode pointer)   --jerry
-	 *
-	 * See comments in get_a_printer_2_default()
-	 */
-
-	if (lp_default_devmode(lp_servicenumber(sharename)) && !info.devmode)
-	{
-		DEBUG(8,("get_a_printer_2: Constructing a default device mode for [%s]\n",
-			printername));
-		info.devmode = construct_nt_devicemode(printername);
-	}
-
-	len += unpack_specifics(&info.specific,dbuf.dptr+len, dbuf.dsize-len);
-
-	/* This will get the current RPC talloc context, but we should be
-       passing this as a parameter... fixme... JRA ! */
-
-	nt_printing_getsec(get_talloc_ctx(), sharename, &info.secdesc_buf);
-
-	/* Fix for OS/2 drivers. */
-
-	if (get_remote_arch() == RA_OS2)
-		map_to_os2_driver(info.drivername);
-
-	SAFE_FREE(dbuf.dptr);
-	*info_ptr=memdup(&info, sizeof(info));
-
-	DEBUG(9,("Unpacked printer [%s] name [%s] running driver [%s]\n",
-		 sharename, info.printername, info.drivername));
-
-	return WERR_OK;	
-}
-
-/****************************************************************************
-debugging function, dump at level 6 the struct in the logs
-****************************************************************************/
-static uint32 dump_a_printer(NT_PRINTER_INFO_LEVEL printer, uint32 level)
-{
-	uint32 result;
-	NT_PRINTER_INFO_LEVEL_2	*info2;
-	
-	DEBUG(106,("Dumping printer at level [%d]\n", level));
-	
-	switch (level)
-	{
-		case 2:
-		{
-			if (printer.info_2 == NULL)
-				result=5;
-			else
-			{
-				info2=printer.info_2;
-			
-				DEBUGADD(106,("attributes:[%d]\n", info2->attributes));
-				DEBUGADD(106,("priority:[%d]\n", info2->priority));
-				DEBUGADD(106,("default_priority:[%d]\n", info2->default_priority));
-				DEBUGADD(106,("starttime:[%d]\n", info2->starttime));
-				DEBUGADD(106,("untiltime:[%d]\n", info2->untiltime));
-				DEBUGADD(106,("status:[%d]\n", info2->status));
-				DEBUGADD(106,("cjobs:[%d]\n", info2->cjobs));
-				DEBUGADD(106,("averageppm:[%d]\n", info2->averageppm));
-				DEBUGADD(106,("changeid:[%d]\n", info2->changeid));
-				DEBUGADD(106,("c_setprinter:[%d]\n", info2->c_setprinter));
-				DEBUGADD(106,("setuptime:[%d]\n", info2->setuptime));
-
-				DEBUGADD(106,("servername:[%s]\n", info2->servername));
-				DEBUGADD(106,("printername:[%s]\n", info2->printername));
-				DEBUGADD(106,("sharename:[%s]\n", info2->sharename));
-				DEBUGADD(106,("portname:[%s]\n", info2->portname));
-				DEBUGADD(106,("drivername:[%s]\n", info2->drivername));
-				DEBUGADD(106,("comment:[%s]\n", info2->comment));
-				DEBUGADD(106,("location:[%s]\n", info2->location));
-				DEBUGADD(106,("sepfile:[%s]\n", info2->sepfile));
-				DEBUGADD(106,("printprocessor:[%s]\n", info2->printprocessor));
-				DEBUGADD(106,("datatype:[%s]\n", info2->datatype));
-				DEBUGADD(106,("parameters:[%s]\n", info2->parameters));
-				result=0;
-			}
-			break;
-		}
-		default:
-			DEBUGADD(106,("dump_a_printer: Level %u not implemented\n", (unsigned int)level ));
-			result=1;
-			break;
-	}
-	
-	return result;
-}
-
-/****************************************************************************
- Get the parameters we can substitute in an NT print job.
-****************************************************************************/
-
-void get_printer_subst_params(int snum, fstring *printername, fstring *sharename, fstring *portname)
-{
-	NT_PRINTER_INFO_LEVEL *printer = NULL;
-
-	**printername = **sharename = **portname = '\0';
-
-	if (!W_ERROR_IS_OK(get_a_printer(&printer, 2, lp_servicename(snum))))
-		return;
-
-	fstrcpy(*printername, printer->info_2->printername);
-	fstrcpy(*sharename, printer->info_2->sharename);
-	fstrcpy(*portname, printer->info_2->portname);
-
-	free_a_printer(&printer, 2);
-}
-
-/****************************************************************************
- Update the changeid time.
- This is SO NASTY as some drivers need this to change, others need it
- static. This value will change every second, and I must hope that this
- is enough..... DON'T CHANGE THIS CODE WITHOUT A TEST MATRIX THE SIZE OF
- UTAH ! JRA.
-****************************************************************************/
-
-static uint32 rev_changeid(void)
-{
-	struct timeval tv;
-
-	get_process_uptime(&tv);
-
-#if 1	/* JERRY */
-	/* Return changeid as msec since spooler restart */
-	return tv.tv_sec * 1000 + tv.tv_usec / 1000;
-#else
-	/*
-	 * This setting seems to work well but is too untested
-	 * to replace the above calculation.  Left in for experiementation
-	 * of the reader            --jerry (Tue Mar 12 09:15:05 CST 2002)
-	 */
-	return tv.tv_sec * 10 + tv.tv_usec / 100000;
-#endif
-}
-
-/*
- * The function below are the high level ones.
- * only those ones must be called from the spoolss code.
- * JFM.
- */
-
-/****************************************************************************
- Modify a printer. This is called from SETPRINTERDATA/DELETEPRINTERDATA.
-****************************************************************************/
-
-WERROR mod_a_printer(NT_PRINTER_INFO_LEVEL printer, uint32 level)
-{
-	WERROR result;
-	
-	dump_a_printer(printer, level);	
-	
-	switch (level)
-	{
-		case 2:
-		{
-			/*
-			 * Update the changestamp.  Emperical tests show that the
-			 * ChangeID is always updated,but c_setprinter is  
-			 *  global spooler variable (not per printer).
-			 */
-
-			/* ChangeID **must** be increasing over the lifetime
-			   of client's spoolss service in order for the
-			   client's cache to show updates */
-
-			printer.info_2->changeid = rev_changeid();
-
-			/*
-			 * Because one day someone will ask:
-			 * NT->NT	An admin connection to a remote
-			 * 		printer show changes imeediately in
-			 * 		the properities dialog
-			 * 	
-			 * 		A non-admin connection will only show the
-			 * 		changes after viewing the properites page
-			 * 		2 times.  Seems to be related to a
-			 * 		race condition in the client between the spooler
-			 * 		updating the local cache and the Explorer.exe GUI
-			 *		actually displaying the properties.
-			 *
-			 *		This is fixed in Win2k.  admin/non-admin
-			 * 		connections both display changes immediately.
-			 *
-			 * 14/12/01	--jerry
-			 */
-
-			result=update_a_printer_2(printer.info_2);
-			break;
-		}
-		default:
-			result=WERR_UNKNOWN_LEVEL;
-			break;
-	}
-	
-	return result;
-}
-
-/****************************************************************************
- Initialize printer devmode & data with previously saved driver init values.
-****************************************************************************/
-
-static BOOL set_driver_init_2(NT_PRINTER_INFO_LEVEL_2 *info_ptr)
-{
-	int                     len = 0;
-	pstring                 key;
-	TDB_DATA                kbuf, dbuf;
-	NT_PRINTER_PARAM        *current;
-	NT_PRINTER_INFO_LEVEL_2 info;
-
-	/*
-	 * Delete any printer data 'specifics' already set. When called for driver
-	 * replace, there will generally be some, but during an add printer, there
-	 * should not be any (if there are delete them).
-	 */
-	while ( (current=info_ptr->specific) != NULL ) {
-		info_ptr->specific=current->next;
-		SAFE_FREE(current->data);
-		SAFE_FREE(current);
-	}
-
-	ZERO_STRUCT(info);
-
-	slprintf(key, sizeof(key)-1, "%s%s", DRIVER_INIT_PREFIX, info_ptr->drivername);
-	dos_to_unix(key);                /* Convert key to unix-codepage */
-
-	kbuf.dptr = key;
-	kbuf.dsize = strlen(key)+1;
-
-	dbuf = tdb_fetch(tdb_drivers, kbuf);
-	if (!dbuf.dptr) {
-		/*
-		 * When changing to a driver that has no init info in the tdb, remove
-		 * the previous drivers init info and leave the new on blank.
-		 */
-		free_nt_devicemode(&info_ptr->devmode);
-		return False;
-	}
-
-	/*
-	 * Get the saved DEVMODE..
-	 */
-	len += unpack_devicemode(&info.devmode,dbuf.dptr+len, dbuf.dsize-len);
-
-	/*
-	 * The saved DEVMODE contains the devicename from the printer used during
-	 * the initialization save. Change it to reflect the new printer.
-	 */
-	ZERO_STRUCT(info.devmode->devicename);
-	fstrcpy(info.devmode->devicename, info_ptr->printername);
-
-
-	/*
-	 * NT/2k does not change out the entire DeviceMode of a printer
-	 * when changing the driver.  Only the driverextra, private, & 
-	 * driverversion fields.   --jerry  (Thu Mar 14 08:58:43 CST 2002)
-	 *
-	 * Later e4xamination revealed that Windows NT/2k does reset the
-	 * the printer's device mode, bit **only** when you change a 
-	 * property of the device mode such as the page orientation.
-	 * --jerry
-	 */
-
-#if 1	/* JERRY */
-
-	/* 
-	 * 	Bind the saved DEVMODE to the new the printer.
-	 */
-	free_nt_devicemode(&info_ptr->devmode);
-	info_ptr->devmode = info.devmode;
-#else
-	/* copy the entire devmode if we currently don't have one */
-
-	if (!info_ptr->devmode) {
-		DEBUG(10,("set_driver_init_2: Current Devmode is NULL.  Copying entire Device Mode\n"));
-		info_ptr->devmode = info.devmode;
-	}
-	else {
-		/* only set the necessary fields */
-
-		DEBUG(10,("set_driver_init_2: Setting driverversion [0x%x] and private data [0x%x]\n",
-			info.devmode->driverversion, info.devmode->driverextra));
-
-		info_ptr->devmode->driverversion = info.devmode->driverversion;
-
-		SAFE_FREE(info_ptr->devmode->private);
-		info_ptr->devmode->private = NULL;
-
-		if (info.devmode->driverversion)
-			info_ptr->devmode->private = memdup(info.devmode->private, info.devmode->driverversion);
-
-		free_nt_devicemode(&info.devmode);
-	}
-#endif
-
-	DEBUG(10,("set_driver_init_2: Set printer [%s] init DEVMODE for driver [%s]\n",
-			info_ptr->printername, info_ptr->drivername));
-
-	/* 
-	 * Add the printer data 'specifics' to the new printer
-	 */
-	len += unpack_specifics(&info_ptr->specific,dbuf.dptr+len, dbuf.dsize-len);
-
-	SAFE_FREE(dbuf.dptr);
-
-	return True;	
-}
-
-/****************************************************************************
- Initialize printer devmode & data with previously saved driver init values.
- When a printer is created using AddPrinter, the drivername bound to the
- printer is used to lookup previously saved driver initialization info, which
- is bound to the new printer.
-****************************************************************************/
-
-BOOL set_driver_init(NT_PRINTER_INFO_LEVEL *printer, uint32 level)
-{
-	BOOL result = False;
-	
-	switch (level) 
-	{
-		case 2:
-			result = set_driver_init_2(printer->info_2);
-			break;
-			
-		default:
-			ZERODEBUG(0,("set_driver_init: Programmer's error!  Unknown driver_init level [%d]\n",
-				level));
-			break;
-	}
-	
-	return result;
-}
-
-/****************************************************************************
- Delete driver init data stored for a specified driver
-****************************************************************************/
-
-BOOL del_driver_init(char *drivername)
-{
-	pstring key;
-	TDB_DATA kbuf;
-
-	if (!drivername || !*drivername) {
-		DEBUG(3,("del_driver_init: No drivername specified!\n"));
-		return False;
-	}
-
-	slprintf(key, sizeof(key)-1, "%s%s", DRIVER_INIT_PREFIX, drivername);
-	dos_to_unix(key);                /* Convert key to unix-codepage */
-
-	kbuf.dptr = key;
-	kbuf.dsize = strlen(key)+1;
-
-	DEBUG(6,("del_driver_init: Removing driver init data for [%s]\n", drivername));
-
-	return (tdb_delete(tdb_drivers, kbuf) == 0);
-}
-
-/****************************************************************************
- Pack up the DEVMODE and specifics for a printer into a 'driver init' entry 
- in the tdb. Note: this is different from the driver entry and the printer
- entry. There should be a single driver init entry for each driver regardless
- of whether it was installed from NT or 2K. Technically, they should be
- different, but they work out to the same struct.
-****************************************************************************/
-
-static uint32 update_driver_init_2(NT_PRINTER_INFO_LEVEL_2 *info)
-{
-	pstring key;
-	char *buf;
-	int buflen, len, ret;
-	TDB_DATA kbuf, dbuf;
-
-	buf = NULL;
-	buflen = 0;
-
- again:	
-	len = 0;
-	len += pack_devicemode(info->devmode, buf+len, buflen-len);
-
-	len += pack_specifics(info->specific, buf+len, buflen-len);
-
-	if (buflen != len) {
-		char *tb;
-
-		tb = (char *)Realloc(buf, len);
-		if (!tb) {
-			ZERODEBUG(0, ("update_driver_init_2: failed to enlarge buffer!\n"));
-			ret = -1;
-			goto done;
-		}
-		else buf = tb;
-		buflen = len;
-		goto again;
-	}
-
-	slprintf(key, sizeof(key)-1, "%s%s", DRIVER_INIT_PREFIX, info->drivername);
-	dos_to_unix(key);                /* Convert key to unix-codepage */
-
-	kbuf.dptr = key;
-	kbuf.dsize = strlen(key)+1;
-	dbuf.dptr = buf;
-	dbuf.dsize = len;
-
-	ret = tdb_store(tdb_drivers, kbuf, dbuf, TDB_REPLACE);
-
-done:
-	if (ret == -1)
-		DEBUG(8, ("update_driver_init_2: error updating printer init to tdb on disk\n"));
-
-	SAFE_FREE(buf);
-
-	DEBUG(10,("update_driver_init_2: Saved printer [%s] init DEVMODE & specifics for driver [%s]\n",
-		 info->sharename, info->drivername));
-
-	return ret;
-}
-
-/****************************************************************************
- Update (i.e. save) the driver init info (DEVMODE and specifics) for a printer
-****************************************************************************/
-
-uint32 update_driver_init(NT_PRINTER_INFO_LEVEL printer, uint32 level)
-{
-	uint32 result;
-	
-	dump_a_printer(printer, level);	
-	
-	switch (level)
-	{
-		case 2:
-		{
-			result=update_driver_init_2(printer.info_2);
-			break;
-		}
-		default:
-			result=1;
-			break;
-	}
-	
-	return result;
-}
-
-/****************************************************************************
- Convert the printer data value, a REG_BINARY array, into an initialization 
- DEVMODE. Note: the array must be parsed as if it was a DEVMODE in an rpc...
- got to keep the endians happy :).
-****************************************************************************/
-
-static BOOL convert_driver_init(NT_PRINTER_PARAM *param, TALLOC_CTX *ctx, NT_DEVICEMODE *nt_devmode)
-{
-	BOOL       result = False;
-	prs_struct ps;
-	DEVICEMODE devmode;
-
-	ZERO_STRUCT(devmode);
-
-	prs_init(&ps, 0, ctx, UNMARSHALL);
-	ps.data_p      = (char *)param->data;
-	ps.buffer_size = param->data_len;
-
-	if (spoolss_io_devmode("phantom DEVMODE", &ps, 0, &devmode))
-		result = convert_devicemode("", &devmode, &nt_devmode);
-	else
-		DEBUG(10,("convert_driver_init: error parsing DEVMODE\n"));
-
-	return result;
-}
-
-/****************************************************************************
- Set the DRIVER_INIT info in the tdb. Requires Win32 client code that:
-
- 1. Use the driver's config DLL to this UNC printername and:
-    a. Call DrvPrintEvent with PRINTER_EVENT_INITIALIZE
-    b. Call DrvConvertDevMode with CDM_DRIVER_DEFAULT to get default DEVMODE
- 2. Call SetPrinterData with the 'magic' key and the DEVMODE as data.
-
- The last step triggers saving the "driver initialization" information for
- this printer into the tdb. Later, new printers that use this driver will
- have this initialization information bound to them. This simulates the
- driver initialization, as if it had run on the Samba server (as it would
- have done on NT).
-
- The Win32 client side code requirement sucks! But until we can run arbitrary
- Win32 printer driver code on any Unix that Samba runs on, we are stuck with it.
- 
- It would have been easier to use SetPrinter because all the UNMARSHALLING of
- the DEVMODE is done there, but 2K/XP clients do not set the DEVMODE... think
- about it and you will realize why.  JRR 010720
-****************************************************************************/
-
-static WERROR save_driver_init_2(NT_PRINTER_INFO_LEVEL *printer, NT_PRINTER_PARAM *param)
-{
-	WERROR        status       = WERR_OK;
-	TALLOC_CTX    *ctx         = NULL;
-	NT_DEVICEMODE *nt_devmode  = NULL;
-	NT_DEVICEMODE *tmp_devmode = printer->info_2->devmode;
-	
-	/*
-	 * When the DEVMODE is already set on the printer, don't try to unpack it.
-	 */
-
-	if (!printer->info_2->devmode && param->data_len) {
-		/*
-		 * Set devmode on printer info, so entire printer initialization can be
-		 * saved to tdb.
-		 */
-
-		if ((ctx = talloc_init()) == NULL)
-			return WERR_NOMEM;
-
-		if ((nt_devmode = (NT_DEVICEMODE*)malloc(sizeof(NT_DEVICEMODE))) == NULL) {
-			status = WERR_NOMEM;
-			goto done;
-		}
-		
-		ZERO_STRUCTP(nt_devmode);
-
-		/*
-		 * The DEVMODE is held in the 'data' component of the param in raw binary.
-		 * Convert it to to a devmode structure
-		 */
-		if (!convert_driver_init(param, ctx, nt_devmode)) {
-			DEBUG(10,("save_driver_init_2: error converting DEVMODE\n"));
-			status = WERR_INVALID_PARAM;
-			goto done;
-		}
-
-		printer->info_2->devmode = nt_devmode;
-	}
-
-	/*
-	 * Pack up and add (or update) the DEVMODE and any current printer data to
-	 * a 'driver init' element in the tdb
-	 * 
-	 */
-
-	if (update_driver_init(*printer, 2)!=0) {
-		DEBUG(10,("save_driver_init_2: error updating DEVMODE\n"));
-		status = WERR_NOMEM;
-		goto done;
-	}
-	
-	/*
-	 * If driver initialization info was successfully saved, set the current 
-	 * printer to match it. This allows initialization of the current printer 
-	 * as well as the driver.
-	 */
-	status = mod_a_printer(*printer, 2);
-	if (!W_ERROR_IS_OK(status)) {
-		DEBUG(10,("save_driver_init_2: error setting DEVMODE on printer [%s]\n",
-				  printer->info_2->printername));
-	}
-	
-#if 0	/* JERRY */
-	srv_spoolss_sendnotify(p, handle);
-#endif
-
-  done:
-	talloc_destroy(ctx);
-	if (nt_devmode)
-		SAFE_FREE(nt_devmode->private);
-	SAFE_FREE(nt_devmode);
-	printer->info_2->devmode = tmp_devmode;
-
-	return status;
-}
-
-/****************************************************************************
- Update the driver init info (DEVMODE and specifics) for a printer
-****************************************************************************/
-
-WERROR save_driver_init(NT_PRINTER_INFO_LEVEL *printer, uint32 level, NT_PRINTER_PARAM *param)
-{
-	WERROR status = WERR_OK;
-	
-	switch (level)
-	{
-		case 2:
-		{
-			status=save_driver_init_2(printer, param);
-			break;
-		}
-		default:
-			status=WERR_UNKNOWN_LEVEL;
-			break;
-	}
-	
-	return status;
-}
-
-/****************************************************************************
- Get a NT_PRINTER_INFO_LEVEL struct. It returns malloced memory.
-****************************************************************************/
-
-WERROR get_a_printer(NT_PRINTER_INFO_LEVEL **pp_printer, uint32 level, fstring sharename)
-{
-	WERROR result;
-	NT_PRINTER_INFO_LEVEL *printer = NULL;
-	
-	*pp_printer = NULL;
-
-	DEBUG(10,("get_a_printer: [%s] level %u\n", sharename, (unsigned int)level));
-
-	switch (level)
-	{
-		case 2:
-		{
-			if ((printer = (NT_PRINTER_INFO_LEVEL *)malloc(sizeof(NT_PRINTER_INFO_LEVEL))) == NULL) {
-				ZERODEBUG(0,("get_a_printer: malloc fail.\n"));
-				return WERR_NOMEM;
-			}
-			ZERO_STRUCTP(printer);
-			result=get_a_printer_2(&printer->info_2, sharename);
-			if (W_ERROR_IS_OK(result)) {
-				dump_a_printer(*printer, level);
-				*pp_printer = printer;
-			} else {
-				SAFE_FREE(printer);
-			}
-			break;
-		}
-		default:
-			result=WERR_UNKNOWN_LEVEL;
-			break;
-	}
-	
-	DEBUG(10,("get_a_printer: [%s] level %u returning %s\n", sharename, (unsigned int)level, dos_errstr(result)));
-
-	return result;
-}
-
-/****************************************************************************
- Deletes a NT_PRINTER_INFO_LEVEL struct.
-****************************************************************************/
-
-uint32 free_a_printer(NT_PRINTER_INFO_LEVEL **pp_printer, uint32 level)
-{
-	uint32 result;
-	NT_PRINTER_INFO_LEVEL *printer = *pp_printer;
-
-	DEBUG(104,("freeing a printer at level [%d]\n", level));
-
-	if (printer == NULL)
-		return 0;
-	
-	switch (level)
-	{
-		case 2:
-		{
-			if (printer->info_2 != NULL)
-			{
-				free_nt_printer_info_level_2(&printer->info_2);
-				result=0;
-			}
-			else
-			{
-				result=4;
-			}
-			break;
-		}
-		default:
-			result=1;
-			break;
-	}
-
-	SAFE_FREE(*pp_printer);
-	return result;
-}
-
-/****************************************************************************
-****************************************************************************/
-uint32 add_a_printer_driver(NT_PRINTER_DRIVER_INFO_LEVEL driver, uint32 level)
-{
-	uint32 result;
-	DEBUG(104,("adding a printer at level [%d]\n", level));
-	dump_a_printer_driver(driver, level);
-	
-	switch (level)
-	{
-		case 3:
-		{
-			result=add_a_printer_driver_3(driver.info_3);
-			break;
-		}
-
-		case 6:
-		{
-			result=add_a_printer_driver_6(driver.info_6);
-			break;
-		}
-		default:
-			result=1;
-			break;
-	}
-	
-	return result;
-}
-/****************************************************************************
-****************************************************************************/
-WERROR get_a_printer_driver(NT_PRINTER_DRIVER_INFO_LEVEL *driver, uint32 level,
-                            fstring drivername, const fstring architecture, uint32 version)
-{
-	WERROR result;
-	
-	switch (level)
-	{
-		case 3:
-			/* Sometime we just want any version of the driver */
-			
-			if ( version == DRIVER_ANY_VERSION ) {
-				/* look for Win2k first and then for NT4 */
-				result = get_a_printer_driver_3(&driver->info_3, drivername, 
-						architecture, 3);
-						
-				if ( !W_ERROR_IS_OK(result) ) {
-					result = get_a_printer_driver_3( &driver->info_3, 
-							drivername, architecture, 2 );
-				}
-			}
-			else {
-				result = get_a_printer_driver_3(&driver->info_3, drivername, 
-					architecture, version);				
-			}
-			break;
-			
-		default:
-			result=W_ERROR(1);
-			break;
-	}
-	
-	if (W_ERROR_IS_OK(result))
-		dump_a_printer_driver(*driver, level);
-		
-	return result;
-}
-
-/****************************************************************************
-****************************************************************************/
-uint32 free_a_printer_driver(NT_PRINTER_DRIVER_INFO_LEVEL driver, uint32 level)
-{
-	uint32 result;
-	
-	switch (level)
-	{
-		case 3:
-		{
-			NT_PRINTER_DRIVER_INFO_LEVEL_3 *info3;
-			if (driver.info_3 != NULL)
-			{
-				info3=driver.info_3;
-				SAFE_FREE(info3->dependentfiles);
-				ZERO_STRUCTP(info3);
-				SAFE_FREE(info3);
-				result=0;
-			}
-			else
-			{
-				result=4;
-			}
-			break;
-		}
-		case 6:
-		{
-			NT_PRINTER_DRIVER_INFO_LEVEL_6 *info6;
-			if (driver.info_6 != NULL)
-			{
-				info6=driver.info_6;
-				SAFE_FREE(info6->dependentfiles);
-				SAFE_FREE(info6->previousnames);
-				ZERO_STRUCTP(info6);
-				SAFE_FREE(info6);
-				result=0;
-			}
-			else
-			{
-				result=4;
-			}
-			break;
-		}
-		default:
-			result=1;
-			break;
-	}
-	return result;
-}
-
-
-/****************************************************************************
-  Determine whether or not a particular driver is currently assigned
-  to a printer
-****************************************************************************/
-
-BOOL printer_driver_in_use ( NT_PRINTER_DRIVER_INFO_LEVEL_3 *info_3 )
-{
-	int snum;
-	int n_services = lp_numservices();
-	NT_PRINTER_INFO_LEVEL *printer = NULL;
-
-	if ( !info_3 ) 
-		return False;
-
-	DEBUG(5,("printer_driver_in_use: Beginning search through ntprinters.tdb...\n"));
-	
-	/* loop through the printers.tdb and check for the drivername */
-	
-	for (snum=0; snum<n_services; snum++) 
-	{
-		if ( !(lp_snum_ok(snum) && lp_print_ok(snum) ) )
-			continue;
-		
-		if ( !W_ERROR_IS_OK(get_a_printer(&printer, 2, lp_servicename(snum))) )
-			continue;
-		
-		if ( !StrCaseCmp(info_3->name, printer->info_2->drivername) ) {
-			free_a_printer( &printer, 2 );
-			return True;
-		}
-		
-		free_a_printer( &printer, 2 );
-	}
-	
-	DEBUG(5,("printer_driver_in_use: Completed search through ntprinters.tdb...\n"));
-	
-	/* report that the driver is not in use by default */
-	
-	return False;
-}
-
-/****************************************************************************
- Remove a printer driver from the TDB.  This assumes that the the driver was
- previously looked up.
- ***************************************************************************/
-
-WERROR delete_printer_driver( NT_PRINTER_DRIVER_INFO_LEVEL_3 *info_3, struct current_user *user,
-                              uint32 version, BOOL delete_files )
-{
-	pstring 	key;
-	fstring		arch;
-	TDB_DATA 	kbuf, dbuf;
-	NT_PRINTER_DRIVER_INFO_LEVEL	ctr;
-
-	/* delete the tdb data first */
-
-	get_short_archi(arch, info_3->environment);
-	slprintf(key, sizeof(key)-1, "%s%s/%d/%s", DRIVERS_PREFIX,
-		arch, version, info_3->name);
-
-	DEBUG(5,("delete_printer_driver: key = [%s] delete_files = %s\n",
-		key, delete_files ? "TRUE" : "FALSE" ));
-
-	ctr.info_3 = info_3;
-	dump_a_printer_driver( ctr, 3 );
-
-	kbuf.dptr=key;
-	kbuf.dsize=strlen(key)+1;
-	
-	/* check if the driver actually exists for this environment */
-	
-	dbuf = tdb_fetch( tdb_drivers, kbuf );
-	if ( !dbuf.dptr ) {
-		DEBUG(8,("delete_printer_driver: Driver unknown [%s]\n", key));
-		return WERR_UNKNOWN_PRINTER_DRIVER;
-	}
-		
-	SAFE_FREE( dbuf.dptr );
-	
-	/* ok... the driver exists so the delete should return success */
-		
-	if (tdb_delete(tdb_drivers, kbuf) == -1) {
-		ZERODEBUG (0,("delete_printer_driver: fail to delete %s!\n", key));
-		return WERR_ACCESS_DENIED;
-	}
-
-#if 0	/* JERRY - no used in Samba 2.2.x */
-	/*
-	 * now delete any associated files if delete_files == True
-	 * even if this part failes, we return succes because the
-	 * driver doesn not exist any more
-	 */
-
-	if ( delete_files )
-		delete_driver_files( i, user );
-
-#endif
-
-	DEBUG(5,("delete_printer_driver: driver delete successful [%s]\n", key));
-
-	return WERR_OK;
-}
-
-/****************************************************************************
-****************************************************************************/
-BOOL get_specific_param_by_index(NT_PRINTER_INFO_LEVEL printer, uint32 level, uint32 param_index,
-                                 fstring value, uint8 **data, uint32 *type, uint32 *len)
-{
-	/* right now that's enough ! */	
-	NT_PRINTER_PARAM *param;
-	int i=0;
-	
-	param=printer.info_2->specific;
-	
-	while (param != NULL && i < param_index) {
-		param=param->next;
-		i++;
-	}
-	
-	if (param == NULL)
-		return False;
-
-	/* exited because it exist */
-	*type=param->type;		
-	StrnCpy(value, param->value, sizeof(fstring)-1);
-	*data=(uint8 *)malloc(param->data_len*sizeof(uint8));
-	if(*data == NULL)
-		return False;
-	ZERO_STRUCTP(*data);
-	memcpy(*data, param->data, param->data_len);
-	*len=param->data_len;
-	return True;
-}
-
-/****************************************************************************
-****************************************************************************/
-BOOL get_specific_param(NT_PRINTER_INFO_LEVEL printer, uint32 level,
-                        fstring value, uint8 **data, uint32 *type, uint32 *len)
-{
-	/* right now that's enough ! */	
-	NT_PRINTER_PARAM *param;
-	
-	DEBUG(10, ("get_specific_param\n"));
-	
-	param=printer.info_2->specific;
-		
-	while (param != NULL)
-	{
-#if 1 /* JRA - I think this should be case insensitive.... */
-		if ( strequal(value, param->value)
-#else
-		if ( !strcmp(value, param->value)
-#endif
-		    && strlen(value)==strlen(param->value))
-			break;
-			
-		param=param->next;
-	}
-	
-	if (param != NULL)
-	{
-        DEBUGADD(10, ("get_specific_param: found one param\n"));
-		/* exited because it exist */
-		*type=param->type;	
-		
-		*data=(uint8 *)malloc(param->data_len*sizeof(uint8));
-		if(*data == NULL)
-			return False;
-		memcpy(*data, param->data, param->data_len);
-		*len=param->data_len;
-
-		DEBUGADD(10, ("get_specific_param: exit true\n"));
-		return (True);
-	}
-	DEBUGADD(10, ("get_specific_param: exit false\n"));
-	return (False);
-}
-
-/****************************************************************************
- Store a security desc for a printer.
-****************************************************************************/
-
-WERROR nt_printing_setsec(char *printername, SEC_DESC_BUF *secdesc_ctr)
-{
-	SEC_DESC_BUF *new_secdesc_ctr = NULL;
-	SEC_DESC_BUF *old_secdesc_ctr = NULL;
-	prs_struct ps;
-	TALLOC_CTX *mem_ctx = NULL;
-	fstring key;
-	WERROR status;
-
-	mem_ctx = talloc_init();
-	if (mem_ctx == NULL)
-		return WERR_NOMEM;
-
-        /* The old owner and group sids of the security descriptor are not
-	   present when new ACEs are added or removed by changing printer
-	   permissions through NT.  If they are NULL in the new security
-	   descriptor then copy them over from the old one. */
-
-	if (!secdesc_ctr->sec->owner_sid || !secdesc_ctr->sec->grp_sid) {
-		DOM_SID *owner_sid, *group_sid;
-		SEC_ACL *dacl, *sacl;
-		SEC_DESC *psd = NULL;
-		size_t size;
-
-		nt_printing_getsec(mem_ctx, printername, &old_secdesc_ctr);
-
-		/* Pick out correct owner and group sids */
-
-		owner_sid = secdesc_ctr->sec->owner_sid ?
-			secdesc_ctr->sec->owner_sid :
-			old_secdesc_ctr->sec->owner_sid;
-
-		group_sid = secdesc_ctr->sec->grp_sid ?
-			secdesc_ctr->sec->grp_sid :
-			old_secdesc_ctr->sec->grp_sid;
-
-		dacl = secdesc_ctr->sec->dacl ?
-			secdesc_ctr->sec->dacl :
-			old_secdesc_ctr->sec->dacl;
-
-		sacl = secdesc_ctr->sec->sacl ?
-			secdesc_ctr->sec->sacl :
-			old_secdesc_ctr->sec->sacl;
-
-		/* Make a deep copy of the security descriptor */
-
-		psd = make_sec_desc(mem_ctx, secdesc_ctr->sec->revision,
-				    owner_sid, group_sid,
-				    sacl,
-				    dacl,
-				    &size);
-
-		new_secdesc_ctr = make_sec_desc_buf(mem_ctx, size, psd);
-	}
-
-	if (!new_secdesc_ctr) {
-		new_secdesc_ctr = secdesc_ctr;
-	}
-
-	/* Store the security descriptor in a tdb */
-
-	prs_init(&ps, (uint32)sec_desc_size(new_secdesc_ctr->sec) +
-		 sizeof(SEC_DESC_BUF), mem_ctx, MARSHALL);
-
-	if (!sec_io_desc_buf("nt_printing_setsec", &new_secdesc_ctr,
-			     &ps, 1)) {
-		status = WERR_BADFUNC;
-		goto out;
-	}
-
-	slprintf(key, sizeof(key)-1, "SECDESC/%s", printername);
-
-	if (tdb_prs_store(tdb_printers, key, &ps)==0) {
-		status = WERR_OK;
-	} else {
-		DEBUG(1,("Failed to store secdesc for %s\n", printername));
-		status = WERR_BADFUNC;
-	}
-
-	/* Free malloc'ed memory */
-
- out:
-
-	prs_mem_free(&ps);
-	if (mem_ctx)
-		talloc_destroy(mem_ctx);
-	return status;
-}
-
-/****************************************************************************
- Construct a default security descriptor buffer for a printer.
-****************************************************************************/
-
-static SEC_DESC_BUF *construct_default_printer_sdb(TALLOC_CTX *ctx)
-{
-	extern DOM_SID global_sam_sid;
-	SEC_ACE ace[3];
-	SEC_ACCESS sa;
-	SEC_ACL *psa = NULL;
-	SEC_DESC_BUF *sdb = NULL;
-	SEC_DESC *psd = NULL;
-	DOM_SID owner_sid;
-	size_t sd_size;
-	enum SID_NAME_USE name_type;
-	fstring dos_domain;
-	
-	/* Create an ACE where Everyone is allowed to print */
-
-	init_sec_access(&sa, PRINTER_ACE_PRINT);
-	init_sec_ace(&ace[0], &global_sid_World, SEC_ACE_TYPE_ACCESS_ALLOWED,
-		     sa, SEC_ACE_FLAG_CONTAINER_INHERIT);
-
-	/* Make the security descriptor owned by the Administrators group
-	   on the PDC of the domain. */
-
-	/* Note that for hysterical raisins, the argument to
-	   secrets_fetch_domain_sid() must be in dos codepage format.  
-	   Aargh! */
-
-	fstrcpy(dos_domain, lp_workgroup());
-	unix_to_dos(dos_domain);
-
-	if (secrets_fetch_domain_sid(dos_domain, &owner_sid)) {
-		sid_append_rid(&owner_sid, DOMAIN_USER_RID_ADMIN);
-	} else {
-
-		/* Backup plan - make printer owned by admins or root.
-		   This should emulate a lanman printer as security
-		   settings can't be changed. */
-
-		if (!lookup_name("root", &owner_sid, &name_type)) {
-			sid_copy(&owner_sid, &global_sam_sid);
-			sid_append_rid(&owner_sid, DOMAIN_USER_RID_ADMIN);
-		}
-	}
-
-	init_sec_access(&sa, PRINTER_ACE_FULL_CONTROL);
-	init_sec_ace(&ace[1], &owner_sid, SEC_ACE_TYPE_ACCESS_ALLOWED,
-		     sa, SEC_ACE_FLAG_OBJECT_INHERIT |
-		     SEC_ACE_FLAG_INHERIT_ONLY);
-
-	init_sec_access(&sa, PRINTER_ACE_FULL_CONTROL);
-	init_sec_ace(&ace[2], &owner_sid, SEC_ACE_TYPE_ACCESS_ALLOWED,
-		     sa, SEC_ACE_FLAG_CONTAINER_INHERIT);
-
-	/* The ACL revision number in rpc_secdesc.h differs from the one
-	   created by NT when setting ACE entries in printer
-	   descriptors.  NT4 complains about the property being edited by a
-	   NT5 machine. */
-
-	if ((psa = make_sec_acl(ctx, NT4_ACL_REVISION, 3, ace)) != NULL) {
-		psd = make_sec_desc(ctx, SEC_DESC_REVISION,
-				    &owner_sid, NULL,
-				    NULL, psa, &sd_size);
-	}
-
-	if (!psd) {
-		ZERODEBUG(0,("construct_default_printer_sd: Failed to make SEC_DESC.\n"));
-		return NULL;
-	}
-
-	sdb = make_sec_desc_buf(ctx, sd_size, psd);
-
-	DEBUG(4,("construct_default_printer_sdb: size = %u.\n",
-		 (unsigned int)sd_size));
-
-	return sdb;
-}
-
-/****************************************************************************
- Get a security desc for a printer.
-****************************************************************************/
-
-BOOL nt_printing_getsec(TALLOC_CTX *ctx, char *printername, SEC_DESC_BUF **secdesc_ctr)
-{
-	prs_struct ps;
-	fstring key;
-	char *temp;
-
-	if ((temp = strchr(printername + 2, '\\'))) {
-		printername = temp + 1;
-	}
-
-	/* Fetch security descriptor from tdb */
-
-	slprintf(key, sizeof(key)-1, "SECDESC/%s", printername);
-
-	if (tdb_prs_fetch(tdb_printers, key, &ps, ctx)!=0 ||
-	    !sec_io_desc_buf("nt_printing_getsec", secdesc_ctr, &ps, 1)) {
-
-		DEBUG(4,("using default secdesc for %s\n", printername));
-
-		if (!(*secdesc_ctr = construct_default_printer_sdb(ctx))) {
-			return False;
-		}
-
-		/* Save default security descriptor for later */
-
-		prs_init(&ps, (uint32)sec_desc_size((*secdesc_ctr)->sec) +
-				sizeof(SEC_DESC_BUF), ctx, MARSHALL);
-
-		if (sec_io_desc_buf("nt_printing_setsec", secdesc_ctr, &ps, 1))
-			tdb_prs_store(tdb_printers, key, &ps);
-
-		prs_mem_free(&ps);
-
-		return True;
-	}
-
-	/* If security descriptor is owned by S-1-1-0 and winbindd is up,
-	   this security descriptor has been created when winbindd was
-	   down.  Take ownership of security descriptor. */
-
-	if (sid_equal((*secdesc_ctr)->sec->owner_sid, &global_sid_World)) {
-		DOM_SID owner_sid;
-		enum SID_NAME_USE name_type;
-
-		/* Change sd owner to workgroup administrator */
-
-		if (winbind_lookup_name(NULL, lp_workgroup(), &owner_sid,
-					&name_type)) {
-			SEC_DESC_BUF *new_secdesc_ctr = NULL;
-			SEC_DESC *psd = NULL;
-			size_t size;
-
-			/* Create new sd */
-
-			sid_append_rid(&owner_sid, DOMAIN_USER_RID_ADMIN);
-
-			psd = make_sec_desc(ctx, (*secdesc_ctr)->sec->revision,
-					    &owner_sid,
-					    (*secdesc_ctr)->sec->grp_sid,
-					    (*secdesc_ctr)->sec->sacl,
-					    (*secdesc_ctr)->sec->dacl,
-					    &size);
-
-			new_secdesc_ctr = make_sec_desc_buf(ctx, size, psd);
-
-			/* Swap with other one */
-
-			*secdesc_ctr = new_secdesc_ctr;
-
-			/* Set it */
-
-			nt_printing_setsec(printername, *secdesc_ctr);
-		}
-	}
-
-	if (DEBUGLEVEL >= 10) {
-		SEC_ACL *the_acl = (*secdesc_ctr)->sec->dacl;
-		int i;
-
-		DEBUG(10, ("secdesc_ctr for %s has %d aces:\n", 
-			   printername, the_acl->num_aces));
-
-		for (i = 0; i < the_acl->num_aces; i++) {
-			fstring sid_str;
-
-			sid_to_string(sid_str, &the_acl->ace[i].trustee);
-
-			DEBUG(10, ("%s %d %d 0x%08x\n", sid_str,
-				   the_acl->ace[i].type, the_acl->ace[i].flags, 
-				   the_acl->ace[i].info.mask)); 
-		}
-	}
-
-	prs_mem_free(&ps);
-	return True;
-}
-
-/* error code:
-	0: everything OK
-	1: level not implemented
-	2: file doesn't exist
-	3: can't allocate memory
-	4: can't free memory
-	5: non existant struct
-*/
-
-/*
-	A printer and a printer driver are 2 different things.
-	NT manages them separatelly, Samba does the same.
-	Why ? Simply because it's easier and it makes sense !
-	
-	Now explanation: You have 3 printers behind your samba server,
-	2 of them are the same make and model (laser A and B). But laser B
-	has an 3000 sheet feeder and laser A doesn't such an option.
-	Your third printer is an old dot-matrix model for the accounting :-).
-	
-	If the /usr/local/samba/lib directory (default dir), you will have
-	5 files to describe all of this.
-	
-	3 files for the printers (1 by printer):
-		NTprinter_laser A
-		NTprinter_laser B
-		NTprinter_accounting
-	2 files for the drivers (1 for the laser and 1 for the dot matrix)
-		NTdriver_printer model X
-		NTdriver_printer model Y
-
-jfm: I should use this comment for the text file to explain
-	same thing for the forms BTW.
-	Je devrais mettre mes commentaires en francais, ca serait mieux :-)
-
-*/
-
-/* Convert generic access rights to printer object specific access rights.
-   It turns out that NT4 security descriptors use generic access rights and
-   NT5 the object specific ones. */
-
-void map_printer_permissions(SEC_DESC *sd)
-{
-	int i;
-
-	for (i = 0; sd->dacl && i < sd->dacl->num_aces; i++) {
-		se_map_generic(&sd->dacl->ace[i].info.mask,
-			       &printer_generic_mapping);
-	}
-}
-
-/****************************************************************************
- Check a user has permissions to perform the given operation.  We use the
- permission constants defined in include/rpc_spoolss.h to check the various
- actions we perform when checking printer access.
-
-   PRINTER_ACCESS_ADMINISTER:
-       print_queue_pause, print_queue_resume, update_printer_sec,
-       update_printer, spoolss_addprinterex_level_2,
-       _spoolss_setprinterdata
-
-   PRINTER_ACCESS_USE:
-       print_job_start
-
-   JOB_ACCESS_ADMINISTER:
-       print_job_delete, print_job_pause, print_job_resume,
-       print_queue_purge
-
- ****************************************************************************/
-BOOL print_access_check(struct current_user *user, int snum, int access_type)
-{
-	SEC_DESC_BUF *secdesc = NULL;
-	uint32 access_granted;
-	NTSTATUS status;
-	BOOL result;
-	char *pname;
-	TALLOC_CTX *mem_ctx = NULL;
-	extern struct current_user current_user;
-	
-	/* If user is NULL then use the current_user structure */
-
-	if (!user)
-		user = &current_user;
-
-	/* Always allow root or printer admins to do anything */
-
-	if (user->uid == 0 ||
-	    user_in_list(uidtoname(user->uid), lp_printer_admin(snum))) {
-		return True;
-	}
-
-	/* Get printer name */
-
-	pname = PRINTERNAME(snum);
-
-	if (!pname || !*pname) {
-		errno = EACCES;
-		return False;
-	}
-
-	/* Get printer security descriptor */
-
-	if(!(mem_ctx = talloc_init())) {
-		errno = ENOMEM;
-		return False;
-	}
-
-	nt_printing_getsec(mem_ctx, pname, &secdesc);
-
-	if (access_type == JOB_ACCESS_ADMINISTER) {
-		SEC_DESC_BUF *parent_secdesc = secdesc;
-
-		/* Create a child security descriptor to check permissions
-		   against.  This is because print jobs are child objects
-		   objects of a printer. */
-
-		secdesc = se_create_child_secdesc(mem_ctx, parent_secdesc->sec, False);
-
-		/* Now this is the bit that really confuses me.  The access
-		   type needs to be changed from JOB_ACCESS_ADMINISTER to
-		   PRINTER_ACCESS_ADMINISTER for this to work.  Something
-		   to do with the child (job) object becoming like a
-		   printer??  -tpot */
-
-		access_type = PRINTER_ACCESS_ADMINISTER;
-	}
-	
-	/* Check access */
-	
-	map_printer_permissions(secdesc->sec);
-
-	result = se_access_check(secdesc->sec, user->nt_user_token, access_type,
-				 &access_granted, &status);
-
-	DEBUG(4, ("access check was %s\n", result ? "SUCCESS" : "FAILURE"));
-
-	talloc_destroy(mem_ctx);
-	
-	if (!result)
-		errno = EACCES;
-
-	return result;
-}
-
-/****************************************************************************
- Check the time parameters allow a print operation.
-*****************************************************************************/
-
-BOOL print_time_access_check(int snum)
-{
-	NT_PRINTER_INFO_LEVEL *printer = NULL;
-	BOOL ok = False;
-	time_t now = time(NULL);
-	struct tm *t;
-	uint32 mins;
-
-	if (!W_ERROR_IS_OK(get_a_printer(&printer, 2, lp_servicename(snum))))
-		return False;
-
-	if (printer->info_2->starttime == 0 && printer->info_2->untiltime == 0)
-		ok = True;
-
-	t = gmtime(&now);
-	mins = (uint32)t->tm_hour*60 + (uint32)t->tm_min;
-
-	if (mins >= printer->info_2->starttime && mins <= printer->info_2->untiltime)
-		ok = True;
-
-	free_a_printer(&printer, 2);
-
-	if (!ok)
-		errno = EACCES;
-
-	return ok;
-}
-
-#if 0	/* JERRY - not used */
-/****************************************************************************
- Attempt to write a default device.
-*****************************************************************************/
-
-WERROR printer_write_default_dev(int snum, const PRINTER_DEFAULT *printer_default)
-{
-	NT_PRINTER_INFO_LEVEL *printer = NULL;
-	WERROR result;
-
-	/*
-	 * Don't bother if no default devicemode was sent.
-	 */
-
-	if (printer_default->devmode_cont.devmode == NULL)
-		return WERR_OK;
-
-	result = get_a_printer(&printer, 2, lp_servicename(snum));
-	if (!W_ERROR_IS_OK(result)) return result;
-
-	/*
-	 * Just ignore it if we already have a devmode.
-	 */
-#if 0
-	if (printer->info_2->devmode != NULL)
-		goto done;
-#endif
-	/*
-	 * We don't have a devicemode and we're trying to write
-	 * one. Check we have the access needed.
-	 */
-	DEBUG(5,("printer_write_default_dev: access: %x\n", printer_default->access_required));
-
-	if ( (printer_default->access_required & PRINTER_ACCESS_ADMINISTER) != 
-	      PRINTER_ACCESS_ADMINISTER) {
-		DEBUG(5,("printer_write_default_dev: invalid request access to update: %x\n", printer_default->access_required));
-		result = WERR_ACCESS_DENIED;
-		goto done;
-	}
-
-	if (!print_access_check(NULL, snum, PRINTER_ACCESS_ADMINISTER)) {
-		DEBUG(5,("printer_write_default_dev: Access denied for printer %s\n",
-			lp_servicename(snum) ));
-		result = WERR_ACCESS_DENIED;
-		/*result = NT_STATUS_NO_PROBLEMO;*/
-		goto done;
-	}
-
-	DEBUG(5,("printer_write_default_dev: updating, check OK.\n"));
-
-	/*
-	 * Convert the on the wire devicemode format to the internal one.
-	 */
-
-	if (!convert_devicemode(printer->info_2->printername,
-				printer_default->devmode_cont.devmode,
-				&printer->info_2->devmode)) {
-		result = WERR_NOMEM;
-		goto done;
-	}
-
-	/*
-	 * Finally write back to the tdb.
-	 */
-
-	result = mod_a_printer(*printer, 2);
-
-  done:
-
-	free_a_printer(&printer, 2);
-	return result;
-}
-#endif	/* JERRY */
diff -Naur samba-2.2.12-orig/source/printing/pcap.c samba-2.2.12/source/printing/pcap.c
--- samba-2.2.12-orig/source/printing/pcap.c	2011-03-04 13:51:45.000000000 +0100
+++ samba-2.2.12/source/printing/pcap.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,426 +0,0 @@
-/* 
-   Unix SMB/Netbios implementation.
-   Version 1.9.
-   printcap parsing
-   Copyright (C) Karl Auer 1993-1998
-
-   Re-working by Martin Kiff, 1994
-   
-   Re-written again by Andrew Tridgell
-
-   Modified for SVID support by Norm Jacobs, 1997
-
-   Modified for CUPS support by Michael Sweet, 1999
-   
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2 of the License, or
-   (at your option) any later version.
-   
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-   
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-*/
-
-/*
- *  Parse printcap file.
- *
- *  This module does exactly one thing - it looks into the printcap file
- *  and tells callers if a specified string appears as a printer name.
- *
- *  The way this module looks at the printcap file is very simplistic.
- *  Only the local printcap file is inspected (no searching of NIS
- *  databases etc).
- *
- *  There are assumed to be one or more printer names per record, held
- *  as a set of sub-fields separated by vertical bar symbols ('|') in the
- *  first field of the record. The field separator is assumed to be a colon
- *  ':' and the record separator a newline.
- * 
- *  Lines ending with a backspace '\' are assumed to flag that the following
- *  line is a continuation line so that a set of lines can be read as one
- *  printcap entry.
- *
- *  A line stating with a hash '#' is assumed to be a comment and is ignored
- *  Comments are discarded before the record is strung together from the
- *  set of continuation lines.
- *
- *  Opening a pipe for "lpc status" and reading that would probably 
- *  be pretty effective. Code to do this already exists in the freely
- *  distributable PCNFS server code.
- *
- *  Modified to call SVID/XPG4 support if printcap name is set to "lpstat"
- *  in smb.conf under Solaris.
- *
- *  Modified to call CUPS support if printcap name is set to "cups"
- *  in smb.conf.
- */
-
-#include "includes.h"
-
-#include "smb.h"
-
-#ifdef AIX
-/*  ******************************************
-     Extend for AIX system and qconfig file
-       from 'boulard@univ-rennes1.fr
-    ****************************************** */
-static int strlocate(char *xpLine,char *xpS)
-{
-	int iS,iL,iRet;
-	char *p;
-	iS = strlen(xpS);
-	iL = strlen(xpLine);
-
-	iRet = 0;
-	p = xpLine;
-	while (iL >= iS)
-	{
-		if (strncmp(p,xpS,iS) == 0) {iRet =1;break;};
-		p++;
-		iL--;
-	}
-	/*DEBUG(3,(" strlocate %s in line '%s',ret=%d\n",xpS,xpLine,iRet));*/
-	
-	return(iRet);
-}
-	
-	
-/* ******************************************************************* */
-/* *    Scan qconfig and search all virtual printer (device printer) * */
-/* ******************************************************************* */
-static void ScanQconfig_fn(char *psz,void (*fn)(char *, char *))
-{
-	int iEtat;
-	FILE *pfile;
-	char *line,*p;
-	pstring name,comment;
-	line  = NULL;
-	*name = 0;
-	*comment = 0;
-
-	if ((pfile = sys_fopen(psz, "r")) == NULL)
-	{
-	      ZERODEBUG(0,( "Unable to open qconfig file %s for read!\n", psz));
-	      return;
-	}
-
-	iEtat = 0;
-	/* scan qconfig file for searching <printername>:	*/
-	for (;(line = fgets_slash(NULL,sizeof(pstring),pfile)); safe_free(line))
-	{
-		if (*line == '*' || *line == 0)
-		continue;
-		switch (iEtat)
-		{
-			case 0: /* locate an entry */
-			 if (*line == '\t' || *line == ' ') continue;
-			 if ((p=strchr(line,':')))
-			 {
-			 	*p = '\0';
-				p = strtok(line,":");
-				if (strcmp(p,"bsh")!=0)
-				  {
-				    pstrcpy(name,p);
-				    iEtat = 1;
-				    continue;
-				  }
-			 }
-			 break;
-			case 1: /* scanning device stanza */
-			 if (*line == '*' || *line == 0) continue;
-		  	 if (*line != '\t' && *line != ' ')
-		  	 {
-		  	   /* name is found without stanza device  */
-		  	   /* probably a good printer ???		*/
-		  	   fn(name,comment);
-		  	   iEtat = 0;
-		  	   continue;
-		  	  }
-		  	
-		  	  if (strlocate(line,"backend"))
-		  	  {
-		  		/* it's a device, not a virtual printer*/
-		  		iEtat = 0;
-		  	  }
-		  	  else if (strlocate(line,"device"))
-		  	  {
-		  		/* it's a good virtual printer */
-		  		fn(name,comment);
-		  		iEtat = 0;
-		  		continue;
-		  	  }
-		  	  break;
-		}
-	}
-	fclose(pfile);
-}
-
-/* Scan qconfig file and locate de printername */
-
-static BOOL ScanQconfig(char *psz,char *pszPrintername)
-{
-	int iLg,iEtat;
-	FILE *pfile;
-	char *pName;
-	char *line;
-
-	pName = NULL;
-	line  = NULL;
-	if ((pszPrintername!= NULL) && ((iLg = strlen(pszPrintername)) > 0))
-	 pName = malloc(iLg+10);
-	if (pName == NULL)
-	{
-		ZERODEBUG(0,(" Unable to allocate memory for printer %s\n",pszPrintername));
-		return(False);
-	}
-	if ((pfile = sys_fopen(psz, "r")) == NULL)
-	{
-	      ZERODEBUG(0,( "Unable to open qconfig file %s for read!\n", psz));
-	      SAFE_FREE(pName);
-	      return(False);
-	}
-	slprintf(pName, iLg + 9, "%s:",pszPrintername);
-	iLg = strlen(pName);
-	/*DEBUG(3,( " Looking for entry %s\n",pName));*/
-	iEtat = 0;
-	/* scan qconfig file for searching <printername>:	*/
-	for (;(line = fgets_slash(NULL,sizeof(pstring),pfile)); safe_free(line))
-	{
-		if (*line == '*' || *line == 0)
-		continue;
-		switch (iEtat)
-		{
-			case 0: /* scanning entry */
-			 if (strncmp(line,pName,iLg) == 0)
-			 {
-			 	iEtat = 1;
-			 	continue;
-			 }
-			 break;
-			case 1: /* scanning device stanza */
-			 if (*line == '*' || *line == 0) continue;
-		  	 if (*line != '\t' && *line != ' ')
-		  	 {
-		  	   /* name is found without stanza device  */
-		  	   /* probably a good printer ???		*/
-		  	   SAFE_FREE (line);
-		  	   SAFE_FREE(pName);
-		  	   fclose(pfile);
-		  	   return(True);
-		  	  }
-		  	
-		  	  if (strlocate(line,"backend"))
-		  	  {
-		  		/* it's a device, not a virtual printer*/
-		  		iEtat = 0;
-		  	  }
-		  	  else if (strlocate(line,"device"))
-		  	  {
-		  		/* it's a good virtual printer */
-		  		SAFE_FREE (line);
-		  		SAFE_FREE(pName);
-		  		fclose(pfile);
-		  		return(True);
-		  	  }
-		  	  break;
-		}
-	}
-	SAFE_FREE (pName);
-	fclose(pfile);
-	return(False);
-}
-#endif /* AIX */
-
-
-/***************************************************************************
-Scan printcap file pszPrintcapname for a printer called pszPrintername. 
-Return True if found, else False. Returns False on error, too, after logging 
-the error at level 0. For generality, the printcap name may be passed - if
-passed as NULL, the configuration will be queried for the name. pszPrintername
-must be in DOS codepage.
-The xxx_printername_ok functions need fixing to understand they are being
-given a DOS codepage. FIXME !! JRA.
-***************************************************************************/
-
-BOOL pcap_printername_ok(char *pszPrintername, const char *pszPrintcapname)
-{
-  char *line=NULL;
-  const char *psz;
-  char *p,*q;
-  FILE *pfile;
-
-  if (pszPrintername == NULL || pszPrintername[0] == '\0')
-    {
-      ZERODEBUG(0,( "Attempt to locate null printername! Internal error?\n"));
-      return(False);
-    }
-
-  /* only go looking if no printcap name supplied */
-  if ((psz = pszPrintcapname) == NULL || psz[0] == '\0')
-    if (((psz = lp_printcapname()) == NULL) || (psz[0] == '\0'))
-      {
-	ZERODEBUG(0,( "No printcap file name configured!\n"));
-	return(False);
-      }
-
-#ifdef HAVE_CUPS
-    if (strequal(psz, "cups"))
-       return (cups_printername_ok(pszPrintername));
-#endif /* HAVE_CUPS */
-
-#ifdef SYSV
-    if (strequal(psz, "lpstat"))
-       return (sysv_printername_ok(pszPrintername));
-#endif
-
-#ifdef AIX
-  if (strlocate(psz,"/qconfig"))
-     return(ScanQconfig(psz,pszPrintername));
-#endif
-
-  if ((pfile = sys_fopen(psz, "r")) == NULL)
-    {
-      ZERODEBUG(0,( "Unable to open printcap file %s for read!\n", psz));
-      return(False);
-    }
-
-  for (;(line = fgets_slash(NULL,sizeof(pstring),pfile)); safe_free(line))
-    {
-      if (*line == '#' || *line == 0)
-	continue;
-
-      unix_to_dos(line);
-
-      /* now we have a real printer line - cut it off at the first : */      
-      p = strchr(line,':');
-      if (p) *p = 0;
-      
-      /* now just check if the name is in the list */
-      /* NOTE: I avoid strtok as the fn calling this one may be using it */
-      for (p=line; p; p=q)
-	{
-	  if ((q = strchr(p,'|'))) *q++ = 0;
-
-	  if (strequal(p,pszPrintername))
-	    {
-	      /* normalise the case */
-	      pstrcpy(pszPrintername,p);
-	      SAFE_FREE(line);
-	      fclose(pfile);
-	      return(True);	      
-	    }
-	  p = q;
-	}
-    }
-
-  fclose(pfile);
-  return(False);
-}
-
-
-/***************************************************************************
-run a function on each printer name in the printcap file. The function is 
-passed the primary name and the comment (if possible). Note the fn() takes
-strings in DOS codepage. This means the xxx_printer_fn() calls must be fixed
-to return DOS codepage. FIXME !! JRA.
-***************************************************************************/
-void pcap_printer_fn(void (*fn)(char *, char *))
-{
-  pstring name,comment;
-  char *line;
-  char *psz;
-  char *p,*q;
-  FILE *pfile;
-
-  /* only go looking if no printcap name supplied */
-  if (((psz = lp_printcapname()) == NULL) || (psz[0] == '\0'))
-    {
-      ZERODEBUG(0,( "No printcap file name configured!\n"));
-      return;
-    }
-
-#ifdef HAVE_CUPS
-    if (strequal(psz, "cups")) {
-      cups_printer_fn(fn);
-      return;
-    }
-#endif /* HAVE_CUPS */
-
-#ifdef SYSV
-    if (strequal(psz, "lpstat")) {
-      sysv_printer_fn(fn);
-      return;
-    }
-#endif
-
-#ifdef AIX
-  if (strlocate(psz,"/qconfig"))
-  {
-  	ScanQconfig_fn(psz,fn);
-     return;
-  }
-#endif
-
-  if ((pfile = sys_fopen(psz, "r")) == NULL)
-    {
-      ZERODEBUG(0,( "Unable to open printcap file %s for read!\n", psz));
-      return;
-    }
-
-  for (;(line = fgets_slash(NULL,sizeof(pstring),pfile)); safe_free(line))
-    {
-      if (*line == '#' || *line == 0)
-	continue;
-
-      /* now we have a real printer line - cut it off at the first : */      
-      p = strchr(line,':');
-      if (p) *p = 0;
-      
-      unix_to_dos(line);
-
-      /* now find the most likely printer name and comment 
-       this is pure guesswork, but it's better than nothing */
-      *name = 0;
-      *comment = 0;
-      for (p=line; p; p=q)
-	{
-	  BOOL has_punctuation;
-	  if ((q = strchr(p,'|'))) *q++ = 0;
-
-	  has_punctuation = (strchr(p,' ') || strchr(p,'\t') || strchr(p,'(') || strchr(p,')'));
-
-	  if (strlen(p)>strlen(comment) && has_punctuation)
-	    {
-	      StrnCpy(comment,p,sizeof(comment)-1);
-	      continue;
-	    }
-
-	  if (strlen(p) <= MAXPRINTERLEN && strlen(p)>strlen(name) && !has_punctuation)
-	    {
-	      if (!*comment) pstrcpy(comment,name);
-	      pstrcpy(name,p);
-	      continue;
-	    }
-
-	  if (!strchr(comment,' ') && 
-	      strlen(p) > strlen(comment))
-	    {
-	      StrnCpy(comment,p,sizeof(comment)-1);
-	      continue;
-	    }
-	}
-
-      comment[60] = 0;
-      name[MAXPRINTERLEN] = 0;
-
-      if (*name) 
-	fn(name,comment);
-    }
-  fclose(pfile);
-}
diff -Naur samba-2.2.12-orig/source/printing/print_cups.c samba-2.2.12/source/printing/print_cups.c
--- samba-2.2.12-orig/source/printing/print_cups.c	2011-03-04 13:51:45.000000000 +0100
+++ samba-2.2.12/source/printing/print_cups.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1293 +0,0 @@
-/*
- * Support code for the Common UNIX Printing System ("CUPS")
- *
- * Copyright 1999-2003 by Michael R Sweet.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- * 
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- */
-
-#include "printing.h"
-
-#ifdef HAVE_CUPS
-#include <cups/cups.h>
-#include <cups/language.h>
-
-
-/*
- * CUPS printing interface definitions...
- */
-
-static int cups_job_delete(int snum, struct printjob *pjob);
-static int cups_job_pause(int snum, struct printjob *pjob);
-static int cups_job_resume(int snum, struct printjob *pjob);
-static int cups_job_submit(int snum, struct printjob *pjob);
-static int cups_queue_get(int snum, print_queue_struct **q,
-                          print_status_struct *status);
-static int cups_queue_pause(int snum);
-static int cups_queue_resume(int snum);
-
-
-struct printif	cups_printif =
-		{
-		  cups_queue_get,
-		  cups_queue_pause,
-		  cups_queue_resume,
-		  cups_job_delete,
-		  cups_job_pause,
-		  cups_job_resume,
-		  cups_job_submit,
-		};
-
-/*
- * 'cups_passwd_cb()' - The CUPS password callback...
- */
-
-static const char *				/* O - Password or NULL */
-cups_passwd_cb(const char *prompt)	/* I - Prompt */
-{
- /*
-  * Always return NULL to indicate that no password is available...
-  */
-
-  return (NULL);
-}
-
-
-/*
- * 'cups_printer_fn()' - Call a function for every printer known to the
- *                       system.
- */
-
-void cups_printer_fn(void (*fn)(char *, char *))
-{
-	/* I - Function to call */
-	http_t		*http;		/* HTTP connection to server */
-	ipp_t		*request,	/* IPP Request */
-			*response;	/* IPP Response */
-	ipp_attribute_t	*attr;		/* Current attribute */
-	cups_lang_t	*language;	/* Default language */
-	char		*name,		/* printer-name attribute */
-			*make_model,	/* printer-make-and-model attribute */
-			*info;		/* printer-info attribute */
-	static const char *requested[] =/* Requested attributes */
-			{
-			  "printer-name",
-			  "printer-make-and-model",
-			  "printer-info"
-			};       
-
-
-	DEBUG(5,("cups_printer_fn(%p)\n", fn));
-
-       /*
-        * Make sure we don't ask for passwords...
-	*/
-
-        cupsSetPasswordCB(cups_passwd_cb);
-
-       /*
-	* Try to connect to the server...
-	*/
-
-	if ((http = httpConnect(cupsServer(), ippPort())) == NULL)
-	{
-		ZERODEBUG(0,("Unable to connect to CUPS server %s - %s\n", 
-			 cupsServer(), strerror(errno)));
-		return;
-	}
-
-       /*
-	* Build a CUPS_GET_PRINTERS request, which requires the following
-	* attributes:
-	*
-	*    attributes-charset
-	*    attributes-natural-language
-	*    requested-attributes
-	*/
-
-	request = ippNew();
-
-	request->request.op.operation_id = CUPS_GET_PRINTERS;
-	request->request.op.request_id   = 1;
-
-	language = cupsLangDefault();
-
-	ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_CHARSET,
-                     "attributes-charset", NULL, cupsLangEncoding(language));
-
-	ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_LANGUAGE,
-                     "attributes-natural-language", NULL, language->language);
-
-        ippAddStrings(request, IPP_TAG_OPERATION, IPP_TAG_NAME,
-	              "requested-attributes",
-		      (sizeof(requested) / sizeof(requested[0])),
-		      NULL, requested);
-
-       /*
-	* Do the request and get back a response...
-	*/
-
-	if ((response = cupsDoRequest(http, request, "/")) == NULL)
-	{
-		ZERODEBUG(0,("Unable to get printer list - %s\n",
-			 ippErrorString(cupsLastError())));
-		httpClose(http);
-		return;
-	}
-
-	for (attr = response->attrs; attr != NULL;)
-	{
-	       /*
-		* Skip leading attributes until we hit a printer...
-		*/
-
-		while (attr != NULL && attr->group_tag != IPP_TAG_PRINTER)
-			attr = attr->next;
-
-		if (attr == NULL)
-        		break;
-
-	       /*
-		* Pull the needed attributes from this printer...
-		*/
-
-		name       = NULL;
-		make_model = NULL;
-		info       = NULL;
-
-		while (attr != NULL && attr->group_tag == IPP_TAG_PRINTER)
-		{
-        		if (strcmp(attr->name, "printer-name") == 0 &&
-			    attr->value_tag == IPP_TAG_NAME)
-				name = attr->values[0].string.text;
-
-        		if (strcmp(attr->name, "printer-make-and-model") == 0 &&
-			    attr->value_tag == IPP_TAG_TEXT)
-				make_model = attr->values[0].string.text;
-
-        		if (strcmp(attr->name, "printer-info") == 0 &&
-			    attr->value_tag == IPP_TAG_TEXT)
-				info = attr->values[0].string.text;
-
-        		attr = attr->next;
-		}
-
-	       /*
-		* See if we have everything needed...
-		*/
-
-		if (name == NULL)
-			break;
-
- 		if (info == NULL || !info[0])
-			(*fn)(name, make_model);
-		else
-			(*fn)(name, info);
-		
-
-	}
-
-	ippDelete(response);
-
-
-       /*
-	* Build a CUPS_GET_CLASSES request, which requires the following
-	* attributes:
-	*
-	*    attributes-charset
-	*    attributes-natural-language
-	*    requested-attributes
-	*/
-
-	request = ippNew();
-
-	request->request.op.operation_id = CUPS_GET_CLASSES;
-	request->request.op.request_id   = 1;
-
-	language = cupsLangDefault();
-
-	ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_CHARSET,
-                     "attributes-charset", NULL, cupsLangEncoding(language));
-
-	ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_LANGUAGE,
-                     "attributes-natural-language", NULL, language->language);
-
-        ippAddStrings(request, IPP_TAG_OPERATION, IPP_TAG_NAME,
-	              "requested-attributes",
-		      (sizeof(requested) / sizeof(requested[0])),
-		      NULL, requested);
-
-       /*
-	* Do the request and get back a response...
-	*/
-
-	if ((response = cupsDoRequest(http, request, "/")) == NULL)
-	{
-		ZERODEBUG(0,("Unable to get printer list - %s\n",
-			 ippErrorString(cupsLastError())));
-		httpClose(http);
-		return;
-	}
-
-	for (attr = response->attrs; attr != NULL;)
-	{
-	       /*
-		* Skip leading attributes until we hit a printer...
-		*/
-
-		while (attr != NULL && attr->group_tag != IPP_TAG_PRINTER)
-			attr = attr->next;
-
-		if (attr == NULL)
-        		break;
-
-	       /*
-		* Pull the needed attributes from this printer...
-		*/
-
-		name       = NULL;
-		make_model = NULL;
-		info       = NULL;
-
-		while (attr != NULL && attr->group_tag == IPP_TAG_PRINTER)
-		{
-        		if (strcmp(attr->name, "printer-name") == 0 &&
-			    attr->value_tag == IPP_TAG_NAME)
-				name = attr->values[0].string.text;
-
-        		if (strcmp(attr->name, "printer-make-and-model") == 0 &&
-			    attr->value_tag == IPP_TAG_TEXT)
-				make_model = attr->values[0].string.text;
-
-        		if (strcmp(attr->name, "printer-info") == 0 &&
-			    attr->value_tag == IPP_TAG_TEXT)
-				info = attr->values[0].string.text;
-
-        		attr = attr->next;
-		}
-
-	       /*
-		* See if we have everything needed...
-		*/
-
-		if (name == NULL)
-			break;
-
- 		if (info == NULL || !info[0])
-			(*fn)(name, make_model);
-		else
-			(*fn)(name, info);
-		
-
-	}
-
-	ippDelete(response);
-
-       /*
-        * Close the connection to the server...
-	*/
-
-	httpClose(http);
-}
-
-
-/*
- * 'cups_printername_ok()' - Provide the equivalent of pcap_printername_ok()
- *                           for CUPS.
- * O - 1 if printer name OK
- * I - Name of printer 
- */
-int cups_printername_ok(const char *name)
-{
-	http_t		*http;		/* HTTP connection to server */
-	ipp_t		*request,	/* IPP Request */
-			*response;	/* IPP Response */
-	cups_lang_t	*language;	/* Default language */
-	char		uri[HTTP_MAX_URI]; /* printer-uri attribute */
-
-
-	DEBUG(5,("cups_printername_ok(\"%s\")\n", name));
-
-       /*
-        * Make sure we don't ask for passwords...
-	*/
-
-        cupsSetPasswordCB(cups_passwd_cb);
-
-       /*
-	* Try to connect to the server...
-	*/
-
-	if ((http = httpConnect(cupsServer(), ippPort())) == NULL)
-	{
-		ZERODEBUG(0,("Unable to connect to CUPS server %s - %s\n", 
-			 cupsServer(), strerror(errno)));
-		return (0);
-	}
-
-       /*
-	* Build an IPP_GET_PRINTER_ATTRS request, which requires the following
-	* attributes:
-	*
-	*    attributes-charset
-	*    attributes-natural-language
-	*    requested-attributes
-	*    printer-uri
-	*/
-
-	request = ippNew();
-
-	request->request.op.operation_id = IPP_GET_PRINTER_ATTRIBUTES;
-	request->request.op.request_id   = 1;
-
-	language = cupsLangDefault();
-
-	ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_CHARSET,
-                     "attributes-charset", NULL, cupsLangEncoding(language));
-
-	ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_LANGUAGE,
-                     "attributes-natural-language", NULL, language->language);
-
-	ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_NAME,
-                     "requested-attributes", NULL, "printer-uri");
-
-	slprintf(uri, sizeof(uri) - 1, "ipp://localhost/printers/%s", name);
-
-	ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_URI,
-                     "printer-uri", NULL, uri);
-
-       /*
-	* Do the request and get back a response...
-	*/
-
-	if ((response = cupsDoRequest(http, request, "/")) == NULL)
-	{
-		ZERODEBUG(0,("Unable to get printer status for %s - %s\n", name,
-			 ippErrorString(cupsLastError())));
-		httpClose(http);
-		return (0);
-	}
-
-	httpClose(http);
-
-	if (response->request.status.status_code >= IPP_OK_CONFLICT)
-	{
-		ZERODEBUG(0,("Unable to get printer status for %s - %s\n", name,
-			 ippErrorString(response->request.status.status_code)));
-		ippDelete(response);
-		return (0);
-	}
-	else
-	{
-		ippDelete(response);
-		return (1);
-	}
-}
-
-
-/*
- * 'cups_job_delete()' - Delete a job.
- */
-
-static int
-cups_job_delete(int snum, struct printjob *pjob)
-{
-	int		ret;		/* Return value */
-	http_t		*http;		/* HTTP connection to server */
-	ipp_t		*request,	/* IPP Request */
-			*response;	/* IPP Response */
-	cups_lang_t	*language;	/* Default language */
-	char		uri[HTTP_MAX_URI]; /* printer-uri attribute */
-
-
-	DEBUG(5,("cups_job_delete(%d, %p (%d))\n", snum, pjob, pjob->sysjob));
-
-       /*
-        * Make sure we don't ask for passwords...
-	*/
-
-        cupsSetPasswordCB(cups_passwd_cb);
-
-       /*
-	* Try to connect to the server...
-	*/
-
-	if ((http = httpConnect(cupsServer(), ippPort())) == NULL)
-	{
-		ZERODEBUG(0,("Unable to connect to CUPS server %s - %s\n", 
-			 cupsServer(), strerror(errno)));
-		return (1);
-	}
-
-       /*
-	* Build an IPP_CANCEL_JOB request, which requires the following
-	* attributes:
-	*
-	*    attributes-charset
-	*    attributes-natural-language
-	*    job-uri
-	*    requesting-user-name
-	*/
-
-	request = ippNew();
-
-	request->request.op.operation_id = IPP_CANCEL_JOB;
-	request->request.op.request_id   = 1;
-
-	language = cupsLangDefault();
-
-	ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_CHARSET,
-        	     "attributes-charset", NULL, cupsLangEncoding(language));
-
-	ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_LANGUAGE,
-        	     "attributes-natural-language", NULL, language->language);
-
-	slprintf(uri, sizeof(uri) - 1, "ipp://localhost/jobs/%d", pjob->sysjob);
-
-	ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_URI, "job-uri", NULL, uri);
-
-	ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_NAME, "requesting-user-name",
-        	     NULL, pjob->user);
-
-       /*
-	* Do the request and get back a response...
-	*/
-
-        ret = 1;
-
-	if ((response = cupsDoRequest(http, request, "/jobs")) != NULL)
-	{
-	  if (response->request.status.status_code >= IPP_OK_CONFLICT)
-		ZERODEBUG(0,("Unable to cancel job %d - %s\n", pjob->sysjob,
-			 ippErrorString(cupsLastError())));
-          else
-	  	ret = 0;
-
-	  ippDelete(response);
-	}
-	else
-	  ZERODEBUG(0,("Unable to cancel job %d - %s\n", pjob->sysjob,
-		   ippErrorString(cupsLastError())));
-
-	httpClose(http);
-
-	return (ret);
-}
-
-
-/*
- * 'cups_job_pause()' - Pause a job.
- */
-
-static int
-cups_job_pause(int snum, struct printjob *pjob)
-{
-	int		ret;		/* Return value */
-	http_t		*http;		/* HTTP connection to server */
-	ipp_t		*request,	/* IPP Request */
-			*response;	/* IPP Response */
-	cups_lang_t	*language;	/* Default language */
-	char		uri[HTTP_MAX_URI]; /* printer-uri attribute */
-
-
-	DEBUG(5,("cups_job_pause(%d, %p (%d))\n", snum, pjob, pjob->sysjob));
-
-       /*
-        * Make sure we don't ask for passwords...
-	*/
-
-        cupsSetPasswordCB(cups_passwd_cb);
-
-       /*
-	* Try to connect to the server...
-	*/
-
-	if ((http = httpConnect(cupsServer(), ippPort())) == NULL)
-	{
-		ZERODEBUG(0,("Unable to connect to CUPS server %s - %s\n", 
-			 cupsServer(), strerror(errno)));
-		return (1);
-	}
-
-       /*
-	* Build an IPP_HOLD_JOB request, which requires the following
-	* attributes:
-	*
-	*    attributes-charset
-	*    attributes-natural-language
-	*    job-uri
-	*    requesting-user-name
-	*/
-
-	request = ippNew();
-
-	request->request.op.operation_id = IPP_HOLD_JOB;
-	request->request.op.request_id   = 1;
-
-	language = cupsLangDefault();
-
-	ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_CHARSET,
-        	     "attributes-charset", NULL, cupsLangEncoding(language));
-
-	ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_LANGUAGE,
-        	     "attributes-natural-language", NULL, language->language);
-
-	slprintf(uri, sizeof(uri) - 1, "ipp://localhost/jobs/%d", pjob->sysjob);
-
-	ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_URI, "job-uri", NULL, uri);
-
-	ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_NAME, "requesting-user-name",
-        	     NULL, pjob->user);
-
-       /*
-	* Do the request and get back a response...
-	*/
-
-        ret = 1;
-
-	if ((response = cupsDoRequest(http, request, "/jobs")) != NULL)
-	{
-	  if (response->request.status.status_code >= IPP_OK_CONFLICT)
-		ZERODEBUG(0,("Unable to hold job %d - %s\n", pjob->sysjob,
-			 ippErrorString(cupsLastError())));
-          else
-	  	ret = 0;
-
-	  ippDelete(response);
-	}
-	else
-	  ZERODEBUG(0,("Unable to hold job %d - %s\n", pjob->sysjob,
-		   ippErrorString(cupsLastError())));
-
-	httpClose(http);
-
-	return (ret);
-}
-
-
-/*
- * 'cups_job_resume()' - Resume a paused job.
- */
-
-static int
-cups_job_resume(int snum, struct printjob *pjob)
-{
-	int		ret;		/* Return value */
-	http_t		*http;		/* HTTP connection to server */
-	ipp_t		*request,	/* IPP Request */
-			*response;	/* IPP Response */
-	cups_lang_t	*language;	/* Default language */
-	char		uri[HTTP_MAX_URI]; /* printer-uri attribute */
-
-
-	DEBUG(5,("cups_job_resume(%d, %p (%d))\n", snum, pjob, pjob->sysjob));
-
-       /*
-        * Make sure we don't ask for passwords...
-	*/
-
-        cupsSetPasswordCB(cups_passwd_cb);
-
-       /*
-	* Try to connect to the server...
-	*/
-
-	if ((http = httpConnect(cupsServer(), ippPort())) == NULL)
-	{
-		ZERODEBUG(0,("Unable to connect to CUPS server %s - %s\n", 
-			 cupsServer(), strerror(errno)));
-		return (1);
-	}
-
-       /*
-	* Build an IPP_RELEASE_JOB request, which requires the following
-	* attributes:
-	*
-	*    attributes-charset
-	*    attributes-natural-language
-	*    job-uri
-	*    requesting-user-name
-	*/
-
-	request = ippNew();
-
-	request->request.op.operation_id = IPP_RELEASE_JOB;
-	request->request.op.request_id   = 1;
-
-	language = cupsLangDefault();
-
-	ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_CHARSET,
-        	     "attributes-charset", NULL, cupsLangEncoding(language));
-
-	ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_LANGUAGE,
-        	     "attributes-natural-language", NULL, language->language);
-
-	slprintf(uri, sizeof(uri) - 1, "ipp://localhost/jobs/%d", pjob->sysjob);
-
-	ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_URI, "job-uri", NULL, uri);
-
-	ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_NAME, "requesting-user-name",
-        	     NULL, pjob->user);
-
-       /*
-	* Do the request and get back a response...
-	*/
-
-        ret = 1;
-
-	if ((response = cupsDoRequest(http, request, "/jobs")) != NULL)
-	{
-	  if (response->request.status.status_code >= IPP_OK_CONFLICT)
-		ZERODEBUG(0,("Unable to release job %d - %s\n", pjob->sysjob,
-			 ippErrorString(cupsLastError())));
-          else
-	  	ret = 0;
-
-	  ippDelete(response);
-	}
-	else
-	  ZERODEBUG(0,("Unable to release job %d - %s\n", pjob->sysjob,
-		   ippErrorString(cupsLastError())));
-
-	httpClose(http);
-
-	return (ret);
-}
-
-
-/*
- * 'cups_job_submit()' - Submit a job for printing.
- */
-
-static int
-cups_job_submit(int snum, struct printjob *pjob)
-{
-	int		ret;		/* Return value */
-	http_t		*http;		/* HTTP connection to server */
-	ipp_t		*request,	/* IPP Request */
-			*response;	/* IPP Response */
-	cups_lang_t	*language;	/* Default language */
-	char		uri[HTTP_MAX_URI]; /* printer-uri attribute */
-
-
-	DEBUG(5,("cups_job_submit(%d, %p (%d))\n", snum, pjob, pjob->sysjob));
-
-       /*
-        * Make sure we don't ask for passwords...
-	*/
-
-        cupsSetPasswordCB(cups_passwd_cb);
-
-       /*
-	* Try to connect to the server...
-	*/
-
-	if ((http = httpConnect(cupsServer(), ippPort())) == NULL)
-	{
-		ZERODEBUG(0,("Unable to connect to CUPS server %s - %s\n", 
-			 cupsServer(), strerror(errno)));
-		return (1);
-	}
-
-       /*
-	* Build an IPP_PRINT_JOB request, which requires the following
-	* attributes:
-	*
-	*    attributes-charset
-	*    attributes-natural-language
-	*    printer-uri
-	*    requesting-user-name
-	*    [document-data]
-	*/
-
-	request = ippNew();
-
-	request->request.op.operation_id = IPP_PRINT_JOB;
-	request->request.op.request_id   = 1;
-
-	language = cupsLangDefault();
-
-	ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_CHARSET,
-        	     "attributes-charset", NULL, cupsLangEncoding(language));
-
-	ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_LANGUAGE,
-        	     "attributes-natural-language", NULL, language->language);
-
-	slprintf(uri, sizeof(uri) - 1, "ipp://localhost/printers/%s",
-	         PRINTERNAME(snum));
-
-	ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_URI,
-        	     "printer-uri", NULL, uri);
-
-	ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_NAME, "requesting-user-name",
-        	     NULL, pjob->user);
-
-	ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_NAME,
-	             "job-originating-host-name", NULL,
-		     get_remote_machine_name());
-
-	ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_NAME, "job-name", NULL,
-        	     pjob->jobname);
-
-       /*
-	* Do the request and get back a response...
-	*/
-
-	slprintf(uri, sizeof(uri) - 1, "/printers/%s", PRINTERNAME(snum));
-
-        ret = 1;
-	if ((response = cupsDoFileRequest(http, request, uri,
-	                                  pjob->filename)) != NULL)
-	{
-		if (response->request.status.status_code >= IPP_OK_CONFLICT)
-			ZERODEBUG(0,("Unable to print file to %s - %s\n", PRINTERNAME(snum),
-			         ippErrorString(cupsLastError())));
-        	else
-			ret = 0;
-
-		ippDelete(response);
-	}
-	else
-		ZERODEBUG(0,("Unable to print file to `%s' - %s\n", PRINTERNAME(snum),
-			 ippErrorString(cupsLastError())));
-
-	httpClose(http);
-
-	if ( ret == 0 )
-		unlink(pjob->filename);
-	/* else print_job_end will do it for us */
-
-	return (ret);
-}
-
-
-/*
- * 'cups_queue_get()' - Get all the jobs in the print queue.
- */
-
-static int
-cups_queue_get(int snum, print_queue_struct **q, print_status_struct *status)
-{
-	http_t		*http;		/* HTTP connection to server */
-	ipp_t		*request,	/* IPP Request */
-			*response;	/* IPP Response */
-	ipp_attribute_t	*attr;		/* Current attribute */
-	cups_lang_t	*language;	/* Default language */
-	char		uri[HTTP_MAX_URI]; /* printer-uri attribute */
-	int		qcount,		/* Number of active queue entries */
-			qalloc;		/* Number of queue entries allocated */
-	print_queue_struct *queue,	/* Queue entries */
-			*temp;		/* Temporary pointer for queue */
-	const char	*user_name,	/* job-originating-user-name attribute */
-			*job_name;	/* job-name attribute */
-	int		job_id;		/* job-id attribute */
-	int		job_k_octets;	/* job-k-octets attribute */
-	time_t		job_time;	/* time-at-creation attribute */
-	ipp_jstate_t	job_status;	/* job-status attribute */
-	int		job_priority;	/* job-priority attribute */
-	static const char *jattrs[] =	/* Requested job attributes */
-			{
-			  "job-id",
-			  "job-k-octets",
-			  "job-name",
-			  "job-originating-user-name",
-			  "job-priority",
-			  "job-state",
-			  "time-at-creation",
-			};
-	static const char *pattrs[] =	/* Requested printer attributes */
-			{
-			  "printer-state",
-			  "printer-state-message"
-			};
-
-
-	DEBUG(5,("cups_queue_get(%d, %p, %p)\n", snum, q, status));
-
-       /*
-        * Make sure we don't ask for passwords...
-	*/
-
-        cupsSetPasswordCB(cups_passwd_cb);
-
-       /*
-	* Try to connect to the server...
-	*/
-
-	if ((http = httpConnect(cupsServer(), ippPort())) == NULL)
-	{
-		ZERODEBUG(0,("Unable to connect to CUPS server %s - %s\n", 
-			 cupsServer(), strerror(errno)));
-		return (0);
-	}
-
-       /*
-        * Generate the printer URI...
-	*/
-
-	slprintf(uri, sizeof(uri) - 1, "ipp://localhost/printers/%s",
-	         PRINTERNAME(snum));
-
-       /*
-	* Build an IPP_GET_JOBS request, which requires the following
-	* attributes:
-	*
-	*    attributes-charset
-	*    attributes-natural-language
-	*    requested-attributes
-	*    printer-uri
-	*/
-
-	request = ippNew();
-
-	request->request.op.operation_id = IPP_GET_JOBS;
-	request->request.op.request_id   = 1;
-
-	language = cupsLangDefault();
-
-	ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_CHARSET,
-                     "attributes-charset", NULL, cupsLangEncoding(language));
-
-	ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_LANGUAGE,
-                     "attributes-natural-language", NULL, language->language);
-
-        ippAddStrings(request, IPP_TAG_OPERATION, IPP_TAG_NAME,
-	              "requested-attributes",
-		      (sizeof(jattrs) / sizeof(jattrs[0])),
-		      NULL, jattrs);
-
-	ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_URI,
-                     "printer-uri", NULL, uri);
-
-       /*
-	* Do the request and get back a response...
-	*/
-
-	if ((response = cupsDoRequest(http, request, "/")) == NULL)
-	{
-		ZERODEBUG(0,("Unable to get jobs for %s - %s\n", uri,
-			 ippErrorString(cupsLastError())));
-		httpClose(http);
-		return (0);
-	}
-
-	if (response->request.status.status_code >= IPP_OK_CONFLICT)
-	{
-		ZERODEBUG(0,("Unable to get jobs for %s - %s\n", uri,
-			 ippErrorString(response->request.status.status_code)));
-		ippDelete(response);
-		httpClose(http);
-
-		return (0);
-	}
-
-       /*
-        * Process the jobs...
-	*/
-
-        qcount = 0;
-	qalloc = 0;
-	queue  = NULL;
-
-        for (attr = response->attrs; attr != NULL; attr = attr->next)
-	{
-	       /*
-		* Skip leading attributes until we hit a job...
-		*/
-
-		while (attr != NULL && attr->group_tag != IPP_TAG_JOB)
-        		attr = attr->next;
-
-		if (attr == NULL)
-			break;
-
-	       /*
-	        * Allocate memory as needed...
-		*/
-		if (qcount >= qalloc)
-		{
-			qalloc += 16;
-
-			temp = Realloc(queue, sizeof(print_queue_struct) * qalloc);
-
-			if (temp == NULL)
-			{
-				ZERODEBUG(0,("cups_queue_get: Not enough memory!"));
-				ippDelete(response);
-				httpClose(http);
-
-				SAFE_FREE(queue);
-				return (0);
-			}
-
-			queue = temp;
-		}
-
-		temp = queue + qcount;
-		memset(temp, 0, sizeof(print_queue_struct));
-
-	       /*
-		* Pull the needed attributes from this job...
-		*/
-
-		job_id       = 0;
-		job_priority = 50;
-		job_status   = IPP_JOB_PENDING;
-		job_time     = 0;
-		job_k_octets = 0;
-		user_name    = NULL;
-		job_name     = NULL;
-
-		while (attr != NULL && attr->group_tag == IPP_TAG_JOB)
-		{
-        		if (attr->name == NULL)
-			{
-				attr = attr->next;
-				break;
-			}
-
-        		if (strcmp(attr->name, "job-id") == 0 &&
-			    attr->value_tag == IPP_TAG_INTEGER)
-				job_id = attr->values[0].integer;
-
-        		if (strcmp(attr->name, "job-k-octets") == 0 &&
-			    attr->value_tag == IPP_TAG_INTEGER)
-				job_k_octets = attr->values[0].integer;
-
-        		if (strcmp(attr->name, "job-priority") == 0 &&
-			    attr->value_tag == IPP_TAG_INTEGER)
-				job_priority = attr->values[0].integer;
-
-        		if (strcmp(attr->name, "job-state") == 0 &&
-			    attr->value_tag == IPP_TAG_ENUM)
-				job_status = (ipp_jstate_t)(attr->values[0].integer);
-
-        		if (strcmp(attr->name, "time-at-creation") == 0 &&
-			    attr->value_tag == IPP_TAG_INTEGER)
-				job_time = attr->values[0].integer;
-
-        		if (strcmp(attr->name, "job-name") == 0 &&
-			    attr->value_tag == IPP_TAG_NAME)
-				job_name = attr->values[0].string.text;
-
-        		if (strcmp(attr->name, "job-originating-user-name") == 0 &&
-			    attr->value_tag == IPP_TAG_NAME)
-				user_name = attr->values[0].string.text;
-
-        		attr = attr->next;
-		}
-
-	       /*
-		* See if we have everything needed...
-		*/
-
-		if (user_name == NULL || job_name == NULL || job_id == 0)
-		{
-        	  if (attr == NULL)
-		    break;
-		  else
-        	    continue;
-		}
-
-		temp->job      = job_id;
-		temp->size     = job_k_octets * 1024;
-		temp->status   = job_status == IPP_JOB_PENDING ? LPQ_QUEUED :
-				 job_status == IPP_JOB_STOPPED ? LPQ_PAUSED :
-                                 job_status == IPP_JOB_HELD ? LPQ_PAUSED :
-			         LPQ_PRINTING;
-		temp->priority = job_priority;
-		temp->time     = job_time;
-		strncpy(temp->fs_user, user_name, sizeof(temp->fs_user) - 1);
-		strncpy(temp->fs_file, job_name, sizeof(temp->fs_file) - 1);
-
-		qcount ++;
-
-		if (attr == NULL)
-        	  break;
-	}
-
-	ippDelete(response);
-
-       /*
-	* Build an IPP_GET_PRINTER_ATTRIBUTES request, which requires the
-	* following attributes:
-	*
-	*    attributes-charset
-	*    attributes-natural-language
-	*    requested-attributes
-	*    printer-uri
-	*/
-
-	request = ippNew();
-
-	request->request.op.operation_id = IPP_GET_PRINTER_ATTRIBUTES;
-	request->request.op.request_id   = 1;
-
-	language = cupsLangDefault();
-
-	ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_CHARSET,
-                     "attributes-charset", NULL, cupsLangEncoding(language));
-
-	ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_LANGUAGE,
-                     "attributes-natural-language", NULL, language->language);
-
-        ippAddStrings(request, IPP_TAG_OPERATION, IPP_TAG_NAME,
-	              "requested-attributes",
-		      (sizeof(pattrs) / sizeof(pattrs[0])),
-		      NULL, pattrs);
-
-	ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_URI,
-                     "printer-uri", NULL, uri);
-
-       /*
-	* Do the request and get back a response...
-	*/
-
-	if ((response = cupsDoRequest(http, request, "/")) == NULL)
-	{
-		ZERODEBUG(0,("Unable to get printer status for %s - %s\n", PRINTERNAME(snum),
-			 ippErrorString(cupsLastError())));
-		httpClose(http);
-		*q = queue;
-		return (qcount);
-	}
-
-	if (response->request.status.status_code >= IPP_OK_CONFLICT)
-	{
-		ZERODEBUG(0,("Unable to get printer status for %s - %s\n", PRINTERNAME(snum),
-			 ippErrorString(response->request.status.status_code)));
-		ippDelete(response);
-		httpClose(http);
-		*q = queue;
-		return (qcount);
-	}
-
-       /*
-        * Get the current printer status and convert it to the SAMBA values.
-	*/
-
-        if ((attr = ippFindAttribute(response, "printer-state", IPP_TAG_ENUM)) != NULL)
-	{
-		if (attr->values[0].integer == IPP_PRINTER_STOPPED)
-			status->status = LPSTAT_STOPPED;
-		else
-			status->status = LPSTAT_OK;
-	}
-
-        if ((attr = ippFindAttribute(response, "printer-state-message",
-	                             IPP_TAG_TEXT)) != NULL)
-	        fstrcpy(status->message, attr->values[0].string.text);
-
-        ippDelete(response);
-
-       /*
-        * Return the job queue...
-	*/
-
-	httpClose(http);
-
-	*q = queue;
-	return (qcount);
-}
-
-
-/*
- * 'cups_queue_pause()' - Pause a print queue.
- */
-
-static int
-cups_queue_pause(int snum)
-{
-	extern userdom_struct current_user_info;
-	int		ret;		/* Return value */
-	http_t		*http;		/* HTTP connection to server */
-	ipp_t		*request,	/* IPP Request */
-			*response;	/* IPP Response */
-	cups_lang_t	*language;	/* Default language */
-	char		uri[HTTP_MAX_URI]; /* printer-uri attribute */
-
-
-	DEBUG(5,("cups_queue_pause(%d)\n", snum));
-
-	/*
-	 * Make sure we don't ask for passwords...
-	 */
-
-        cupsSetPasswordCB(cups_passwd_cb);
-
-	/*
-	 * Try to connect to the server...
-	 */
-
-	if ((http = httpConnect(cupsServer(), ippPort())) == NULL)
-	{
-		ZERODEBUG(0,("Unable to connect to CUPS server %s - %s\n", 
-			 cupsServer(), strerror(errno)));
-		return (1);
-	}
-
-	/*
-	 * Build an IPP_PAUSE_PRINTER request, which requires the following
-	 * attributes:
-	 *
-	 *    attributes-charset
-	 *    attributes-natural-language
-	 *    printer-uri
-	 *    requesting-user-name
-	 */
-
-	request = ippNew();
-
-	request->request.op.operation_id = IPP_PAUSE_PRINTER;
-	request->request.op.request_id   = 1;
-
-	language = cupsLangDefault();
-
-	ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_CHARSET,
-        	     "attributes-charset", NULL, cupsLangEncoding(language));
-
-	ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_LANGUAGE,
-        	     "attributes-natural-language", NULL, language->language);
-
-	slprintf(uri, sizeof(uri) - 1, "ipp://localhost/printers/%s",
-	         PRINTERNAME(snum));
-
-	ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_URI, "printer-uri", NULL, uri);
-
-	ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_NAME, "requesting-user-name",
-        	     NULL, current_user_info.unix_name);
-
-       /*
-	* Do the request and get back a response...
-	*/
-
-        ret = 1;
-
-	if ((response = cupsDoRequest(http, request, "/admin/")) != NULL)
-	{
-	  if (response->request.status.status_code >= IPP_OK_CONFLICT)
-		ZERODEBUG(0,("Unable to pause printer %s - %s\n", PRINTERNAME(snum),
-			 ippErrorString(cupsLastError())));
-          else
-	  	ret = 0;
-
-	  ippDelete(response);
-	}
-	else
-	  ZERODEBUG(0,("Unable to pause printer %s - %s\n", PRINTERNAME(snum),
-		   ippErrorString(cupsLastError())));
-
-	httpClose(http);
-
-	return (ret);
-}
-
-
-/*
- * 'cups_queue_resume()' - Restart a print queue.
- */
-
-static int
-cups_queue_resume(int snum)
-{
-	extern userdom_struct current_user_info;
-	int		ret;		/* Return value */
-	http_t		*http;		/* HTTP connection to server */
-	ipp_t		*request,	/* IPP Request */
-			*response;	/* IPP Response */
-	cups_lang_t	*language;	/* Default language */
-	char		uri[HTTP_MAX_URI]; /* printer-uri attribute */
-
-
-	DEBUG(5,("cups_queue_resume(%d)\n", snum));
-
-       /*
-        * Make sure we don't ask for passwords...
-	*/
-
-        cupsSetPasswordCB(cups_passwd_cb);
-
-       /*
-	* Try to connect to the server...
-	*/
-
-	if ((http = httpConnect(cupsServer(), ippPort())) == NULL)
-	{
-		ZERODEBUG(0,("Unable to connect to CUPS server %s - %s\n", 
-			 cupsServer(), strerror(errno)));
-		return (1);
-	}
-
-       /*
-	* Build an IPP_RESUME_PRINTER request, which requires the following
-	* attributes:
-	*
-	*    attributes-charset
-	*    attributes-natural-language
-	*    printer-uri
-	*    requesting-user-name
-	*/
-
-	request = ippNew();
-
-	request->request.op.operation_id = IPP_RESUME_PRINTER;
-	request->request.op.request_id   = 1;
-
-	language = cupsLangDefault();
-
-	ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_CHARSET,
-        	     "attributes-charset", NULL, cupsLangEncoding(language));
-
-	ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_LANGUAGE,
-        	     "attributes-natural-language", NULL, language->language);
-
-	slprintf(uri, sizeof(uri) - 1, "ipp://localhost/printers/%s",
-	         PRINTERNAME(snum));
-
-	ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_URI, "printer-uri", NULL, uri);
-
-	ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_NAME, "requesting-user-name",
-        	     NULL, current_user_info.unix_name);
-
-       /*
-	* Do the request and get back a response...
-	*/
-
-        ret = 1;
-
-	if ((response = cupsDoRequest(http, request, "/admin/")) != NULL)
-	{
-	  if (response->request.status.status_code >= IPP_OK_CONFLICT)
-		ZERODEBUG(0,("Unable to resume printer %s - %s\n", PRINTERNAME(snum),
-			 ippErrorString(cupsLastError())));
-          else
-	  	ret = 0;
-
-	  ippDelete(response);
-	}
-	else
-	  ZERODEBUG(0,("Unable to resume printer %s - %s\n", PRINTERNAME(snum),
-		   ippErrorString(cupsLastError())));
-
-	httpClose(http);
-
-	return (ret);
-}
-
-
-#else
- /* this keeps fussy compilers happy */
- void print_cups_dummy(void) {}
-#endif /* HAVE_CUPS */
diff -Naur samba-2.2.12-orig/source/printing/printfsp.c samba-2.2.12/source/printing/printfsp.c
--- samba-2.2.12-orig/source/printing/printfsp.c	2004-08-12 20:24:22.000000000 +0200
+++ samba-2.2.12/source/printing/printfsp.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,105 +0,0 @@
-/* 
-   Unix SMB/Netbios implementation.
-   Version 3.0
-   printing backend routines for smbd - using files_struct rather
-   than only snum
-   Copyright (C) Andrew Tridgell 1992-2000
-   
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2 of the License, or
-   (at your option) any later version.
-   
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-   
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-*/
-
-#include "includes.h"
-
-/***************************************************************************
-open a print file and setup a fsp for it. This is a wrapper around
-print_job_start().
-***************************************************************************/
-
-files_struct *print_fsp_open(connection_struct *conn, char *fname)
-{
-	int jobid;
-	SMB_STRUCT_STAT sbuf;
-	extern struct current_user current_user;
-	files_struct *fsp = file_new(conn);
-	fstring name;
-
-	if(!fsp)
-		return NULL;
-
-	fstrcpy( name, "Remote Downlevel Document");
-	if (fname) {
-		char *p = strrchr(fname, '/');
-		fstrcat(name, " ");
-		if (!p)
-			p = fname;
-		fstrcat(name, p);
-	}
-
-	jobid = print_job_start(&current_user, SNUM(conn), name);
-	if (jobid == -1) {
-		file_free(fsp);
-		return NULL;
-	}
-
-	/* setup a full fsp */
-	fsp->print_jobid = jobid;
-	fsp->fd = print_job_fd(jobid);
-	GetTimeOfDay(&fsp->open_time);
-	fsp->vuid = current_user.vuid;
-	fsp->size = 0;
-	fsp->pos = -1;
-	fsp->can_lock = True;
-	fsp->can_read = False;
-	fsp->can_write = True;
-	fsp->share_mode = 0;
-	fsp->print_file = True;
-	fsp->modified = False;
-	fsp->oplock_type = NO_OPLOCK;
-	fsp->sent_oplock_break = NO_BREAK_SENT;
-	fsp->is_directory = False;
-	fsp->directory_delete_on_close = False;
-	fsp->conn = conn;
-	string_set(&fsp->fsp_name,print_job_fname(jobid));
-	fsp->wbmpx_ptr = NULL;      
-	fsp->wcp = NULL; 
-	conn->vfs_ops.fstat(fsp,fsp->fd, &sbuf);
-	fsp->mode = sbuf.st_mode;
-	fsp->inode = sbuf.st_ino;
-	fsp->dev = sbuf.st_dev;
-
-	conn->num_files_open++;
-
-	return fsp;
-}
-
-/****************************************************************************
-print a file - called on closing the file
-****************************************************************************/
-void print_fsp_end(files_struct *fsp, BOOL normal_close)
-{
-	if (fsp->share_mode == FILE_DELETE_ON_CLOSE) {
-		/*
-		 * Truncate the job. print_job_end will take
-		 * care of deleting it for us. JRA.
-		 */
-		sys_ftruncate(fsp->fd, 0);
-	}
-
-	print_job_end(fsp->print_jobid, normal_close);
-
-	if (fsp->fsp_name) {
-		string_free(&fsp->fsp_name);
-	}
-}
diff -Naur samba-2.2.12-orig/source/printing/print_generic.c samba-2.2.12/source/printing/print_generic.c
--- samba-2.2.12-orig/source/printing/print_generic.c	2011-03-04 13:51:45.000000000 +0100
+++ samba-2.2.12/source/printing/print_generic.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,252 +0,0 @@
-/* 
-   Unix SMB/Netbios implementation.
-   Version 3.0
-   printing command routines
-   Copyright (C) Andrew Tridgell 1992-2000
-   
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2 of the License, or
-   (at your option) any later version.
-   
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-   
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-*/
-
-#include "printing.h"
-
-
-/*
- * Generic printing interface definitions...
- */
-
-static int generic_job_delete(int snum, struct printjob *pjob);
-static int generic_job_pause(int snum, struct printjob *pjob);
-static int generic_job_resume(int snum, struct printjob *pjob);
-static int generic_job_submit(int snum, struct printjob *pjob);
-static int generic_queue_get(int snum, print_queue_struct **q,
-                             print_status_struct *status);
-static int generic_queue_pause(int snum);
-static int generic_queue_resume(int snum);
-
-
-struct printif	generic_printif =
-		{
-		  generic_queue_get,
-		  generic_queue_pause,
-		  generic_queue_resume,
-		  generic_job_delete,
-		  generic_job_pause,
-		  generic_job_resume,
-		  generic_job_submit,
-		};
-
-/****************************************************************************
-run a given print command 
-a null terminated list of value/substitute pairs is provided
-for local substitution strings
-****************************************************************************/
-static int print_run_command(int snum,char *command, int *outfd, ...)
-{
-
-	pstring syscmd;
-	char *p, *arg;
-	int ret;
-	va_list ap;
-	va_start(ap, outfd);
-
-	if (!command || !*command) return -1;
-
-	if (!VALID_SNUM(snum)) {
-		ZERODEBUG(0,("Invalid snum %d for command %s\n", snum, command));
-		return -1;
-	}
-
-	pstrcpy(syscmd, command);
-
-	while ((arg = va_arg(ap, char *))) {
-		char *value = va_arg(ap,char *);
-		pstring_sub(syscmd, arg, value);
-	}
-	va_end(ap);
-  
-	p = PRINTERNAME(snum);
-  
-	pstring_sub(syscmd, "%p", p);
-	standard_sub_snum(snum,syscmd,sizeof(syscmd));
-
-	/* Convert script args to unix-codepage */
-	dos_to_unix(syscmd);
-	ret = smbrun(syscmd,outfd);
-
-	DEBUG(3,("Running the command `%s' gave %d\n",syscmd,ret));
-
-	return ret;
-}
-
-
-/****************************************************************************
-delete a print job
-****************************************************************************/
-static int generic_job_delete(int snum, struct printjob *pjob)
-{
-	fstring jobstr;
-
-	/* need to delete the spooled entry */
-	slprintf(jobstr, sizeof(jobstr)-1, "%d", pjob->sysjob);
-	return print_run_command(
-		   snum, 
-		   lp_lprmcommand(snum), NULL,
-		   "%j", jobstr,
-		   "%T", http_timestring(pjob->starttime),
-		   NULL);
-}
-
-/****************************************************************************
-pause a job
-****************************************************************************/
-static int generic_job_pause(int snum, struct printjob *pjob)
-{
-	fstring jobstr;
-	
-	/* need to pause the spooled entry */
-	slprintf(jobstr, sizeof(jobstr)-1, "%d", pjob->sysjob);
-	return print_run_command(snum, 
-				 lp_lppausecommand(snum), NULL,
-				 "%j", jobstr,
-				 NULL);
-}
-
-/****************************************************************************
-resume a job
-****************************************************************************/
-static int generic_job_resume(int snum, struct printjob *pjob)
-{
-	fstring jobstr;
-	
-	/* need to pause the spooled entry */
-	slprintf(jobstr, sizeof(jobstr)-1, "%d", pjob->sysjob);
-	return print_run_command(snum, 
-				 lp_lpresumecommand(snum), NULL,
-				 "%j", jobstr,
-				 NULL);
-}
-
-/****************************************************************************
- Submit a file for printing - called from print_job_end()
-****************************************************************************/
-
-static int generic_job_submit(int snum, struct printjob *pjob)
-{
-	int ret;
-	pstring current_directory;
-	pstring print_directory;
-	char *wd, *p;
-	pstring jobname;
-	fstring job_page_count, job_size;
-
-	/* we print from the directory path to give the best chance of
-           parsing the lpq output */
-	wd = sys_getwd(current_directory);
-	if (!wd)
-		return 0;
-
-	pstrcpy(print_directory, pjob->filename);
-	p = strrchr(print_directory,'/');
-	if (!p)
-		return 0;
-	*p++ = 0;
-
-	if (chdir(print_directory) != 0)
-		return 0;
-
-	pstrcpy(jobname, pjob->jobname);
-	pstring_sub(jobname, "'", "_");
-	slprintf(job_page_count, sizeof(job_page_count)-1, "%d", pjob->page_count);
-	slprintf(job_size, sizeof(job_size)-1, "%d", pjob->size);
-
-	/* send it to the system spooler */
-	ret = print_run_command(snum, 
-			  lp_printcommand(snum), NULL,
-			  "%s", p,
-  			  "%J", jobname,
-			  "%f", p,
-			  "%z", job_size,
-			  "%c", job_page_count,
-			  NULL);
-
-	chdir(wd);
-
-        return ret;
-}
-
-
-/****************************************************************************
-get the current list of queued jobs
-****************************************************************************/
-static int generic_queue_get(int snum, print_queue_struct **q, print_status_struct *status)
-{
-	char **qlines;
-	int fd;
-	int numlines, i, qcount;
-	print_queue_struct *queue = NULL;
-	fstring printer_name;
-              
-	/* Convert printer name (i.e. share name) to unix-codepage */
-	fstrcpy(printer_name, lp_servicename(snum));
-	dos_to_unix(printer_name);
-	
-	print_run_command(snum, lp_lpqcommand(snum), &fd, NULL);
-
-	if (fd == -1) {
-		DEBUG(5,("generic_queue_get: Can't read print queue status for printer %s\n",
-			printer_name ));
-		return 0;
-	}
-	
-	numlines = 0;
-	qlines = fd_lines_load(fd, &numlines, True);
-	close(fd);
-
-	/* turn the lpq output into a series of job structures */
-	qcount = 0;
-	ZERO_STRUCTP(status);
-	if (numlines)
-		queue = (print_queue_struct *)malloc(sizeof(print_queue_struct)*(numlines+1));
-
-	if (queue) {
-		for (i=0; i<numlines; i++) {
-			/* parse the line */
-			if (parse_lpq_entry(snum,qlines[i],
-					    &queue[qcount],status,qcount==0)) {
-				qcount++;
-			}
-		}		
-	}
-	file_lines_free(qlines);
-
-        *q = queue;
-	return qcount;
-}
-
-/****************************************************************************
- pause a queue
-****************************************************************************/
-static int generic_queue_pause(int snum)
-{
-	return print_run_command(snum, lp_queuepausecommand(snum), NULL, NULL);
-}
-
-/****************************************************************************
- resume a queue
-****************************************************************************/
-static int generic_queue_resume(int snum)
-{
-	return print_run_command(snum, lp_queueresumecommand(snum), NULL, NULL);
-}
diff -Naur samba-2.2.12-orig/source/printing/printing.c samba-2.2.12/source/printing/printing.c
--- samba-2.2.12-orig/source/printing/printing.c	2011-03-04 13:51:45.000000000 +0100
+++ samba-2.2.12/source/printing/printing.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1454 +0,0 @@
-/* 
-   Unix SMB/Netbios implementation.
-   Version 3.0
-   printing backend routines
-   Copyright (C) Andrew Tridgell 1992-2000
-   
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2 of the License, or
-   (at your option) any later version.
-   
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-   
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-*/
-
-#include "printing.h"
-
-/* Current printer interface */
-struct printif *current_printif = &generic_printif;
-
-/* 
-   the printing backend revolves around a tdb database that stores the
-   SMB view of the print queue 
-   
-   The key for this database is a jobid - a internally generated number that
-   uniquely identifies a print job
-
-   reading the print queue involves two steps:
-     - possibly running lpq and updating the internal database from that
-     - reading entries from the database
-
-   jobids are assigned when a job starts spooling. 
-*/
-
-/* the open printing.tdb database */
-static TDB_CONTEXT *tdb;
-static pid_t local_pid;
-
-static int get_queue_status(int, print_status_struct *);
-
-/****************************************************************************
- Initialise the printing backend. Called once at startup. 
- Does not survive a fork
-****************************************************************************/
-
-BOOL print_backend_init(void)
-{
-	const char *sversion = "INFO/version";
-
-	if (tdb && local_pid == sys_getpid())
-		return True;
-	tdb = tdb_open_log(lock_path("printing.tdb"), 0, TDB_DEFAULT, O_RDWR|O_CREAT, 0600);
-	if (!tdb) {
-		ZERODEBUG(0,("print_backend_init: Failed to open printing backend database %s.\n",
-					lock_path("printing.tdb") ));
-		return False;
-	}
-	local_pid = sys_getpid();
-
-	/* handle a Samba upgrade */
-	tdb_lock_bystring(tdb, sversion, 0);
-	if (tdb_fetch_int32(tdb, sversion) != PRINT_DATABASE_VERSION) {
-		tdb_traverse(tdb, tdb_traverse_delete_fn, NULL);
-		tdb_store_int32(tdb, sversion, PRINT_DATABASE_VERSION);
-	}
-	tdb_unlock_bystring(tdb, sversion);
-
-	/* select the appropriate printing interface... */
-#ifdef HAVE_CUPS
-	if (strcmp(lp_printcapname(), "cups") == 0)
-		current_printif = &cups_printif;
-#endif /* HAVE_CUPS */
-
-	/* do NT print initialization... */
-	return nt_printing_init();
-}
-
-/****************************************************************************
- Useful function to generate a tdb key.
-****************************************************************************/
-
-static TDB_DATA print_key(int jobid)
-{
-	static int j;
-	TDB_DATA ret;
-
-	j = jobid;
-	ret.dptr = (void *)&j;
-	ret.dsize = sizeof(j);
-	return ret;
-}
-
-/****************************************************************************
- Useful function to find a print job in the database.
-****************************************************************************/
-
-static struct printjob *print_job_find(int jobid)
-{
-	static struct printjob pjob;
-	TDB_DATA ret;
-
-	ret = tdb_fetch(tdb, print_key(jobid));
-	if (!ret.dptr || ret.dsize != sizeof(pjob))
-		return NULL;
-
-	memcpy(&pjob, ret.dptr, sizeof(pjob));
-	SAFE_FREE(ret.dptr);
-	unix_to_dos(pjob.queuename);
-	return &pjob;
-}
-
-/****************************************************************************
- Store a job structure back to the database.
-****************************************************************************/
-
-static BOOL print_job_store(int jobid, struct printjob *pjob)
-{
-	TDB_DATA d;
-	BOOL ret;
-
-	dos_to_unix(pjob->queuename);
-	d.dptr = (void *)pjob;
-	d.dsize = sizeof(*pjob);
-	ret = (tdb_store(tdb, print_key(jobid), d, TDB_REPLACE) == 0);
-	unix_to_dos(pjob->queuename);
-	return ret;
-}
-
-/****************************************************************************
- Parse a file name from the system spooler to generate a jobid.
-****************************************************************************/
-
-static int print_parse_jobid(char *fname)
-{
-	int jobid;
-
-	if (strncmp(fname,PRINT_SPOOL_PREFIX,strlen(PRINT_SPOOL_PREFIX)) != 0)
-		return -1;
-	fname += strlen(PRINT_SPOOL_PREFIX);
-
-	jobid = atoi(fname);
-	if (jobid <= 0)
-		return -1;
-
-	return jobid;
-}
-
-/****************************************************************************
- List a unix job in the print database.
-****************************************************************************/
-
-static void print_unix_job(int snum, print_queue_struct *q)
-{
-	int jobid = q->job + UNIX_JOB_START;
-	struct printjob pj, *old_pj;
-
-	/* Preserve the timestamp on an existing unix print job */
-
-	old_pj = print_job_find(jobid);
-
-	ZERO_STRUCT(pj);
-
-	pj.pid = (pid_t)-1;
-	pj.sysjob = q->job;
-	pj.fd = -1;
-	pj.starttime = old_pj ? old_pj->starttime : q->time;
-	pj.status = q->status;
-	pj.size = q->size;
-	pj.spooled = True;
-	pj.smbjob = False;
-	fstrcpy(pj.filename, "");
-	fstrcpy(pj.jobname, q->fs_file);
-	fstrcpy(pj.user, q->fs_user);
-	fstrcpy(pj.queuename, lp_servicename(snum));
-
-	print_job_store(jobid, &pj);
-}
-
-
-struct traverse_struct {
-	print_queue_struct *queue;
-	int qcount, snum, maxcount, total_jobs;
-	time_t lpq_time;
-};
-
-/****************************************************************************
- Utility fn to delete any jobs that are no longer active.
-****************************************************************************/
-
-static int traverse_fn_delete(TDB_CONTEXT *t, TDB_DATA key, TDB_DATA data, void *state)
-{
-	struct traverse_struct *ts = (struct traverse_struct *)state;
-	struct printjob pjob;
-	int i, jobid;
-
-	if (data.dsize != sizeof(pjob) || key.dsize != sizeof(int))
-		return 0;
-	memcpy(&jobid, key.dptr, sizeof(jobid));
-	memcpy(&pjob,  data.dptr, sizeof(pjob));
-	unix_to_dos(pjob.queuename);
-
-	if (ts->snum != lp_servicenumber(pjob.queuename)) {
-		/* this isn't for the queue we are looking at */
-		ts->total_jobs++;
-		return 0;
-	}
-
-	if (!pjob.smbjob) {
-		/* remove a unix job if it isn't in the system queue any more */
-
-		for (i=0;i<ts->qcount;i++) {
-			if (jobid == ts->queue[i].job + UNIX_JOB_START)
-				break;
-		}
-		if (i == ts->qcount)
-			tdb_delete(tdb, key);
-		else
-			ts->total_jobs++;
-		return 0;
-	}
-
-	/* maybe it hasn't been spooled yet */
-	if (!pjob.spooled) {
-		/* if a job is not spooled and the process doesn't
-                   exist then kill it. This cleans up after smbd
-                   deaths */
-		if (!process_exists(pjob.pid))
-			tdb_delete(tdb, key);
-		else
-			ts->total_jobs++;
-		return 0;
-	}
-
-	for (i=0;i<ts->qcount;i++) {
-		int qid = print_parse_jobid(ts->queue[i].fs_file);
-		if (jobid == qid)
-			break;
-	}
-	
-	/* The job isn't in the system queue - we have to assume it has
-	   completed, so delete the database entry. */
-
-	if (i == ts->qcount) {
-
-		/* A race can occur between the time a job is spooled and
-		   when it appears in the lpq output.  This happens when
-		   the job is added to printing.tdb when another smbd
-		   running print_queue_update() has completed a lpq and
-		   is currently traversing the printing tdb and deleting jobs.
-		   Don't delete the job if it was submitted after the lpq_time. */
-
-		if (pjob.starttime < ts->lpq_time)
-			tdb_delete(t, key);
-		else
-			ts->total_jobs++;
-	}
-	else
-		ts->total_jobs++;
-
-	return 0;
-}
-
-/****************************************************************************
- Check if the print queue has been updated recently enough.
-****************************************************************************/
-
-static void print_cache_flush(int snum)
-{
-	fstring key;
-	slprintf(key, sizeof(key)-1, "CACHE/%s", lp_servicename(snum));
-	dos_to_unix(key);                /* Convert key to unix-codepage */
-	tdb_store_int32(tdb, key, -1);
-}
-
-/****************************************************************************
- Check if someone already thinks they are doing the update.
-****************************************************************************/
-
-static pid_t get_updating_pid(fstring printer_name)
-{
-	fstring keystr;
-	TDB_DATA data, key;
-	pid_t updating_pid;
-
-	slprintf(keystr, sizeof(keystr)-1, "UPDATING/%s", printer_name);
-    	key.dptr = keystr;
-	key.dsize = strlen(keystr);
-
-	data = tdb_fetch(tdb, key);
-	if (!data.dptr || data.dsize != sizeof(pid_t))
-		return (pid_t)-1;
-
-	memcpy(&updating_pid, data.dptr, sizeof(pid_t));
-	SAFE_FREE(data.dptr);
-
-	if (process_exists(updating_pid))
-		return updating_pid;
-
-	return (pid_t)-1;
-}
-
-/****************************************************************************
- Set the fact that we're doing the update, or have finished doing the update
- in th tdb.
-****************************************************************************/
-
-static void set_updating_pid(fstring printer_name, BOOL delete)
-{
-	fstring keystr;
-	TDB_DATA key;
-	TDB_DATA data;
-	pid_t updating_pid = sys_getpid();
-
-	slprintf(keystr, sizeof(keystr)-1, "UPDATING/%s", printer_name);
-    	key.dptr = keystr;
-	key.dsize = strlen(keystr);
-
-	if (delete) {
-		tdb_delete(tdb, key);
-		return;
-	}
-	
-	data.dptr = (void *)&updating_pid;
-	data.dsize = sizeof(pid_t);
-
-	tdb_store(tdb, key, data, TDB_REPLACE);	
-}
-
-/****************************************************************************
- Send a message saying the queue changed.
-****************************************************************************/
-
-static void send_queue_message(const char *printer_name, uint32 high, uint32 low)
-{
-	char msg[sizeof(PRINTER_MESSAGE_INFO)];
-	PRINTER_MESSAGE_INFO info;
-
-	ZERO_STRUCT(info);
-
-	info.low = low;
-	info.high = high;
-	info.flags = 0;
-	fstrcpy(info.printer_name, printer_name);
-	memcpy( msg, &info, sizeof(PRINTER_MESSAGE_INFO));
-
-	message_send_all(conn_tdb_ctx(), MSG_PRINTER_NOTIFY, msg, sizeof(PRINTER_MESSAGE_INFO), False, NULL);
-}
-
-/****************************************************************************
-update the internal database from the system print queue for a queue
-****************************************************************************/
-
-static void print_queue_update(int snum)
-{
-	int i, qcount;
-	print_queue_struct *queue = NULL;
-	print_status_struct status;
-	print_status_struct old_status;
-	struct printjob *pjob;
-	struct traverse_struct tstruct;
-	fstring keystr, printer_name, cachestr;
-	TDB_DATA data, key;
-
-	/* Convert printer name (i.e. share name) to unix-codepage for all of the 
-	 * following tdb key generation */
-	fstrcpy(printer_name, lp_servicename(snum));
-	dos_to_unix(printer_name);
-	
-	/*
-	 * Check to see if someone else is doing this update.
-	 * This is essentially a mutex on the update.
-	 */
-
-	if (get_updating_pid(printer_name) != -1)
-		return;
-
-	/* Lock the queue for the database update */
-
-	slprintf(keystr, sizeof(keystr) - 1, "LOCK/%s", printer_name);
-	/* Only wait 10 seconds for this. */
-	if (tdb_lock_bystring(tdb, keystr, 10) == -1) {
-		ZERODEBUG(0,("print_queue_update: Failed to lock printing database\n" ));
-		return;
-	}
-
-	/*
-	 * Ensure that no one else got in here.
-	 * If the updating pid is still -1 then we are
-	 * the winner.
-	 */
-
-	if (get_updating_pid(printer_name) != -1) {
-		/*
-		 * Someone else is doing the update, exit.
-		 */
-		tdb_unlock_bystring(tdb, keystr);
-		return;
-	}
-
-	/*
-	 * We're going to do the update ourselves.
-	 */
-
-	/* Tell others we're doing the update. */
-	set_updating_pid(printer_name, False);
-
-	/*
-	 * Allow others to enter and notice we're doing
-	 * the update.
-	 */
-
-	tdb_unlock_bystring(tdb, keystr);
-
-	/*
-	 * Update the cache time FIRST ! Stops others even
-	 * attempting to get the lock and doing this
-	 * if the lpq takes a long time.
-	 */
-
-	slprintf(cachestr, sizeof(cachestr)-1, "CACHE/%s", printer_name);
-	tdb_store_int32(tdb, cachestr, (int)time(NULL));
-
-        /* get the current queue using the appropriate interface */
-	ZERO_STRUCT(status);
-
-	qcount = (*(current_printif->queue_get))(snum, &queue, &status);
-
-	DEBUG(3, ("%d job%s in queue for %s\n", qcount, (qcount != 1) ?
-		"s" : "", printer_name));
-
-	/*
-	  any job in the internal database that is marked as spooled
-	  and doesn't exist in the system queue is considered finished
-	  and removed from the database
-
-	  any job in the system database but not in the internal database 
-	  is added as a unix job
-
-	  fill in any system job numbers as we go
-	*/
-	for (i=0; i<qcount; i++) {
-		int jobid = print_parse_jobid(queue[i].fs_file);
-
-		if (jobid == -1) {
-			/* assume its a unix print job */
-			print_unix_job(snum, &queue[i]);
-			continue;
-		}
-
-		/* we have an active SMB print job - update its status */
-		pjob = print_job_find(jobid);
-		if (!pjob) {
-			/* err, somethings wrong. Probably smbd was restarted
-			   with jobs in the queue. All we can do is treat them
-			   like unix jobs. Pity. */
-			print_unix_job(snum, &queue[i]);
-			continue;
-		}
-
-		pjob->sysjob = queue[i].job;
-		pjob->status = queue[i].status;
-
-		print_job_store(jobid, pjob);
-	}
-
-	/* now delete any queued entries that don't appear in the
-           system queue */
-	tstruct.queue = queue;
-	tstruct.qcount = qcount;
-	tstruct.snum = snum;
-	tstruct.total_jobs = 0;
-	tstruct.lpq_time = time(NULL);
-
-	tdb_traverse(tdb, traverse_fn_delete, (void *)&tstruct);
-
-	safe_free(tstruct.queue);
-
-	tdb_store_int32(tdb, "INFO/total_jobs", tstruct.total_jobs);
-
-	/*
-	 * Get the old print status. We will use this to compare the
-	 * number of jobs. If they have changed we need to send a
-	 * "changed" message to the smbds.
-	 */
-
-	if( qcount != get_queue_status(snum, &old_status)) {
-		DEBUG(10,("print_queue_update: queue status change %d jobs -> %d jobs for printer %s\n",
-				old_status.qcount, qcount, printer_name ));
-		send_queue_message(printer_name, 0, PRINTER_CHANGE_JOB);
-	}
-
-	/* store the new queue status structure */
-	slprintf(keystr, sizeof(keystr)-1, "STATUS/%s", printer_name);
-	key.dptr = keystr;
-	key.dsize = strlen(keystr);
-
-	status.qcount = qcount;
-	data.dptr = (void *)&status;
-	data.dsize = sizeof(status);
-	tdb_store(tdb, key, data, TDB_REPLACE);	
-
-	/*
-	 * Update the cache time again. We want to do this call
-	 * as little as possible...
-	 */
-
-	slprintf(keystr, sizeof(keystr)-1, "CACHE/%s", printer_name);
-	tdb_store_int32(tdb, keystr, (int32)time(NULL));
-
-	/* Delete our pid from the db. */
-	set_updating_pid(printer_name, True);
-}
-
-/****************************************************************************
- Check if a jobid is valid. It is valid if it exists in the database.
-****************************************************************************/
-
-BOOL print_job_exists(int jobid)
-{
-	return tdb_exists(tdb, print_key(jobid));
-}
-
-/****************************************************************************
- Work out which service a jobid is for.
- Note that we have to look up by queue name to ensure that it works for 
- other than the process that started the job.
-****************************************************************************/
-
-int print_job_snum(int jobid)
-{
-	struct printjob *pjob = print_job_find(jobid);
-	if (!pjob)
-		return -1;
-
-	return find_service(pjob->queuename);
-}
-
-/****************************************************************************
- Give the fd used for a jobid.
-****************************************************************************/
-
-int print_job_fd(int jobid)
-{
-	struct printjob *pjob = print_job_find(jobid);
-	if (!pjob)
-		return -1;
-	/* don't allow another process to get this info - it is meaningless */
-	if (pjob->pid != local_pid)
-		return -1;
-	return pjob->fd;
-}
-
-/****************************************************************************
- Give the filename used for a jobid.
- Only valid for the process doing the spooling and when the job
- has not been spooled.
-****************************************************************************/
-
-char *print_job_fname(int jobid)
-{
-	struct printjob *pjob = print_job_find(jobid);
-	if (!pjob || pjob->spooled || pjob->pid != local_pid)
-		return NULL;
-	return pjob->filename;
-}
-
-/****************************************************************************
- Set the place in the queue for a job.
-****************************************************************************/
-
-BOOL print_job_set_place(int jobid, int place)
-{
-	DEBUG(2,("print_job_set_place not implemented yet\n"));
-	return False;
-}
-
-/****************************************************************************
- Set the name of a job. Only possible for owner.
-****************************************************************************/
-
-BOOL print_job_set_name(int jobid, char *name)
-{
-	struct printjob *pjob = print_job_find(jobid);
-	if (!pjob || pjob->pid != local_pid)
-		return False;
-
-	fstrcpy(pjob->jobname, name);
-	return print_job_store(jobid, pjob);
-}
-
-/****************************************************************************
- Delete a print job - don't update queue.
-****************************************************************************/
-
-static BOOL print_job_delete1(int jobid)
-{
-	struct printjob *pjob = print_job_find(jobid);
-	int snum, result = 0;
-
-	if (!pjob)
-		return False;
-
-	/*
-	 * If already deleting just return.
-	 */
-
-	if (pjob->status == LPQ_DELETING)
-		return True;
-
-	snum = print_job_snum(jobid);
-	if (snum == -1) {
-		DEBUG(5,("print_job_delete1: unknown service number for jobid %d\n", jobid));
-		return False;
-	}
-
-	/* Hrm - we need to be able to cope with deleting a job before it
-	   has reached the spooler. */
-
-	if (pjob->sysjob == -1) {
-		DEBUG(5, ("attempt to delete job %d not seen by lpr\n", jobid));
-	}
-
-	/* Set the tdb entry to be deleting. */
-
-	pjob->status = LPQ_DELETING;
-	print_job_store(jobid, pjob);
-
-	if (pjob->spooled && pjob->sysjob != -1)
-		result = (*(current_printif->job_delete))(snum, pjob);
-
-	/* Delete the tdb entry if the delete suceeded or the job hasn't
-	   been spooled. */
-
-	if (result == 0) {
-		tdb_delete(tdb, print_key(jobid));
-	}
-
-	return (result == 0);
-}
-
-/****************************************************************************
- Return true if the current user owns the print job.
-****************************************************************************/
-
-static BOOL is_owner(struct current_user *user, int jobid)
-{
-	struct printjob *pjob = print_job_find(jobid);
-	user_struct *vuser;
-
-	if (!pjob || !user)
-		return False;
-
-	if ((vuser = get_valid_user_struct(user->vuid)) != NULL) {
-		return strequal(pjob->user, 
-				unix_to_dos_static(vuser->user.smb_name));
-	} else {
-		return strequal(pjob->user, 
-				unix_to_dos_static(uidtoname(user->uid)));
-	}
-}
-
-/****************************************************************************
- Delete a print job.
-****************************************************************************/
-
-BOOL print_job_delete(struct current_user *user, int jobid, WERROR *errcode)
-{
-	int snum = print_job_snum(jobid);
-	char *printer_name;
-	BOOL owner;
-
-	if (snum == -1) {
-		DEBUG(5,("print_job_delete: unknown service number for jobid %d\n", jobid));
-		return False;
-	}
-
-	owner = is_owner(user, jobid);
-	
-	/* Check access against security descriptor or whether the user
-	   owns their job. */
-
-	if (!owner && 
-	    !print_access_check(user, snum, JOB_ACCESS_ADMINISTER)) {
-		DEBUG(3, ("delete denied by security descriptor\n"));
-		*errcode = WERR_ACCESS_DENIED;
-		return False;
-	}
-
-	if (!print_job_delete1(jobid))
-		return False;
-
-	/* force update the database and say the delete failed if the
-           job still exists */
-
-	print_queue_update(snum);
-
-	/* Send a printer notify message */
-
-	printer_name = PRINTERNAME(snum);
-
-	send_queue_message(printer_name, 0, PRINTER_CHANGE_JOB);
-
-	return !print_job_exists(jobid);
-}
-
-/****************************************************************************
- Pause a job.
-****************************************************************************/
-
-BOOL print_job_pause(struct current_user *user, int jobid, WERROR *errcode)
-{
-	struct printjob *pjob = print_job_find(jobid);
-	int snum, ret = -1;
-	char *printer_name;
-	
-	if (!pjob || !user)
-		return False;
-
-	if (!pjob->spooled || pjob->sysjob == -1)
-		return False;
-
-	snum = print_job_snum(jobid);
-	if (snum == -1) {
-		DEBUG(5,("print_job_pause: unknown service number for jobid %d\n", jobid));
-		return False;
-	}
-
-	if (!is_owner(user, jobid) &&
-	    !print_access_check(user, snum, JOB_ACCESS_ADMINISTER)) {
-		DEBUG(3, ("pause denied by security descriptor\n"));
-		*errcode = WERR_ACCESS_DENIED;
-		return False;
-	}
-
-	/* need to pause the spooled entry */
-	ret = (*(current_printif->job_pause))(snum, pjob);
-
-	if (ret != 0) {
-		*errcode = WERR_INVALID_PARAM;
-		return False;
-	}
-
-	/* force update the database */
-	print_cache_flush(snum);
-
-	/* Send a printer notify message */
-
-	printer_name = PRINTERNAME(snum);
-
-	send_queue_message(printer_name, 0, PRINTER_CHANGE_JOB);
-
-	/* how do we tell if this succeeded? */
-
-	return True;
-}
-
-/****************************************************************************
- Resume a job.
-****************************************************************************/
-
-BOOL print_job_resume(struct current_user *user, int jobid, WERROR *errcode)
-{
-	struct printjob *pjob = print_job_find(jobid);
-	char *printer_name;
-	int snum, ret;
-	
-	if (!pjob || !user)
-		return False;
-
-	if (!pjob->spooled || pjob->sysjob == -1)
-		return False;
-
-	snum = print_job_snum(jobid);
-	if (snum == -1) {
-		DEBUG(5,("print_job_resume: unknown service number for jobid %d\n", jobid));
-		return False;
-	}
-
-	if (!is_owner(user, jobid) &&
-	    !print_access_check(user, snum, JOB_ACCESS_ADMINISTER)) {
-		DEBUG(3, ("resume denied by security descriptor\n"));
-		*errcode = WERR_ACCESS_DENIED;
-		return False;
-	}
-
-	ret = (*(current_printif->job_resume))(snum, pjob);
-
-	if (ret != 0) {
-		*errcode = WERR_INVALID_PARAM;
-		return False;
-	}
-
-	/* force update the database */
-	print_cache_flush(snum);
-
-	/* Send a printer notify message */
-
-	printer_name = PRINTERNAME(snum);
-
-	send_queue_message(printer_name, 0, PRINTER_CHANGE_JOB);
-
-	return True;
-}
-
-/****************************************************************************
- Write to a print file.
-****************************************************************************/
-
-int print_job_write(int jobid, const char *buf, int size)
-{
-	int return_code;
-	struct printjob *pjob = print_job_find(jobid);
-
-	if (!pjob)
-		return -1;
-	/* don't allow another process to get this info - it is meaningless */
-	if (pjob->pid != local_pid)
-		return -1;
-
-	return_code = write(pjob->fd, buf, size);
-	if (return_code>0) {
-		pjob->size += size;
-		print_job_store(jobid, pjob);
-	}
-	return return_code;
-}
-
-/****************************************************************************
- Check if the print queue has been updated recently enough.
-****************************************************************************/
-
-static BOOL print_cache_expired(int snum)
-{
-	fstring key;
-	time_t last_qscan_time, time_now = time(NULL);
-
-	slprintf(key, sizeof(key), "CACHE/%s", lp_servicename(snum));
-	dos_to_unix(key);                /* Convert key to unix-codepage */
-	last_qscan_time = (time_t)tdb_fetch_int32(tdb, key);
-
-	/*
-	 * Invalidate the queue for 3 reasons.
-	 * (1). last queue scan time == -1.
-	 * (2). Current time - last queue scan time > allowed cache time.
-	 * (3). last queue scan time > current time + MAX_CACHE_VALID_TIME (1 hour by default).
-	 * This last test picks up machines for which the clock has been moved
-	 * forward, an lpq scan done and then the clock moved back. Otherwise
-	 * that last lpq scan would stay around for a loooong loooong time... :-). JRA.
-	 */
-
-	if (last_qscan_time == ((time_t)-1) || (time_now - last_qscan_time) >= lp_lpqcachetime() ||
-			last_qscan_time > (time_now + MAX_CACHE_VALID_TIME)) {
-		DEBUG(3, ("print cache expired for queue %s \
-(last_qscan_time = %d, time now = %d, qcachetime = %d)\n", lp_servicename(snum),
-			(int)last_qscan_time, (int)time_now, (int)lp_lpqcachetime() ));
-		return True;
-	}
-	return False;
-}
-
-/****************************************************************************
- Get the queue status - do not update if db is out of date.
-****************************************************************************/
-
-static int get_queue_status(int snum, print_status_struct *status)
-{
-	fstring keystr;
-	TDB_DATA data, key;
-
-	ZERO_STRUCTP(status);
-	slprintf(keystr, sizeof(keystr)-1, "STATUS/%s", lp_servicename(snum));
-	dos_to_unix(keystr);             /* Convert key to unix-codepage */
-	key.dptr = keystr;
-	key.dsize = strlen(keystr);
-	data = tdb_fetch(tdb, key);
-	if (data.dptr) {
-		if (data.dsize == sizeof(print_status_struct)) {
-			memcpy(status, data.dptr, sizeof(print_status_struct));
-		}
-		SAFE_FREE(data.dptr);
-	}
-	return status->qcount;
-}
-
-/****************************************************************************
- Determine the number of jobs in a queue.
-****************************************************************************/
-
-int print_queue_length(int snum, print_status_struct *pstatus)
-{
-	print_status_struct status;
-	int len;
- 
-	/* make sure the database is up to date */
-	if (print_cache_expired(snum))
-		print_queue_update(snum);
- 
-	/* also fetch the queue status */
-	memset(&status, 0, sizeof(status));
-	len = get_queue_status(snum, &status);
-	if (pstatus)
-		*pstatus = status;
-	return len;
-}
-
-/****************************************************************************
- Determine the number of jobs in all queues.
-****************************************************************************/
-
-static int get_total_jobs(int snum)
-{
-	int total_jobs;
-
-	/* make sure the database is up to date */
-	if (print_cache_expired(snum))
-		print_queue_update(snum);
-
-	total_jobs = tdb_fetch_int32(tdb, "INFO/total_jobs");
-	if (total_jobs >0)
-		return total_jobs;
-	else
-		return 0;
-}
-
-/***************************************************************************
- Start spooling a job - return the jobid.
-***************************************************************************/
-
-int print_job_start(struct current_user *user, int snum, char *jobname)
-{
-	int jobid;
-	char *path;
-	struct printjob pjob;
-	int next_jobid;
-	user_struct *vuser;
-	int njobs = 0;
-
-	errno = 0;
-
-	if (!print_access_check(user, snum, PRINTER_ACCESS_USE)) {
-		DEBUG(3, ("print_job_start: job start denied by security descriptor\n"));
-		return -1;
-	}
-
-	if (!print_time_access_check(snum)) {
-		DEBUG(3, ("print_job_start: job start denied by time check\n"));
-		return -1;
-	}
-
-	path = lp_pathname(snum);
-
-	/* see if we have sufficient disk space */
-	if (lp_minprintspace(snum)) {
-		SMB_BIG_UINT dspace, dsize;
-		if (sys_fsusage(path, &dspace, &dsize) == 0 &&
-		    dspace < 2*(SMB_BIG_UINT)lp_minprintspace(snum)) {
-			DEBUG(3, ("print_job_start: disk space check failed.\n"));
-			errno = ENOSPC;
-			return -1;
-		}
-	}
-
-	/* for autoloaded printers, check that the printcap entry still exists */
-	if (lp_autoloaded(snum) && !pcap_printername_ok(lp_servicename(snum), NULL)) {
-		DEBUG(3, ("print_job_start: printer name %s check failed.\n", lp_servicename(snum) ));
-		errno = ENOENT;
-		return -1;
-	}
-
-	/* Insure the maximum queue size is not violated */
-	if (lp_maxprintjobs(snum) && (njobs = print_queue_length(snum,NULL)) > lp_maxprintjobs(snum)) {
-		DEBUG(3, ("print_job_start: number of jobs (%d) larger than max printjobs per queue (%d).\n",
-			njobs, lp_maxprintjobs(snum) ));
-		errno = ENOSPC;
-		return -1;
-	}
-
-	/* Insure the maximum print jobs in the system is not violated */
-	if (lp_totalprintjobs() && get_total_jobs(snum) > lp_totalprintjobs()) {
-		DEBUG(3, ("print_job_start: number of jobs (%d) larger than max printjobs per system (%d).\n",
-			njobs, lp_totalprintjobs() ));
-		errno = ENOSPC;
-		return -1;
-	}
-
-	/* create the database entry */
-	ZERO_STRUCT(pjob);
-	pjob.pid = local_pid;
-	pjob.sysjob = -1;
-	pjob.fd = -1;
-	pjob.starttime = time(NULL);
-	pjob.status = LPQ_SPOOLING;
-	pjob.size = 0;
-	pjob.spooled = False;
-	pjob.smbjob = True;
-
-	fstrcpy(pjob.jobname, jobname);
-
-	if ((vuser = get_valid_user_struct(user->vuid)) != NULL) {
-		fstrcpy(pjob.user, unix_to_dos_static(vuser->user.smb_name));
-	} else {
-		fstrcpy(pjob.user, unix_to_dos_static(uidtoname(user->uid)));
-	}
-
-	fstrcpy(pjob.queuename, lp_servicename(snum));
-
-	/* Lock the database - only wait 20 seconds. */
-	if (tdb_lock_bystring(tdb, "INFO/nextjob", 20) == -1) {
-		ZERODEBUG(0,("print_job_start: failed to lock printing database.\n"));
-		return -1;
-	}
-
-	next_jobid = tdb_fetch_int32(tdb, "INFO/nextjob");
-	if (next_jobid == -1)
-		next_jobid = 1;
-
-	for (jobid = NEXT_JOBID(next_jobid); jobid != next_jobid; jobid = NEXT_JOBID(jobid)) {
-		if (!print_job_exists(jobid))
-			break;
-	}
-	if (jobid == next_jobid || !print_job_store(jobid, &pjob)) {
-		DEBUG(3, ("print_job_start: either jobid (%d)==next_jobid(%d) or print_job_store failed.\n",
-				jobid, next_jobid ));
-		jobid = -1;
-		goto fail;
-	}
-
-	tdb_store_int32(tdb, "INFO/nextjob", jobid);
-
-	/* we have a job entry - now create the spool file */
-	slprintf(pjob.filename, sizeof(pjob.filename)-1, "%s/%s%.6d.XXXXXX", 
-		 path, PRINT_SPOOL_PREFIX, jobid);
-	pjob.fd = smb_mkstemp(pjob.filename);
-
-	if (pjob.fd == -1) {
-		if (errno == EACCES) {
-			/* Common setup error, force a report. */
-			ZERODEBUG(0, ("print_job_start: insufficient permissions \
-to open spool file %s.\n", pjob.filename));
-		} else {
-			/* Normal case, report at level 3 and above. */
-			DEBUG(3, ("print_job_start: can't open spool file %s,\n", pjob.filename));
-			DEBUGADD(3, ("errno = %d (%s).\n", errno, strerror(errno)));
-		}
-		goto fail;
-	}
-
-	print_job_store(jobid, &pjob);
-
-	tdb_unlock_bystring(tdb, "INFO/nextjob");
-
-	/*
-	 * If the printer is marked as postscript output a leading
-	 * file identifier to ensure the file is treated as a raw
-	 * postscript file.
-	 * This has a similar effect as CtrlD=0 in WIN.INI file.
-	 * tim@fsg.com 09/06/94
-	 */
-	if (lp_postscript(snum)) {
-		print_job_write(jobid, "%!\n",3);
-	}
-
-	return jobid;
-
- fail:
-	if (jobid != -1) {
-		tdb_delete(tdb, print_key(jobid));
-	}
-
-	tdb_unlock_bystring(tdb, "INFO/nextjob");
-
-	DEBUG(3, ("print_job_start: returning fail. Error = %s\n", strerror(errno) ));
-	return -1;
-}
-
-/****************************************************************************
- Update the number of pages spooled to jobid
-****************************************************************************/
-
-void print_job_endpage(int jobid)
-{
-	struct printjob *pjob = print_job_find(jobid);
-	if (!pjob)
-		return;
-	/* don't allow another process to get this info - it is meaningless */
-	if (pjob->pid != local_pid)
-		return;
-
-	pjob->page_count++;
-	print_job_store(jobid, pjob);
-}
-
-/****************************************************************************
- Print a file - called on closing the file. This spools the job.
- If normal close is false then we're tearing down the jobs - treat as an
- error.
-****************************************************************************/
-
-BOOL print_job_end(int jobid, BOOL normal_close)
-{
-	struct printjob *pjob = print_job_find(jobid);
-	int snum, ret;
-	SMB_STRUCT_STAT sbuf;
-
-	if (!pjob)
-		return False;
-
-	if (pjob->spooled || pjob->pid != local_pid)
-		return False;
-
-	snum = print_job_snum(jobid);
-	if (snum == -1) {
-		DEBUG(5,("print_job_end: unknown service number for jobid %d\n", jobid));
-		return False;
-	}
-
-	if (normal_close && (sys_fstat(pjob->fd, &sbuf) == 0)) {
-		pjob->size = sbuf.st_size;
-		close(pjob->fd);
-		pjob->fd = -1;
-	} else {
-
-		/* 
-		 * Not a normal close or we couldn't stat the job file,
-		 * so something has gone wrong. Cleanup.
-		 */
-		close(pjob->fd);
-		pjob->fd = -1;
-		DEBUG(3,("print_job_end: failed to stat file for jobid %d\n", jobid ));
-		goto fail;
-	}
-
-	/* Technically, this is not quit right. If the printer has a separator
-	 * page turned on, the NT spooler prints the separator page even if the
-	 * print job is 0 bytes. 010215 JRR */
-	if (pjob->size == 0 || pjob->status == LPQ_DELETING) {
-		/* don't bother spooling empty files or something being deleted. */
-		DEBUG(5,("print_job_end: canceling spool of %s (%s)\n",
-			pjob->filename, pjob->size ? "deleted" : "zero length" ));
-		unlink(pjob->filename);
-		tdb_delete(tdb, print_key(jobid));
-		return True;
-	}
-
-	ret = (*(current_printif->job_submit))(snum, pjob);
-
-	if (ret)
-		goto fail;
-
-	/* The print job has been sucessfully handed over to the back-end */
-	
-	pjob->spooled = True;
-	pjob->status = LPQ_QUEUED;
-	print_job_store(jobid, pjob);
-	
-	/* make sure the database is up to date */
-	if (print_cache_expired(snum))
-		print_queue_update(snum);
-	
-	return True;
-
-fail:
-
-	/* The print job was not succesfully started. Cleanup */
-	/* Still need to add proper error return propagation! 010122:JRR */
-	unlink(pjob->filename);
-	tdb_delete(tdb, print_key(jobid));
-	return False;
-}
-
-/****************************************************************************
- Utility fn to enumerate the print queue.
-****************************************************************************/
-
-static int traverse_fn_queue(TDB_CONTEXT *t, TDB_DATA key, TDB_DATA data, void *state)
-{
-	struct traverse_struct *ts = (struct traverse_struct *)state;
-	struct printjob pjob;
-	int i, jobid;
-
-	if (data.dsize != sizeof(pjob) || key.dsize != sizeof(int))
-		return 0;
-	memcpy(&jobid, key.dptr, sizeof(jobid));
-	memcpy(&pjob,  data.dptr, sizeof(pjob));
-	unix_to_dos(pjob.queuename);
-
-	/* maybe it isn't for this queue */
-	if (ts->snum != lp_servicenumber(pjob.queuename))
-		return 0;
-
-	if (ts->qcount >= ts->maxcount)
-		return 0;
-
-	i = ts->qcount;
-
-	ts->queue[i].job = jobid;
-	ts->queue[i].size = pjob.size;
-	ts->queue[i].page_count = pjob.page_count;
-	ts->queue[i].status = pjob.status;
-	ts->queue[i].priority = 1;
-	ts->queue[i].time = pjob.starttime;
-	fstrcpy(ts->queue[i].fs_user, pjob.user);
-	fstrcpy(ts->queue[i].fs_file, pjob.jobname);
-
-	ts->qcount++;
-
-	return 0;
-}
-
-struct traverse_count_struct {
-	int snum, count;
-};
-
-/****************************************************************************
- Utility fn to count the number of entries in the print queue.
-****************************************************************************/
-
-static int traverse_count_fn_queue(TDB_CONTEXT *t, TDB_DATA key, TDB_DATA data, void *state)
-{
-	struct traverse_count_struct *ts = (struct traverse_count_struct *)state;
-	struct printjob pjob;
-	int jobid;
-
-	if (data.dsize != sizeof(pjob) || key.dsize != sizeof(int))
-		return 0;
-	memcpy(&jobid, key.dptr, sizeof(jobid));
-	memcpy(&pjob,  data.dptr, sizeof(pjob));
-	unix_to_dos(pjob.queuename);
-
-	/* maybe it isn't for this queue */
-	if (ts->snum != lp_servicenumber(pjob.queuename))
-		return 0;
-
-	ts->count++;
-
-	return 0;
-}
-
-/****************************************************************************
- Sort print jobs by submittal time.
-****************************************************************************/
-
-static int printjob_comp(print_queue_struct *j1, print_queue_struct *j2)
-{
-	/* Silly cases */
-
-	if (!j1 && !j2)
-		return 0;
-	if (!j1)
-		return -1;
-	if (!j2)
-		return 1;
-
-	/* Sort on job start time */
-
-	if (j1->time == j2->time)
-		return 0;
-	return (j1->time > j2->time) ? 1 : -1;
-}
-
-/****************************************************************************
- Get a printer queue listing.
-****************************************************************************/
-
-int print_queue_status(int snum, 
-		       print_queue_struct **queue,
-		       print_status_struct *status)
-{
-	struct traverse_struct tstruct;
-	struct traverse_count_struct tsc;
-	fstring keystr;
-	TDB_DATA data, key;
-
-	/* make sure the database is up to date */
-	if (print_cache_expired(snum))
-		print_queue_update(snum);
-
-	*queue = NULL;
-	
-	/*
-	 * Fetch the queue status.  We must do this first, as there may
-	 * be no jobs in the queue.
-	 */
-	ZERO_STRUCTP(status);
-	slprintf(keystr, sizeof(keystr)-1, "STATUS/%s", lp_servicename(snum));
-	dos_to_unix(keystr);             /* Convert key to unix-codepage */
-	key.dptr = keystr;
-	key.dsize = strlen(keystr);
-	data = tdb_fetch(tdb, key);
-	if (data.dptr) {
-		if (data.dsize == sizeof(*status)) {
-			memcpy(status, data.dptr, sizeof(*status));
-		}
-		SAFE_FREE(data.dptr);
-	}
-
-	/*
-	 * Now, fetch the print queue information.  We first count the number
-	 * of entries, and then only retrieve the queue if necessary.
-	 */
-	tsc.count = 0;
-	tsc.snum = snum;
-	
-	tdb_traverse(tdb, traverse_count_fn_queue, (void *)&tsc);
-
-	if (tsc.count == 0)
-		return 0;
-
-	/* Allocate the queue size. */
-	if ((tstruct.queue = (print_queue_struct *)
-	     malloc(sizeof(print_queue_struct)*tsc.count)) == NULL)
-		return 0;
-
-	/*
-	 * Fill in the queue.
-	 * We need maxcount as the queue size may have changed between
-	 * the two calls to tdb_traverse.
-	 */
-	tstruct.qcount = 0;
-	tstruct.maxcount = tsc.count;
-	tstruct.snum = snum;
-
-	tdb_traverse(tdb, traverse_fn_queue, (void *)&tstruct);
-
-	/* Sort the queue by submission time otherwise they are displayed
-	   in hash order. */
-
-	qsort(tstruct.queue, tstruct.qcount, sizeof(print_queue_struct),
-	      QSORT_CAST(printjob_comp));
-
-	*queue = tstruct.queue;
-	return tstruct.qcount;
-}
-
-/****************************************************************************
- Turn a queue name into a snum.
-****************************************************************************/
-
-int print_queue_snum(char *qname)
-{
-	int snum = lp_servicenumber(qname);
-	if (snum == -1 || !lp_print_ok(snum))
-		return -1;
-	return snum;
-}
-
-/****************************************************************************
- Pause a queue.
-****************************************************************************/
-
-BOOL print_queue_pause(struct current_user *user, int snum, WERROR *errcode)
-{
-	char *printer_name;
-	int ret;
-	
-	if (!print_access_check(user, snum, PRINTER_ACCESS_ADMINISTER)) {
-		*errcode = WERR_ACCESS_DENIED;
-		return False;
-	}
-
-	ret = (*(current_printif->queue_pause))(snum);
-
-	if (ret != 0) {
-		*errcode = WERR_INVALID_PARAM;
-		return False;
-	}
-
-	/* force update the database */
-	print_cache_flush(snum);
-
-	/* Send a printer notify message */
-
-	printer_name = PRINTERNAME(snum);
-
-	send_queue_message(printer_name, 0, PRINTER_CHANGE_JOB);
-
-	return True;
-}
-
-/****************************************************************************
- Resume a queue.
-****************************************************************************/
-
-BOOL print_queue_resume(struct current_user *user, int snum, WERROR *errcode)
-{
-	char *printer_name;
-	int ret;
-
-	if (!print_access_check(user, snum, PRINTER_ACCESS_ADMINISTER)) {
-		*errcode = WERR_ACCESS_DENIED;
-		return False;
-	}
-
-	ret = (*(current_printif->queue_resume))(snum);
-
-	if (ret != 0) {
-		*errcode = WERR_INVALID_PARAM;
-		return False;
-	}
-
-	/* make sure the database is up to date */
-	if (print_cache_expired(snum)) print_queue_update(snum);
-
-	/* Send a printer notify message */
-
-	printer_name = PRINTERNAME(snum);
-
-	send_queue_message(printer_name, 0, PRINTER_CHANGE_JOB);
-
-	return True;
-}
-
-/****************************************************************************
- Purge a queue - implemented by deleting all jobs that we can delete.
-****************************************************************************/
-
-BOOL print_queue_purge(struct current_user *user, int snum, WERROR *errcode)
-{
-	print_queue_struct *queue;
-	print_status_struct status;
-	char *printer_name;
-	int njobs, i;
-	BOOL can_job_admin;
-
-	/* Force and update so the count is accurate (i.e. not a cached count) */
-	print_queue_update(snum);
-	
-	can_job_admin = print_access_check(user, snum, JOB_ACCESS_ADMINISTER);
-	njobs = print_queue_status(snum, &queue, &status);
-
-	for (i=0;i<njobs;i++) {
-		BOOL owner = is_owner(user, queue[i].job);
-
-		if (owner || can_job_admin) {
-			print_job_delete1(queue[i].job);
-		}
-	}
-
-	safe_free(queue);
-
-	/* Send a printer notify message */
-
-	printer_name = PRINTERNAME(snum);
-
-	send_queue_message(printer_name, 0, PRINTER_CHANGE_JOB);
-
-	return True;
-}
diff -Naur samba-2.2.12-orig/source/printing/print_svid.c samba-2.2.12/source/printing/print_svid.c
--- samba-2.2.12-orig/source/printing/print_svid.c	2011-03-04 13:51:45.000000000 +0100
+++ samba-2.2.12/source/printing/print_svid.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,145 +0,0 @@
-/*
- * Copyright (C) 1997-1998 by Norm Jacobs, Colorado Springs, Colorado, USA
- * Copyright (C) 1997-1998 by Sun Microsystem, Inc.
- * All Rights Reserved
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- * 
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- */
-
-/*
- * This module implements support for gathering and comparing available
- * printer information on a SVID or XPG4 compliant system.  It does this
- * through the use of the SVID/XPG4 command "lpstat(1)".
- *
- * The expectations is that execution of the command "lpstat -v" will
- * generate responses in the form of:
- *
- *	device for serial: /dev/term/b
- *	system for fax: server
- *	system for color: server (as printer chroma)
- */
-
-
-#include "includes.h"
-#include "smb.h"
-
-#ifdef SYSV
-
-typedef struct printer {
-	char *name;
-	struct printer *next;
-} printer_t;
-static printer_t *printers = NULL;
-
-static void populate_printers(void)
-{
-	char **lines;
-	int i;
-
-	lines = file_lines_pload("/usr/bin/lpstat -v", NULL, False);
-	if (!lines) return;
-
-	for (i=0;lines[i];i++) {
-		printer_t *ptmp;
-		char *name, *tmp;
-		char *buf = lines[i];
-
-		/* eat "system/device for " */
-		if (((tmp = strchr(buf, ' ')) == NULL) ||
-		    ((tmp = strchr(++tmp, ' ')) == NULL))
-			continue;
-
-		/*
-		 * In case we're only at the "for ".
-		 */
-
-		if(!strncmp("for ",++tmp,4)) {
-			tmp=strchr(tmp, ' ');
-			tmp++;
-		}
-
-		/* Eat whitespace. */
-
-		while(*tmp == ' ')
-			++tmp;
-
-		/*
-		 * On HPUX there is an extra line that can be ignored.
-		 * d.thibadeau 2001/08/09
-		 */
-		if(!strncmp("remote to",tmp,9))
-			continue;
-
-		name = tmp;
-
-		/* truncate the ": ..." */
-		if ((tmp = strchr(name, ':')) != NULL)
-			*tmp = '\0';
-		
-		/* add it to the cache */
-		if ((ptmp = malloc(sizeof (*ptmp))) != NULL) {
-			ZERO_STRUCTP(ptmp);
-			if((ptmp->name = strdup(name)) == NULL)
-				ZERODEBUG(0,("populate_printers: malloc fail in strdup !\n"));
-			ptmp->next = printers;
-			printers = ptmp;
-		} else {
-			ZERODEBUG(0,("populate_printers: malloc fail for ptmp\n"));
-		}
-	}
-
-	file_lines_free(lines);
-}
-
-
-/*
- * provide the equivalent of pcap_printer_fn() for SVID/XPG4 conforming
- * systems.  It was unclear why pcap_printer_fn() was tossing names longer
- * than 8 characters.  I suspect that its a protocol limit, but amazingly
- * names longer than 8 characters appear to work with my test
- * clients (Win95/NT).
- */
-void sysv_printer_fn(void (*fn)(char *, char *))
-{
-	printer_t *tmp;
-
-	if (printers == NULL)
-		populate_printers();
-	for (tmp = printers; tmp != NULL; tmp = tmp->next)
-		(fn)(unix_to_dos_static(tmp->name), "");
-}
-
-
-/*
- * provide the equivalent of pcap_printername_ok() for SVID/XPG4 conforming
- * systems.
- */
-int sysv_printername_ok(char *name)
-{
-	printer_t *tmp;
-
-	if (printers == NULL)
-		populate_printers();
-	for (tmp = printers; tmp != NULL; tmp = tmp->next)
-		if (strcmp(tmp->name, name) == 0)
-			return (True);
-	return (False);
-}
-
-#else
-/* this keeps fussy compilers happy */
- void print_svid_dummy(void);
- void print_svid_dummy(void) {}
-#endif
diff -Naur samba-2.2.12-orig/source/rpcclient/cmd_spoolss.c samba-2.2.12/source/rpcclient/cmd_spoolss.c
--- samba-2.2.12-orig/source/rpcclient/cmd_spoolss.c	2011-03-04 13:51:45.000000000 +0100
+++ samba-2.2.12/source/rpcclient/cmd_spoolss.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1718 +0,0 @@
-/*
-   Unix SMB/CIFS implementation.
-   RPC pipe client
-
-   Copyright (C) Gerald Carter                     2001
-   Copyright (C) Tim Potter                        2000
-   Copyright (C) Andrew Tridgell              1992-1999
-   Copyright (C) Luke Kenneth Casson Leighton 1996-1999
- 
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2 of the License, or
-   (at your option) any later version.
-   
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-   
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-*/
-
-#include "includes.h"
-#include "rpcclient.h"
-
-struct table_node {
-	const char 	*long_archi;
-	const char 	*short_archi;
-	int	version;
-};
- 
-struct table_node archi_table[]= {
-
-	{"Windows 4.0",          "WIN40",	0 },
-	{"Windows NT x86",       "W32X86",	2 },
-	{"Windows NT R4000",     "W32MIPS",	2 },
-	{"Windows NT Alpha_AXP", "W32ALPHA",	2 },
-	{"Windows NT PowerPC",   "W32PPC",	2 },
-	{NULL,                   "",		-1 }
-};
-
-/****************************************************************************
-function to do the mapping between the long architecture name and
-the short one.
-****************************************************************************/
-BOOL get_short_archi(char *short_archi, const char *long_archi)
-{
-        int i=-1;
-
-        DEBUG(107,("Getting architecture dependant directory\n"));
-        do {
-                i++;
-        } while ( (archi_table[i].long_archi!=NULL ) &&
-                  StrCaseCmp(long_archi, archi_table[i].long_archi) );
-
-        if (archi_table[i].long_archi==NULL) {
-                DEBUGADD(10,("Unknown architecture [%s] !\n", long_archi));
-                return False;
-        }
-
-        StrnCpy (short_archi, archi_table[i].short_archi, strlen(archi_table[i].short_archi));
-
-        DEBUGADD(108,("index: [%d]\n", i));
-        DEBUGADD(108,("long architecture: [%s]\n", long_archi));
-        DEBUGADD(108,("short architecture: [%s]\n", short_archi));
-
-        return True;
-}
-
-
-/**********************************************************************
- * dummy function  -- placeholder
-  */
-static NTSTATUS cmd_spoolss_not_implemented(struct cli_state *cli, 
-                                            TALLOC_CTX *mem_ctx,
-                                            int argc, char **argv)
-{
-	printf ("(*) This command is not currently implemented.\n");
-	return NT_STATUS_OK;
-}
-
-/***********************************************************************
- * Get printer information
- */
-static NTSTATUS cmd_spoolss_open_printer_ex(struct cli_state *cli, 
-                                            TALLOC_CTX *mem_ctx,
-                                            int argc, char **argv)
-{
-	WERROR 	        werror;
-	pstring		printername;
-	fstring		servername, user;
-	POLICY_HND	hnd;
-	uint32 desired_access = MAXIMUM_ALLOWED_ACCESS;
-
-	if (argc != 2 && argc != 3) {
-		printf("Usage: %s <printername> [0xallowed_access]\n", argv[0]);
-		return NT_STATUS_OK;
-	}
-	
-	if (!cli)
-		return NT_STATUS_UNSUCCESSFUL;
-
-	slprintf (servername, sizeof(fstring)-1, "\\\\%s", cli->desthost);
-	strupper (servername);
-	fstrcpy  (user, cli->user_name);
-	fstrcpy  (printername, argv[1]);
-
-	if (argc == 3)
-		desired_access = strtol(argv[2], NULL, 16);
-
-	/* Open the printer handle */
-
-	werror = cli_spoolss_open_printer_ex(cli, mem_ctx, printername, 
-					     "", desired_access, 
-					     servername, user, &hnd);
-
-	if (W_ERROR_IS_OK(werror)) {
-		printf("Printer %s opened successfully\n", printername);
-		werror = cli_spoolss_close_printer(cli, mem_ctx, &hnd);
-
-		if (!W_ERROR_IS_OK(werror)) {
-			printf("Error closing printer handle! (%s)\n", 
-				dos_errstr(werror));
-		}
-	} else {
-		printf("Failed to open printer %s: %s\n", printername,
-				dos_errstr(werror));
-	}
-
-	return W_ERROR_IS_OK(werror) ? NT_STATUS_OK : NT_STATUS_UNSUCCESSFUL;
-}
-
-
-/****************************************************************************
-printer info level 0 display function
-****************************************************************************/
-static void display_print_info_0(PRINTER_INFO_0 *i0)
-{
-	fstring name = "";
-	fstring servername = "";
-
-	if (!i0)
-		return;
-
-	if (i0->printername.buffer)
-		rpcstr_pull(name, i0->printername.buffer, sizeof(name), 0, STR_TERMINATE);
-
-	if (i0->servername.buffer)
-		rpcstr_pull(servername, i0->servername.buffer, sizeof(servername), 0,STR_TERMINATE);
-  
-	printf("\tprintername:[%s]\n", name);
-	printf("\tservername:[%s]\n", servername);
-	printf("\tcjobs:[0x%x]\n", i0->cjobs);
-	printf("\ttotal_jobs:[0x%x]\n", i0->total_jobs);
-	
-	printf("\t:date: [%d]-[%d]-[%d] (%d)\n", i0->year, i0->month, 
-	       i0->day, i0->dayofweek);
-	printf("\t:time: [%d]-[%d]-[%d]-[%d]\n", i0->hour, i0->minute, 
-	       i0->second, i0->milliseconds);
-	
-	printf("\tglobal_counter:[0x%x]\n", i0->global_counter);
-	printf("\ttotal_pages:[0x%x]\n", i0->total_pages);
-	
-	printf("\tmajorversion:[0x%x]\n", i0->major_version);
-	printf("\tbuildversion:[0x%x]\n", i0->build_version);
-	
-	printf("\tunknown7:[0x%x]\n", i0->unknown7);
-	printf("\tunknown8:[0x%x]\n", i0->unknown8);
-	printf("\tunknown9:[0x%x]\n", i0->unknown9);
-	printf("\tsession_counter:[0x%x]\n", i0->session_counter);
-	printf("\tunknown11:[0x%x]\n", i0->unknown11);
-	printf("\tprinter_errors:[0x%x]\n", i0->printer_errors);
-	printf("\tunknown13:[0x%x]\n", i0->unknown13);
-	printf("\tunknown14:[0x%x]\n", i0->unknown14);
-	printf("\tunknown15:[0x%x]\n", i0->unknown15);
-	printf("\tunknown16:[0x%x]\n", i0->unknown16);
-	printf("\tchange_id:[0x%x]\n", i0->change_id);
-	printf("\tunknown18:[0x%x]\n", i0->unknown18);
-	printf("\tstatus:[0x%x]\n", i0->status);
-	printf("\tunknown20:[0x%x]\n", i0->unknown20);
-	printf("\tc_setprinter:[0x%x]\n", i0->c_setprinter);
-	printf("\tunknown22:[0x%x]\n", i0->unknown22);
-	printf("\tunknown23:[0x%x]\n", i0->unknown23);
-	printf("\tunknown24:[0x%x]\n", i0->unknown24);
-	printf("\tunknown25:[0x%x]\n", i0->unknown25);
-	printf("\tunknown26:[0x%x]\n", i0->unknown26);
-	printf("\tunknown27:[0x%x]\n", i0->unknown27);
-	printf("\tunknown28:[0x%x]\n", i0->unknown28);
-	printf("\tunknown29:[0x%x]\n", i0->unknown29);
-	
-	printf("\n");
-}
-
-/****************************************************************************
-printer info level 1 display function
-****************************************************************************/
-static void display_print_info_1(PRINTER_INFO_1 *i1)
-{
-	fstring desc = "";
-	fstring name = "";
-	fstring comm = "";
-
-	if (i1->description.buffer)
-		rpcstr_pull(desc, i1->description.buffer, sizeof(desc), 0, 
-			    STR_TERMINATE);
-
-	if (i1->name.buffer)
-		rpcstr_pull(name, i1->name.buffer, sizeof(name), 0, 
-			    STR_TERMINATE);
-
-	if (i1->comment.buffer)
-		rpcstr_pull(comm, i1->comment.buffer, sizeof(comm), 0, 
-			    STR_TERMINATE);
-
-	printf("\tflags:[0x%x]\n", i1->flags);
-	printf("\tname:[%s]\n", name);
-	printf("\tdescription:[%s]\n", desc);
-	printf("\tcomment:[%s]\n", comm);
-
-	printf("\n");
-}
-
-/****************************************************************************
-printer info level 2 display function
-****************************************************************************/
-static void display_print_info_2(PRINTER_INFO_2 *i2)
-{
-	fstring servername = "";
-	fstring printername = "";
-	fstring sharename = "";
-	fstring portname = "";
-	fstring drivername = "";
-	fstring comment = "";
-	fstring location = "";
-	fstring sepfile = "";
-	fstring printprocessor = "";
-	fstring datatype = "";
-	fstring parameters = "";
-	
-	if (i2->servername.buffer)
-		rpcstr_pull(servername, i2->servername.buffer,sizeof(servername), 0, STR_TERMINATE);
-
-	if (i2->printername.buffer)
-		rpcstr_pull(printername, i2->printername.buffer,sizeof(printername), 0, STR_TERMINATE);
-
-	if (i2->sharename.buffer)
-		rpcstr_pull(sharename, i2->sharename.buffer,sizeof(sharename), 0, STR_TERMINATE);
-
-	if (i2->portname.buffer)
-		rpcstr_pull(portname, i2->portname.buffer,sizeof(portname), 0, STR_TERMINATE);
-
-	if (i2->drivername.buffer)
-		rpcstr_pull(drivername, i2->drivername.buffer,sizeof(drivername), 0, STR_TERMINATE);
-
-	if (i2->comment.buffer)
-		rpcstr_pull(comment, i2->comment.buffer,sizeof(comment), 0, STR_TERMINATE);
-
-	if (i2->location.buffer)
-		rpcstr_pull(location, i2->location.buffer,sizeof(location), 0, STR_TERMINATE);
-
-	if (i2->sepfile.buffer)
-		rpcstr_pull(sepfile, i2->sepfile.buffer,sizeof(sepfile), 0, STR_TERMINATE);
-
-	if (i2->printprocessor.buffer) 
-		rpcstr_pull(printprocessor, i2->printprocessor.buffer,sizeof(printprocessor), 0, STR_TERMINATE);
-
-	if (i2->datatype.buffer)
-		rpcstr_pull(datatype, i2->datatype.buffer,sizeof(datatype), 0, STR_TERMINATE);
-
-	if (i2->parameters.buffer)
-		rpcstr_pull(parameters, i2->parameters.buffer,sizeof(parameters), 0, STR_TERMINATE);
-
-	printf("\tservername:[%s]\n", servername);
-	printf("\tprintername:[%s]\n", printername);
-	printf("\tsharename:[%s]\n", sharename);
-	printf("\tportname:[%s]\n", portname);
-	printf("\tdrivername:[%s]\n", drivername);
-	printf("\tcomment:[%s]\n", comment);
-	printf("\tlocation:[%s]\n", location);
-	printf("\tsepfile:[%s]\n", sepfile);
-	printf("\tprintprocessor:[%s]\n", printprocessor);
-	printf("\tdatatype:[%s]\n", datatype);
-	printf("\tparameters:[%s]\n", parameters);
-	printf("\tattributes:[0x%x]\n", i2->attributes);
-	printf("\tpriority:[0x%x]\n", i2->priority);
-	printf("\tdefaultpriority:[0x%x]\n", i2->defaultpriority);
-	printf("\tstarttime:[0x%x]\n", i2->starttime);
-	printf("\tuntiltime:[0x%x]\n", i2->untiltime);
-	printf("\tstatus:[0x%x]\n", i2->status);
-	printf("\tcjobs:[0x%x]\n", i2->cjobs);
-	printf("\taverageppm:[0x%x]\n", i2->averageppm);
-
-	if (i2->secdesc) 
-		display_sec_desc(i2->secdesc);
-
-	printf("\n");
-}
-
-/****************************************************************************
-printer info level 3 display function
-****************************************************************************/
-static void display_print_info_3(PRINTER_INFO_3 *i3)
-{
-	printf("\tflags:[0x%x]\n", i3->flags);
-
-	display_sec_desc(i3->secdesc);
-
-	printf("\n");
-}
-
-/* Enumerate printers */
-
-static NTSTATUS cmd_spoolss_enum_printers(struct cli_state *cli, 
-                                          TALLOC_CTX *mem_ctx,
-                                          int argc, char **argv)
-{
-	WERROR                  result;
-	uint32			info_level = 1;
-	PRINTER_INFO_CTR	ctr;
-	uint32			i = 0, num_printers, needed;
-
-	if (argc > 2) 
-	{
-		printf("Usage: %s [level]\n", argv[0]);
-		return NT_STATUS_OK;
-	}
-
-	if (argc == 2) {
-		info_level = atoi(argv[1]);
-	}
-
-	/* Enumerate printers  -- Should we enumerate types other 
-	   than PRINTER_ENUM_LOCAL?  Maybe accept as a parameter?  --jerry */
-
-	ZERO_STRUCT(ctr);
-
-	result = cli_spoolss_enum_printers(
-		cli, mem_ctx, 0, &needed, PRINTER_ENUM_LOCAL, 
-		info_level, &num_printers, &ctr);
-
-	if (W_ERROR_V(result) == ERRinsufficientbuffer)
-		result = cli_spoolss_enum_printers(
-			cli, mem_ctx, needed, NULL, PRINTER_ENUM_LOCAL, 
-			info_level, &num_printers, &ctr);
-
-	if (W_ERROR_IS_OK(result)) {
-
-		if (!num_printers) {
-			printf ("No printers returned.\n");
-			goto done;
-		}
-	
-		for (i = 0; i < num_printers; i++) {
-		switch(info_level) {
-		case 0:
-				display_print_info_0(&ctr.printers_0[i]);
-			break;
-		case 1:
-				display_print_info_1(&ctr.printers_1[i]);
-			break;
-		case 2:
-				display_print_info_2(&ctr.printers_2[i]);
-			break;
-		case 3:
-				display_print_info_3(&ctr.printers_3[i]);
-			break;
-		default:
-			printf("unknown info level %d\n", info_level);
-				goto done;
-			}
-		}
-	}
-	done:
-
-	return W_ERROR_IS_OK(result) ? NT_STATUS_OK : NT_STATUS_UNSUCCESSFUL;
-}
-
-/****************************************************************************
-port info level 1 display function
-****************************************************************************/
-static void display_port_info_1(PORT_INFO_1 *i1)
-{
-	fstring buffer;
-	
-	rpcstr_pull(buffer, i1->port_name.buffer, sizeof(buffer), 0, STR_TERMINATE);
-	printf("\tPort Name:\t[%s]\n", buffer);
-}
-
-/****************************************************************************
-port info level 2 display function
-****************************************************************************/
-static void display_port_info_2(PORT_INFO_2 *i2)
-{
-	fstring buffer;
-	
-	rpcstr_pull(buffer, i2->port_name.buffer, sizeof(buffer), 0, STR_TERMINATE);
-	printf("\tPort Name:\t[%s]\n", buffer);
-	rpcstr_pull(buffer, i2->monitor_name.buffer, sizeof(buffer), 0, STR_TERMINATE);
-
-	printf("\tMonitor Name:\t[%s]\n", buffer);
-	rpcstr_pull(buffer, i2->description.buffer, sizeof(buffer), 0, STR_TERMINATE);
-
-	printf("\tDescription:\t[%s]\n", buffer);
-	printf("\tPort Type:\t[%d]\n", i2->port_type);
-	printf("\tReserved:\t[%d]\n", i2->reserved);
-	printf("\n");
-}
-
-/* Enumerate ports */
-
-static NTSTATUS cmd_spoolss_enum_ports(struct cli_state *cli, 
-				       TALLOC_CTX *mem_ctx, int argc, 
-				       char **argv)
-{
-	WERROR         		result;
-	uint32                  needed, info_level = 1;
-	PORT_INFO_CTR 		ctr;
-	int 			returned;
-	
-	if (argc > 2) {
-		printf("Usage: %s [level]\n", argv[0]);
-		return NT_STATUS_OK;
-	}
-	
-	if (argc == 2)
-		info_level = atoi(argv[1]);
-
-	/* Enumerate ports */
-
-	ZERO_STRUCT(ctr);
-
-	result = cli_spoolss_enum_ports(cli, mem_ctx, 0, &needed, info_level, 
-					&returned, &ctr);
-
-	if (W_ERROR_V(result) == ERRinsufficientbuffer)
-		result = cli_spoolss_enum_ports(cli, mem_ctx, needed, NULL,
-						info_level, &returned, &ctr);
-
-	if (W_ERROR_IS_OK(result)) {
-		int i;
-
-		for (i = 0; i < returned; i++) {
-			switch (info_level) {
-			case 1:
-				display_port_info_1(&ctr.port.info_1[i]);
-			break;
-			case 2:
-				display_port_info_2(&ctr.port.info_2[i]);
-				break;
-			default:
-				printf("unknown info level %d\n", info_level);
-				break;
-			}
-		}
-	}
-
-	return W_ERROR_IS_OK(result) ? NT_STATUS_OK : NT_STATUS_UNSUCCESSFUL;
-}
-
-/***********************************************************************
- * Set printer comment - use a level2 set.
- */
-static NTSTATUS cmd_spoolss_setprinter(struct cli_state *cli, 
-                                       TALLOC_CTX *mem_ctx,
-                                       int argc, char **argv)
-{
-	POLICY_HND 	pol;
-	WERROR		result;
-	uint32 		needed;
-	uint32 		info_level = 2;
-	BOOL 		opened_hnd = False;
-	PRINTER_INFO_CTR ctr;
-	fstring 	printername, 
-			servername,
-			user,
-			comment;
-
-	if (argc == 1 || argc > 3) {
-		printf("Usage: %s printername comment\n", argv[0]);
-		
-		return NT_STATUS_OK;
-	}
-
-	/* Open a printer handle */
-	if (argc == 3) {
-		fstrcpy(comment, argv[2]);
-	}
-
-	slprintf (servername, sizeof(fstring)-1, "\\\\%s", cli->desthost);
-	strupper (servername);
-	fstrcpy (printername, argv[1]);
-	fstrcpy  (user, cli->user_name);
-	
-	/* get a printer handle */
-	result = cli_spoolss_open_printer_ex(cli, mem_ctx, printername, "", 
-				MAXIMUM_ALLOWED_ACCESS, servername,
-		user, &pol);
-				
-	if (!W_ERROR_IS_OK(result))
-		goto done;
- 
-	opened_hnd = True;
-
-	/* Get printer info */
-        result = cli_spoolss_getprinter(cli, mem_ctx, 0, &needed, &pol, info_level, &ctr);
-
-        if (W_ERROR_V(result) == ERRinsufficientbuffer)
-                result = cli_spoolss_getprinter(cli, mem_ctx, needed, NULL, &pol, info_level, &ctr);
-
-        if (!W_ERROR_IS_OK(result))
-		goto done;
-
-
-	/* Modify the comment. */
-	init_unistr(&ctr.printers_2->comment, comment);
-	ctr.printers_2->devmode = NULL;
-	ctr.printers_2->secdesc = NULL;
-
-	result =  cli_spoolss_setprinter(cli, mem_ctx, &pol, info_level, &ctr, 0);
-	if (W_ERROR_IS_OK(result))
-		printf("Success in setting comment.\n");
-
- done: 
-	if (opened_hnd) 
-		cli_spoolss_close_printer(cli, mem_ctx, &pol);
-
-	return W_ERROR_IS_OK(result) ? NT_STATUS_OK : NT_STATUS_UNSUCCESSFUL;
-}
-
-/***********************************************************************
- * Get printer information
- */
-static NTSTATUS cmd_spoolss_getprinter(struct cli_state *cli, 
-                                       TALLOC_CTX *mem_ctx,
-                                       int argc, char **argv)
-{
-	POLICY_HND 	pol;
-	WERROR          result;
-	uint32 		info_level = 1;
-	BOOL 		opened_hnd = False;
-	PRINTER_INFO_CTR ctr;
-	fstring 	printername, 
-			servername,
-			user;
-	uint32 needed;
-
-	if (argc == 1 || argc > 3) {
-		printf("Usage: %s <printername> [level]\n", argv[0]);
-		return NT_STATUS_OK;
-	}
-
-	/* Open a printer handle */
-	if (argc == 3) {
-		info_level = atoi(argv[2]);
-	}
-
-	slprintf (servername, sizeof(fstring)-1, "\\\\%s", cli->desthost);
-	strupper (servername);
-	slprintf (printername, sizeof(fstring)-1, "%s\\%s", servername, argv[1]);
-	fstrcpy  (user, cli->user_name);
-	
-	/* get a printer handle */
-
-	result = cli_spoolss_open_printer_ex(cli, mem_ctx, printername, 
-					     "", MAXIMUM_ALLOWED_ACCESS, 
-					     servername, user, &pol);
-
-	if (!W_ERROR_IS_OK(result))
-		goto done;
- 
-	opened_hnd = True;
-
-	/* Get printer info */
-
-	result = cli_spoolss_getprinter(cli, mem_ctx, 0, &needed,
-					&pol, info_level, &ctr);
-
-	if (W_ERROR_V(result) == ERRinsufficientbuffer)
-		result = cli_spoolss_getprinter(
-			cli, mem_ctx, needed, NULL, &pol, info_level, &ctr);
-
-	if (!W_ERROR_IS_OK(result))
-		goto done;
-
-	/* Display printer info */
-
-	switch (info_level) {
-	case 0: 
-		display_print_info_0(ctr.printers_0);
-		break;
-	case 1:
-		display_print_info_1(ctr.printers_1);
-		break;
-	case 2:
-		display_print_info_2(ctr.printers_2);
-		break;
-	case 3:
-		display_print_info_3(ctr.printers_3);
-		break;
-	default:
-		printf("unknown info level %d\n", info_level);
-		break;
-	}
-
- done: 
-	if (opened_hnd) 
-		cli_spoolss_close_printer(cli, mem_ctx, &pol);
-
-	return W_ERROR_IS_OK(result) ? NT_STATUS_OK : NT_STATUS_UNSUCCESSFUL;
-}
-
-/****************************************************************************
-printer info level 0 display function
-****************************************************************************/
-static void display_print_driver_1(DRIVER_INFO_1 *i1)
-{
-	fstring name;
-	if (i1 == NULL)
-		return;
-
-	rpcstr_pull(name, i1->name.buffer, sizeof(name), 0, STR_TERMINATE);
-
-	printf ("Printer Driver Info 1:\n");
-	printf ("\tDriver Name: [%s]\n\n", name);
-	
-	return;
-}
-
-/****************************************************************************
-printer info level 1 display function
-****************************************************************************/
-static void display_print_driver_2(DRIVER_INFO_2 *i1)
-{
-	fstring name;
-	fstring architecture;
-	fstring driverpath;
-	fstring datafile;
-	fstring configfile;
-	if (i1 == NULL)
-		return;
-
-	rpcstr_pull(name, i1->name.buffer, sizeof(name), 0, STR_TERMINATE);
-	rpcstr_pull(architecture, i1->architecture.buffer, sizeof(architecture), 0, STR_TERMINATE);
-	rpcstr_pull(driverpath, i1->driverpath.buffer, sizeof(driverpath), 0, STR_TERMINATE);
-	rpcstr_pull(datafile, i1->datafile.buffer, sizeof(datafile), 0, STR_TERMINATE);
-	rpcstr_pull(configfile, i1->configfile.buffer, sizeof(configfile), 0, STR_TERMINATE);
-
-	printf ("Printer Driver Info 2:\n");
-	printf ("\tVersion: [%x]\n", i1->version);
-	printf ("\tDriver Name: [%s]\n", name);
-	printf ("\tArchitecture: [%s]\n", architecture);
-	printf ("\tDriver Path: [%s]\n", driverpath);
-	printf ("\tDatafile: [%s]\n", datafile);
-	printf ("\tConfigfile: [%s]\n\n", configfile);
-
-	return;
-}
-
-/****************************************************************************
-printer info level 2 display function
-****************************************************************************/
-static void display_print_driver_3(DRIVER_INFO_3 *i1)
-{
-	fstring name;
-	fstring architecture;
-	fstring driverpath;
-	fstring datafile;
-	fstring configfile;
-	fstring helpfile;
-	fstring dependentfiles;
-	fstring monitorname;
-	fstring defaultdatatype;
-	
-	int length=0;
-	BOOL valid = True;
-	
-	if (i1 == NULL)
-		return;
-
-	rpcstr_pull(name, i1->name.buffer, sizeof(name), 0, STR_TERMINATE);
-	rpcstr_pull(architecture, i1->architecture.buffer, sizeof(architecture), 0, STR_TERMINATE);
-	rpcstr_pull(driverpath, i1->driverpath.buffer, sizeof(driverpath), 0, STR_TERMINATE);
-	rpcstr_pull(datafile, i1->datafile.buffer, sizeof(datafile), 0, STR_TERMINATE);
-	rpcstr_pull(configfile, i1->configfile.buffer, sizeof(configfile), 0, STR_TERMINATE);
-	rpcstr_pull(helpfile, i1->helpfile.buffer, sizeof(helpfile), 0, STR_TERMINATE);
-	rpcstr_pull(monitorname, i1->monitorname.buffer, sizeof(monitorname), 0, STR_TERMINATE);
-	rpcstr_pull(defaultdatatype, i1->defaultdatatype.buffer, sizeof(defaultdatatype), 0, STR_TERMINATE);
-
-	printf ("Printer Driver Info 3:\n");
-	printf ("\tVersion: [%x]\n", i1->version);
-	printf ("\tDriver Name: [%s]\n",name);
-	printf ("\tArchitecture: [%s]\n", architecture);
-	printf ("\tDriver Path: [%s]\n", driverpath);
-	printf ("\tDatafile: [%s]\n", datafile);
-	printf ("\tConfigfile: [%s]\n", configfile);
-	printf ("\tHelpfile: [%s]\n\n", helpfile);
-
-	while (valid)
-	{
-		rpcstr_pull(dependentfiles, i1->dependentfiles+length, sizeof(dependentfiles), 0, STR_TERMINATE);
-		
-		length+=strlen(dependentfiles)+1;
-		
-		if (strlen(dependentfiles) > 0)
-		{
-			printf ("\tDependentfiles: [%s]\n", dependentfiles);
-		}
-		else
-		{
-			valid = False;
-		}
-	}
-	
-	printf ("\n");
-
-	printf ("\tMonitorname: [%s]\n", monitorname);
-	printf ("\tDefaultdatatype: [%s]\n\n", defaultdatatype);
-
-	return;	
-}
-
-/***********************************************************************
- * Get printer information
- */
-static NTSTATUS cmd_spoolss_getdriver(struct cli_state *cli, 
-                                      TALLOC_CTX *mem_ctx,
-                                      int argc, char **argv)
-{
-	POLICY_HND 	pol;
-	WERROR          werror;
-	NTSTATUS	result;
-	uint32		info_level = 3;
-	BOOL 		opened_hnd = False;
-	PRINTER_DRIVER_CTR 	ctr;
-	fstring 	printername, 
-			servername, 
-			user;
-	uint32		i;
-
-	if ((argc == 1) || (argc > 3)) 
-	{
-		printf("Usage: %s <printername> [level]\n", argv[0]);
-		return NT_STATUS_OK;
-	}
-
-	/* get the arguments need to open the printer handle */
-	slprintf (servername, sizeof(fstring)-1, "\\\\%s", cli->desthost);
-	strupper (servername);
-	fstrcpy  (user, cli->user_name);
-	fstrcpy  (printername, argv[1]);
-	if (argc == 3)
-		info_level = atoi(argv[2]);
-
-	/* Open a printer handle */
-
-	werror = cli_spoolss_open_printer_ex(cli, mem_ctx, printername, "", 
-					     PRINTER_ACCESS_USE,
-					     servername, user, &pol);
-
-	result = W_ERROR_IS_OK(werror) ? NT_STATUS_OK : NT_STATUS_UNSUCCESSFUL;
-
-	if (!NT_STATUS_IS_OK(result)) {
-		printf("Error opening printer handle for %s!\n", printername);
-		return result;
-	}
-
-	opened_hnd = True;
-
-	/* loop through and print driver info level for each architecture */
-
-	for (i=0; archi_table[i].long_archi!=NULL; i++) {
-		uint32 needed;
-
-		werror = cli_spoolss_getprinterdriver(
-			cli, mem_ctx, 0, &needed, &pol, info_level, 
-			archi_table[i].long_archi, &ctr);
-
-		if (W_ERROR_V(werror) == ERRinsufficientbuffer)
-			werror = cli_spoolss_getprinterdriver(
-				cli, mem_ctx, needed, NULL, &pol, info_level, 
-						       archi_table[i].long_archi, &ctr);
-
-		if (!W_ERROR_IS_OK(werror))
-			continue;
-			
-		printf ("\n[%s]\n", archi_table[i].long_archi);
-			
-		switch (info_level) {
-		case 1:
-			display_print_driver_1 (ctr.info1);
-			break;
-		case 2:
-			display_print_driver_2 (ctr.info2);
-			break;
-		case 3:
-			display_print_driver_3 (ctr.info3);
-			break;
-		default:
-			printf("unknown info level %d\n", info_level);
-			break;
-		}
-	}
-	
-	/* Cleanup */
-
-	if (opened_hnd)
-		cli_spoolss_close_printer (cli, mem_ctx, &pol);
-	
-	return W_ERROR_IS_OK(result) ? NT_STATUS_OK : NT_STATUS_UNSUCCESSFUL;
-}
-
-/***********************************************************************
- * Get printer information
- */
-static NTSTATUS cmd_spoolss_enum_drivers(struct cli_state *cli, 
-                                         TALLOC_CTX *mem_ctx,
-                                         int argc, char **argv)
-{
-	WERROR werror;
-	uint32          info_level = 1;
-	PRINTER_DRIVER_CTR 	ctr;
-	uint32		i, j,
-			returned;
-
-	if (argc > 2) 
-	{
-		printf("Usage: enumdrivers [level]\n");
-		return NT_STATUS_OK;
-	}
-
-	if (argc == 2)
-		info_level = atoi(argv[1]);
-
-
-	/* loop through and print driver info level for each architecture */
-	for (i=0; archi_table[i].long_archi!=NULL; i++) 
-	{
-		uint32 needed;
-
-		werror = cli_spoolss_enumprinterdrivers(
-			cli, mem_ctx, 0, &needed, info_level, 
-			archi_table[i].long_archi, &returned, &ctr);
-
-		if (W_ERROR_V(werror) == ERRinsufficientbuffer)
-			werror = cli_spoolss_enumprinterdrivers(
-				cli, mem_ctx, needed, NULL, info_level, 
-				archi_table[i].long_archi, &returned, &ctr);
-
-		if (returned == 0)
-			continue;
-			
-		if (!W_ERROR_IS_OK(werror)) {
-			printf ("Error getting driver for environment [%s] - %d\n",
-				archi_table[i].long_archi, W_ERROR_V(werror));
-			continue;
-		}
-		
-		printf ("\n[%s]\n", archi_table[i].long_archi);
-		switch (info_level) 
-		{
-			
-		case 1:
-			for (j=0; j < returned; j++) {
-				display_print_driver_1 (&(ctr.info1[j]));
-			}
-			break;
-		case 2:
-			for (j=0; j < returned; j++) {
-				display_print_driver_2 (&(ctr.info2[j]));
-			}
-			break;
-		case 3:
-			for (j=0; j < returned; j++) {
-				display_print_driver_3 (&(ctr.info3[j]));
-			}
-			break;
-		default:
-			printf("unknown info level %d\n", info_level);
-			break;
-		}
-	}
-	
-	return W_ERROR_IS_OK(werror) ? NT_STATUS_OK : NT_STATUS_UNSUCCESSFUL;
-}
-
-/****************************************************************************
-printer info level 1 display function
-****************************************************************************/
-static void display_printdriverdir_1(DRIVER_DIRECTORY_1 *i1)
-{
-        fstring name;
-        if (i1 == NULL)
-                return;
- 
-	rpcstr_pull(name, i1->name.buffer, sizeof(name), 0, STR_TERMINATE);
- 
-	printf ("\tDirectory Name:[%s]\n", name);
-}
-
-/***********************************************************************
- * Get printer driver directory information
- */
-static NTSTATUS cmd_spoolss_getdriverdir(struct cli_state *cli, 
-                                         TALLOC_CTX *mem_ctx,
-                                         int argc, char **argv)
-{
-	WERROR result;
-	fstring			env;
-	DRIVER_DIRECTORY_CTR	ctr;
-	uint32 needed;
-
-	if (argc > 2) {
-		printf("Usage: %s [environment]\n", argv[0]);
-		return NT_STATUS_OK;
-	}
-
-	/* Get the arguments need to open the printer handle */
-
-	if (argc == 2)
-		fstrcpy (env, argv[1]);
-	else
-		fstrcpy (env, "Windows NT x86");
-
-	/* Get the directory.  Only use Info level 1 */
-
-	result = cli_spoolss_getprinterdriverdir(
-		cli, mem_ctx, 0, &needed, 1, env, &ctr);
-
-	if (W_ERROR_V(result) == ERRinsufficientbuffer)
-		result = cli_spoolss_getprinterdriverdir(
-			cli, mem_ctx, needed, NULL, 1, env, &ctr);
-	
-	if (W_ERROR_IS_OK(result))
-		display_printdriverdir_1(ctr.info1);
-
-	return W_ERROR_IS_OK(result) ? NT_STATUS_OK : NT_STATUS_UNSUCCESSFUL;
-}
-
-/*******************************************************************************
- set the version and environment fields of a DRIVER_INFO_3 struct
- ******************************************************************************/
-void set_drv_info_3_env (DRIVER_INFO_3 *info, const char *arch)
-{
-
-	int i;
-	
-	for (i=0; archi_table[i].long_archi != NULL; i++) 
-	{
-		if (strcmp(arch, archi_table[i].short_archi) == 0)
-		{
-			info->version = archi_table[i].version;
-			init_unistr (&info->architecture, archi_table[i].long_archi);
-			break;
-		}
-	}
-	
-	if (archi_table[i].long_archi == NULL)
-	{
-		ZERODEBUG(0, ("set_drv_info_3_env: Unknown arch [%s]\n", arch));
-	}
-	
-	return;
-}
-
-
-/**************************************************************************
- wrapper for strtok to get the next parameter from a delimited list.
- Needed to handle the empty parameter string denoted by "NULL"
- *************************************************************************/
-static char* get_driver_3_param (char* str, const char* delim, UNISTR* dest)
-{
-	char	*ptr;
-
-	/* get the next token */
-	ptr = strtok(str, delim);
-
-	/* a string of 'NULL' is used to represent an empty
-	   parameter because two consecutive delimiters
-	   will not return an empty string.  See man strtok(3)
-	   for details */
-	if (StrCaseCmp(ptr, "NULL") == 0)
-		ptr = NULL;
-
-	if (dest != NULL)
-		init_unistr(dest, ptr);	
-
-	return ptr;
-}
-
-/********************************************************************************
- fill in the members of a DRIVER_INFO_3 struct using a character 
- string in the form of
- 	 <Long Printer Name>:<Driver File Name>:<Data File Name>:\
-	     <Config File Name>:<Help File Name>:<Language Monitor Name>:\
-	     <Default Data Type>:<Comma Separated list of Files> 
- *******************************************************************************/
-static BOOL init_drv_info_3_members (
-	TALLOC_CTX *mem_ctx, 
-	DRIVER_INFO_3 *info, 
-	char *args
-)
-{
-	char	*str, *str2;
-	uint32	len, i;
-	
-	/* fill in the UNISTR fields */
-	str = get_driver_3_param (args, ":", &info->name);
-	str = get_driver_3_param (NULL, ":", &info->driverpath);
-	str = get_driver_3_param (NULL, ":", &info->datafile);
-	str = get_driver_3_param (NULL, ":", &info->configfile);
-	str = get_driver_3_param (NULL, ":", &info->helpfile);
-	str = get_driver_3_param (NULL, ":", &info->monitorname);
-	str = get_driver_3_param (NULL, ":", &info->defaultdatatype);
-
-	/* <Comma Separated List of Dependent Files> */
-	str2 = get_driver_3_param (NULL, ":", NULL); /* save the beginning of the string */
-	str = str2;			
-
-	/* begin to strip out each filename */
-	str = strtok(str, ",");		
-	len = 0;
-	while (str != NULL)
-	{
-		/* keep a cumlative count of the str lengths */
-		len += strlen(str)+1;
-		str = strtok(NULL, ",");
-	}
-
-	/* allocate the space; add one extra slot for a terminating NULL.
-	   Each filename is NULL terminated and the end contains a double
-	   NULL */
-	if ((info->dependentfiles=(uint16*)talloc(mem_ctx, (len+1)*sizeof(uint16))) == NULL)
-	{
-		ZERODEBUG(0,("init_drv_info_3_members: Unable to malloc memory for dependenfiles\n"));
-		return False;
-	}
-	for (i=0; i<len; i++)
-	{
-		info->dependentfiles[i] = SSVAL(&info->dependentfiles[i], 0, str2[i]);
-	}
-	info->dependentfiles[len] = '\0';
-
-	return True;
-}
-
-
-static NTSTATUS cmd_spoolss_addprinterdriver(struct cli_state *cli, 
-                                             TALLOC_CTX *mem_ctx,
-                                             int argc, char **argv)
-{
-	WERROR result;
-	uint32                  level = 3;
-	PRINTER_DRIVER_CTR	ctr;
-	DRIVER_INFO_3		info3;
-	fstring			arch;
-	fstring			driver_name;
-
-	/* parse the command arguements */
-	if (argc != 3)
-	{
-		printf ("Usage: %s <Environment>\\\n", argv[0]);
-		printf ("\t<Long Printer Name>:<Driver File Name>:<Data File Name>:\\\n");
-    		printf ("\t<Config File Name>:<Help File Name>:<Language Monitor Name>:\\\n");
-	    	printf ("\t<Default Data Type>:<Comma Separated list of Files>\n");
-
-		return NT_STATUS_OK;
-        }
-		
-	/* Fill in the DRIVER_INFO_3 struct */
-	ZERO_STRUCT(info3);
-	if (!get_short_archi(arch, argv[1]))
-	{
-		printf ("Error Unknown architechture [%s]\n", argv[1]);
-		return NT_STATUS_INVALID_PARAMETER;
-	}
-	else
-		set_drv_info_3_env(&info3, arch);
-
-	if (!init_drv_info_3_members(mem_ctx, &info3, argv[2]))
-	{
-		printf ("Error Invalid parameter list - %s.\n", argv[2]);
-		return NT_STATUS_INVALID_PARAMETER;
-	}
-
-
-	ctr.info3 = &info3;
-	result = cli_spoolss_addprinterdriver (cli, mem_ctx, level, &ctr);
-
-	if (W_ERROR_IS_OK(result)) {
-		rpcstr_pull(driver_name, info3.name.buffer, 
-			    sizeof(driver_name), 0, STR_TERMINATE);
-		printf ("Printer Driver %s successfully installed.\n",
-			driver_name);
-	}
-
-	return W_ERROR_IS_OK(result) ? NT_STATUS_OK : NT_STATUS_UNSUCCESSFUL;
-}
-
-
-static NTSTATUS cmd_spoolss_addprinterex(struct cli_state *cli, 
-                                         TALLOC_CTX *mem_ctx, 
-                                         int argc, char **argv)
-{
-	WERROR result;
-	uint32			level = 2;
-	PRINTER_INFO_CTR	ctr;
-	PRINTER_INFO_2		info2;
-	fstring			servername;
-	
-	/* parse the command arguements */
-	if (argc != 5)
-	{
-		printf ("Usage: %s <name> <shared name> <driver> <port>\n", argv[0]);
-		return NT_STATUS_OK;
-        }
-	
-        slprintf (servername, sizeof(fstring)-1, "\\\\%s", cli->desthost);
-        strupper (servername);
-
-	/* Fill in the DRIVER_INFO_3 struct */
-	ZERO_STRUCT(info2);
-#if 0	/* JERRY */
-	init_unistr( &info2.servername, 	servername);
-#endif
-	init_unistr( &info2.printername,	argv[1]);
-	init_unistr( &info2.sharename, 		argv[2]);
-	init_unistr( &info2.drivername,		argv[3]);
-	init_unistr( &info2.portname,		argv[4]);
-	init_unistr( &info2.comment,		"Created by rpcclient");
-	init_unistr( &info2.printprocessor, 	"winprint");
-	init_unistr( &info2.datatype,		"RAW");
-	info2.devmode = 	NULL;
-	info2.secdesc = 	NULL;
-	info2.attributes 	= PRINTER_ATTRIBUTE_SHARED;
-	info2.priority 		= 0;
-	info2.defaultpriority	= 0;
-	info2.starttime		= 0;
-	info2.untiltime		= 0;
-	
-	/* These three fields must not be used by AddPrinter() 
-	   as defined in the MS Platform SDK documentation..  
-	   --jerry
-	info2.status		= 0;
-	info2.cjobs		= 0;
-	info2.averageppm	= 0;
-	*/
-
-	ctr.printers_2 = &info2;
-	result = cli_spoolss_addprinterex (cli, mem_ctx, level, &ctr);
-
-	if (W_ERROR_IS_OK(result))
-	printf ("Printer %s successfully installed.\n", argv[1]);
-
-	return W_ERROR_IS_OK(result) ? NT_STATUS_OK : NT_STATUS_UNSUCCESSFUL;
-}
-
-static NTSTATUS cmd_spoolss_setdriver(struct cli_state *cli, TALLOC_CTX *mem_ctx,
-                                      int argc, char **argv)
-{
-	POLICY_HND		pol;
-	WERROR                  result;
-	uint32			level = 2;
-	BOOL			opened_hnd = False;
-	PRINTER_INFO_CTR	ctr;
-	PRINTER_INFO_2		info2;
-	fstring			servername,
-				printername,
-				user;
-	uint32 needed;
-	
-	/* parse the command arguements */
-	if (argc != 3)
-	{
-		printf ("Usage: %s <printer> <driver>\n", argv[0]);
-		return NT_STATUS_OK;
-        }
-
-	slprintf (servername, sizeof(fstring)-1, "\\\\%s", cli->desthost);
-	strupper (servername);
-	slprintf (printername, sizeof(fstring)-1, "%s\\%s", servername, argv[1]);
-	fstrcpy  (user, cli->user_name);
-
-	/* Get a printer handle */
-
-	result = cli_spoolss_open_printer_ex(cli, mem_ctx, printername, "",
-					     PRINTER_ALL_ACCESS,
-					     servername, user, &pol);
-
-	if (!W_ERROR_IS_OK(result))
-		goto done;
-
-	opened_hnd = True;
-
-	/* Get printer info */
-
-	ZERO_STRUCT (info2);
-	ctr.printers_2 = &info2;
-
-	result = cli_spoolss_getprinter(cli, mem_ctx, 0, &needed, &pol, level, &ctr);
-
-	if (W_ERROR_V(result) == ERRinsufficientbuffer)
-		result = cli_spoolss_getprinter(cli, mem_ctx, needed, NULL, &pol, level, &ctr);
-
-	if (!W_ERROR_IS_OK(result)) {
-		printf ("Unable to retrieve printer information!\n");
-		goto done;
-	}
-
-	/* Set the printer driver */
-
-	init_unistr(&ctr.printers_2->drivername, argv[2]);
-
-	result = cli_spoolss_setprinter(cli, mem_ctx, &pol, level, &ctr, 0);
-
-	if (!W_ERROR_IS_OK(result)) {
-		printf("SetPrinter call failed!\n");
-		goto done;;
-	}
-
-	printf("Succesfully set %s to driver %s.\n", argv[1], argv[2]);
-
-done:
-	/* Cleanup */
-
-	if (opened_hnd)
-		cli_spoolss_close_printer(cli, mem_ctx, &pol);
-
-	return W_ERROR_IS_OK(result) ? NT_STATUS_OK : NT_STATUS_UNSUCCESSFUL;
-}
-
-
-static NTSTATUS cmd_spoolss_deletedriver(struct cli_state *cli,
-                                         TALLOC_CTX *mem_ctx,
-                                         int argc, char **argv)
-{
-	WERROR result;
-	fstring			servername;
-	int			i;
-	
-	/* parse the command arguements */
-	if (argc != 2)
-	{
-		printf ("Usage: %s <driver>\n", argv[0]);
-		return NT_STATUS_OK;
-        }
-
-	slprintf (servername, sizeof(fstring)-1, "\\\\%s", cli->desthost);
-	strupper (servername);
-
-	/* delete the driver for all architectures */
-	for (i=0; archi_table[i].long_archi; i++)
-	{
-		/* make the call to remove the driver */
-		result = cli_spoolss_deleteprinterdriver(
-			cli, mem_ctx, archi_table[i].long_archi, argv[1]);
-
-		if ( !W_ERROR_IS_OK(result) ) {
-			if ( !W_ERROR_EQUAL(result, WERR_UNKNOWN_PRINTER_DRIVER) ) {
-				printf ("Failed to remove driver %s for arch [%s] - error 0x%x!\n", 
-					argv[1], archi_table[i].long_archi, 
-					W_ERROR_V(result));
-			}
-		} 
-		else 
-		{
-			printf ("Driver %s removed for arch [%s].\n", argv[1], 
-				archi_table[i].long_archi);
-		}
-	}
-		
-	return W_ERROR_IS_OK(result) || W_ERROR_EQUAL(result, WERR_UNKNOWN_PRINTER_DRIVER) ? NT_STATUS_OK : NT_STATUS_UNSUCCESSFUL;
-}
-
-static NTSTATUS cmd_spoolss_getprintprocdir(struct cli_state *cli, 
-					    TALLOC_CTX *mem_ctx,
-					    int argc, char **argv)
-{
-	WERROR result;
-	char *servername = NULL, *environment = NULL;
-	fstring procdir;
-	uint32 needed;
-	
-	/* parse the command arguements */
-	if (argc > 2) {
-		printf ("Usage: %s [environment]\n", argv[0]);
-		return NT_STATUS_OK;
-        }
-
-	if (asprintf(&servername, "\\\\%s", cli->desthost) < 0)
-		return NT_STATUS_NO_MEMORY;
-	strupper(servername);
-
-	if (asprintf(&environment, "%s", (argc == 2) ? argv[1] : 
-		 			PRINTER_DRIVER_ARCHITECTURE) < 0) {
-		SAFE_FREE(servername);
-		return NT_STATUS_NO_MEMORY;
-	}
-
-	result = cli_spoolss_getprintprocessordirectory(
-		cli, mem_ctx, 0, &needed, servername, environment, procdir);
-
-	if (W_ERROR_V(result) == ERRinsufficientbuffer)
-		result = cli_spoolss_getprintprocessordirectory(
-			cli, mem_ctx, needed, NULL, servername, environment, 
-			procdir);
-
-	if (W_ERROR_IS_OK(result))
-		printf("%s\n", procdir);
-
-	SAFE_FREE(servername);
-	SAFE_FREE(environment);
-
-	return W_ERROR_IS_OK(result) ? NT_STATUS_OK : NT_STATUS_UNSUCCESSFUL;
-}
-
-/* Add a form */
-
-static NTSTATUS cmd_spoolss_addform(struct cli_state *cli, TALLOC_CTX *mem_ctx,
-				    int argc, char **argv)
-{
-	POLICY_HND handle;
-	WERROR werror;
-	char *servername = NULL, *printername = NULL;
-	FORM form;
-	BOOL got_handle = False;
-	
-	/* Parse the command arguements */
-
-	if (argc != 3) {
-		printf ("Usage: %s <printer> <formname>\n", argv[0]);
-		return NT_STATUS_OK;
-        }
-	
-	/* Get a printer handle */
-
-	asprintf(&servername, "\\\\%s", cli->desthost);
-	strupper(servername);
-	asprintf(&printername, "%s\\%s", servername, argv[1]);
-
-	werror = cli_spoolss_open_printer_ex(cli, mem_ctx, printername, "", 
-					     MAXIMUM_ALLOWED_ACCESS, 
-					     servername, cli->user_name, &handle);
-
-	if (!W_ERROR_IS_OK(werror))
-		goto done;
-
-	got_handle = True;
-
-	/* Dummy up some values for the form data */
-
-	form.flags = FORM_USER;
-	form.size_x = form.size_y = 100;
-	form.left = 0;
-	form.top = 10;
-	form.right = 20;
-	form.bottom = 30;
-
-	init_unistr2(&form.name, argv[2], strlen(argv[2]) + 1);
-
-	/* Add the form */
-
-
-	werror = cli_spoolss_addform(cli, mem_ctx, &handle, 1, &form);
-
- done:
-	if (got_handle)
-		cli_spoolss_close_printer(cli, mem_ctx, &handle);
-
-	SAFE_FREE(servername);
-	SAFE_FREE(printername);
-
-	return W_ERROR_IS_OK(werror) ? NT_STATUS_OK : NT_STATUS_UNSUCCESSFUL;
-}
-
-/* Set a form */
-
-static NTSTATUS cmd_spoolss_setform(struct cli_state *cli, TALLOC_CTX *mem_ctx,
-				    int argc, char **argv)
-{
-	POLICY_HND handle;
-	WERROR werror;
-	char *servername = NULL, *printername = NULL;
-	FORM form;
-	BOOL got_handle = False;
-	
-	/* Parse the command arguements */
-
-	if (argc != 3) {
-		printf ("Usage: %s <printer> <formname>\n", argv[0]);
-		return NT_STATUS_OK;
-        }
-	
-	/* Get a printer handle */
-
-	asprintf(&servername, "\\\\%s", cli->desthost);
-	strupper(servername);
-	asprintf(&printername, "%s\\%s", servername, argv[1]);
-
-	werror = cli_spoolss_open_printer_ex(
-		cli, mem_ctx, printername, "", MAXIMUM_ALLOWED_ACCESS, 
-		servername, cli->user_name, &handle);
-
-	if (!W_ERROR_IS_OK(werror))
-		goto done;
-
-	got_handle = True;
-
-	/* Dummy up some values for the form data */
-
-	form.flags = FORM_PRINTER;
-	form.size_x = form.size_y = 100;
-	form.left = 0;
-	form.top = 1000;
-	form.right = 2000;
-	form.bottom = 3000;
-
-	init_unistr2(&form.name, argv[2], strlen(argv[2]) + 1);
-
-	/* Set the form */
-
-	werror = cli_spoolss_setform(cli, mem_ctx, &handle, 1, argv[2], &form);
-
- done:
-	if (got_handle)
-		cli_spoolss_close_printer(cli, mem_ctx, &handle);
-
-	SAFE_FREE(servername);
-	SAFE_FREE(printername);
-
-	return W_ERROR_IS_OK(werror) ? NT_STATUS_OK : NT_STATUS_UNSUCCESSFUL;
-}
-
-/* Get a form */
-
-static NTSTATUS cmd_spoolss_getform(struct cli_state *cli, TALLOC_CTX *mem_ctx,
-				    int argc, char **argv)
-{
-	POLICY_HND handle;
-	WERROR werror;
-	char *servername = NULL, *printername = NULL;
-	FORM_1 form;
-	BOOL got_handle = False;
-	uint32 needed;
-	
-	/* Parse the command arguements */
-
-	if (argc != 3) {
-		printf ("Usage: %s <printer> <formname>\n", argv[0]);
-		return NT_STATUS_OK;
-        }
-	
-	/* Get a printer handle */
-
-	asprintf(&servername, "\\\\%s", cli->desthost);
-	strupper(servername);
-	asprintf(&printername, "%s\\%s", servername, argv[1]);
-
-	werror = cli_spoolss_open_printer_ex(
-		cli, mem_ctx, printername, "", MAXIMUM_ALLOWED_ACCESS, 
-		servername, cli->user_name, &handle);
-
-	if (!W_ERROR_IS_OK(werror))
-		goto done;
-
-	got_handle = True;
-
-	/* Set the form */
-
-	werror = cli_spoolss_getform(cli, mem_ctx, 0, &needed,
-				     &handle, argv[2], 1, &form);
-
-	if (W_ERROR_V(werror) == ERRinsufficientbuffer)
-		werror = cli_spoolss_getform(cli, mem_ctx, needed, NULL,
-					     &handle, argv[2], 1, &form);
-
-	if (!W_ERROR_IS_OK(werror))
-		goto done;
-
-	printf("width: %d\n", form.width);
-	printf("length: %d\n", form.length);
-	printf("left: %d\n", form.left);
-	printf("top: %d\n", form.top);
-	printf("right: %d\n", form.right);
-	printf("bottom: %d\n", form.bottom);
-
- done:
-	if (got_handle)
-		cli_spoolss_close_printer(cli, mem_ctx, &handle);
-
-	SAFE_FREE(servername);
-	SAFE_FREE(printername);
-
-	return W_ERROR_IS_OK(werror) ? NT_STATUS_OK : NT_STATUS_UNSUCCESSFUL;
-}
-
-/* Delete a form */
-
-static NTSTATUS cmd_spoolss_deleteform(struct cli_state *cli, 
-				       TALLOC_CTX *mem_ctx, int argc, 
-				       char **argv)
-{
-	POLICY_HND handle;
-	WERROR werror;
-	char *servername = NULL, *printername = NULL;
-	BOOL got_handle = False;
-	
-	/* Parse the command arguements */
-
-	if (argc != 3) {
-		printf ("Usage: %s <printer> <formname>\n", argv[0]);
-		return NT_STATUS_OK;
-        }
-	
-	/* Get a printer handle */
-
-	asprintf(&servername, "\\\\%s", cli->desthost);
-	strupper(servername);
-	asprintf(&printername, "%s\\%s", servername, argv[1]);
-
-	werror = cli_spoolss_open_printer_ex(
-		cli, mem_ctx, printername, "", MAXIMUM_ALLOWED_ACCESS, 
-		servername, cli->user_name, &handle);
-
-	if (!W_ERROR_IS_OK(werror))
-		goto done;
-
-	got_handle = True;
-
-	/* Delete the form */
-
-	werror = cli_spoolss_deleteform(cli, mem_ctx, &handle, argv[2]);
-
- done:
-	if (got_handle)
-		cli_spoolss_close_printer(cli, mem_ctx, &handle);
-
-	SAFE_FREE(servername);
-	SAFE_FREE(printername);
-
-	return W_ERROR_IS_OK(werror) ? NT_STATUS_OK : NT_STATUS_UNSUCCESSFUL;
-}
-
-/* Enumerate forms */
-
-static NTSTATUS cmd_spoolss_enum_forms(struct cli_state *cli, 
-				       TALLOC_CTX *mem_ctx, int argc, 
-				       char **argv)
-{
-	POLICY_HND handle;
-	WERROR werror;
-	char *servername = NULL, *printername = NULL;
-	BOOL got_handle = False;
-	uint32 needed, num_forms, level = 1, i;
-	FORM_1 *forms;
-	
-	/* Parse the command arguements */
-
-	if (argc != 2) {
-		printf ("Usage: %s <printer>\n", argv[0]);
-		return NT_STATUS_OK;
-        }
-	
-	/* Get a printer handle */
-
-	asprintf(&servername, "\\\\%s", cli->desthost);
-	strupper(servername);
-	asprintf(&printername, "%s\\%s", servername, argv[1]);
-
-	werror = cli_spoolss_open_printer_ex(
-		cli, mem_ctx, printername, "", MAXIMUM_ALLOWED_ACCESS, 
-		servername, cli->user_name, &handle);
-
-	if (!W_ERROR_IS_OK(werror))
-		goto done;
-
-	got_handle = True;
-
-	/* Enumerate forms */
-
-	werror = cli_spoolss_enumforms(
-		cli, mem_ctx, 0, &needed, &handle, level, &num_forms, &forms);
-
-	if (W_ERROR_V(werror) == ERRinsufficientbuffer)
-		werror = cli_spoolss_enumforms(
-			cli, mem_ctx, needed, NULL, &handle, level, 
-			&num_forms, &forms);
-
-	if (!W_ERROR_IS_OK(werror))
-		goto done;
-
-	/* Display output */
-
-	for (i = 0; i < num_forms; i++) {
-		fstring form_name;
-
-		if (forms[i].name.buffer)
-			rpcstr_pull(form_name, forms[i].name.buffer,
-				    sizeof(form_name), 0, STR_TERMINATE);
-
-		printf("%s\n", form_name);
-	}
-
- done:
-	if (got_handle)
-		cli_spoolss_close_printer(cli, mem_ctx, &handle);
-
-	SAFE_FREE(servername);
-	SAFE_FREE(printername);
-
-	return W_ERROR_IS_OK(werror) ? NT_STATUS_OK : NT_STATUS_UNSUCCESSFUL;
-}
-
-static NTSTATUS cmd_spoolss_setprinterdata(struct cli_state *cli,
-					    TALLOC_CTX *mem_ctx,
-					    int argc, char **argv)
-{
-	WERROR result;
-	uint32 needed;
-	fstring servername, printername, user;
-	POLICY_HND pol;
-	BOOL opened_hnd = False;
-	PRINTER_INFO_CTR ctr;
-	PRINTER_INFO_0 *info = NULL;
-
-	/* parse the command arguements */
-	if (argc != 4) {
-		printf ("Usage: %s <printer> <value> <data>\n", argv[0]);
-		return NT_STATUS_OK;
-        }
-
-	slprintf (servername, sizeof(fstring)-1, "\\\\%s", cli->desthost);
-	strupper (servername);
-	slprintf (printername, sizeof(fstring)-1, "%s\\%s", servername, argv[1]);
-	fstrcpy  (user, cli->user_name);
-
-	/* get a printer handle */
-	result = cli_spoolss_open_printer_ex(cli, mem_ctx, printername, "",
-					     MAXIMUM_ALLOWED_ACCESS, servername, 
-					     user, &pol);
-	if (!W_ERROR_IS_OK(result))
-		goto done;
-
-	opened_hnd = True;
-	
-        result = cli_spoolss_getprinter(cli, mem_ctx, 0, &needed,
-                                        &pol, 0, &ctr);
-
-        if (W_ERROR_V(result) == ERRinsufficientbuffer)
-                result = cli_spoolss_getprinter(cli, mem_ctx, needed, NULL, &pol, 0, &ctr);
-	
-        if (!W_ERROR_IS_OK(result))
-		goto done;
-		
-	printf("%s\n", timestring(True));
-	printf("\tchange_id (before set)\t:[0x%x]\n", info->change_id);
-	
-
-	/* Set the printer data */
-	
-	result = cli_spoolss_setprinterdata(cli, mem_ctx, &pol, argv[2], argv[3]);
-	if (!W_ERROR_IS_OK(result)) {
-		printf ("Unable to set [%s=%s]!\n", argv[2], argv[3]);
-		goto done;
-	}
-	printf("\tSetPrinterData succeeded [%s: %s]\n", argv[2], argv[3]);
-
-        result = cli_spoolss_getprinter(cli, mem_ctx, 0, &needed, &pol, 0, &ctr);
-
-        if (W_ERROR_V(result) == ERRinsufficientbuffer)
-                result = cli_spoolss_getprinter(cli, mem_ctx, needed, NULL, &pol, 0, &ctr);
-
-        if (!W_ERROR_IS_OK(result))
-		goto done;
-		
-	printf("%s\n", timestring(True));
-	printf("\tchange_id (after set)\t:[0x%x]\n", info->change_id);
-
-done:
-	/* cleanup */
-	if (opened_hnd)
-		cli_spoolss_close_printer(cli, mem_ctx, &pol);
-
-	return W_ERROR_IS_OK(result) ? NT_STATUS_OK : NT_STATUS_UNSUCCESSFUL;
-}
-
-/* List of commands exported by this module */
-struct cmd_set spoolss_commands[] = {
-
-	{ "SPOOLSS"  },
-
-	{ "adddriver",		cmd_spoolss_addprinterdriver,	PIPE_SPOOLSS, "Add a print driver",                  "" },
-	{ "addprinter",		cmd_spoolss_addprinterex,	PIPE_SPOOLSS, "Add a printer",                       "" },
-	{ "deldriver",		cmd_spoolss_deletedriver,	PIPE_SPOOLSS, "Delete a printer driver",             "" },
-	{ "enumdata",		cmd_spoolss_not_implemented,	PIPE_SPOOLSS, "Enumerate printer data (*)",          "" },
-	{ "enumjobs",		cmd_spoolss_not_implemented,	PIPE_SPOOLSS, "Enumerate print jobs (*)",            "" },
-	{ "enumports", 		cmd_spoolss_enum_ports, 	PIPE_SPOOLSS, "Enumerate printer ports",             "" },
-	{ "enumdrivers", 	cmd_spoolss_enum_drivers, 	PIPE_SPOOLSS, "Enumerate installed printer drivers", "" },
-	{ "enumprinters", 	cmd_spoolss_enum_printers, 	PIPE_SPOOLSS, "Enumerate printers",                  "" },
-	{ "getdata",		cmd_spoolss_not_implemented,	PIPE_SPOOLSS, "Get print driver data (*)",           "" },
-	{ "getdriver",		cmd_spoolss_getdriver,		PIPE_SPOOLSS, "Get print driver information",        "" },
-	{ "getdriverdir",	cmd_spoolss_getdriverdir,	PIPE_SPOOLSS, "Get print driver upload directory",   "" },
-	{ "getprinter", 	cmd_spoolss_getprinter, 	PIPE_SPOOLSS, "Get printer info",                    "" },
-	{ "getprintprocdir",	cmd_spoolss_getprintprocdir,    PIPE_SPOOLSS, "Get print processor directory",       "" },
-	{ "openprinter",	cmd_spoolss_open_printer_ex,	PIPE_SPOOLSS, "Open printer handle",                 "" },
-	{ "setdriver",		cmd_spoolss_setdriver,		PIPE_SPOOLSS, "Set printer driver",                  "" },
-	{ "getprintprocdir",	cmd_spoolss_getprintprocdir,    PIPE_SPOOLSS, "Get print processor directory",       "" },
-	{ "addform",            cmd_spoolss_addform,            PIPE_SPOOLSS, "Add form",                            "" },
-	{ "setform",            cmd_spoolss_setform,            PIPE_SPOOLSS, "Set form",                            "" },
-	{ "getform",            cmd_spoolss_getform,            PIPE_SPOOLSS, "Get form",                            "" },
-	{ "deleteform",         cmd_spoolss_deleteform,         PIPE_SPOOLSS, "Delete form",                         "" },
-	{ "enumforms",          cmd_spoolss_enum_forms,         PIPE_SPOOLSS, "Enumerate forms",                     "" },
-	{ "setprinter",	        cmd_spoolss_setprinter,         PIPE_SPOOLSS, "Set printer comment",                 "" },
-	{ "setprinterdata",	cmd_spoolss_setprinterdata,     PIPE_SPOOLSS, "Set REG_SZ printer data",             "" },
-
-	{ NULL }
-};
diff -Naur samba-2.2.12-orig/source/rpcclient/display_spool.c samba-2.2.12/source/rpcclient/display_spool.c
--- samba-2.2.12-orig/source/rpcclient/display_spool.c	2004-08-12 20:24:20.000000000 +0200
+++ samba-2.2.12/source/rpcclient/display_spool.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,927 +0,0 @@
-/* 
-   Unix SMB/CIFS implementation.
-   Samba utility functions
-   Copyright (C) Andrew Tridgell 1992-1999
-   Copyright (C) Luke Kenneth Casson Leighton 1996 - 1999
-   
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2 of the License, or
-   (at your option) any later version.
-   
-   This program is distributed in the hope that it will be useful, 
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-   
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-*/
-
-#include "includes.h"
-
-/****************************************************************************
-printer info level 0 display function
-****************************************************************************/
-static void display_print_info_0(FILE *out_hnd, PRINTER_INFO_0 *i1)
-{
-	fstring name;
-	fstring server;
-	if (i1 == NULL)
-		return;
-
-	rpcstr_pull(name, i1->printername.buffer, sizeof(name), 0, STR_TERMINATE);
-	rpcstr_pull(server, i1->servername.buffer, sizeof(server), 0, STR_TERMINATE);
-
-	report(out_hnd, "\tprintername:[%s]\n", name);
-	report(out_hnd, "\tservername:[%s]\n", server);
-	report(out_hnd, "\tcjobs:[%x]\n", i1->cjobs);
-	report(out_hnd, "\ttotal_jobs:[%x]\n", i1->total_jobs);
-	
-	report(out_hnd, "\t:date: [%d]-[%d]-[%d] (%d)\n", i1->year, i1->month, i1->day, i1->dayofweek);
-	report(out_hnd, "\t:time: [%d]-[%d]-[%d]-[%d]\n", i1->hour, i1->minute, i1->second, i1->milliseconds);
-	
-	report(out_hnd, "\tglobal_counter:[%x]\n", i1->global_counter);
-	report(out_hnd, "\ttotal_pages:[%x]\n", i1->total_pages);
-	
-	report(out_hnd, "\tmajorversion:[%x]\n", i1->major_version);
-	report(out_hnd, "\tbuildversion:[%x]\n", i1->build_version);
-	
-	report(out_hnd, "\tunknown7:[%x]\n", i1->unknown7);
-	report(out_hnd, "\tunknown8:[%x]\n", i1->unknown8);
-	report(out_hnd, "\tunknown9:[%x]\n", i1->unknown9);
-	report(out_hnd, "\tsession_counter:[%x]\n", i1->session_counter);
-	report(out_hnd, "\tunknown11:[%x]\n", i1->unknown11);
-	report(out_hnd, "\tprinter_errors:[%x]\n", i1->printer_errors);
-	report(out_hnd, "\tunknown13:[%x]\n", i1->unknown13);
-	report(out_hnd, "\tunknown14:[%x]\n", i1->unknown14);
-	report(out_hnd, "\tunknown15:[%x]\n", i1->unknown15);
-	report(out_hnd, "\tunknown16:[%x]\n", i1->unknown16);
-	report(out_hnd, "\tchange_id:[%x]\n", i1->change_id);
-	report(out_hnd, "\tunknown18:[%x]\n", i1->unknown18);
-	report(out_hnd, "\tstatus:[%x]\n", i1->status);
-	report(out_hnd, "\tunknown20:[%x]\n", i1->unknown20);
-	report(out_hnd, "\tc_setprinter:[%x]\n", i1->c_setprinter);
-	report(out_hnd, "\tunknown22:[%x]\n", i1->unknown22);
-	report(out_hnd, "\tunknown23:[%x]\n", i1->unknown23);
-	report(out_hnd, "\tunknown24:[%x]\n", i1->unknown24);
-	report(out_hnd, "\tunknown25:[%x]\n", i1->unknown25);
-	report(out_hnd, "\tunknown26:[%x]\n", i1->unknown26);
-	report(out_hnd, "\tunknown27:[%x]\n", i1->unknown27);
-	report(out_hnd, "\tunknown28:[%x]\n", i1->unknown28);
-	report(out_hnd, "\tunknown29:[%x]\n", i1->unknown29);
-}
-
-/****************************************************************************
-printer info level 1 display function
-****************************************************************************/
-static void display_print_info_1(FILE *out_hnd, PRINTER_INFO_1 *i1)
-{
-	fstring desc;
-	fstring name;
-	fstring comm;
-	if (i1 == NULL)
-		return;
-
-	rpcstr_pull(name, i1->name.buffer, sizeof(name), 0, STR_TERMINATE);
-	rpcstr_pull(desc, i1->description.buffer, sizeof(desc), 0, STR_TERMINATE);
-	rpcstr_pull(comm, i1->comment.buffer, sizeof(comm), 0, STR_TERMINATE);
-
-	report(out_hnd, "\tflags:[%x]\n", i1->flags);
-	report(out_hnd, "\tname:[%s]\n", name);
-	report(out_hnd, "\tdescription:[%s]\n", desc);
-	report(out_hnd, "\tcomment:[%s]\n\n", comm);
-}
-
-/****************************************************************************
-printer info level 2 display function
-****************************************************************************/
-static void display_print_info_2(FILE *out_hnd, PRINTER_INFO_2 *i2)
-{
-	fstring servername;
-	fstring printername;
-	fstring sharename;
-	fstring portname;
-	fstring drivername;
-	fstring comment;
-	fstring location;
-	fstring sepfile;
-	fstring printprocessor;
-	fstring datatype;
-	fstring parameters;
-	
-	if (i2 == NULL)
-		return;
-
-	rpcstr_pull(servername, i2->servername.buffer,sizeof(servername), 0, STR_TERMINATE);
-	rpcstr_pull(printername, i2->printername.buffer,sizeof(printername), 0, STR_TERMINATE);
-	rpcstr_pull(sharename, i2->sharename.buffer,sizeof(sharename), 0, STR_TERMINATE);
-	rpcstr_pull(portname, i2->portname.buffer,sizeof(portname), 0, STR_TERMINATE);
-	rpcstr_pull(drivername, i2->drivername.buffer,sizeof(drivername), 0, STR_TERMINATE);
-	rpcstr_pull(comment, i2->comment.buffer,sizeof(comment), 0, STR_TERMINATE);
-	rpcstr_pull(location, i2->location.buffer,sizeof(location), 0, STR_TERMINATE);
-	rpcstr_pull(sepfile, i2->sepfile.buffer,sizeof(sepfile), 0, STR_TERMINATE);
-	rpcstr_pull(printprocessor, i2->printprocessor.buffer,sizeof(printprocessor), 0, STR_TERMINATE);
-	rpcstr_pull(datatype, i2->datatype.buffer,sizeof(datatype), 0, STR_TERMINATE);
-	rpcstr_pull(parameters, i2->parameters.buffer,sizeof(parameters), 0, STR_TERMINATE);
-	
-	report(out_hnd, "\tservername:[%s]\n", servername);
-	report(out_hnd, "\tprintername:[%s]\n", printername);
-	report(out_hnd, "\tsharename:[%s]\n", sharename);
-	report(out_hnd, "\tportname:[%s]\n", portname);
-	report(out_hnd, "\tdrivername:[%s]\n", drivername);
-	report(out_hnd, "\tcomment:[%s]\n", comment);
-	report(out_hnd, "\tlocation:[%s]\n", location);
-	report(out_hnd, "\tsepfile:[%s]\n", sepfile);
-	report(out_hnd, "\tprintprocessor:[%s]\n", printprocessor);
-	report(out_hnd, "\tdatatype:[%s]\n", datatype);
-	report(out_hnd, "\tparameters:[%s]\n", parameters);
-	report(out_hnd, "\tattributes:[%x]\n", i2->attributes);
-	report(out_hnd, "\tpriority:[%x]\n", i2->priority);
-	report(out_hnd, "\tdefaultpriority:[%x]\n", i2->defaultpriority);
-	report(out_hnd, "\tstarttime:[%x]\n", i2->starttime);
-	report(out_hnd, "\tuntiltime:[%x]\n", i2->untiltime);
-	report(out_hnd, "\tstatus:[%x]\n", i2->status);
-	report(out_hnd, "\tcjobs:[%x]\n", i2->cjobs);
-	report(out_hnd, "\taverageppm:[%x]\n\n", i2->averageppm);
-
-	if (i2->secdesc != NULL)
-	{
-		display_sec_desc(out_hnd, ACTION_HEADER   , i2->secdesc);
-		display_sec_desc(out_hnd, ACTION_ENUMERATE, i2->secdesc);
-		display_sec_desc(out_hnd, ACTION_FOOTER   , i2->secdesc);
-	}
-}
-
-/****************************************************************************
-printer info level 3 display function
-****************************************************************************/
-static void display_print_info_3(FILE *out_hnd, PRINTER_INFO_3 *i3)
-{
-	if (i3 == NULL)
-		return;
-
-	report(out_hnd, "\tflags:[%x]\n", i3->flags);
-
-	display_sec_desc(out_hnd, ACTION_HEADER   , i3->secdesc);
-	display_sec_desc(out_hnd, ACTION_ENUMERATE, i3->secdesc);
-	display_sec_desc(out_hnd, ACTION_FOOTER   , i3->secdesc);
-}
-
-/****************************************************************************
-connection info level 0 container display function
-****************************************************************************/
-static void display_printer_info_0_ctr(FILE *out_hnd, enum action_type action, uint32 count,  PRINTER_INFO_CTR ctr)
-{
-	int i;
-	PRINTER_INFO_0 *in;
-
-	switch (action)
-	{
-		case ACTION_HEADER:
-			report(out_hnd, "Printer Info Level 0:\n");
-			break;
-		case ACTION_ENUMERATE:
-			for (i = 0; i < count; i++) {
-				in=ctr.printers_0;
-				display_print_info_0(out_hnd, &(in[i]) );
-			}
-			break;
-		case ACTION_FOOTER:
-			report(out_hnd, "\n");
-			break;
-	}
-}
-
-/****************************************************************************
-connection info level 1 container display function
-****************************************************************************/
-static void display_printer_info_1_ctr(FILE *out_hnd, enum action_type action, uint32 count,  PRINTER_INFO_CTR ctr)
-{
-	int i;
-	PRINTER_INFO_1 *in;
-
-	switch (action)
-	{
-		case ACTION_HEADER:
-			report(out_hnd, "Printer Info Level 1:\n");
-			break;
-		case ACTION_ENUMERATE:
-			for (i = 0; i < count; i++) {
-				in=ctr.printers_1;
-				display_print_info_1(out_hnd, &(in[i]) );
-			}
-			break;
-		case ACTION_FOOTER:
-			report(out_hnd, "\n");
-			break;
-	}
-}
-
-/****************************************************************************
-connection info level 2 container display function
-****************************************************************************/
-static void display_printer_info_2_ctr(FILE *out_hnd, enum action_type action, uint32 count,  PRINTER_INFO_CTR ctr)
-{
-	int i;
-	PRINTER_INFO_2 *in;
-
-	switch (action)
-	{
-		case ACTION_HEADER:
-			report(out_hnd, "Printer Info Level 2:\n");
-			break;
-		case ACTION_ENUMERATE:
-			for (i = 0; i < count; i++) {
-				in=ctr.printers_2;
-				display_print_info_2(out_hnd, &(in[i]) );
-			}
-			break;
-		case ACTION_FOOTER:
-			report(out_hnd, "\n");
-			break;
-	}
-}
-
-/****************************************************************************
-connection info level 3 container display function
-****************************************************************************/
-static void display_printer_info_3_ctr(FILE *out_hnd, enum action_type action, uint32 count,  PRINTER_INFO_CTR ctr)
-{
-	int i;
-	PRINTER_INFO_3 *in;
-
-	switch (action)
-	{
-		case ACTION_HEADER:
-			report(out_hnd, "Printer Info Level 3:\n");
-			break;
-		case ACTION_ENUMERATE:
-			for (i = 0; i < count; i++) {
-				in=ctr.printers_3;
-				display_print_info_3(out_hnd, &(in[i]) );
-			}
-			break;
-		case ACTION_FOOTER:
-			report(out_hnd, "\n");
-			break;
-	}
-}
-
-/****************************************************************************
-connection info container display function
-****************************************************************************/
-void display_printer_info_ctr(FILE *out_hnd, enum action_type action, uint32 level,
-				uint32 count, PRINTER_INFO_CTR ctr)
-{
-	switch (level) {
-		case 0:
-			display_printer_info_0_ctr(out_hnd, action, count, ctr);
-			break;
-		case 1:
-			display_printer_info_1_ctr(out_hnd, action, count, ctr);
-			break;
-		case 2:
-			display_printer_info_2_ctr(out_hnd, action, count, ctr);
-			break;
-		case 3:
-			display_printer_info_3_ctr(out_hnd, action, count, ctr);
-			break;
-		default:
-			report(out_hnd, "display_printer_info_ctr: Unknown Info Level\n");
-			break;
-	}
-}
-
-/****************************************************************************
-connection info level 3 container display function
-****************************************************************************/
-static void display_port_info_1_ctr(FILE *out_hnd, enum action_type action, 
-				    uint32 count,  PORT_INFO_CTR *ctr)
-{
-	uint32	i = 0;
-	switch (action)
-	{
-		case ACTION_HEADER:
-			report(out_hnd, "Port Info Level 1:\n");
-			break;
-		case ACTION_ENUMERATE:
-			for (i=0; i<count; i++)
-				display_port_info_1(out_hnd, action, &ctr->port.info_1[i]);
-			break;
-		case ACTION_FOOTER:
-			report(out_hnd, "\n");
-			break;
-	}
-}
-
-/****************************************************************************
-connection info level 3 container display function
-****************************************************************************/
-static void display_port_info_2_ctr(FILE *out_hnd, enum action_type action, 
-				    uint32 count,  PORT_INFO_CTR *ctr)
-{
-	uint32	i = 0;
-	switch (action)
-	{
-		case ACTION_HEADER:
-			report(out_hnd, "Port Info Level 2:\n");
-			break;
-		case ACTION_ENUMERATE:
-			for (i=0; i<count; i++)
-				display_port_info_2(out_hnd, action, &ctr->port.info_2[i]);
-			break;
-		case ACTION_FOOTER:
-			report(out_hnd, "\n");
-			break;
-	}
-}
-
-/****************************************************************************
-connection info container display function
-****************************************************************************/
-void display_port_info_ctr(FILE *out_hnd, enum action_type action, uint32 level,
-				uint32 count, PORT_INFO_CTR *ctr)
-{
-	switch (level) {
-		case 1:
-			display_port_info_1_ctr(out_hnd, action, count, ctr);
-			break;
-		case 2:
-			display_port_info_2_ctr(out_hnd, action, count, ctr);
-			break;
-		default:
-			report(out_hnd, "display_port_info_ctr: Unknown Info Level\n");
-			break;
-	}
-}
-
-/****************************************************************************
-connection info container display function
-****************************************************************************/
-void display_port_info_1(FILE *out_hnd, enum action_type action, PORT_INFO_1 *i1)
-{
-	fstring buffer;
-	
-	switch (action)
-	{
-		case ACTION_HEADER:
-			report(out_hnd, "Port:\n");
-			break;
-		case ACTION_ENUMERATE:
-			rpcstr_pull(buffer, i1->port_name.buffer, sizeof(bufferi), 0, STR_TERMINATE);
-			fprintf (out_hnd, "\tPort Name:\t[%s]\n\n", buffer);
-			break;
-		case ACTION_FOOTER:
-			report(out_hnd, "\n");
-			break;
-	}
-}
-
-/****************************************************************************
-connection info container display function
-****************************************************************************/
-void display_port_info_2(FILE *out_hnd, enum action_type action, PORT_INFO_2 *i2)
-{
-	fstring buffer;
-	
-	switch (action)
-	{
-		case ACTION_HEADER:
-			report(out_hnd, "Port:\n");
-			break;
-		case ACTION_ENUMERATE:
-			rpcstr_pull(buffer, i2->port_name.buffer, sizeof(buffer), 0, STR_TERMINATE);
-			fprintf (out_hnd, "\tPort Name:\t[%s]\n", buffer);
-			rpcstr_pull(buffer, i2->monitor_name.buffer, sizeof(buffer), 0, STR_TERMINATE);
-
-			fprintf (out_hnd, "\tMonitor Name:\t[%s]\n", buffer);
-			rpcstr_pull(buffer, i2->description.buffer, sizeof(buffer), 0, STR_TERMINATE);
-			fprintf (out_hnd, "\tDescription:\t[%s]\n", buffer);
-			fprintf (out_hnd, "\tPort Type:\t[%d]\n", i2->port_type);
-			fprintf (out_hnd, "\tReserved:\t[%d]\n", i2->reserved);
-			fprintf (out_hnd, "\n");
-			break;
-		case ACTION_FOOTER:
-			report(out_hnd, "\n");
-			break;
-	}
-}
-
-/****************************************************************************
-connection info container display function
-****************************************************************************/
-void display_printer_enumdata(FILE *out_hnd, enum action_type action, uint32 idx, 
-				uint32 valuelen, uint16 *value, uint32 rvaluelen,
-				uint32 type, 
-				uint32 datalen, uint8 *data, uint32 rdatalen)
-{
-	fstring buffer;
-	
-	switch (action)
-	{
-		case ACTION_HEADER:
-			report(out_hnd, "Printer enum data:\n");
-			report(out_hnd, "index\tvaluelen\tvalue\t\trvaluelen");
-			report(out_hnd, "\ttype\tdatalen\tdata\trdatalen\n");
-			break;
-		case ACTION_ENUMERATE:
-			report(out_hnd, "[%d]", idx);
-			report(out_hnd, "\t[%d]", valuelen);
-			rpcstr_pull(buffer, value, sizeof(buffer), 0, STR_TERMINATE);
-			report(out_hnd, "\t[%s]", buffer);
-			report(out_hnd, "\t[%d]", rvaluelen);
-			report(out_hnd, "\t\t[%d]", type);
-			report(out_hnd, "\t[%d]", datalen);
-/*			report(out_hnd, "\t[%s]", data);*/
-			report(out_hnd, "\t[%d]\n", rdatalen);
-			break;
-		case ACTION_FOOTER:
-			report(out_hnd, "\n");
-			break;
-	}
-}
-
-/****************************************************************************
-job info level 2 display function
-****************************************************************************/
-void display_job_info_2(FILE *out_hnd, enum action_type action, 
-		JOB_INFO_2 *const i2)
-{
-	if (i2 == NULL)
-	{
-		return;
-	}
-
-	switch (action)
-	{
-		case ACTION_HEADER:
-		{
-			report(out_hnd, "Job Info Level 2:\n");
-
-			break;
-		}
-		case ACTION_ENUMERATE:
-		{
-			fstring tmp;
-
-			report(out_hnd, "\tjob id:\t%d\n", i2->jobid);
-			rpcstr_pull(tmp, i2->printername.buffer, sizeof(tmp), 0, STR_TERMINATE);
-			report(out_hnd, "\tprinter name:\t%s\n", tmp);
-			rpcstr_pull(tmp, i2->machinename.buffer, sizeof(tmp), 0, STR_TERMINATE);
-			report(out_hnd, "\tmachine name:\t%s\n", tmp);
-			rpcstr_pull(tmp, i2->username.buffer, sizeof(tmp), 0, STR_TERMINATE);
-			report(out_hnd, "\tusername:\t%s\n", tmp);
-			rpcstr_pull(tmp, i2->document.buffer, sizeof(tmp), 0, STR_TERMINATE);
-			report(out_hnd, "\tdocument:\t%s\n", tmp);
-			rpcstr_pull(tmp, i2->notifyname.buffer, sizeof(tmp), 0, STR_TERMINATE);
-			report(out_hnd, "\tnotify name:\t%s\n", tmp);
-			rpcstr_pull(tmp, i2->datatype.buffer, sizeof(tmp), 0, STR_TERMINATE);
-			report(out_hnd, "\tdata type:\t%s\n", tmp);
-			rpcstr_pull(tmp, i2->printprocessor.buffer, sizeof(tmp), 0, STR_TERMINATE);
-			report(out_hnd, "\tprint processor:\t%s\n", tmp);
-			rpcstr_pull(tmp, i2->parameters.buffer, sizeof(tmp), 0, STR_TERMINATE);
-			report(out_hnd, "\tparameters:\t%s\n", tmp);
-			rpcstr_pull(tmp, i2->drivername.buffer, sizeof(tmp), 0, STR_TERMINATE);
-			report(out_hnd, "\tdriver name:\t%s\n", tmp);
-			report(out_hnd, "\tDevice Mode:\tNOT DISPLAYED YET\n");
-
-			rpcstr_pull(tmp, i2->text_status.buffer, sizeof(tmp), 0, STR_TERMINATE);
-			report(out_hnd, "\ttext status:\t%s\n", tmp);
-		/*	SEC_DESC sec_desc;*/
-			report(out_hnd, "\tstatus:\t%d\n", i2->status);
-			report(out_hnd, "\tpriority:\t%d\n", i2->priority);
-			report(out_hnd, "\tposition:\t%d\n", i2->position);
-			report(out_hnd, "\tstarttime:\t%d\n", i2->starttime);
-			report(out_hnd, "\tuntiltime:\t%d\n", i2->untiltime);
-			report(out_hnd, "\ttotalpages:\t%d\n", i2->totalpages);
-			report(out_hnd, "\tsize:\t%d\n", i2->size);
-/*
-			SYSTEMTIME submitted;
-*/
-			report(out_hnd, "\tsubmitted:\tNOT DISPLAYED YET\n");
-			report(out_hnd, "\ttimeelapsed:\t%d\n", i2->timeelapsed);
-			report(out_hnd, "\tpagesprinted:\t%d\n", i2->pagesprinted);
-		}
-		case ACTION_FOOTER:
-		{
-			report(out_hnd, "\n");
-			break;
-		}
-	}
-
-}
-
-/****************************************************************************
-job info level 1 display function
-****************************************************************************/
-void display_job_info_1(FILE *out_hnd, enum action_type action, 
-		JOB_INFO_1 *const i1)
-{
-	if (i1 == NULL)
-	{
-		return;
-	}
-
-	switch (action)
-	{
-		case ACTION_HEADER:
-		{
-			report(out_hnd, "Job Info Level 1:\n");
-
-			break;
-		}
-		case ACTION_ENUMERATE:
-		{
-			fstring tmp;
-
-			report(out_hnd, "\tjob id:\t%d\n", i1->jobid);
-			rpcstr_pull(tmp, i1->printername.buffer, sizeof(tmp), 0, STR_TERMINATE);
-			report(out_hnd, "\tprinter name:\t%s\n", tmp);
-			rpcstr_pull(tmp, i1->machinename.buffer, sizeof(tmp), 0, STR_TERMINATE);
-			report(out_hnd, "\tmachine name:\t%s\n", tmp);
-			rpcstr_pull(tmp, i1->username.buffer, sizeof(tmp), 0, STR_TERMINATE);
-			report(out_hnd, "\tusername:\t%s\n", tmp);
-			rpcstr_pull(tmp, i1->document.buffer, sizeof(tmp), 0, STR_TERMINATE);
-			report(out_hnd, "\tdocument:\t%s\n", tmp);
-			rpcstr_pull(tmp, i1->datatype.buffer, sizeof(tmp), 0, STR_TERMINATE);
-			report(out_hnd, "\tdata type:\t%s\n", tmp);
-			rpcstr_pull(tmp, i1->text_status.buffer, sizeof(tmp), 0, STR_TERMINATE);
-			report(out_hnd, "\ttext status:\t%s\n", tmp);
-			report(out_hnd, "\tstatus:\t%d\n", i1->status);
-			report(out_hnd, "\tpriority:\t%d\n", i1->priority);
-			report(out_hnd, "\tposition:\t%d\n", i1->position);
-			report(out_hnd, "\ttotalpages:\t%d\n", i1->totalpages);
-/*
-			SYSTEMTIME submitted;
-*/
-			report(out_hnd, "\tsubmitted:\tNOT DISPLAYED YET\n");
-			report(out_hnd, "\tpagesprinted:\t%d\n", i1->pagesprinted);
-
-			break;
-		}
-		case ACTION_FOOTER:
-		{
-			report(out_hnd, "\n");
-			break;
-		}
-	}
-
-}
-
-/****************************************************************************
-connection info level 2 container display function
-****************************************************************************/
-void display_job_info_2_ctr(FILE *out_hnd, enum action_type action, 
-				uint32 count, JOB_INFO_2 *const *const ctr)
-{
-	if (ctr == NULL)
-	{
-		report(out_hnd, "display_job_info_2_ctr: unavailable due to an internal error\n");
-		return;
-	}
-
-	switch (action)
-	{
-		case ACTION_HEADER:
-		{
-			break;
-		}
-		case ACTION_ENUMERATE:
-		{
-			int i;
-
-			for (i = 0; i < count; i++)
-			{
-				display_job_info_2(out_hnd, ACTION_HEADER   , ctr[i]);
-				display_job_info_2(out_hnd, ACTION_ENUMERATE, ctr[i]);
-				display_job_info_2(out_hnd, ACTION_FOOTER   , ctr[i]);
-			}
-			break;
-		}
-		case ACTION_FOOTER:
-		{
-			break;
-		}
-	}
-}
-
-/****************************************************************************
-connection info level 1 container display function
-****************************************************************************/
-void display_job_info_1_ctr(FILE *out_hnd, enum action_type action, 
-				uint32 count, JOB_INFO_1 *const *const ctr)
-{
-	if (ctr == NULL)
-	{
-		report(out_hnd, "display_job_info_1_ctr: unavailable due to an internal error\n");
-		return;
-	}
-
-	switch (action)
-	{
-		case ACTION_HEADER:
-		{
-			break;
-		}
-		case ACTION_ENUMERATE:
-		{
-			int i;
-
-			for (i = 0; i < count; i++)
-			{
-				display_job_info_1(out_hnd, ACTION_HEADER   , ctr[i]);
-				display_job_info_1(out_hnd, ACTION_ENUMERATE, ctr[i]);
-				display_job_info_1(out_hnd, ACTION_FOOTER   , ctr[i]);
-			}
-			break;
-		}
-		case ACTION_FOOTER:
-		{
-			break;
-		}
-	}
-}
-
-/****************************************************************************
-connection info container display function
-****************************************************************************/
-void display_job_info_ctr(FILE *out_hnd, enum action_type action, 
-				uint32 level, uint32 count,
-				void *const *const ctr)
-{
-	if (ctr == NULL)
-	{
-		report(out_hnd, "display_job_info_ctr: unavailable due to an internal error\n");
-		return;
-	}
-
-	switch (level)
-	{
-		case 1:
-		{
-			display_job_info_1_ctr(out_hnd, action, 
-			                   count, (JOB_INFO_1*const*const)ctr);
-			break;
-		}
-		case 2:
-		{
-			display_job_info_2_ctr(out_hnd, action, 
-			                   count, (JOB_INFO_2*const*const)ctr);
-			break;
-		}
-		default:
-		{
-			report(out_hnd, "display_job_info_ctr: Unknown Info Level\n");
-			break;
-		}
-	}
-}
-
-/****************************************************************************
-printer info level 0 display function
-****************************************************************************/
-static void display_print_driver_1(FILE *out_hnd, DRIVER_INFO_1 *i1)
-{
-	fstring name;
-	if (i1 == NULL)
-		return;
-
-	rpcstr_pull(name, i1->name.buffer, sizeof(name), 0, STR_TERMINATE);
-
-	report(out_hnd, "\tname:[%s]\n", name);
-}
-
-/****************************************************************************
-printer info level 1 display function
-****************************************************************************/
-static void display_print_driver_2(FILE *out_hnd, DRIVER_INFO_2 *i1)
-{
-	fstring name;
-	fstring architecture;
-	fstring driverpath;
-	fstring datafile;
-	fstring configfile;
-	if (i1 == NULL)
-		return;
-
-	rpcstr_pull(name, i1->name.buffer, sizeof(name), 0, STR_TERMINATE);
-	rpcstr_pull(architecture, i1->architecture.buffer, sizeof(architecture), 0, STR_TERMINATE);
-	rpcstr_pull(driverpath, i1->driverpath.buffer, sizeof(driverpath), 0, STR_TERMINATE);
-	rpcstr_pull(datafile, i1->datafile.buffer, sizeof(datafile), 0, STR_TERMINATE);
-	rpcstr_pull(configfile, i1->conigfile.buffer, sizeof(configfile), 0, STR_TERMINATE);
-
-	report(out_hnd, "\tversion:[%x]\n", i1->version);
-	report(out_hnd, "\tname:[%s]\n", name);
-	report(out_hnd, "\tarchitecture:[%s]\n", architecture);
-	report(out_hnd, "\tdriverpath:[%s]\n", driverpath);
-	report(out_hnd, "\tdatafile:[%s]\n", datafile);
-	report(out_hnd, "\tconfigfile:[%s]\n", configfile);
-}
-
-/****************************************************************************
-printer info level 2 display function
-****************************************************************************/
-static void display_print_driver_3(FILE *out_hnd, DRIVER_INFO_3 *i1)
-{
-	fstring name;
-	fstring architecture;
-	fstring driverpath;
-	fstring datafile;
-	fstring configfile;
-	fstring helpfile;
-	fstring dependentfiles;
-	fstring monitorname;
-	fstring defaultdatatype;
-	
-	int length=0;
-	BOOL valid = True;
-	
-	if (i1 == NULL)
-		return;
-
-	rpcstr_pull(name, i1->name.buffer, sizeof(name), 0, STR_TERMINATE);
-	rpcstr_pull(architecture, i1->architecture.buffer, sizeof(architecture), 0, STR_TERMINATE);
-	rpcstr_pull(driverpath, i1->driverpath.buffer, sizeof(driverpath), 0, STR_TERMINATE);
-	rpcstr_pull(datafile, i1->datafile.buffer, sizeof(datafile), 0, STR_TERMINATE);
-	rpcstr_pull(configfile, i1->configfile.buffer, sizeof(configfile), 0, STR_TERMINATE);
-	rpcstr_pull(helpfile, i1->helpfile.buffer, sizeof(helpfile), 0, STR_TERMINATE);
-	rpcstr_pull(monitorname, i1->monitorname.buffer, sizeof(monitorname), 0, STR_TERMINATE);
-	rpcstr_pull(defaultdatatype, i1->defaultdatatype.buffer, sizeof(defaultdatatype), 0, STR_TERMINATE);
-
-	report(out_hnd, "\tversion:[%x]\n", i1->version);
-	report(out_hnd, "\tname:[%s]\n",name);
-	report(out_hnd, "\tarchitecture:[%s]\n", architecture);
-	report(out_hnd, "\tdriverpath:[%s]\n", driverpath);
-	report(out_hnd, "\tdatafile:[%s]\n", datafile);
-	report(out_hnd, "\tconfigfile:[%s]\n", configfile);
-	report(out_hnd, "\thelpfile:[%s]\n\n", helpfile);
-
-	while (valid)
-	{
-		rpcstr_pull(dependentfiles, i1->dependentfiles+length, sizeof(dependentfiles), 0, STR_TERMINATE);
-		length+=strlen(dependentfiles)+1;
-		
-		if (strlen(dependentfiles) > 0)
-		{
-			report(out_hnd, "\tdependentfiles:[%s]\n", dependentfiles);
-		}
-		else
-		{
-			valid = False;
-		}
-	}
-	
-	report(out_hnd, "\n\tmonitorname:[%s]\n", monitorname);
-	report(out_hnd, "\tdefaultdatatype:[%s]\n", defaultdatatype);
-	
-}
-
-/****************************************************************************
-connection info level 1 container display function
-****************************************************************************/
-static void display_printer_driver_1_ctr(FILE *out_hnd, enum action_type action, uint32 count,  PRINTER_DRIVER_CTR ctr)
-{
-	int i;
-	DRIVER_INFO_1 *in;
-
-	switch (action)
-	{
-		case ACTION_HEADER:
-			report(out_hnd, "Printer driver Level 1:\n");
-			break;
-		case ACTION_ENUMERATE:
-			for (i = 0; i < count; i++) {
-				in=ctr.info1;
-				display_print_driver_1(out_hnd, &(in[i]) );
-			}
-			break;
-		case ACTION_FOOTER:
-			report(out_hnd, "\n");
-			break;
-	}
-}
-
-/****************************************************************************
-connection info level 2 container display function
-****************************************************************************/
-static void display_printer_driver_2_ctr(FILE *out_hnd, enum action_type action, uint32 count,  PRINTER_DRIVER_CTR ctr)
-{
-	int i;
-	DRIVER_INFO_2 *in;
-
-	switch (action)
-	{
-		case ACTION_HEADER:
-			report(out_hnd, "Printer driver Level 2:\n");
-			break;
-		case ACTION_ENUMERATE:
-			for (i = 0; i < count; i++) {
-				in=ctr.info2;
-				display_print_driver_2(out_hnd, &(in[i]) );
-			}
-			break;
-		case ACTION_FOOTER:
-			report(out_hnd, "\n");
-			break;
-	}
-}
-
-/****************************************************************************
-connection info level 3 container display function
-****************************************************************************/
-static void display_printer_driver_3_ctr(FILE *out_hnd, enum action_type action, uint32 count,  PRINTER_DRIVER_CTR ctr)
-{
-	int i;
-	DRIVER_INFO_3 *in;
-
-	switch (action)
-	{
-		case ACTION_HEADER:
-			report(out_hnd, "Printer driver Level 3:\n");
-			break;
-		case ACTION_ENUMERATE:
-			for (i = 0; i < count; i++) {
-				in=ctr.info3;
-				display_print_driver_3(out_hnd, &(in[i]) );
-			}
-			break;
-		case ACTION_FOOTER:
-			report(out_hnd, "\n");
-			break;
-	}
-}
-
-/****************************************************************************
-connection info container display function
-****************************************************************************/
-void display_printer_driver_ctr(FILE *out_hnd, enum action_type action, uint32 level,
-				uint32 count, PRINTER_DRIVER_CTR ctr)
-{
-	switch (level) {
-		case 1:
-			display_printer_driver_1_ctr(out_hnd, action, count, ctr);
-			break;
-		case 2:
-			display_printer_driver_2_ctr(out_hnd, action, count, ctr);
-			break;
-		case 3:
-			display_printer_driver_3_ctr(out_hnd, action, count, ctr);
-			break;
-		default:
-			report(out_hnd, "display_printer_driver_ctr: Unknown Info Level\n");
-			break;
-	}
-}
-
-
-/****************************************************************************
-printer info level 1 display function
-****************************************************************************/
-static void display_printdriverdir_info_1(FILE *out_hnd, DRIVER_DIRECTORY_1 *i1)
-{
-	fstring name;
-	if (i1 == NULL)
-		return;
-
-	rpcstr_pull(name, i1->name.buffer, sizeof(name), 0, STR_TERMINATE);
-
-	report(out_hnd, "\tname:[%s]\n", name);
-}
-
-/****************************************************************************
-connection info level 1 container display function
-****************************************************************************/
-static void display_printerdriverdir_info_1_ctr(FILE *out_hnd, enum action_type action, DRIVER_DIRECTORY_CTR ctr)
-{
-
-	switch (action)
-	{
-		case ACTION_HEADER:
-			report(out_hnd, "Printer driver dir Info Level 1:\n");
-			break;
-		case ACTION_ENUMERATE:
-				display_printdriverdir_info_1(out_hnd, &(ctr.driver.info_1) );
-			break;
-		case ACTION_FOOTER:
-			report(out_hnd, "\n");
-			break;
-	}
-}
-
-/****************************************************************************
-connection info container display function
-****************************************************************************/
-void display_printerdriverdir_info_ctr(FILE *out_hnd, enum action_type action, uint32 level,
-				DRIVER_DIRECTORY_CTR ctr)
-{
-	switch (level) {
-		case 1:
-			display_printerdriverdir_info_1_ctr(out_hnd, action, ctr);
-			break;
-		default:
-			report(out_hnd, "display_printerdriverdir_info_ctr: Unknown Info Level\n");
-			break;
-	}
-}
diff -Naur samba-2.2.12-orig/source/rpcclient/rpcclient.c samba-2.2.12/source/rpcclient/rpcclient.c
--- samba-2.2.12-orig/source/rpcclient/rpcclient.c	2011-03-04 13:51:45.000000000 +0100
+++ samba-2.2.12/source/rpcclient/rpcclient.c	2011-03-04 13:20:27.000000000 +0100
@@ -405,7 +405,6 @@
 
 extern struct cmd_set lsarpc_commands[];
 extern struct cmd_set samr_commands[];
-extern struct cmd_set spoolss_commands[];
 extern struct cmd_set netlogon_commands[];
 extern struct cmd_set srvsvc_commands[];
 extern struct cmd_set dfs_commands[];
@@ -415,7 +414,6 @@
 	rpcclient_commands,
 	lsarpc_commands,
 	samr_commands,
-	spoolss_commands,
 	netlogon_commands,
 	srvsvc_commands,
 	dfs_commands,
diff -Naur samba-2.2.12-orig/source/rpc_client/cli_spoolss_notify.c samba-2.2.12/source/rpc_client/cli_spoolss_notify.c
--- samba-2.2.12-orig/source/rpc_client/cli_spoolss_notify.c	2011-03-04 13:51:45.000000000 +0100
+++ samba-2.2.12/source/rpc_client/cli_spoolss_notify.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,448 +0,0 @@
-/*
- *  Unix SMB/CIFS implementation.
- *  RPC Pipe client / server routines
- *  Copyright (C) Andrew Tridgell              1992-2000,
- *  Copyright (C) Jean Francois Micouleau      1998-2000,
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- */
-
-#include "includes.h"
-#if 0
-#include "rpc_parse.h"
-#include "nterr.h"
-#endif
-extern pstring global_myname;
-
-struct msg_info_table {
-	uint32 msg;
-	uint32 field;
-	const char *name;
-	void (*construct_fn) (int snum, SPOOL_NOTIFY_INFO_DATA *data,
-		print_queue_struct *queue,
-		NT_PRINTER_INFO_LEVEL *printer, TALLOC_CTX *mem_ctx);
-};
-
-struct msg_info_table msg_table[] = {
-{ PRINTER_MESSAGE_DRIVER,      PRINTER_NOTIFY_DRIVER_NAME,    "PRINTER_MESSAGE_DRIVER",      spoolss_notify_driver_name  },
-{ PRINTER_MESSAGE_ATTRIBUTES,  PRINTER_NOTIFY_ATTRIBUTES,     "PRINTER_MESSAGE_ATTRIBUTES",  spoolss_notify_attributes   },
-{ PRINTER_MESSAGE_COMMENT,     PRINTER_NOTIFY_COMMENT,        "PRINTER_MESSAGE_COMMENT",     spoolss_notify_comment      },
-{ PRINTER_MESSAGE_LOCATION,    PRINTER_NOTIFY_LOCATION,       "PRINTER_MESSAGE_LOCATION",    spoolss_notify_location     },
-{ PRINTER_MESSAGE_PRINTERNAME, PRINTER_NOTIFY_PRINTER_NAME,   "PRINTER_MESSAGE_PRINTERNAME", spoolss_notify_printer_name },
-{ PRINTER_MESSAGE_SHARENAME,   PRINTER_NOTIFY_SHARE_NAME,     "PRINTER_MESSAGE_SHARENAME",   spoolss_notify_share_name   },
-{ PRINTER_MESSAGE_PORT,        PRINTER_NOTIFY_PORT_NAME,      "PRINTER_MESSAGE_PORT",        spoolss_notify_port_name    },
-{ PRINTER_MESSAGE_CJOBS,       PRINTER_NOTIFY_CJOBS,          "PRINTER_MESSAGE_CJOBS",       spoolss_notify_cjobs        },
-{ PRINTER_MESSAGE_SEPFILE,     PRINTER_NOTIFY_SEPFILE,        "PRINTER_MESSAGE_SEPFILE",     spoolss_notify_sepfile      },
-{ PRINTER_MESSAGE_PARAMS,      PRINTER_NOTIFY_PARAMETERS,     "PRINTER_MESSAGE_PARAMETERS",  spoolss_notify_parameters   },
-{ PRINTER_MESSAGE_DATATYPE,    PRINTER_NOTIFY_DATATYPE,       "PRINTER_MESSAGE_DATATYPE",    spoolss_notify_datatype     },
-{ PRINTER_MESSAGE_NULL,        0x0,                           "",                            NULL                        },
-};
-
-/*********************************************************
- Disconnect from the client machine.
-**********************************************************/
-BOOL spoolss_disconnect_from_client( struct cli_state *cli)
-{
-	cli_nt_session_close(cli);
-	cli_ulogoff(cli);
-	cli_shutdown(cli);
-
-	return True;
-}
-
-
-/*********************************************************
- Connect to the client machine.
-**********************************************************/
-
-BOOL spoolss_connect_to_client( struct cli_state *cli, char *remote_machine)
-{
-	ZERO_STRUCTP(cli);
-	if(cli_initialise(cli) == NULL) {
-		ZERODEBUG(0,("connect_to_client: unable to initialize client connection.\n"));
-		return False;
-	}
-
-	if(!resolve_name( remote_machine, &cli->dest_ip, 0x20)) {
-		ZERODEBUG(0,("connect_to_client: Can't resolve address for %s\n", remote_machine));
-		cli_shutdown(cli);
-	return False;
-	}
-
-	if (ismyip(cli->dest_ip)) {
-		ZERODEBUG(0,("connect_to_client: Machine %s is one of our addresses. Cannot add to ourselves.\n", remote_machine));
-		cli_shutdown(cli);
-		return False;
-	}
-
-	if (!cli_connect(cli, remote_machine, &cli->dest_ip)) {
-		ZERODEBUG(0,("connect_to_client: unable to connect to SMB server on machine %s. Error was : %s.\n", remote_machine, cli_errstr(cli) ));
-		cli_shutdown(cli);
-		return False;
-	}
-  
-	if (!attempt_netbios_session_request(cli, global_myname, remote_machine, &cli->dest_ip)) {
-		ZERODEBUG(0,("connect_to_client: machine %s rejected the NetBIOS session request.\n", 
-			remote_machine));
-		cli_shutdown(cli);
-		return False;
-	}
-
-	cli->protocol = PROTOCOL_NT1;
-    
-	if (!cli_negprot(cli)) {
-		ZERODEBUG(0,("connect_to_client: machine %s rejected the negotiate protocol. Error was : %s.\n", remote_machine, cli_errstr(cli) ));
-		cli_shutdown(cli);
-		return False;
-	}
-
-	if (cli->protocol != PROTOCOL_NT1) {
-		ZERODEBUG(0,("connect_to_client: machine %s didn't negotiate NT protocol.\n", remote_machine));
-		cli_shutdown(cli);
-		return False;
-	}
-    
-	/*
-	 * Do an anonymous session setup.
-	 */
-    
-	if (!cli_session_setup(cli, "", "", 0, "", 0, "")) {
-		ZERODEBUG(0,("connect_to_client: machine %s rejected the session setup. Error was : %s.\n", remote_machine, cli_errstr(cli) ));
-		cli_shutdown(cli);
-		return False;
-	}
-    
-	if (!(cli->sec_mode & NEGOTIATE_SECURITY_USER_LEVEL)) {
-		ZERODEBUG(0,("connect_to_client: machine %s isn't in user level security mode\n", remote_machine));
-		cli_shutdown(cli);
-		return False;
-	}
-    
-	if (!cli_send_tconX(cli, "IPC$", "IPC", "", 1)) {
-		ZERODEBUG(0,("connect_to_client: machine %s rejected the tconX on the IPC$ share. Error was : %s.\n", remote_machine, cli_errstr(cli) ));
-		cli_shutdown(cli);
-		return False;
-	}
-
-	/*
-	 * Ok - we have an anonymous connection to the IPC$ share.
-	 * Now start the NT Domain stuff :-).
-	 */
-
-	if(cli_nt_session_open(cli, PIPE_SPOOLSS) == False) {
-		ZERODEBUG(0,("connect_to_client: unable to open the domain client session to machine %s. Error was : %s.\n", remote_machine, cli_errstr(cli)));
-		cli_nt_session_close(cli);
-		cli_ulogoff(cli);
-		cli_shutdown(cli);
-		return False;
-	} 
-
-	return True;
-}
-
-/*
- * SPOOLSS Client RPC's used by servers as the notification
- * back channel
- */
-
- /***************************************************************************
- do a reply open printer
-****************************************************************************/
-
-WERROR cli_spoolss_reply_open_printer(struct cli_state *cli, TALLOC_CTX *mem_ctx, 
-				char *printer, uint32 localprinter, uint32 type, 
-				POLICY_HND *handle)
-{
-	WERROR result = W_ERROR(ERRgeneral);
-	
-	prs_struct rbuf;
-	prs_struct buf; 
-
-	SPOOL_Q_REPLYOPENPRINTER q_s;
-	SPOOL_R_REPLYOPENPRINTER r_s;
-
-	prs_init(&buf, 1024, mem_ctx, MARSHALL);
-	prs_init(&rbuf, 0, mem_ctx, UNMARSHALL );
-
-	/* create and send a MSRPC command with api SPOOLSS_REPLYOPENPRINTER */
-	
-	/* store the parameters */
-	make_spoolss_q_replyopenprinter(&q_s, printer, localprinter, type);
-
-	/* turn parameters into data stream */
-	if(!spoolss_io_q_replyopenprinter("", &q_s,  &buf, 0)) {
-		ZERODEBUG(0,("cli_spoolss_reply_open_printer: Error : failed to marshall SPOOL_Q_REPLYOPENPRINTER struct.\n"));
-		goto done;
-	}
-
-	/* send the data on \PIPE\ */
-	if (!rpc_api_pipe_req(cli, SPOOLSS_REPLYOPENPRINTER, &buf, &rbuf)) 
-		goto done;
-	
-	/* turn data stream into parameters*/
-	if(!spoolss_io_r_replyopenprinter("", &r_s, &rbuf, 0)) {
-		ZERODEBUG(0,("cli_spoolss_reply_open_printer: Error : failed to unmarshall SPOOL_R_REPLYOPENPRINTER struct.\n"));
-		goto done;
-	}
-	
-	memcpy(handle, &r_s.handle, sizeof(r_s.handle));
-	result = r_s.status;
-
-done:
-	prs_mem_free(&buf);
-	prs_mem_free(&rbuf);
-
-	return result;
-}
-
-/***************************************************************************
- do a reply open printer
-****************************************************************************/
-
-WERROR cli_spoolss_reply_close_printer(struct cli_state *cli, TALLOC_CTX *mem_ctx, 
-					POLICY_HND *handle)
-{
-	WERROR result = W_ERROR(ERRgeneral);
-	prs_struct rbuf;
-	prs_struct buf; 
-
-	SPOOL_Q_REPLYCLOSEPRINTER q_s;
-	SPOOL_R_REPLYCLOSEPRINTER r_s;
-
-	prs_init(&buf, 1024, cli->mem_ctx, MARSHALL);
-	prs_init(&rbuf, 0, cli->mem_ctx, UNMARSHALL );
-
-	/* create and send a MSRPC command with api  */
-	
-	/* store the parameters */
-	make_spoolss_q_reply_closeprinter(&q_s, handle);
-
-	/* turn parameters into data stream */
-	if(!spoolss_io_q_replycloseprinter("", &q_s,  &buf, 0)) {
-		ZERODEBUG(0,("cli_spoolss_reply_close_printer: Error : failed to marshall SPOOL_Q_REPLY_CLOSEPRINTER struct.\n"));
-		goto done;
-	}
-
-	/* send the data on \PIPE\ */
-	if (!rpc_api_pipe_req(cli, SPOOLSS_REPLYCLOSEPRINTER, &buf, &rbuf))
-		goto done;
-
-	/* turn data stream into parameters*/
-	if(!spoolss_io_r_replycloseprinter("", &r_s, &rbuf, 0)) {
-		ZERODEBUG(0,("cli_spoolss_reply_close_printer: Error : failed to marshall SPOOL_R_REPLY_CLOSEPRINTER struct.\n"));
-		goto done;
-	}
-	
-
-	result = r_s.status;
-	
-done:
-	prs_mem_free(&buf);
-	prs_mem_free(&rbuf);
-
-	return result;
-}
-
- 
-/*********************************************************************
- This SPOOLSS_ROUTERREPLYPRINTER function is used to send a change 
- notification event when the registration **did not** use 
- SPOOL_NOTIFY_OPTION_TYPE structure to specify the events to monitor.
- Also see cli_spolss_reply_rrpcn()
- *********************************************************************/
- 
-WERROR cli_spoolss_routerreplyprinter (struct cli_state *cli, TALLOC_CTX *mem_ctx,
-					POLICY_HND *pol, uint32 condition, uint32 changd_id)
-{
-	prs_struct qbuf, rbuf;
-	SPOOL_Q_ROUTERREPLYPRINTER q;
-        SPOOL_R_ROUTERREPLYPRINTER r;
-	WERROR result = W_ERROR(ERRgeneral);
-
-	ZERO_STRUCT(q);
-	ZERO_STRUCT(r);
-
-
-	/* Initialise input parameters */
-
-	prs_init(&qbuf, MAX_PDU_FRAG_LEN, mem_ctx, MARSHALL);
-	prs_init(&rbuf, 0, mem_ctx, UNMARSHALL);
-
-
-	/* write the request */
-	make_spoolss_q_routerreplyprinter(&q, pol, condition, changd_id);
-
-	/* Marshall data and send request */
-	if (!spoolss_io_q_routerreplyprinter ("", &q, &qbuf, 0)) {
-		ZERODEBUG(0,("cli_spoolss_routerreplyprinter: Unable to marshall SPOOL_Q_ROUTERREPLYPRINTER!\n"));
-		goto done;
-	}
-		
-		
-	if (!rpc_api_pipe_req (cli, SPOOLSS_ROUTERREPLYPRINTER, &qbuf, &rbuf)) 
-		goto done;
-
-	/* Unmarshall response */
-	if (!spoolss_io_r_routerreplyprinter ("", &r, &rbuf, 0)) {
-		ZERODEBUG(0,("cli_spoolss_routerreplyprinter: Unable to unmarshall SPOOL_R_ROUTERREPLYPRINTER!\n"));
-		goto done;
-	}
-		
-	/* Return output parameters */
-	result = r.status;
-
-done:
-	prs_mem_free(&qbuf);
-	prs_mem_free(&rbuf);
-
-	return result;	
-}
-
-
-/**********************************************************************************
- Build the SPOOL_NOTIFY_INFO_DATA entries based upon the flags which have been set
- *********************************************************************************/
-
-static int build_notify_data (TALLOC_CTX *ctx, NT_PRINTER_INFO_LEVEL *printer, uint32 flags, 
-			SPOOL_NOTIFY_INFO_DATA **notify_data)
-{
-	SPOOL_NOTIFY_INFO_DATA *data;
-	uint32 idx = 0;
-	int i = 0;
-	
-	while ((msg_table[i].msg != PRINTER_MESSAGE_NULL) && flags)
-	{
-		if (flags & msg_table[i].msg) 
-		{
-			DEBUG(10,("build_notify_data: %s set on [%s][%d]\n", msg_table[i].name,
-				printer->info_2->printername, idx));
-			if ((data=Realloc(*notify_data, (idx+1)*sizeof(SPOOL_NOTIFY_INFO_DATA))) == NULL) {
-				ZERODEBUG(0,("build_notify_data: Realloc() failed with size [%d]!\n",
-					(idx+1)*sizeof(SPOOL_NOTIFY_INFO_DATA)));
-				return -1;
-			}
-			*notify_data = data;
-
-			/* clear memory */
-			memset(*notify_data+idx, 0x0, sizeof(SPOOL_NOTIFY_INFO_DATA));
-
-			/*
-			 * 'id' (last param here) is undefined when type == PRINTER_NOTIFY_TYPE
-			 * See PRINTER_NOTIFY_INFO_DATA entries in MSDN
-			 * --jerry
-			 */
-			construct_info_data(*notify_data+idx, PRINTER_NOTIFY_TYPE, msg_table[i].field, 0x00);
-
-			msg_table[i].construct_fn(-1, *notify_data+idx, NULL, printer, ctx);
-			idx++;
-		}
-		
-		i++;
-	}
-	
-	return idx;
-}
-
-/*********************************************************************
- This SPOOLSS_ROUTERREPLYPRINTER function is used to send a change 
- notification event when the registration **did** use 
- SPOOL_NOTIFY_OPTION_TYPE structure to specify the events to monitor
- Also see cli_spoolss_routereplyprinter()
- *********************************************************************/
-
-WERROR cli_spoolss_reply_rrpcn(struct cli_state *cli, TALLOC_CTX *mem_ctx, 
-					POLICY_HND *handle, PRINTER_MESSAGE_INFO *info,
-					NT_PRINTER_INFO_LEVEL *printer)
-{
-	prs_struct rbuf;
-	prs_struct buf;
-
-	SPOOL_NOTIFY_INFO 	notify_info;
-	SPOOL_NOTIFY_INFO_DATA	*notify_data = NULL;
-	uint32 			data_len;
-
-	WERROR result = W_ERROR(ERRgeneral);
-
-	SPOOL_Q_REPLY_RRPCN q_s;
-	SPOOL_R_REPLY_RRPCN r_s;
-
-	if (!info) {
-		DEBUG(5,("cli_spoolss_reply_rrpcn: NULL printer message info pointer!\n"));
-		goto done;
-	}
-		
-	prs_init(&buf, 1024, mem_ctx, MARSHALL);
-	prs_init(&rbuf, 0,   mem_ctx, UNMARSHALL );
-
-	ZERO_STRUCT(notify_info);
-
-	/*
-	 * See comments in _spoolss_setprinter() about PRINTER_CHANGE_XXX
-	 * events.  --jerry
-	 */
-	DEBUG(10,("cli_spoolss_reply_rrpcn: PRINTER_MESSAGE flags = 0x%8x\n", info->flags));
-
-	data_len = build_notify_data(mem_ctx, printer, info->flags, &notify_data);
-	if (info->flags && (data_len == -1)) {
-		ZERODEBUG(0,("cli_spoolss_reply_rrpcn: Failed to build SPOOL_NOTIFY_INFO_DATA [flags == 0x%x] for printer [%s]\n",
-			info->flags, info->printer_name));
-		result = WERR_NOMEM;
-		goto done;
-	}
-	notify_info.version = 0x2;
-	notify_info.flags   = 0x00020000;	/* ?? */
-	notify_info.count   = data_len;
-	notify_info.data    = notify_data;
-
-	/* create and send a MSRPC command with api  */
-	/* store the parameters */
-
-	make_spoolss_q_reply_rrpcn(&q_s, handle, info->low, info->high, &notify_info);
-
-	/* turn parameters into data stream */
-	if(!spoolss_io_q_reply_rrpcn("", &q_s,  &buf, 0)) {
-		ZERODEBUG(0,("cli_spoolss_reply_rrpcn: Error : failed to marshall SPOOL_Q_REPLY_RRPCN struct.\n"));
-		goto done;
-	}
-
-	/* send the data on \PIPE\ */
-	if (!rpc_api_pipe_req(cli, SPOOLSS_RRPCN, &buf, &rbuf)) 
-		goto done;
-
-
-	/* turn data stream into parameters*/
-	if(!spoolss_io_r_reply_rrpcn("", &r_s, &rbuf, 0)) {
-		ZERODEBUG(0,("cli_spoolss_reply_rrpcn: Error : failed to unmarshall SPOOL_R_REPLY_RRPCN struct.\n"));
-		goto done;
-	}
-
-	if (r_s.unknown0 == 0x00080000) {
-		DEBUG(8,("cli_spoolss_reply_rrpcn: I think the spooler resonded that the notification was ignored.\n"));
-	}
-
-	result = r_s.status;
-
-done:
-	prs_mem_free(&buf);
-	prs_mem_free(&rbuf);
-	/*
-	 * The memory allocated in this array is talloc'd so we only need
-	 * free the array here. JRA.
-	 */
-	SAFE_FREE(notify_data);
-	
-	return result;
-}
-
diff -Naur samba-2.2.12-orig/source/rpc_parse/parse_spoolss.c samba-2.2.12/source/rpc_parse/parse_spoolss.c
--- samba-2.2.12-orig/source/rpc_parse/parse_spoolss.c	2011-03-04 13:51:45.000000000 +0100
+++ samba-2.2.12/source/rpc_parse/parse_spoolss.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,7165 +0,0 @@
-/* 
- *  Unix SMB/CIFS implementation.
- *  RPC Pipe client / server routines
- *  Copyright (C) Andrew Tridgell              1992-2000,
- *  Copyright (C) Luke Kenneth Casson Leighton 1996-2000,
- *  Copyright (C) Jean Franois Micouleau      1998-2000,
- *  Copyright (C) Gerald Carter                2000-2002,
- *  Copyright (C) Tim Potter		       2001-2002.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *  
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *  
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- */
-
-#include "includes.h"
-
-/*******************************************************************
-return the length of a UNISTR string.
-********************************************************************/  
-
-static uint32 str_len_uni(UNISTR *source)
-{
- 	uint32 i=0;
-
-	if (!source->buffer)
-		return 0;
-
-	while (source->buffer[i])
-		i++;
-
-	return i;
-}
-
-/*******************************************************************
-This should be moved in a more generic lib.
-********************************************************************/  
-
-static BOOL spoolss_io_system_time(const char *desc, prs_struct *ps, int depth, SYSTEMTIME *systime)
-{
-	if(!prs_uint16("year", ps, depth, &systime->year))
-		return False;
-	if(!prs_uint16("month", ps, depth, &systime->month))
-		return False;
-	if(!prs_uint16("dayofweek", ps, depth, &systime->dayofweek))
-		return False;
-	if(!prs_uint16("day", ps, depth, &systime->day))
-		return False;
-	if(!prs_uint16("hour", ps, depth, &systime->hour))
-		return False;
-	if(!prs_uint16("minute", ps, depth, &systime->minute))
-		return False;
-	if(!prs_uint16("second", ps, depth, &systime->second))
-		return False;
-	if(!prs_uint16("milliseconds", ps, depth, &systime->milliseconds))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
-********************************************************************/  
-
-BOOL make_systemtime(SYSTEMTIME *systime, struct tm *unixtime)
-{
-	systime->year=unixtime->tm_year+1900;
-	systime->month=unixtime->tm_mon+1;
-	systime->dayofweek=unixtime->tm_wday;
-	systime->day=unixtime->tm_mday;
-	systime->hour=unixtime->tm_hour;
-	systime->minute=unixtime->tm_min;
-	systime->second=unixtime->tm_sec;
-	systime->milliseconds=0;
-
-	return True;
-}
-
-/*******************************************************************
-reads or writes an DOC_INFO structure.
-********************************************************************/  
-
-static BOOL smb_io_doc_info_1(const char *desc, DOC_INFO_1 *info_1, prs_struct *ps, int depth)
-{
-	if (info_1 == NULL) return False;
-
-	prs_debug(ps, depth, desc, "smb_io_doc_info_1");
-	depth++;
- 
-	if(!prs_align(ps))
-		return False;
-	
-	if(!prs_uint32("p_docname",    ps, depth, &info_1->p_docname))
-		return False;
-	if(!prs_uint32("p_outputfile", ps, depth, &info_1->p_outputfile))
-		return False;
-	if(!prs_uint32("p_datatype",   ps, depth, &info_1->p_datatype))
-		return False;
-
-	if(!smb_io_unistr2("", &info_1->docname,    info_1->p_docname,    ps, depth))
-		return False;
-	if(!smb_io_unistr2("", &info_1->outputfile, info_1->p_outputfile, ps, depth))
-		return False;
-	if(!smb_io_unistr2("", &info_1->datatype,   info_1->p_datatype,   ps, depth))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
-reads or writes an DOC_INFO structure.
-********************************************************************/  
-
-static BOOL smb_io_doc_info(const char *desc, DOC_INFO *info, prs_struct *ps, int depth)
-{
-	uint32 useless_ptr=0;
-	
-	if (info == NULL) return False;
-
-	prs_debug(ps, depth, desc, "smb_io_doc_info");
-	depth++;
- 
-	if(!prs_align(ps))
-		return False;
-        
-	if(!prs_uint32("switch_value", ps, depth, &info->switch_value))
-		return False;
-	
-	if(!prs_uint32("doc_info_X ptr", ps, depth, &useless_ptr))
-		return False;
-
-	switch (info->switch_value)
-	{
-		case 1:	
-			if(!smb_io_doc_info_1("",&info->doc_info_1, ps, depth))
-				return False;
-			break;
-		case 2:
-			/*
-			  this is just a placeholder
-			  
-			  MSDN July 1998 says doc_info_2 is only on
-			  Windows 95, and as Win95 doesn't do RPC to print
-			  this case is nearly impossible
-			  
-			  Maybe one day with Windows for dishwasher 2037 ...
-			  
-			*/
-			/* smb_io_doc_info_2("",&info->doc_info_2, ps, depth); */
-			break;
-		default:
-			ZERODEBUG(0,("Something is obviously wrong somewhere !\n"));
-			break;
-	}
-
-	return True;
-}
-
-/*******************************************************************
-reads or writes an DOC_INFO_CONTAINER structure.
-********************************************************************/  
-
-static BOOL smb_io_doc_info_container(const char *desc, DOC_INFO_CONTAINER *cont, prs_struct *ps, int depth)
-{
-	if (cont == NULL) return False;
-
-	prs_debug(ps, depth, desc, "smb_io_doc_info_container");
-	depth++;
- 
-	if(!prs_align(ps))
-		return False;
-        
-	if(!prs_uint32("level", ps, depth, &cont->level))
-		return False;
-	
-	if(!smb_io_doc_info("",&cont->docinfo, ps, depth))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
-reads or writes an NOTIFY OPTION TYPE structure.
-********************************************************************/  
-
-/* NOTIFY_OPTION_TYPE and NOTIFY_OPTION_TYPE_DATA are really one
-   structure.  The _TYPE structure is really the deferred referrants (i.e
-   the notify fields array) of the _TYPE structure. -tpot */
-
-static BOOL smb_io_notify_option_type(const char *desc, SPOOL_NOTIFY_OPTION_TYPE *type, prs_struct *ps, int depth)
-{
-	prs_debug(ps, depth, desc, "smb_io_notify_option_type");
-	depth++;
- 
-	if (!prs_align(ps))
-		return False;
-
-	if(!prs_uint16("type", ps, depth, &type->type))
-		return False;
-	if(!prs_uint16("reserved0", ps, depth, &type->reserved0))
-		return False;
-	if(!prs_uint32("reserved1", ps, depth, &type->reserved1))
-		return False;
-	if(!prs_uint32("reserved2", ps, depth, &type->reserved2))
-		return False;
-	if(!prs_uint32("count", ps, depth, &type->count))
-		return False;
-	if(!prs_uint32("fields_ptr", ps, depth, &type->fields_ptr))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
-reads or writes an NOTIFY OPTION TYPE DATA.
-********************************************************************/  
-
-static BOOL smb_io_notify_option_type_data(const char *desc, SPOOL_NOTIFY_OPTION_TYPE *type, prs_struct *ps, int depth)
-{
-	int i;
-
-	prs_debug(ps, depth, desc, "smb_io_notify_option_type_data");
-	depth++;
- 
- 	/* if there are no fields just return */
-	if (type->fields_ptr==0)
-		return True;
-
-	if(!prs_align(ps))
-		return False;
-
-	if(!prs_uint32("count2", ps, depth, &type->count2))
-		return False;
-	
-	if (type->count2 != type->count)
-		DEBUG(4,("What a mess, count was %x now is %x !\n", type->count, type->count2));
-
-	/* parse the option type data */
-	for(i=0;i<type->count2;i++)
-		if(!prs_uint16("fields",ps,depth,&type->fields[i]))
-			return False;
-	return True;
-}
-
-/*******************************************************************
-reads or writes an NOTIFY OPTION structure.
-********************************************************************/  
-
-static BOOL smb_io_notify_option_type_ctr(const char *desc, SPOOL_NOTIFY_OPTION_TYPE_CTR *ctr , prs_struct *ps, int depth)
-{		
-	int i;
-	
-	prs_debug(ps, depth, desc, "smb_io_notify_option_type_ctr");
-	depth++;
- 
-	if(!prs_uint32("count", ps, depth, &ctr->count))
-		return False;
-
-	/* reading */
-	if (UNMARSHALLING(ps))
-		if((ctr->type=(SPOOL_NOTIFY_OPTION_TYPE *)prs_alloc_mem(ps,ctr->count*sizeof(SPOOL_NOTIFY_OPTION_TYPE))) == NULL)
-			return False;
-		
-	/* the option type struct */
-	for(i=0;i<ctr->count;i++)
-		if(!smb_io_notify_option_type("", &ctr->type[i] , ps, depth))
-			return False;
-
-	/* the type associated with the option type struct */
-	for(i=0;i<ctr->count;i++)
-		if(!smb_io_notify_option_type_data("", &ctr->type[i] , ps, depth))
-			return False;
-	
-	return True;
-}
-
-/*******************************************************************
-reads or writes an NOTIFY OPTION structure.
-********************************************************************/  
-
-static BOOL smb_io_notify_option(const char *desc, SPOOL_NOTIFY_OPTION *option, prs_struct *ps, int depth)
-{
-	prs_debug(ps, depth, desc, "smb_io_notify_option");
-	depth++;
- 	
-	if(!prs_uint32("version", ps, depth, &option->version))
-		return False;
-	if(!prs_uint32("flags", ps, depth, &option->flags))
-		return False;
-	if(!prs_uint32("count", ps, depth, &option->count))
-		return False;
-	if(!prs_uint32("option_type_ptr", ps, depth, &option->option_type_ptr))
-		return False;
-	
-	/* marshalling or unmarshalling, that would work */	
-	if (option->option_type_ptr!=0) {
-		if(!smb_io_notify_option_type_ctr("", &option->ctr ,ps, depth))
-			return False;
-	}
-	else {
-		option->ctr.type=NULL;
-		option->ctr.count=0;
-	}
-	
-	return True;
-}
-
-/*******************************************************************
-reads or writes an NOTIFY INFO DATA structure.
-********************************************************************/  
-
-static BOOL smb_io_notify_info_data(const char *desc,SPOOL_NOTIFY_INFO_DATA *data, prs_struct *ps, int depth)
-{
-	uint32 useless_ptr=0xADDE0FF0;
-
-	uint32 how_many_words;
-	BOOL isvalue;
-	uint32 x;
-	
-	prs_debug(ps, depth, desc, "smb_io_notify_info_data");
-	depth++;
-
-	how_many_words=data->size;
-	if (how_many_words==POINTER) {
-		how_many_words=TWO_VALUE;
-	}
-	
-	isvalue=data->enc_type;
-
-	if(!prs_align(ps))
-		return False;
-	if(!prs_uint16("type",           ps, depth, &data->type))
-		return False;
-	if(!prs_uint16("field",          ps, depth, &data->field))
-		return False;
-	/*prs_align(ps);*/
-
-	if(!prs_uint32("how many words", ps, depth, &how_many_words))
-		return False;
-	if(!prs_uint32("id",             ps, depth, &data->id))
-		return False;
-	if(!prs_uint32("how many words", ps, depth, &how_many_words))
-		return False;
-
-
-	/*prs_align(ps);*/
-
-	if (isvalue==True) {
-		if(!prs_uint32("value[0]", ps, depth, &data->notify_data.value[0]))
-			return False;
-		if(!prs_uint32("value[1]", ps, depth, &data->notify_data.value[1]))
-			return False;
-		/*prs_align(ps);*/
-	} else {
-		/* it's a string */
-		/* length in ascii including \0 */
-		x=2*(data->notify_data.data.length+1);
-		if(!prs_uint32("string length", ps, depth, &x ))
-			return False;
-		if(!prs_uint32("pointer", ps, depth, &useless_ptr))
-			return False;
-		/*prs_align(ps);*/
-	}
-
-	return True;
-}
-
-/*******************************************************************
-reads or writes an NOTIFY INFO DATA structure.
-********************************************************************/  
-
-BOOL smb_io_notify_info_data_strings(const char *desc,SPOOL_NOTIFY_INFO_DATA *data,
-                                     prs_struct *ps, int depth)
-{
-	uint32 x;
-	BOOL isvalue;
-	
-	prs_debug(ps, depth, desc, "smb_io_notify_info_data_strings");
-	depth++;
-	
-	if(!prs_align(ps))
-		return False;
-
-	isvalue=data->enc_type;
-
-	if (isvalue==False) {
-		/* length of string in unicode include \0 */
-		x=data->notify_data.data.length+1;
-		if(!prs_uint32("string length", ps, depth, &x ))
-			return False;
-		if (MARSHALLING(ps)) {
-			/* These are already in little endian format. Don't byte swap. */
-			if (x == 1) {
-
-				/* No memory allocated for this string
-				   therefore following the data.string
-				   pointer is a bad idea.  Use a pointer to
-				   the uint32 length union member to
-				   provide a source for a unicode NULL */
-
-				if(!prs_uint8s(True,"string",ps,depth, (uint8 *)&data->notify_data.data.length,x*2)) 
-					return False;
-			} else {
-				if(!prs_uint16uni(True,"string",ps,depth,data->notify_data.data.string,x))
-					return False;
-			}
-		} else {
-
-			/* Tallocate memory for string */
-
-			data->notify_data.data.string = (uint16 *)prs_alloc_mem(ps, x * 2);
-			if (!data->notify_data.data.string) 
-				return False;
-
-			if(!prs_uint16uni(True,"string",ps,depth,data->notify_data.data.string,x))
-				return False;
-		}
-	}
-#if 0	/* JERRY */
-	/* Win2k does not seem to put this parse align here */
-	if(!prs_align(ps))
-		return False;
-#endif
-
-	return True;
-}
-
-/*******************************************************************
-reads or writes an NOTIFY INFO structure.
-********************************************************************/  
-
-static BOOL smb_io_notify_info(const char *desc, SPOOL_NOTIFY_INFO *info, prs_struct *ps, int depth)
-{
-	int i;
-
-	prs_debug(ps, depth, desc, "smb_io_notify_info");
-	depth++;
- 
-	if(!prs_align(ps))
-		return False;
-
-	if(!prs_uint32("count", ps, depth, &info->count))
-		return False;
-	if(!prs_uint32("version", ps, depth, &info->version))
-		return False;
-	if(!prs_uint32("flags", ps, depth, &info->flags))
-		return False;
-	if(!prs_uint32("count", ps, depth, &info->count))
-		return False;
-
-	for (i=0;i<info->count;i++) {
-		if(!smb_io_notify_info_data(desc, &info->data[i], ps, depth))
-			return False;
-	}
-
-	/* now do the strings at the end of the stream */	
-	for (i=0;i<info->count;i++) {
-		if(!smb_io_notify_info_data_strings(desc, &info->data[i], ps, depth))
-			return False;
-	}
-
-	return True;
-}
-
-/*******************************************************************
-********************************************************************/  
-
-static BOOL spool_io_user_level_1(const char *desc, SPOOL_USER_1 *q_u, prs_struct *ps, int depth)
-{
-	prs_debug(ps, depth, desc, "");
-	depth++;
-
-	/* reading */
-	if (UNMARSHALLING(ps))
-		ZERO_STRUCTP(q_u);
-
-	if (!prs_align(ps))
-		return False;
-	if (!prs_uint32("size", ps, depth, &q_u->size))
-		return False;
-	if (!prs_uint32("client_name_ptr", ps, depth, &q_u->client_name_ptr))
-		return False;
-	if (!prs_uint32("user_name_ptr", ps, depth, &q_u->user_name_ptr))
-		return False;
-	if (!prs_uint32("build", ps, depth, &q_u->build))
-		return False;
-	if (!prs_uint32("major", ps, depth, &q_u->major))
-		return False;
-	if (!prs_uint32("minor", ps, depth, &q_u->minor))
-		return False;
-	if (!prs_uint32("processor", ps, depth, &q_u->processor))
-		return False;
-
-	if (!smb_io_unistr2("", &q_u->client_name, q_u->client_name_ptr, ps, depth))
-		return False;
-	if (!prs_align(ps))
-		return False;
-	if (!smb_io_unistr2("", &q_u->user_name,   q_u->user_name_ptr,   ps, depth))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
-********************************************************************/  
-
-static BOOL spool_io_user_level(const char *desc, SPOOL_USER_CTR *q_u, prs_struct *ps, int depth)
-{
-	if (q_u==NULL)
-		return False;
-
-	prs_debug(ps, depth, desc, "spool_io_user_level");
-	depth++;
-
-	if (!prs_align(ps))
-		return False;
-	if (!prs_uint32("level", ps, depth, &q_u->level))
-		return False;
-	if (!prs_uint32("ptr", ps, depth, &q_u->ptr))
-		return False;
-	
-	switch (q_u->level) {	
-	case 1:
-		if (!spool_io_user_level_1("", &q_u->user1, ps, depth))
-			return False;
-		break;
-	default:
-		return False;	
-	}	
-
-	return True;
-}
-
-/*******************************************************************
- * read or write a DEVICEMODE struct.
- * on reading allocate memory for the private member
- ********************************************************************/
-
-#define DM_NUM_OPTIONAL_FIELDS 		8
-
-BOOL spoolss_io_devmode(const char *desc, prs_struct *ps, int depth, DEVICEMODE *devmode)
-{
-	uint32 available_space;		/* size of the device mode left to parse */
-					/* only important on unmarshalling       */
-	int i = 0;
-					
-	struct optional_fields {
-		fstring		name;
-		uint32*		field;
-	} opt_fields[DM_NUM_OPTIONAL_FIELDS] = {
-		{ "icmmethod",		NULL },
-		{ "icmintent",		NULL },
-		{ "mediatype",		NULL },
-		{ "dithertype",		NULL },
-		{ "reserved1",		NULL },
-		{ "reserved2",		NULL },
-		{ "panningwidth",	NULL },
-		{ "panningheight",	NULL }
-	};
-
-	/* assign at run time to keep non-gcc vompilers happy */
-
-	opt_fields[0].field = &devmode->icmmethod;
-	opt_fields[1].field = &devmode->icmintent;
-	opt_fields[2].field = &devmode->mediatype;
-	opt_fields[3].field = &devmode->dithertype;
-	opt_fields[4].field = &devmode->reserved1;
-	opt_fields[5].field = &devmode->reserved2;
-	opt_fields[6].field = &devmode->panningwidth;
-	opt_fields[7].field = &devmode->panningheight;
-		
-	
-	prs_debug(ps, depth, desc, "spoolss_io_devmode");
-	depth++;
-
-	if (UNMARSHALLING(ps)) {
-		devmode->devicename.buffer = (uint16 *)prs_alloc_mem(ps, 32 * sizeof(uint16) );
-		if (devmode->devicename.buffer == NULL)
-			return False;
-	}
-
-	if (!prs_uint16uni(True,"devicename", ps, depth, devmode->devicename.buffer, MAXDEVICENAME))
-		return False;
-	
-	if (!prs_uint16("specversion",      ps, depth, &devmode->specversion))
-		return False;	
-		
-	/* Sanity Check - look for unknown specversions, but don't fail if we see one.
-	   Let the size determine that */
-	   
-	switch (devmode->specversion) {
-		case 0x0320:
-		case 0x0400:
-		case 0x0401:
-			break;
-			
-		default:
-			ZERODEBUG(0,("spoolss_io_devmode: Unknown specversion in devicemode [0x%x]\n",
-				devmode->specversion));
-			ZERODEBUG(0,("spoolss_io_devmode: please report to samba-technical@samba.org!\n"));
-			break;
-	}
-			
-	
-	if (!prs_uint16("driverversion",    ps, depth, &devmode->driverversion))
-		return False;
-	if (!prs_uint16("size",             ps, depth, &devmode->size))
-		return False;
-	if (!prs_uint16("driverextra",      ps, depth, &devmode->driverextra))
-		return False;
-	if (!prs_uint32("fields",           ps, depth, &devmode->fields))
-		return False;
-	if (!prs_uint16("orientation",      ps, depth, &devmode->orientation))
-		return False;
-	if (!prs_uint16("papersize",        ps, depth, &devmode->papersize))
-		return False;
-	if (!prs_uint16("paperlength",      ps, depth, &devmode->paperlength))
-		return False;
-	if (!prs_uint16("paperwidth",       ps, depth, &devmode->paperwidth))
-		return False;
-	if (!prs_uint16("scale",            ps, depth, &devmode->scale))
-		return False;
-	if (!prs_uint16("copies",           ps, depth, &devmode->copies))
-		return False;
-	if (!prs_uint16("defaultsource",    ps, depth, &devmode->defaultsource))
-		return False;
-	if (!prs_uint16("printquality",     ps, depth, &devmode->printquality))
-		return False;
-	if (!prs_uint16("color",            ps, depth, &devmode->color))
-		return False;
-	if (!prs_uint16("duplex",           ps, depth, &devmode->duplex))
-		return False;
-	if (!prs_uint16("yresolution",      ps, depth, &devmode->yresolution))
-		return False;
-	if (!prs_uint16("ttoption",         ps, depth, &devmode->ttoption))
-		return False;
-	if (!prs_uint16("collate",          ps, depth, &devmode->collate))
-		return False;
-
-	if (UNMARSHALLING(ps)) {
-		devmode->formname.buffer = (uint16 *)prs_alloc_mem(ps, 32 * sizeof(uint16) );
-		if (devmode->formname.buffer == NULL)
-			return False;
-	}
-
-	if (!prs_uint16uni(True, "formname",  ps, depth, devmode->formname.buffer, 32))
-		return False;
-	if (!prs_uint16("logpixels",        ps, depth, &devmode->logpixels))
-		return False;
-	if (!prs_uint32("bitsperpel",       ps, depth, &devmode->bitsperpel))
-		return False;
-	if (!prs_uint32("pelswidth",        ps, depth, &devmode->pelswidth))
-		return False;
-	if (!prs_uint32("pelsheight",       ps, depth, &devmode->pelsheight))
-		return False;
-	if (!prs_uint32("displayflags",     ps, depth, &devmode->displayflags))
-		return False;
-	if (!prs_uint32("displayfrequency", ps, depth, &devmode->displayfrequency))
-		return False;
-	/* 
-	 * every device mode I've ever seen on the wire at least has up 
-	 * to the displayfrequency field.   --jerry (05-09-2002)
-	 */
-	 
-	/* add uint32's + uint16's + two UNICODE strings */
-	 
-	available_space = devmode->size - (sizeof(uint32)*6 + sizeof(uint16)*18 + sizeof(uint16)*64);
-	
-	/* Sanity check - we only have uint32's left tp parse */
-	
-	if ( available_space && ((available_space % sizeof(uint32)) != 0) ) {
-		ZERODEBUG(0,("spoolss_io_devmode: available_space [%d] no in multiple of 4 bytes (size = %d)!\n",
-			available_space, devmode->size));
-		ZERODEBUG(0,("spoolss_io_devmode: please report to samba-technical@samba.org!\n"));
-		return False;
-	}
-	
-	/* 
-	 * Conditional parsing.  Assume that the DeviceMode has been 
-	 * zero'd by the caller. 
-	 */
-
-	while ((available_space > 0) && (i < DM_NUM_OPTIONAL_FIELDS))
-	{
-		DEBUG(10, ("spoolss_io_devmode: [%d] bytes left to parse in devmode\n", available_space));
-		if (!prs_uint32(opt_fields[i].name, ps, depth, opt_fields[i].field))
-			return False;
-		available_space -= sizeof(uint32);
-		i++;
-	}	 
-	
-	/* Sanity Check - we should no available space at this point unless 
-	   MS changes the device mode structure */
-	   
-	if (available_space) {
-		ZERODEBUG(0,("spoolss_io_devmode: I've parsed all I know and there is still stuff left|\n"));
-		ZERODEBUG(0,("spoolss_io_devmode: available_space = [%d], devmode_size = [%d]!\n",
-			available_space, devmode->size));
-		ZERODEBUG(0,("spoolss_io_devmode: please report to samba-technical@samba.org!\n"));
-		return False;
-	}
-	
-
-	if (devmode->driverextra!=0) {
-		if (UNMARSHALLING(ps)) {
-			devmode->private=(uint8 *)prs_alloc_mem(ps, devmode->driverextra*sizeof(uint8));
-			if(devmode->private == NULL)
-				return False;
-			DEBUG(7,("spoolss_io_devmode: allocated memory [%d] for private\n",devmode->driverextra)); 
-		}
-			
-		DEBUG(7,("spoolss_io_devmode: parsing [%d] bytes of private\n",devmode->driverextra));
-		if (!prs_uint8s(False, "private",  ps, depth,
-				devmode->private, devmode->driverextra))
-			return False;
-	}
-
-	return True;
-}
-
-/*******************************************************************
- Read or write a DEVICEMODE container
-********************************************************************/  
-
-static BOOL spoolss_io_devmode_cont(const char *desc, DEVMODE_CTR *dm_c, prs_struct *ps, int depth)
-{
-	if (dm_c==NULL)
-		return False;
-
-	prs_debug(ps, depth, desc, "spoolss_io_devmode_cont");
-	depth++;
-
-	if(!prs_align(ps))
-		return False;
-	
-	if (!prs_uint32("size", ps, depth, &dm_c->size))
-		return False;
-
-	if (!prs_uint32("devmode_ptr", ps, depth, &dm_c->devmode_ptr))
-		return False;
-
-	if (dm_c->size==0 || dm_c->devmode_ptr==0) {
-		if (UNMARSHALLING(ps))
-			/* if while reading there is no DEVMODE ... */
-			dm_c->devmode=NULL;
-		return True;
-	}
-	
-	/* so we have a DEVICEMODE to follow */		
-	if (UNMARSHALLING(ps)) {
-		DEBUG(9,("Allocating memory for spoolss_io_devmode\n"));
-		dm_c->devmode=(DEVICEMODE *)prs_alloc_mem(ps,sizeof(DEVICEMODE));
-		if(dm_c->devmode == NULL)
-			return False;
-	}
-	
-	/* this is bad code, shouldn't be there */
-	if (!prs_uint32("size", ps, depth, &dm_c->size))
-		return False;
-		
-	if (!spoolss_io_devmode(desc, ps, depth, dm_c->devmode))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
-********************************************************************/  
-
-static BOOL spoolss_io_printer_default(const char *desc, PRINTER_DEFAULT *pd, prs_struct *ps, int depth)
-{
-	if (pd==NULL)
-		return False;
-
-	prs_debug(ps, depth, desc, "spoolss_io_printer_default");
-	depth++;
-
-	if (!prs_uint32("datatype_ptr", ps, depth, &pd->datatype_ptr))
-		return False;
-
-	if (!smb_io_unistr2("datatype", &pd->datatype, pd->datatype_ptr, ps,depth))
-		return False;
-	
-	if (!prs_align(ps))
-		return False;
-
-	if (!spoolss_io_devmode_cont("", &pd->devmode_cont, ps, depth))
-		return False;
-
-	if (!prs_align(ps))
-		return False;
-
-	if (!prs_uint32("access_required", ps, depth, &pd->access_required))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
- * init a structure.
- ********************************************************************/
-
-BOOL make_spoolss_q_open_printer_ex(SPOOL_Q_OPEN_PRINTER_EX *q_u,
-		const fstring printername, 
-		const fstring datatype, 
-		uint32 access_required,
-		const fstring clientname,
-		const fstring user_name)
-{
-	DEBUG(5,("make_spoolss_q_open_printer_ex\n"));
-	q_u->printername_ptr = (printername!=NULL)?1:0;
-	init_unistr2(&q_u->printername, printername, strlen(printername)+1);
-
-	q_u->printer_default.datatype_ptr = 0;
-/*
-	q_u->printer_default.datatype_ptr = (datatype!=NULL)?1:0;
-	init_unistr2(&q_u->printer_default.datatype, datatype, strlen(datatype));
-*/
-	q_u->printer_default.devmode_cont.size=0;
-	q_u->printer_default.devmode_cont.devmode_ptr=0;
-	q_u->printer_default.devmode_cont.devmode=NULL;
-	q_u->printer_default.access_required=access_required;
-	q_u->user_switch=1;
-	q_u->user_ctr.level=1;
-	q_u->user_ctr.ptr=1;
-	q_u->user_ctr.user1.size=strlen(clientname)+strlen(user_name)+10;
-	q_u->user_ctr.user1.client_name_ptr = (clientname!=NULL)?1:0;
-	q_u->user_ctr.user1.user_name_ptr = (user_name!=NULL)?1:0;
-	q_u->user_ctr.user1.build=1381;
-	q_u->user_ctr.user1.major=2;
-	q_u->user_ctr.user1.minor=0;
-	q_u->user_ctr.user1.processor=0;
-	init_unistr2(&q_u->user_ctr.user1.client_name, clientname, strlen(clientname)+1);
-	init_unistr2(&q_u->user_ctr.user1.user_name, user_name, strlen(user_name)+1);
-	
-	return True;
-}
-
-/*******************************************************************
- * init a structure.
- ********************************************************************/
-
-BOOL make_spoolss_q_addprinterex(
-	TALLOC_CTX *mem_ctx,
-	SPOOL_Q_ADDPRINTEREX *q_u, 
-	const char *srv_name,
-	const char* clientname, 
-	const char* user_name,
-	uint32 level, 
-	PRINTER_INFO_CTR *ctr)
-{
-	DEBUG(5,("make_spoolss_q_addprinterex\n"));
-	
-	if (!ctr) return False;
-
-	ZERO_STRUCTP(q_u);
-
-	q_u->server_name_ptr = (srv_name!=NULL)?1:0;
-	init_unistr2(&q_u->server_name, srv_name, strlen(srv_name));
-
-	q_u->level = level;
-	
-	q_u->info.level = level;
-	q_u->info.info_ptr = (ctr->printers_2!=NULL)?1:0;
-	switch (level) {
-		case 2:
-			/* init q_u->info.info2 from *info */
-			if (!make_spoolss_printer_info_2(mem_ctx, &q_u->info.info_2, ctr->printers_2)) {
-				ZERODEBUG(0,("make_spoolss_q_addprinterex: Unable to fill SPOOL_Q_ADDPRINTEREX struct!\n"));
-				return False;
-			}
-			break;
-		default :
-			break;
-	}
-
-	q_u->user_switch=1;
-
-	q_u->user_ctr.level=1;
-	q_u->user_ctr.ptr=1;
-	q_u->user_ctr.user1.client_name_ptr = (clientname!=NULL)?1:0;
-	q_u->user_ctr.user1.user_name_ptr = (user_name!=NULL)?1:0;
-	q_u->user_ctr.user1.build=1381;
-	q_u->user_ctr.user1.major=2;
-	q_u->user_ctr.user1.minor=0;
-	q_u->user_ctr.user1.processor=0;
-	init_unistr2(&q_u->user_ctr.user1.client_name, clientname, strlen(clientname)+1);
-	init_unistr2(&q_u->user_ctr.user1.user_name, user_name, strlen(user_name)+1);
-	q_u->user_ctr.user1.size=q_u->user_ctr.user1.user_name.uni_str_len +
-	                         q_u->user_ctr.user1.client_name.uni_str_len + 2;
-	
-	return True;
-}
-	
-/*******************************************************************
-create a SPOOL_PRINTER_INFO_2 stuct from a PRINTER_INFO_2 struct
-*******************************************************************/
-
-BOOL make_spoolss_printer_info_2(TALLOC_CTX *mem_ctx, SPOOL_PRINTER_INFO_LEVEL_2 **spool_info2, 
-				PRINTER_INFO_2 *info)
-{
-
-	SPOOL_PRINTER_INFO_LEVEL_2 *inf;
-
-	/* allocate the necessary memory */
-	if (!(inf=(SPOOL_PRINTER_INFO_LEVEL_2*)talloc(mem_ctx, sizeof(SPOOL_PRINTER_INFO_LEVEL_2)))) {
-		ZERODEBUG(0,("make_spoolss_printer_info_2: Unable to allocate SPOOL_PRINTER_INFO_LEVEL_2 sruct!\n"));
-		return False;
-	}
-	
-	inf->servername_ptr 	= (info->servername.buffer!=NULL)?1:0;
-	inf->printername_ptr 	= (info->printername.buffer!=NULL)?1:0;
-	inf->sharename_ptr 	= (info->sharename.buffer!=NULL)?1:0;
-	inf->portname_ptr 	= (info->portname.buffer!=NULL)?1:0;
-	inf->drivername_ptr 	= (info->drivername.buffer!=NULL)?1:0;
-	inf->comment_ptr 	= (info->comment.buffer!=NULL)?1:0;
-	inf->location_ptr 	= (info->location.buffer!=NULL)?1:0;
-	inf->devmode_ptr 	= (info->devmode!=NULL)?1:0;
-	inf->sepfile_ptr 	= (info->sepfile.buffer!=NULL)?1:0;
-	inf->printprocessor_ptr = (info->printprocessor.buffer!=NULL)?1:0;
-	inf->datatype_ptr 	= (info->datatype.buffer!=NULL)?1:0;
-	inf->parameters_ptr 	= (info->parameters.buffer!=NULL)?1:0;
-	inf->secdesc_ptr 	= (info->secdesc!=NULL)?1:0;
-	inf->attributes 	= info->attributes;
-	inf->priority 		= info->priority;
-	inf->default_priority 	= info->defaultpriority;
-	inf->starttime		= info->starttime;
-	inf->untiltime		= info->untiltime;
-	inf->cjobs		= info->cjobs;
-	inf->averageppm	= info->averageppm;
-	init_unistr2_from_unistr(&inf->servername, 	&info->servername);
-	init_unistr2_from_unistr(&inf->printername, 	&info->printername);
-	init_unistr2_from_unistr(&inf->sharename, 	&info->sharename);
-	init_unistr2_from_unistr(&inf->portname, 	&info->portname);
-	init_unistr2_from_unistr(&inf->drivername, 	&info->drivername);
-	init_unistr2_from_unistr(&inf->comment, 	&info->comment);
-	init_unistr2_from_unistr(&inf->location, 	&info->location);
-	init_unistr2_from_unistr(&inf->sepfile, 	&info->sepfile);
-	init_unistr2_from_unistr(&inf->printprocessor,	&info->printprocessor);
-	init_unistr2_from_unistr(&inf->datatype, 	&info->datatype);
-	init_unistr2_from_unistr(&inf->parameters, 	&info->parameters);
-	init_unistr2_from_unistr(&inf->datatype, 	&info->datatype);
-
-	*spool_info2 = inf;
-
-	return True;
-}
-
-
-/*******************************************************************
- * read a structure.
- * called from spoolss_q_open_printer_ex (srv_spoolss.c)
- ********************************************************************/
-
-BOOL spoolss_io_q_open_printer(const char *desc, SPOOL_Q_OPEN_PRINTER *q_u, prs_struct *ps, int depth)
-{
-	if (q_u == NULL)
-		return False;
-
-	prs_debug(ps, depth, desc, "spoolss_io_q_open_printer");
-	depth++;
-
-	if (!prs_align(ps))
-		return False;
-
-	if (!prs_uint32("printername_ptr", ps, depth, &q_u->printername_ptr))
-		return False;
-	if (!smb_io_unistr2("", &q_u->printername, q_u->printername_ptr, ps,depth))
-		return False;
-	
-	if (!prs_align(ps))
-		return False;
-
-	if (!spoolss_io_printer_default("", &q_u->printer_default, ps, depth))
-		return False;
-		
-	return True;
-}
-
-/*******************************************************************
- * write a structure.
- * called from static spoolss_r_open_printer_ex (srv_spoolss.c)
- * called from spoolss_open_printer_ex (cli_spoolss.c)
- ********************************************************************/
-
-BOOL spoolss_io_r_open_printer(const char *desc, SPOOL_R_OPEN_PRINTER *r_u, prs_struct *ps, int depth)
-{
-	if (r_u == NULL) return False;
-
-	prs_debug(ps, depth, desc, "spoolss_io_r_open_printer");
-	depth++;
-	
-	if (!prs_align(ps))
-		return False;
-
-	if (!smb_io_pol_hnd("printer handle",&(r_u->handle),ps,depth))
-		return False;
-
-	if (!prs_werror("status code", ps, depth, &(r_u->status)))
-		return False;
-
-	return True;
-}
-
-
-/*******************************************************************
- * read a structure.
- * called from spoolss_q_open_printer_ex (srv_spoolss.c)
- ********************************************************************/
-
-BOOL spoolss_io_q_open_printer_ex(const char *desc, SPOOL_Q_OPEN_PRINTER_EX *q_u, prs_struct *ps, int depth)
-{
-	if (q_u == NULL)
-		return False;
-
-	prs_debug(ps, depth, desc, "spoolss_io_q_open_printer_ex");
-	depth++;
-
-	if (!prs_align(ps))
-		return False;
-
-	if (!prs_uint32("printername_ptr", ps, depth, &q_u->printername_ptr))
-		return False;
-	if (!smb_io_unistr2("", &q_u->printername, q_u->printername_ptr, ps,depth))
-		return False;
-	
-	if (!prs_align(ps))
-		return False;
-
-	if (!spoolss_io_printer_default("", &q_u->printer_default, ps, depth))
-		return False;
-		
-	if (!prs_uint32("user_switch", ps, depth, &q_u->user_switch))
-		return False;	
-	if (!spool_io_user_level("", &q_u->user_ctr, ps, depth))
-		return False;
-		
-	return True;
-}
-
-/*******************************************************************
- * write a structure.
- * called from static spoolss_r_open_printer_ex (srv_spoolss.c)
- * called from spoolss_open_printer_ex (cli_spoolss.c)
- ********************************************************************/
-
-BOOL spoolss_io_r_open_printer_ex(const char *desc, SPOOL_R_OPEN_PRINTER_EX *r_u, prs_struct *ps, int depth)
-{
-	if (r_u == NULL) return False;
-
-	prs_debug(ps, depth, desc, "spoolss_io_r_open_printer_ex");
-	depth++;
-	
-	if (!prs_align(ps))
-		return False;
-
-	if (!smb_io_pol_hnd("printer handle",&(r_u->handle),ps,depth))
-		return False;
-
-	if (!prs_werror("status code", ps, depth, &(r_u->status)))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
- * init a structure.
- ********************************************************************/
-BOOL make_spoolss_q_deleteprinterdriver(
-	TALLOC_CTX *mem_ctx,
-	SPOOL_Q_DELETEPRINTERDRIVER *q_u, 
-	const char *server,
-	const char* arch, 
-	const char* driver 
-)
-{
-	DEBUG(5,("make_spoolss_q_deleteprinterdriver\n"));
-	
-	q_u->server_ptr = (server!=NULL)?1:0;
-
-	/* these must be NULL terminated or else NT4 will
-	   complain about invalid parameters --jerry */
-	init_unistr2(&q_u->server, server, strlen(server)+1);
-	init_unistr2(&q_u->arch, arch, strlen(arch)+1);
-	init_unistr2(&q_u->driver, driver, strlen(driver)+1);
-
-	
-	return True;
-}
-
-
-/*******************************************************************
- * make a structure.
- ********************************************************************/
-
-BOOL make_spoolss_q_getprinterdata(SPOOL_Q_GETPRINTERDATA *q_u,
-                                const POLICY_HND *handle,
-                                UNISTR2 *valuename, uint32 size)
-{
-        if (q_u == NULL) return False;
-
-        DEBUG(5,("make_spoolss_q_getprinterdata\n"));
-
-        q_u->handle = *handle;
-        copy_unistr2(&q_u->valuename, valuename);
-        q_u->size = size;
-
-        return True;
-}
-
-/*******************************************************************
- * read a structure.
- * called from spoolss_q_getprinterdata (srv_spoolss.c)
- ********************************************************************/
-
-BOOL spoolss_io_q_getprinterdata(const char *desc, SPOOL_Q_GETPRINTERDATA *q_u, prs_struct *ps, int depth)
-{
-	if (q_u == NULL)
-		return False;
-
-	prs_debug(ps, depth, desc, "spoolss_io_q_getprinterdata");
-	depth++;
-
-	if (!prs_align(ps))
-		return False;
-	if (!smb_io_pol_hnd("printer handle",&q_u->handle,ps,depth))
-		return False;
-	if (!prs_align(ps))
-		return False;
-	if (!smb_io_unistr2("valuename", &q_u->valuename,True,ps,depth))
-		return False;
-	if (!prs_align(ps))
-		return False;
-	if (!prs_uint32("size", ps, depth, &q_u->size))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
- * read a structure.
- * called from spoolss_q_deleteprinterdata (srv_spoolss.c)
- ********************************************************************/
-
-BOOL spoolss_io_q_deleteprinterdata(const char *desc, SPOOL_Q_DELETEPRINTERDATA *q_u, prs_struct *ps, int depth)
-{
-	if (q_u == NULL)
-		return False;
-
-	prs_debug(ps, depth, desc, "spoolss_io_q_deleteprinterdata");
-	depth++;
-
-	if (!prs_align(ps))
-		return False;
-	if (!smb_io_pol_hnd("printer handle",&q_u->handle,ps,depth))
-		return False;
-	if (!prs_align(ps))
-		return False;
-	if (!smb_io_unistr2("valuename", &q_u->valuename,True,ps,depth))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
- * write a structure.
- * called from spoolss_r_deleteprinterdata (srv_spoolss.c)
- ********************************************************************/
-
-BOOL spoolss_io_r_deleteprinterdata(const char *desc, SPOOL_R_DELETEPRINTERDATA *r_u, prs_struct *ps, int depth)
-{
-	prs_debug(ps, depth, desc, "spoolss_io_r_deleteprinterdata");
-	depth++;
-	if(!prs_werror("status", ps, depth, &r_u->status))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
- * write a structure.
- * called from spoolss_r_getprinterdata (srv_spoolss.c)
- ********************************************************************/
-
-BOOL spoolss_io_r_getprinterdata(const char *desc, SPOOL_R_GETPRINTERDATA *r_u, prs_struct *ps, int depth)
-{
-	if (r_u == NULL)
-		return False;
-
-	prs_debug(ps, depth, desc, "spoolss_io_r_getprinterdata");
-	depth++;
-
-	if (!prs_align(ps))
-		return False;
-	if (!prs_uint32("type", ps, depth, &r_u->type))
-		return False;
-	if (!prs_uint32("size", ps, depth, &r_u->size))
-		return False;
-	
-	if (UNMARSHALLING(ps) && r_u->size) {
-		r_u->data = prs_alloc_mem(ps, r_u->size);
-		if(!r_u->data)
-			return False;
-	}
-
-	if (!prs_uint8s(False,"data", ps, depth, r_u->data, r_u->size))
-		return False;
-		
-	if (!prs_align(ps))
-		return False;
-	
-	if (!prs_uint32("needed", ps, depth, &r_u->needed))
-		return False;
-	if (!prs_werror("status", ps, depth, &r_u->status))
-		return False;
-		
-	return True;
-}
-
-/*******************************************************************
- * make a structure.
- ********************************************************************/
-
-BOOL make_spoolss_q_closeprinter(SPOOL_Q_CLOSEPRINTER *q_u, POLICY_HND *hnd)
-{
-	if (q_u == NULL) return False;
-
-	DEBUG(5,("make_spoolss_q_closeprinter\n"));
-
-	memcpy(&q_u->handle, hnd, sizeof(q_u->handle));
-
-	return True;
-}
-
-/*******************************************************************
- * read a structure.
- * called from static spoolss_q_abortprinter (srv_spoolss.c)
- * called from spoolss_abortprinter (cli_spoolss.c)
- ********************************************************************/
-
-BOOL spoolss_io_q_abortprinter(const char *desc, SPOOL_Q_ABORTPRINTER *q_u, prs_struct *ps, int depth)
-{
-	if (q_u == NULL) return False;
-
-	prs_debug(ps, depth, desc, "spoolss_io_q_abortprinter");
-	depth++;
-
-	if (!prs_align(ps))
-		return False;
-
-	if (!smb_io_pol_hnd("printer handle",&q_u->handle,ps,depth))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
- * write a structure.
- * called from spoolss_r_abortprinter (srv_spoolss.c)
- ********************************************************************/
-
-BOOL spoolss_io_r_abortprinter(const char *desc, SPOOL_R_ABORTPRINTER *r_u, prs_struct *ps, int depth)
-{
-	prs_debug(ps, depth, desc, "spoolss_io_r_abortprinter");
-	depth++;
-	if(!prs_werror("status", ps, depth, &r_u->status))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
- * read a structure.
- * called from static spoolss_q_deleteprinter (srv_spoolss.c)
- * called from spoolss_deleteprinter (cli_spoolss.c)
- ********************************************************************/
-
-BOOL spoolss_io_q_deleteprinter(const char *desc, SPOOL_Q_DELETEPRINTER *q_u, prs_struct *ps, int depth)
-{
-	if (q_u == NULL) return False;
-
-	prs_debug(ps, depth, desc, "spoolss_io_q_deleteprinter");
-	depth++;
-
-	if (!prs_align(ps))
-		return False;
-
-	if (!smb_io_pol_hnd("printer handle",&q_u->handle,ps,depth))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
- * write a structure.
- * called from static spoolss_r_deleteprinter (srv_spoolss.c)
- * called from spoolss_deleteprinter (cli_spoolss.c)
- ********************************************************************/
-
-BOOL spoolss_io_r_deleteprinter(const char *desc, SPOOL_R_DELETEPRINTER *r_u, prs_struct *ps, int depth)
-{
-	prs_debug(ps, depth, desc, "spoolss_io_r_deleteprinter");
-	depth++;
-	
-	if (!prs_align(ps))
-		return False;
-
-	if (!smb_io_pol_hnd("printer handle",&r_u->handle,ps,depth))
-		return False;
-	if (!prs_werror("status", ps, depth, &r_u->status))
-		return False;
-	
-	return True;
-}
-
-
-/*******************************************************************
- * read a structure.
- * called from api_spoolss_deleteprinterdriver (srv_spoolss.c)
- * called from spoolss_deleteprinterdriver (cli_spoolss.c)
- ********************************************************************/
-
-BOOL spoolss_io_q_deleteprinterdriver(const char *desc, SPOOL_Q_DELETEPRINTERDRIVER *q_u, prs_struct *ps, int depth)
-{
-	if (q_u == NULL) return False;
-
-	prs_debug(ps, depth, desc, "spoolss_io_q_deleteprinterdriver");
-	depth++;
-
-	if (!prs_align(ps))
-		return False;
-
-	if(!prs_uint32("server_ptr", ps, depth, &q_u->server_ptr))
-		return False;		
-	if(!smb_io_unistr2("server", &q_u->server, q_u->server_ptr, ps, depth))
-		return False;
-	if(!smb_io_unistr2("arch", &q_u->arch, True, ps, depth))
-		return False;
-	if(!smb_io_unistr2("driver", &q_u->driver, True, ps, depth))
-		return False;
-
-
-	return True;
-}
-
-
-/*******************************************************************
- * write a structure.
- ********************************************************************/
-BOOL spoolss_io_r_deleteprinterdriver(const char *desc, SPOOL_R_DELETEPRINTERDRIVER *r_u, prs_struct *ps, int depth)
-{
-	if (r_u == NULL) return False;
-
-	prs_debug(ps, depth, desc, "spoolss_io_r_deleteprinterdriver");
-	depth++;
-
-	if (!prs_align(ps))
-		return False;
-
-	if (!prs_werror("status", ps, depth, &r_u->status))
-		return False;
-
-	return True;
-}
-
-
-
-/*******************************************************************
- * read a structure.
- * called from static spoolss_q_closeprinter (srv_spoolss.c)
- * called from spoolss_closeprinter (cli_spoolss.c)
- ********************************************************************/
-
-BOOL spoolss_io_q_closeprinter(const char *desc, SPOOL_Q_CLOSEPRINTER *q_u, prs_struct *ps, int depth)
-{
-	if (q_u == NULL) return False;
-
-	prs_debug(ps, depth, desc, "spoolss_io_q_closeprinter");
-	depth++;
-
-	if (!prs_align(ps))
-		return False;
-
-	if (!smb_io_pol_hnd("printer handle",&q_u->handle,ps,depth))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
- * write a structure.
- * called from static spoolss_r_closeprinter (srv_spoolss.c)
- * called from spoolss_closeprinter (cli_spoolss.c)
- ********************************************************************/
-
-BOOL spoolss_io_r_closeprinter(const char *desc, SPOOL_R_CLOSEPRINTER *r_u, prs_struct *ps, int depth)
-{
-	prs_debug(ps, depth, desc, "spoolss_io_r_closeprinter");
-	depth++;
-	
-	if (!prs_align(ps))
-		return False;
-
-	if (!smb_io_pol_hnd("printer handle",&r_u->handle,ps,depth))
-		return False;
-	if (!prs_werror("status", ps, depth, &r_u->status))
-		return False;
-	
-	return True;
-}
-
-/*******************************************************************
- * read a structure.
- * called from spoolss_q_startdocprinter (srv_spoolss.c)
- ********************************************************************/
-
-BOOL spoolss_io_q_startdocprinter(const char *desc, SPOOL_Q_STARTDOCPRINTER *q_u, prs_struct *ps, int depth)
-{
-	if (q_u == NULL) return False;
-
-	prs_debug(ps, depth, desc, "spoolss_io_q_startdocprinter");
-	depth++;
-
-	if(!prs_align(ps))
-		return False;
-
-	if(!smb_io_pol_hnd("printer handle",&q_u->handle,ps,depth))
-		return False;
-	
-	if(!smb_io_doc_info_container("",&q_u->doc_info_container, ps, depth))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
- * write a structure.
- * called from spoolss_r_startdocprinter (srv_spoolss.c)
- ********************************************************************/
-
-BOOL spoolss_io_r_startdocprinter(const char *desc, SPOOL_R_STARTDOCPRINTER *r_u, prs_struct *ps, int depth)
-{
-	prs_debug(ps, depth, desc, "spoolss_io_r_startdocprinter");
-	depth++;
-	if(!prs_uint32("jobid", ps, depth, &r_u->jobid))
-		return False;
-	if(!prs_werror("status", ps, depth, &r_u->status))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
- * read a structure.
- * called from spoolss_q_enddocprinter (srv_spoolss.c)
- ********************************************************************/
-
-BOOL spoolss_io_q_enddocprinter(const char *desc, SPOOL_Q_ENDDOCPRINTER *q_u, prs_struct *ps, int depth)
-{
-	if (q_u == NULL) return False;
-
-	prs_debug(ps, depth, desc, "spoolss_io_q_enddocprinter");
-	depth++;
-
-	if(!prs_align(ps))
-		return False;
-
-	if(!smb_io_pol_hnd("printer handle",&q_u->handle,ps,depth))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
- * write a structure.
- * called from spoolss_r_enddocprinter (srv_spoolss.c)
- ********************************************************************/
-
-BOOL spoolss_io_r_enddocprinter(const char *desc, SPOOL_R_ENDDOCPRINTER *r_u, prs_struct *ps, int depth)
-{
-	prs_debug(ps, depth, desc, "spoolss_io_r_enddocprinter");
-	depth++;
-	if(!prs_werror("status", ps, depth, &r_u->status))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
- * read a structure.
- * called from spoolss_q_startpageprinter (srv_spoolss.c)
- ********************************************************************/
-
-BOOL spoolss_io_q_startpageprinter(const char *desc, SPOOL_Q_STARTPAGEPRINTER *q_u, prs_struct *ps, int depth)
-{
-	if (q_u == NULL) return False;
-
-	prs_debug(ps, depth, desc, "spoolss_io_q_startpageprinter");
-	depth++;
-
-	if(!prs_align(ps))
-		return False;
-
-	if(!smb_io_pol_hnd("printer handle",&q_u->handle,ps,depth))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
- * write a structure.
- * called from spoolss_r_startpageprinter (srv_spoolss.c)
- ********************************************************************/
-
-BOOL spoolss_io_r_startpageprinter(const char *desc, SPOOL_R_STARTPAGEPRINTER *r_u, prs_struct *ps, int depth)
-{
-	prs_debug(ps, depth, desc, "spoolss_io_r_startpageprinter");
-	depth++;
-	if(!prs_werror("status", ps, depth, &r_u->status))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
- * read a structure.
- * called from spoolss_q_endpageprinter (srv_spoolss.c)
- ********************************************************************/
-
-BOOL spoolss_io_q_endpageprinter(const char *desc, SPOOL_Q_ENDPAGEPRINTER *q_u, prs_struct *ps, int depth)
-{
-	if (q_u == NULL) return False;
-
-	prs_debug(ps, depth, desc, "spoolss_io_q_endpageprinter");
-	depth++;
-
-	if(!prs_align(ps))
-		return False;
-
-	if(!smb_io_pol_hnd("printer handle",&q_u->handle,ps,depth))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
- * write a structure.
- * called from spoolss_r_endpageprinter (srv_spoolss.c)
- ********************************************************************/
-
-BOOL spoolss_io_r_endpageprinter(const char *desc, SPOOL_R_ENDPAGEPRINTER *r_u, prs_struct *ps, int depth)
-{
-	prs_debug(ps, depth, desc, "spoolss_io_r_endpageprinter");
-	depth++;
-	if(!prs_werror("status", ps, depth, &r_u->status))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
- * read a structure.
- * called from spoolss_q_writeprinter (srv_spoolss.c)
- ********************************************************************/
-
-BOOL spoolss_io_q_writeprinter(const char *desc, SPOOL_Q_WRITEPRINTER *q_u, prs_struct *ps, int depth)
-{
-	if (q_u == NULL) return False;
-
-	prs_debug(ps, depth, desc, "spoolss_io_q_writeprinter");
-	depth++;
-
-	if(!prs_align(ps))
-		return False;
-
-	if(!smb_io_pol_hnd("printer handle",&q_u->handle,ps,depth))
-		return False;
-	if(!prs_uint32("buffer_size", ps, depth, &q_u->buffer_size))
-		return False;
-	
-	if (q_u->buffer_size!=0)
-	{
-		if (UNMARSHALLING(ps))
-			q_u->buffer=(uint8 *)prs_alloc_mem(ps,q_u->buffer_size*sizeof(uint8));
-		if(q_u->buffer == NULL)
-			return False;	
-		if(!prs_uint8s(True, "buffer", ps, depth, q_u->buffer, q_u->buffer_size))
-			return False;
-	}
-	if(!prs_align(ps))
-		return False;
-	if(!prs_uint32("buffer_size2", ps, depth, &q_u->buffer_size2))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
- * write a structure.
- * called from spoolss_r_writeprinter (srv_spoolss.c)
- ********************************************************************/
-
-BOOL spoolss_io_r_writeprinter(const char *desc, SPOOL_R_WRITEPRINTER *r_u, prs_struct *ps, int depth)
-{
-	prs_debug(ps, depth, desc, "spoolss_io_r_writeprinter");
-	depth++;
-	if(!prs_uint32("buffer_written", ps, depth, &r_u->buffer_written))
-		return False;
-	if(!prs_werror("status", ps, depth, &r_u->status))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
- * read a structure.
- * called from spoolss_q_rffpcnex (srv_spoolss.c)
- ********************************************************************/
-
-BOOL spoolss_io_q_rffpcnex(const char *desc, SPOOL_Q_RFFPCNEX *q_u, prs_struct *ps, int depth)
-{
-	prs_debug(ps, depth, desc, "spoolss_io_q_rffpcnex");
-	depth++;
-
-	if(!prs_align(ps))
-		return False;
-
-	if(!smb_io_pol_hnd("printer handle", &q_u->handle, ps, depth))
-		return False;
-	if(!prs_uint32("flags", ps, depth, &q_u->flags))
-		return False;
-	if(!prs_uint32("options", ps, depth, &q_u->options))
-		return False;
-	if(!prs_uint32("localmachine_ptr", ps, depth, &q_u->localmachine_ptr))
-		return False;
-	if(!smb_io_unistr2("localmachine", &q_u->localmachine, q_u->localmachine_ptr, ps, depth))
-		return False;
-
-	if(!prs_align(ps))
-		return False;
-		
-	if(!prs_uint32("printerlocal", ps, depth, &q_u->printerlocal))
-		return False;
-
-	if(!prs_uint32("option_ptr", ps, depth, &q_u->option_ptr))
-		return False;
-	
-	if (q_u->option_ptr!=0) {
-	
-		if (UNMARSHALLING(ps))
-			if((q_u->option=(SPOOL_NOTIFY_OPTION *)prs_alloc_mem(ps,sizeof(SPOOL_NOTIFY_OPTION))) == NULL)
-				return False;
-	
-		if(!smb_io_notify_option("notify option", q_u->option, ps, depth))
-			return False;
-	}
-	
-	return True;
-}
-
-/*******************************************************************
- * write a structure.
- * called from spoolss_r_rffpcnex (srv_spoolss.c)
- ********************************************************************/
-
-BOOL spoolss_io_r_rffpcnex(const char *desc, SPOOL_R_RFFPCNEX *r_u, prs_struct *ps, int depth)
-{
-	prs_debug(ps, depth, desc, "spoolss_io_r_rffpcnex");
-	depth++;
-
-	if(!prs_werror("status", ps, depth, &r_u->status))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
- * read a structure.
- * called from spoolss_q_rfnpcnex (srv_spoolss.c)
- ********************************************************************/
-
-BOOL spoolss_io_q_rfnpcnex(const char *desc, SPOOL_Q_RFNPCNEX *q_u, prs_struct *ps, int depth)
-{
-	prs_debug(ps, depth, desc, "spoolss_io_q_rfnpcnex");
-	depth++;
-
-	if(!prs_align(ps))
-		return False;
-
-	if(!smb_io_pol_hnd("printer handle",&q_u->handle,ps,depth))
-		return False;
-
-	if(!prs_uint32("change", ps, depth, &q_u->change))
-		return False;
-	
-	if(!prs_uint32("option_ptr", ps, depth, &q_u->option_ptr))
-		return False;
-	
-	if (q_u->option_ptr!=0) {
-	
-		if (UNMARSHALLING(ps))
-			if((q_u->option=(SPOOL_NOTIFY_OPTION *)prs_alloc_mem(ps,sizeof(SPOOL_NOTIFY_OPTION))) == NULL)
-				return False;
-	
-		if(!smb_io_notify_option("notify option", q_u->option, ps, depth))
-			return False;
-	}
-
-	return True;
-}
-
-/*******************************************************************
- * write a structure.
- * called from spoolss_r_rfnpcnex (srv_spoolss.c)
- ********************************************************************/
-
-BOOL spoolss_io_r_rfnpcnex(const char *desc, SPOOL_R_RFNPCNEX *r_u, prs_struct *ps, int depth)
-{
-	prs_debug(ps, depth, desc, "spoolss_io_r_rfnpcnex");
-	depth++;
-
-	if(!prs_align(ps))
-		return False;
-		
-	if (!prs_uint32("info_ptr", ps, depth, &r_u->info_ptr))
-		return False;
-
-	if(!smb_io_notify_info("notify info", &r_u->info ,ps,depth))
-		return False;
-	
-	if(!prs_align(ps))
-		return False;
-	if(!prs_werror("status", ps, depth, &r_u->status))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
- * return the length of a uint16 (obvious, but the code is clean)
- ********************************************************************/
-
-static uint32 size_of_uint16(uint16 *value)
-{
-	return (sizeof(*value));
-}
-
-/*******************************************************************
- * return the length of a uint32 (obvious, but the code is clean)
- ********************************************************************/
-
-static uint32 size_of_uint32(uint32 *value)
-{
-	return (sizeof(*value));
-}
-
-/*******************************************************************
- * return the length of a NTTIME (obvious, but the code is clean)
- ********************************************************************/
-
-static uint32 size_of_nttime(NTTIME *value)
-{
-	return (sizeof(*value));
-}
-
-/*******************************************************************
- * return the length of a UNICODE string in number of char, includes:
- * - the leading zero
- * - the relative pointer size
- ********************************************************************/
-
-static uint32 size_of_relative_string(UNISTR *string)
-{
-	uint32 size=0;
-	
-	size=str_len_uni(string);	/* the string length       */
-	size=size+1;			/* add the trailing zero   */
-	size=size*2;			/* convert in char         */
-	size=size+4;			/* add the size of the ptr */	
-
-#if 0	/* JERRY */
-	/* 
-	 * Do not include alignment as Win2k does not align relative
-	 * strings within a buffer   --jerry 
-	 */
-	/* Ensure size is 4 byte multiple (prs_align is being called...). */
-	/* size += ((4 - (size & 3)) & 3); */
-#endif 
-
-	return size;
-}
-
-/*******************************************************************
- * return the length of a uint32 (obvious, but the code is clean)
- ********************************************************************/
-
-static uint32 size_of_device_mode(DEVICEMODE *devmode)
-{
-	if (devmode==NULL)
-		return (4);
-	else 
-		return (4+devmode->size+devmode->driverextra);
-}
-
-/*******************************************************************
- * return the length of a uint32 (obvious, but the code is clean)
- ********************************************************************/
-
-static uint32 size_of_systemtime(SYSTEMTIME *systime)
-{
-	if (systime==NULL)
-		return (4);
-	else 
-		return (sizeof(SYSTEMTIME) +4);
-}
-
-/*******************************************************************
- * write a UNICODE string and its relative pointer.
- * used by all the RPC structs passing a buffer
- *
- * As I'm a nice guy, I'm forcing myself to explain this code.
- * MS did a good job in the overall spoolss code except in some
- * functions where they are passing the API buffer directly in the
- * RPC request/reply. That's to maintain compatiility at the API level.
- * They could have done it the good way the first time.
- *
- * So what happen is: the strings are written at the buffer's end, 
- * in the reverse order of the original structure. Some pointers to
- * the strings are also in the buffer. Those are relative to the
- * buffer's start.
- *
- * If you don't understand or want to change that function,
- * first get in touch with me: jfm@samba.org
- *
- ********************************************************************/
-
-static BOOL smb_io_relstr(const char *desc, NEW_BUFFER *buffer, int depth, UNISTR *string)
-{
-	prs_struct *ps=&buffer->prs;
-	
-	if (MARSHALLING(ps)) {
-		uint32 struct_offset = prs_offset(ps);
-		uint32 relative_offset;
-		
-		buffer->string_at_end -= (size_of_relative_string(string) - 4);
-		if(!prs_set_offset(ps, buffer->string_at_end))
-			return False;
-#if 0	/* JERRY */
-		/*
-		 * Win2k does not align strings in a buffer
-		 * Tested against WinNT 4.0 SP 6a & 2k SP2  --jerry
-		 */
-		if (!prs_align(ps))
-			return False;
-#endif
-		buffer->string_at_end = prs_offset(ps);
-		
-		/* write the string */
-		if (!smb_io_unistr(desc, string, ps, depth))
-			return False;
-
-		if(!prs_set_offset(ps, struct_offset))
-			return False;
-		
-		relative_offset=buffer->string_at_end - buffer->struct_start;
-		/* write its offset */
-		if (!prs_uint32("offset", ps, depth, &relative_offset))
-			return False;
-	}
-	else {
-		uint32 old_offset;
-		
-		/* read the offset */
-		if (!prs_uint32("offset", ps, depth, &(buffer->string_at_end)))
-			return False;
-
-		old_offset = prs_offset(ps);
-		if(!prs_set_offset(ps, buffer->string_at_end+buffer->struct_start))
-			return False;
-
-		/* read the string */
-		if (!smb_io_unistr(desc, string, ps, depth))
-			return False;
-
-		if(!prs_set_offset(ps, old_offset))
-			return False;
-	}
-	return True;
-}
-
-/*******************************************************************
- * write a array of UNICODE strings and its relative pointer.
- * used by 2 RPC structs
- ********************************************************************/
-
-static BOOL smb_io_relarraystr(const char *desc, NEW_BUFFER *buffer, int depth, uint16 **string)
-{
-	UNISTR chaine;
-	
-	prs_struct *ps=&buffer->prs;
-	
-	if (MARSHALLING(ps)) {
-		uint32 struct_offset = prs_offset(ps);
-		uint32 relative_offset;
-		uint16 *p;
-		uint16 *q;
-		uint16 zero=0;
-		p=*string;
-		q=*string;
-
-		/* first write the last 0 */
-		buffer->string_at_end -= 2;
-		if(!prs_set_offset(ps, buffer->string_at_end))
-			return False;
-
-		if(!prs_uint16("leading zero", ps, depth, &zero))
-			return False;
-
-		while (p && (*p!=0)) {	
-			while (*q!=0)
-				q++;
-
-			/* Yes this should be malloc not talloc. Don't change. */
-
-			chaine.buffer = malloc((q-p+1)*sizeof(uint16));
-			if (chaine.buffer == NULL)
-				return False;
-
-			memcpy(chaine.buffer, p, (q-p+1)*sizeof(uint16));
-
-			buffer->string_at_end -= (q-p+1)*sizeof(uint16);
-
-			if(!prs_set_offset(ps, buffer->string_at_end)) {
-				SAFE_FREE(chaine.buffer);
-				return False;
-			}
-
-			/* write the string */
-			if (!smb_io_unistr(desc, &chaine, ps, depth)) {
-				SAFE_FREE(chaine.buffer);
-				return False;
-			}
-			q++;
-			p=q;
-
-			SAFE_FREE(chaine.buffer);
-		}
-		
-		if(!prs_set_offset(ps, struct_offset))
-			return False;
-		
-		relative_offset=buffer->string_at_end - buffer->struct_start;
-		/* write its offset */
-		if (!prs_uint32("offset", ps, depth, &relative_offset))
-			return False;
-
-	} else {
-
-		/* UNMARSHALLING */
-
-		uint32 old_offset;
-		uint16 *chaine2=NULL;
-		int l_chaine=0;
-		int l_chaine2=0;
-		size_t realloc_size = 0;
-
-		*string=NULL;
-				
-		/* read the offset */
-		if (!prs_uint32("offset", ps, depth, &buffer->string_at_end))
-			return False;
-
-		old_offset = prs_offset(ps);
-		if(!prs_set_offset(ps, buffer->string_at_end + buffer->struct_start))
-			return False;
-	
-		do {
-			if (!smb_io_unistr(desc, &chaine, ps, depth))
-				return False;
-			
-			l_chaine=str_len_uni(&chaine);
-			
-			/* we're going to add two more bytes here in case this
-			   is the last string in the array and we need to add 
-			   an extra NULL for termination */
-			if (l_chaine > 0)
-			{
-				uint16 *tc2;
-			
-				realloc_size = (l_chaine2+l_chaine+2)*sizeof(uint16);
-
-				/* Yes this should be realloc - it's freed below. JRA */
-
-				if((tc2=(uint16 *)Realloc(chaine2, realloc_size)) == NULL) {
-					SAFE_FREE(chaine2);
-					return False;
-				}
-				else chaine2 = tc2;
-				memcpy(chaine2+l_chaine2, chaine.buffer, (l_chaine+1)*sizeof(uint16));
-				l_chaine2+=l_chaine+1;
-			}
-		
-		} while(l_chaine!=0);
-		
-		/* the end should be bould NULL terminated so add 
-		   the second one here */
-		if (chaine2)
-		{
-			chaine2[l_chaine2] = '\0';
-			*string=(uint16 *)talloc_memdup(prs_get_mem_context(ps),chaine2,realloc_size);
-			SAFE_FREE(chaine2);
-		}
-
-		if(!prs_set_offset(ps, old_offset))
-			return False;
-	}
-	return True;
-}
-
-/*******************************************************************
- Parse a DEVMODE structure and its relative pointer.
-********************************************************************/
-
-static BOOL smb_io_relsecdesc(const char *desc, NEW_BUFFER *buffer, int depth, SEC_DESC **secdesc)
-{
-	prs_struct *ps= &buffer->prs;
-
-	prs_debug(ps, depth, desc, "smb_io_relsecdesc");
-	depth++;
-
-	if (MARSHALLING(ps)) {
-		uint32 struct_offset = prs_offset(ps);
-		uint32 relative_offset;
-
-		if (! *secdesc) {
-			relative_offset = 0;
-			if (!prs_uint32("offset", ps, depth, &relative_offset))
-				return False;
-			return True;
-		}
-		
-		if (*secdesc != NULL) {
-			buffer->string_at_end -= sec_desc_size(*secdesc);
-
-			if(!prs_set_offset(ps, buffer->string_at_end))
-				return False;
-			/* write the secdesc */
-			if (!sec_io_desc(desc, secdesc, ps, depth))
-				return False;
-
-			if(!prs_set_offset(ps, struct_offset))
-				return False;
-		}
-
-		relative_offset=buffer->string_at_end - buffer->struct_start;
-		/* write its offset */
-
-		if (!prs_uint32("offset", ps, depth, &relative_offset))
-			return False;
-	} else {
-		uint32 old_offset;
-		
-		/* read the offset */
-		if (!prs_uint32("offset", ps, depth, &buffer->string_at_end))
-			return False;
-
-		old_offset = prs_offset(ps);
-		if(!prs_set_offset(ps, buffer->string_at_end + buffer->struct_start))
-			return False;
-
-		/* read the sd */
-		if (!sec_io_desc(desc, secdesc, ps, depth))
-			return False;
-
-		if(!prs_set_offset(ps, old_offset))
-			return False;
-	}
-	return True;
-}
-
-/*******************************************************************
- Parse a DEVMODE structure and its relative pointer.
-********************************************************************/
-
-static BOOL smb_io_reldevmode(const char *desc, NEW_BUFFER *buffer, int depth, DEVICEMODE **devmode)
-{
-	prs_struct *ps=&buffer->prs;
-
-	prs_debug(ps, depth, desc, "smb_io_reldevmode");
-	depth++;
-
-	if (MARSHALLING(ps)) {
-		uint32 struct_offset = prs_offset(ps);
-		uint32 relative_offset;
-		
-		if (*devmode == NULL) {
-			relative_offset=0;
-			if (!prs_uint32("offset", ps, depth, &relative_offset))
-				return False;
-			DEBUG(8, ("boing, the devmode was NULL\n"));
-			
-			return True;
-		}
-		
-		buffer->string_at_end -= ((*devmode)->size + (*devmode)->driverextra);
-		
-		if(!prs_set_offset(ps, buffer->string_at_end))
-			return False;
-		
-		/* write the DEVMODE */
-		if (!spoolss_io_devmode(desc, ps, depth, *devmode))
-			return False;
-
-		if(!prs_set_offset(ps, struct_offset))
-			return False;
-		
-		relative_offset=buffer->string_at_end - buffer->struct_start;
-		/* write its offset */
-		if (!prs_uint32("offset", ps, depth, &relative_offset))
-			return False;
-	}
-	else {
-		uint32 old_offset;
-		
-		/* read the offset */
-		if (!prs_uint32("offset", ps, depth, &buffer->string_at_end))
-			return False;
-		if (buffer->string_at_end == 0) {
-			*devmode = NULL;
-			return True;
-		}
-
-		old_offset = prs_offset(ps);
-		if(!prs_set_offset(ps, buffer->string_at_end + buffer->struct_start))
-			return False;
-
-		/* read the string */
-		if((*devmode=(DEVICEMODE *)prs_alloc_mem(ps,sizeof(DEVICEMODE))) == NULL)
-			return False;
-		if (!spoolss_io_devmode(desc, ps, depth, *devmode))
-			return False;
-
-		if(!prs_set_offset(ps, old_offset))
-			return False;
-	}
-	return True;
-}
-
-/*******************************************************************
- Parse a PRINTER_INFO_0 structure.
-********************************************************************/  
-
-BOOL smb_io_printer_info_0(const char *desc, NEW_BUFFER *buffer, PRINTER_INFO_0 *info, int depth)
-{
-	prs_struct *ps=&buffer->prs;
-
-	prs_debug(ps, depth, desc, "smb_io_printer_info_0");
-	depth++;	
-	
-	buffer->struct_start=prs_offset(ps);
-
-	if (!smb_io_relstr("printername", buffer, depth, &info->printername))
-		return False;
-	if (!smb_io_relstr("servername", buffer, depth, &info->servername))
-		return False;
-	
-	if(!prs_uint32("cjobs", ps, depth, &info->cjobs))
-		return False;
-	if(!prs_uint32("total_jobs", ps, depth, &info->total_jobs))
-		return False;
-	if(!prs_uint32("total_bytes", ps, depth, &info->total_bytes))
-		return False;
-
-	if(!prs_uint16("year", ps, depth, &info->year))
-		return False;
-	if(!prs_uint16("month", ps, depth, &info->month))
-		return False;
-	if(!prs_uint16("dayofweek", ps, depth, &info->dayofweek))
-		return False;
-	if(!prs_uint16("day", ps, depth, &info->day))
-		return False;
-	if(!prs_uint16("hour", ps, depth, &info->hour))
-		return False;
-	if(!prs_uint16("minute", ps, depth, &info->minute))
-		return False;
-	if(!prs_uint16("second", ps, depth, &info->second))
-		return False;
-	if(!prs_uint16("milliseconds", ps, depth, &info->milliseconds))
-		return False;
-
-	if(!prs_uint32("global_counter", ps, depth, &info->global_counter))
-		return False;
-	if(!prs_uint32("total_pages", ps, depth, &info->total_pages))
-		return False;
-
-	if(!prs_uint16("major_version", ps, depth, &info->major_version))
-		return False;
-	if(!prs_uint16("build_version", ps, depth, &info->build_version))
-		return False;
-	if(!prs_uint32("unknown7", ps, depth, &info->unknown7))
-		return False;
-	if(!prs_uint32("unknown8", ps, depth, &info->unknown8))
-		return False;
-	if(!prs_uint32("unknown9", ps, depth, &info->unknown9))
-		return False;
-	if(!prs_uint32("session_counter", ps, depth, &info->session_counter))
-		return False;
-	if(!prs_uint32("unknown11", ps, depth, &info->unknown11))
-		return False;
-	if(!prs_uint32("printer_errors", ps, depth, &info->printer_errors))
-		return False;
-	if(!prs_uint32("unknown13", ps, depth, &info->unknown13))
-		return False;
-	if(!prs_uint32("unknown14", ps, depth, &info->unknown14))
-		return False;
-	if(!prs_uint32("unknown15", ps, depth, &info->unknown15))
-		return False;
-	if(!prs_uint32("unknown16", ps, depth, &info->unknown16))
-		return False;
-	if(!prs_uint32("change_id", ps, depth, &info->change_id))
-		return False;
-	if(!prs_uint32("unknown18", ps, depth, &info->unknown18))
-		return False;
-	if(!prs_uint32("status"   , ps, depth, &info->status))
-		return False;
-	if(!prs_uint32("unknown20", ps, depth, &info->unknown20))
-		return False;
-	if(!prs_uint32("c_setprinter", ps, depth, &info->c_setprinter))
-		return False;
-	if(!prs_uint16("unknown22", ps, depth, &info->unknown22))
-		return False;
-	if(!prs_uint16("unknown23", ps, depth, &info->unknown23))
-		return False;
-	if(!prs_uint16("unknown24", ps, depth, &info->unknown24))
-		return False;
-	if(!prs_uint16("unknown25", ps, depth, &info->unknown25))
-		return False;
-	if(!prs_uint16("unknown26", ps, depth, &info->unknown26))
-		return False;
-	if(!prs_uint16("unknown27", ps, depth, &info->unknown27))
-		return False;
-	if(!prs_uint16("unknown28", ps, depth, &info->unknown28))
-		return False;
-	if(!prs_uint16("unknown29", ps, depth, &info->unknown29))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
- Parse a PRINTER_INFO_1 structure.
-********************************************************************/  
-
-BOOL smb_io_printer_info_1(const char *desc, NEW_BUFFER *buffer, PRINTER_INFO_1 *info, int depth)
-{
-	prs_struct *ps=&buffer->prs;
-
-	prs_debug(ps, depth, desc, "smb_io_printer_info_1");
-	depth++;	
-	
-	buffer->struct_start=prs_offset(ps);
-
-	if (!prs_uint32("flags", ps, depth, &info->flags))
-		return False;
-	if (!smb_io_relstr("description", buffer, depth, &info->description))
-		return False;
-	if (!smb_io_relstr("name", buffer, depth, &info->name))
-		return False;
-	if (!smb_io_relstr("comment", buffer, depth, &info->comment))
-		return False;	
-
-	return True;
-}
-
-/*******************************************************************
- Parse a PRINTER_INFO_2 structure.
-********************************************************************/  
-
-BOOL smb_io_printer_info_2(const char *desc, NEW_BUFFER *buffer, PRINTER_INFO_2 *info, int depth)
-{
-	prs_struct *ps=&buffer->prs;
-	uint32 dm_offset, sd_offset, current_offset;
-	uint32 dummy_value = 0, has_secdesc = 0;
-	
-	prs_debug(ps, depth, desc, "smb_io_printer_info_2");
-	depth++;	
-	
-	buffer->struct_start=prs_offset(ps);
-	
-	if (!smb_io_relstr("servername", buffer, depth, &info->servername))
-		return False;
-	if (!smb_io_relstr("printername", buffer, depth, &info->printername))
-		return False;
-	if (!smb_io_relstr("sharename", buffer, depth, &info->sharename))
-		return False;
-	if (!smb_io_relstr("portname", buffer, depth, &info->portname))
-		return False;
-	if (!smb_io_relstr("drivername", buffer, depth, &info->drivername))
-		return False;
-	if (!smb_io_relstr("comment", buffer, depth, &info->comment))
-		return False;
-	if (!smb_io_relstr("location", buffer, depth, &info->location))
-		return False;
-
-	/* save current offset and wind forwared by a uint32 */
-	dm_offset = prs_offset(ps);
-	if (!prs_uint32("devmode", ps, depth, &dummy_value))
-		return False;
-
-	if (!smb_io_relstr("sepfile", buffer, depth, &info->sepfile))
-		return False;
-	if (!smb_io_relstr("printprocessor", buffer, depth, &info->printprocessor))
-		return False;
-	if (!smb_io_relstr("datatype", buffer, depth, &info->datatype))
-		return False;
-	if (!smb_io_relstr("parameters", buffer, depth, &info->parameters))
-		return False;
-
-	/* save current offset for the sec_desc */
-	sd_offset = prs_offset(ps);
-	if (!prs_uint32("sec_desc", ps, depth, &has_secdesc))
-		return False;
-	
-	/* save current location so we can pick back up here */
-	current_offset = prs_offset(ps);
-	
-	/* parse the devmode */
-	if (!prs_set_offset(ps, dm_offset))
-		return False;
-	if (!smb_io_reldevmode("devmode", buffer, depth, &info->devmode))
-		return False;
-	
-	/* parse the sec_desc */
-	if (has_secdesc) {
-		if (!prs_set_offset(ps, sd_offset))
-			return False;
-		if (!smb_io_relsecdesc("secdesc", buffer, depth, &info->secdesc))
-			return False;
-	}
-		
-	/* pick up where we left off */
-	if (!prs_set_offset(ps, current_offset))
-		return False;
-
-	if (!prs_uint32("attributes", ps, depth, &info->attributes))
-		return False;
-	if (!prs_uint32("priority", ps, depth, &info->priority))
-		return False;
-	if (!prs_uint32("defpriority", ps, depth, &info->defaultpriority))
-		return False;
-	if (!prs_uint32("starttime", ps, depth, &info->starttime))
-		return False;
-	if (!prs_uint32("untiltime", ps, depth, &info->untiltime))
-		return False;
-	if (!prs_uint32("status", ps, depth, &info->status))
-		return False;
-	if (!prs_uint32("jobs", ps, depth, &info->cjobs))
-		return False;
-	if (!prs_uint32("averageppm", ps, depth, &info->averageppm))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
- Parse a PRINTER_INFO_3 structure.
-********************************************************************/  
-
-BOOL smb_io_printer_info_3(const char *desc, NEW_BUFFER *buffer, PRINTER_INFO_3 *info, int depth)
-{
-	prs_struct *ps=&buffer->prs;
-
-	prs_debug(ps, depth, desc, "smb_io_printer_info_3");
-	depth++;	
-	
-	buffer->struct_start=prs_offset(ps);
-	
-	if (!prs_uint32("flags", ps, depth, &info->flags))
-		return False;
-	if (!sec_io_desc("sec_desc", &info->secdesc, ps, depth))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
- Parse a PRINTER_INFO_4 structure.
-********************************************************************/  
-
-BOOL smb_io_printer_info_4(const char *desc, NEW_BUFFER *buffer, PRINTER_INFO_4 *info, int depth)
-{
-	prs_struct *ps=&buffer->prs;
-
-	prs_debug(ps, depth, desc, "smb_io_printer_info_4");
-	depth++;	
-	
-	buffer->struct_start=prs_offset(ps);
-	
-	if (!smb_io_relstr("printername", buffer, depth, &info->printername))
-		return False;
-	if (!smb_io_relstr("servername", buffer, depth, &info->servername))
-		return False;
-	if (!prs_uint32("attributes", ps, depth, &info->attributes))
-		return False;
-	return True;
-}
-
-/*******************************************************************
- Parse a PRINTER_INFO_5 structure.
-********************************************************************/  
-
-BOOL smb_io_printer_info_5(const char *desc, NEW_BUFFER *buffer, PRINTER_INFO_5 *info, int depth)
-{
-	prs_struct *ps=&buffer->prs;
-
-	prs_debug(ps, depth, desc, "smb_io_printer_info_5");
-	depth++;	
-	
-	buffer->struct_start=prs_offset(ps);
-	
-	if (!smb_io_relstr("printername", buffer, depth, &info->printername))
-		return False;
-	if (!smb_io_relstr("portname", buffer, depth, &info->portname))
-		return False;
-	if (!prs_uint32("attributes", ps, depth, &info->attributes))
-		return False;
-	if (!prs_uint32("device_not_selected_timeout", ps, depth, &info->device_not_selected_timeout))
-		return False;
-	if (!prs_uint32("transmission_retry_timeout", ps, depth, &info->transmission_retry_timeout))
-		return False;
-	return True;
-}
-
-/*******************************************************************
- Parse a PORT_INFO_1 structure.
-********************************************************************/  
-
-BOOL smb_io_port_info_1(const char *desc, NEW_BUFFER *buffer, PORT_INFO_1 *info, int depth)
-{
-	prs_struct *ps=&buffer->prs;
-
-	prs_debug(ps, depth, desc, "smb_io_port_info_1");
-	depth++;	
-	
-	buffer->struct_start=prs_offset(ps);
-	
-	if (!smb_io_relstr("port_name", buffer, depth, &info->port_name))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
- Parse a PORT_INFO_2 structure.
-********************************************************************/  
-
-BOOL smb_io_port_info_2(const char *desc, NEW_BUFFER *buffer, PORT_INFO_2 *info, int depth)
-{
-	prs_struct *ps=&buffer->prs;
-
-	prs_debug(ps, depth, desc, "smb_io_port_info_2");
-	depth++;	
-	
-	buffer->struct_start=prs_offset(ps);
-	
-	if (!smb_io_relstr("port_name", buffer, depth, &info->port_name))
-		return False;
-	if (!smb_io_relstr("monitor_name", buffer, depth, &info->monitor_name))
-		return False;
-	if (!smb_io_relstr("description", buffer, depth, &info->description))
-		return False;
-	if (!prs_uint32("port_type", ps, depth, &info->port_type))
-		return False;
-	if (!prs_uint32("reserved", ps, depth, &info->reserved))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
- Parse a DRIVER_INFO_1 structure.
-********************************************************************/
-
-BOOL smb_io_printer_driver_info_1(const char *desc, NEW_BUFFER *buffer, DRIVER_INFO_1 *info, int depth) 
-{
-	prs_struct *ps=&buffer->prs;
-
-	prs_debug(ps, depth, desc, "smb_io_printer_driver_info_1");
-	depth++;	
-	
-	buffer->struct_start=prs_offset(ps);
-
-	if (!smb_io_relstr("name", buffer, depth, &info->name))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
- Parse a DRIVER_INFO_2 structure.
-********************************************************************/
-
-BOOL smb_io_printer_driver_info_2(const char *desc, NEW_BUFFER *buffer, DRIVER_INFO_2 *info, int depth) 
-{
-	prs_struct *ps=&buffer->prs;
-
-	prs_debug(ps, depth, desc, "smb_io_printer_driver_info_2");
-	depth++;	
-	
-	buffer->struct_start=prs_offset(ps);
-
-	if (!prs_uint32("version", ps, depth, &info->version))
-		return False;
-	if (!smb_io_relstr("name", buffer, depth, &info->name))
-		return False;
-	if (!smb_io_relstr("architecture", buffer, depth, &info->architecture))
-		return False;
-	if (!smb_io_relstr("driverpath", buffer, depth, &info->driverpath))
-		return False;
-	if (!smb_io_relstr("datafile", buffer, depth, &info->datafile))
-		return False;
-	if (!smb_io_relstr("configfile", buffer, depth, &info->configfile))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
- Parse a DRIVER_INFO_3 structure.
-********************************************************************/
-
-BOOL smb_io_printer_driver_info_3(const char *desc, NEW_BUFFER *buffer, DRIVER_INFO_3 *info, int depth)
-{
-	prs_struct *ps=&buffer->prs;
-
-	prs_debug(ps, depth, desc, "smb_io_printer_driver_info_3");
-	depth++;	
-	
-	buffer->struct_start=prs_offset(ps);
-
-	if (!prs_uint32("version", ps, depth, &info->version))
-		return False;
-	if (!smb_io_relstr("name", buffer, depth, &info->name))
-		return False;
-	if (!smb_io_relstr("architecture", buffer, depth, &info->architecture))
-		return False;
-	if (!smb_io_relstr("driverpath", buffer, depth, &info->driverpath))
-		return False;
-	if (!smb_io_relstr("datafile", buffer, depth, &info->datafile))
-		return False;
-	if (!smb_io_relstr("configfile", buffer, depth, &info->configfile))
-		return False;
-	if (!smb_io_relstr("helpfile", buffer, depth, &info->helpfile))
-		return False;
-
-	if (!smb_io_relarraystr("dependentfiles", buffer, depth, &info->dependentfiles))
-		return False;
-
-	if (!smb_io_relstr("monitorname", buffer, depth, &info->monitorname))
-		return False;
-	if (!smb_io_relstr("defaultdatatype", buffer, depth, &info->defaultdatatype))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
- Parse a DRIVER_INFO_6 structure.
-********************************************************************/
-
-BOOL smb_io_printer_driver_info_6(const char *desc, NEW_BUFFER *buffer, DRIVER_INFO_6 *info, int depth)
-{
-	prs_struct *ps=&buffer->prs;
-
-	prs_debug(ps, depth, desc, "smb_io_printer_driver_info_6");
-	depth++;	
-	
-	buffer->struct_start=prs_offset(ps);
-
-	if (!prs_uint32("version", ps, depth, &info->version))
-		return False;
-	if (!smb_io_relstr("name", buffer, depth, &info->name))
-		return False;
-	if (!smb_io_relstr("architecture", buffer, depth, &info->architecture))
-		return False;
-	if (!smb_io_relstr("driverpath", buffer, depth, &info->driverpath))
-		return False;
-	if (!smb_io_relstr("datafile", buffer, depth, &info->datafile))
-		return False;
-	if (!smb_io_relstr("configfile", buffer, depth, &info->configfile))
-		return False;
-	if (!smb_io_relstr("helpfile", buffer, depth, &info->helpfile))
-		return False;
-
-	if (!smb_io_relarraystr("dependentfiles", buffer, depth, &info->dependentfiles))
-		return False;
-
-	if (!smb_io_relstr("monitorname", buffer, depth, &info->monitorname))
-		return False;
-	if (!smb_io_relstr("defaultdatatype", buffer, depth, &info->defaultdatatype))
-		return False;
-
-	if (!smb_io_relarraystr("previousdrivernames", buffer, depth, &info->previousdrivernames))
-		return False;
-
-	if (!prs_uint32("date.low", ps, depth, &info->driver_date.low))
-		return False;
-	if (!prs_uint32("date.high", ps, depth, &info->driver_date.high))
-		return False;
-
-	if (!prs_uint32("padding", ps, depth, &info->padding))
-		return False;
-
-	if (!prs_uint32("driver_version_low", ps, depth, &info->driver_version_low))
-		return False;
-
-	if (!prs_uint32("driver_version_high", ps, depth, &info->driver_version_high))
-		return False;
-
-	if (!smb_io_relstr("mfgname", buffer, depth, &info->mfgname))
-		return False;
-	if (!smb_io_relstr("oem_url", buffer, depth, &info->oem_url))
-		return False;
-	if (!smb_io_relstr("hardware_id", buffer, depth, &info->hardware_id))
-		return False;
-	if (!smb_io_relstr("provider", buffer, depth, &info->provider))
-		return False;
-	
-	return True;
-}
-
-/*******************************************************************
- Parse a JOB_INFO_1 structure.
-********************************************************************/  
-
-BOOL smb_io_job_info_1(const char *desc, NEW_BUFFER *buffer, JOB_INFO_1 *info, int depth)
-{
-	prs_struct *ps=&buffer->prs;
-
-	prs_debug(ps, depth, desc, "smb_io_job_info_1");
-	depth++;	
-	
-	buffer->struct_start=prs_offset(ps);
-
-	if (!prs_uint32("jobid", ps, depth, &info->jobid))
-		return False;
-	if (!smb_io_relstr("printername", buffer, depth, &info->printername))
-		return False;
-	if (!smb_io_relstr("machinename", buffer, depth, &info->machinename))
-		return False;
-	if (!smb_io_relstr("username", buffer, depth, &info->username))
-		return False;
-	if (!smb_io_relstr("document", buffer, depth, &info->document))
-		return False;
-	if (!smb_io_relstr("datatype", buffer, depth, &info->datatype))
-		return False;
-	if (!smb_io_relstr("text_status", buffer, depth, &info->text_status))
-		return False;
-	if (!prs_uint32("status", ps, depth, &info->status))
-		return False;
-	if (!prs_uint32("priority", ps, depth, &info->priority))
-		return False;
-	if (!prs_uint32("position", ps, depth, &info->position))
-		return False;
-	if (!prs_uint32("totalpages", ps, depth, &info->totalpages))
-		return False;
-	if (!prs_uint32("pagesprinted", ps, depth, &info->pagesprinted))
-		return False;
-	if (!spoolss_io_system_time("submitted", ps, depth, &info->submitted))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
- Parse a JOB_INFO_2 structure.
-********************************************************************/  
-
-BOOL smb_io_job_info_2(const char *desc, NEW_BUFFER *buffer, JOB_INFO_2 *info, int depth)
-{	
-	uint32 pipo=0;
-	prs_struct *ps=&buffer->prs;
-	
-	prs_debug(ps, depth, desc, "smb_io_job_info_2");
-	depth++;	
-
-	buffer->struct_start=prs_offset(ps);
-	
-	if (!prs_uint32("jobid",ps, depth, &info->jobid))
-		return False;
-	if (!smb_io_relstr("printername", buffer, depth, &info->printername))
-		return False;
-	if (!smb_io_relstr("machinename", buffer, depth, &info->machinename))
-		return False;
-	if (!smb_io_relstr("username", buffer, depth, &info->username))
-		return False;
-	if (!smb_io_relstr("document", buffer, depth, &info->document))
-		return False;
-	if (!smb_io_relstr("notifyname", buffer, depth, &info->notifyname))
-		return False;
-	if (!smb_io_relstr("datatype", buffer, depth, &info->datatype))
-		return False;
-
-	if (!smb_io_relstr("printprocessor", buffer, depth, &info->printprocessor))
-		return False;
-	if (!smb_io_relstr("parameters", buffer, depth, &info->parameters))
-		return False;
-	if (!smb_io_relstr("drivername", buffer, depth, &info->drivername))
-		return False;
-	if (!smb_io_reldevmode("devmode", buffer, depth, &info->devmode))
-		return False;
-	if (!smb_io_relstr("text_status", buffer, depth, &info->text_status))
-		return False;
-
-/*	SEC_DESC sec_desc;*/
-	if (!prs_uint32("Hack! sec desc", ps, depth, &pipo))
-		return False;
-
-	if (!prs_uint32("status",ps, depth, &info->status))
-		return False;
-	if (!prs_uint32("priority",ps, depth, &info->priority))
-		return False;
-	if (!prs_uint32("position",ps, depth, &info->position))	
-		return False;
-	if (!prs_uint32("starttime",ps, depth, &info->starttime))
-		return False;
-	if (!prs_uint32("untiltime",ps, depth, &info->untiltime))	
-		return False;
-	if (!prs_uint32("totalpages",ps, depth, &info->totalpages))
-		return False;
-	if (!prs_uint32("size",ps, depth, &info->size))
-		return False;
-	if (!spoolss_io_system_time("submitted", ps, depth, &info->submitted) )
-		return False;
-	if (!prs_uint32("timeelapsed",ps, depth, &info->timeelapsed))
-		return False;
-	if (!prs_uint32("pagesprinted",ps, depth, &info->pagesprinted))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
-********************************************************************/  
-
-BOOL smb_io_form_1(const char *desc, NEW_BUFFER *buffer, FORM_1 *info, int depth)
-{
-	prs_struct *ps=&buffer->prs;
-	
-	prs_debug(ps, depth, desc, "smb_io_form_1");
-	depth++;
-		
-	buffer->struct_start=prs_offset(ps);
-	
-	if (!prs_uint32("flag", ps, depth, &info->flag))
-		return False;
-		
-	if (!smb_io_relstr("name", buffer, depth, &info->name))
-		return False;
-
-	if (!prs_uint32("width", ps, depth, &info->width))
-		return False;
-	if (!prs_uint32("length", ps, depth, &info->length))
-		return False;
-	if (!prs_uint32("left", ps, depth, &info->left))
-		return False;
-	if (!prs_uint32("top", ps, depth, &info->top))
-		return False;
-	if (!prs_uint32("right", ps, depth, &info->right))
-		return False;
-	if (!prs_uint32("bottom", ps, depth, &info->bottom))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
- Read/write a BUFFER struct.
-********************************************************************/  
-
-static BOOL spoolss_io_buffer(const char *desc, prs_struct *ps, int depth, NEW_BUFFER **pp_buffer)
-{
-	NEW_BUFFER *buffer = *pp_buffer;
-
-	prs_debug(ps, depth, desc, "spoolss_io_buffer");
-	depth++;
-	
-	if (UNMARSHALLING(ps))
-		buffer = *pp_buffer = (NEW_BUFFER *)prs_alloc_mem(ps, sizeof(NEW_BUFFER));
-
-	if (buffer == NULL)
-		return False;
-
-	if (!prs_uint32("ptr", ps, depth, &buffer->ptr))
-		return False;
-	
-	/* reading */
-	if (UNMARSHALLING(ps)) {
-		buffer->size=0;
-		buffer->string_at_end=0;
-		
-		if (buffer->ptr==0) {
-			/*
-			 * JRA. I'm not sure if the data in here is in big-endian format if
-			 * the client is big-endian. Leave as default (little endian) for now.
-			 */
-
-			if (!prs_init(&buffer->prs, 0, prs_get_mem_context(ps), UNMARSHALL))
-				return False;
-			return True;
-		}
-		
-		if (!prs_uint32("size", ps, depth, &buffer->size))
-			return False;
-					
-		/*
-		 * JRA. I'm not sure if the data in here is in big-endian format if
-		 * the client is big-endian. Leave as default (little endian) for now.
-		 */
-
-		if (!prs_init(&buffer->prs, buffer->size, prs_get_mem_context(ps), UNMARSHALL))
-			return False;
-
-		if (!prs_append_some_prs_data(&buffer->prs, ps, prs_offset(ps), buffer->size))
-			return False;
-
-		if (!prs_set_offset(&buffer->prs, 0))
-			return False;
-
-		if (!prs_set_offset(ps, buffer->size+prs_offset(ps)))
-			return False;
-
-		buffer->string_at_end=buffer->size;
-		
-		return True;
-	}
-	else {
-		BOOL ret = False;
-
-		/* writing */
-		if (buffer->ptr==0) {
-			/* We have finished with the data in buffer->prs - free it. */
-			prs_mem_free(&buffer->prs);
-			return True;
-		}
-	
-		if (!prs_uint32("size", ps, depth, &buffer->size))
-			goto out;
-
-		if (!prs_append_some_prs_data(ps, &buffer->prs, 0, buffer->size))
-			goto out;
-
-		ret = True;
-	out:
-
-		/* We have finished with the data in buffer->prs - free it. */
-		prs_mem_free(&buffer->prs);
-
-		return ret;
-	}
-}
-
-/*******************************************************************
- move a BUFFER from the query to the reply.
- As the data pointers in NEW_BUFFER are malloc'ed, not talloc'ed,
- this is ok. This is an OPTIMIZATION and is not strictly neccessary.
- Clears the memory to zero also.
-********************************************************************/  
-
-void spoolss_move_buffer(NEW_BUFFER *src, NEW_BUFFER **dest)
-{
-	prs_switch_type(&src->prs, MARSHALL);
-	if(!prs_set_offset(&src->prs, 0))
-		return;
-	prs_force_dynamic(&src->prs);
-	prs_mem_clear(&src->prs);
-	*dest=src;
-}
-
-/*******************************************************************
- Get the size of a BUFFER struct.
-********************************************************************/  
-
-uint32 new_get_buffer_size(NEW_BUFFER *buffer)
-{
-	return (buffer->size);
-}
-
-/*******************************************************************
- Parse a DRIVER_DIRECTORY_1 structure.
-********************************************************************/  
-
-BOOL smb_io_driverdir_1(const char *desc, NEW_BUFFER *buffer, DRIVER_DIRECTORY_1 *info, int depth)
-{
-	prs_struct *ps=&buffer->prs;
-
-	prs_debug(ps, depth, desc, "smb_io_driverdir_1");
-	depth++;
-
-	buffer->struct_start=prs_offset(ps);
-
-	if (!smb_io_unistr(desc, &info->name, ps, depth))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
- Parse a PORT_INFO_1 structure.
-********************************************************************/  
-
-BOOL smb_io_port_1(const char *desc, NEW_BUFFER *buffer, PORT_INFO_1 *info, int depth)
-{
-	prs_struct *ps=&buffer->prs;
-
-	prs_debug(ps, depth, desc, "smb_io_port_1");
-	depth++;
-
-	buffer->struct_start=prs_offset(ps);
-
-	if(!smb_io_relstr("port_name", buffer, depth, &info->port_name))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
- Parse a PORT_INFO_2 structure.
-********************************************************************/  
-
-BOOL smb_io_port_2(const char *desc, NEW_BUFFER *buffer, PORT_INFO_2 *info, int depth)
-{
-	prs_struct *ps=&buffer->prs;
-
-	prs_debug(ps, depth, desc, "smb_io_port_2");
-	depth++;
-
-	buffer->struct_start=prs_offset(ps);
-
-	if(!smb_io_relstr("port_name", buffer, depth, &info->port_name))
-		return False;
-	if(!smb_io_relstr("monitor_name", buffer, depth, &info->monitor_name))
-		return False;
-	if(!smb_io_relstr("description", buffer, depth, &info->description))
-		return False;
-	if(!prs_uint32("port_type", ps, depth, &info->port_type))
-		return False;
-	if(!prs_uint32("reserved", ps, depth, &info->reserved))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
-********************************************************************/  
-
-BOOL smb_io_printprocessor_info_1(const char *desc, NEW_BUFFER *buffer, PRINTPROCESSOR_1 *info, int depth)
-{
-	prs_struct *ps=&buffer->prs;
-
-	prs_debug(ps, depth, desc, "smb_io_printprocessor_info_1");
-	depth++;	
-
-	buffer->struct_start=prs_offset(ps);
-	
-	if (smb_io_relstr("name", buffer, depth, &info->name))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
-********************************************************************/  
-
-BOOL smb_io_printprocdatatype_info_1(const char *desc, NEW_BUFFER *buffer, PRINTPROCDATATYPE_1 *info, int depth)
-{
-	prs_struct *ps=&buffer->prs;
-
-	prs_debug(ps, depth, desc, "smb_io_printprocdatatype_info_1");
-	depth++;	
-
-	buffer->struct_start=prs_offset(ps);
-	
-	if (smb_io_relstr("name", buffer, depth, &info->name))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
-********************************************************************/  
-
-BOOL smb_io_printmonitor_info_1(const char *desc, NEW_BUFFER *buffer, PRINTMONITOR_1 *info, int depth)
-{
-	prs_struct *ps=&buffer->prs;
-
-	prs_debug(ps, depth, desc, "smb_io_printmonitor_info_1");
-	depth++;	
-
-	buffer->struct_start=prs_offset(ps);
-
-	if (!smb_io_relstr("name", buffer, depth, &info->name))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
-********************************************************************/  
-
-BOOL smb_io_printmonitor_info_2(const char *desc, NEW_BUFFER *buffer, PRINTMONITOR_2 *info, int depth)
-{
-	prs_struct *ps=&buffer->prs;
-
-	prs_debug(ps, depth, desc, "smb_io_printmonitor_info_2");
-	depth++;	
-
-	buffer->struct_start=prs_offset(ps);
-
-	if (!smb_io_relstr("name", buffer, depth, &info->name))
-		return False;
-	if (!smb_io_relstr("environment", buffer, depth, &info->environment))
-		return False;
-	if (!smb_io_relstr("dll_name", buffer, depth, &info->dll_name))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
-return the size required by a struct in the stream
-********************************************************************/  
-
-uint32 spoolss_size_printer_info_0(PRINTER_INFO_0 *info)
-{
-	int size=0;
-	
-	size+=size_of_relative_string( &info->printername );
-	size+=size_of_relative_string( &info->servername );
-
-	size+=size_of_uint32( &info->cjobs);
-	size+=size_of_uint32( &info->total_jobs);
-	size+=size_of_uint32( &info->total_bytes);
-
-	size+=size_of_uint16( &info->year);
-	size+=size_of_uint16( &info->month);
-	size+=size_of_uint16( &info->dayofweek);
-	size+=size_of_uint16( &info->day);
-	size+=size_of_uint16( &info->hour);
-	size+=size_of_uint16( &info->minute);
-	size+=size_of_uint16( &info->second);
-	size+=size_of_uint16( &info->milliseconds);
-
-	size+=size_of_uint32( &info->global_counter);
-	size+=size_of_uint32( &info->total_pages);
-
-	size+=size_of_uint16( &info->major_version);
-	size+=size_of_uint16( &info->build_version);
-
-	size+=size_of_uint32( &info->unknown7);
-	size+=size_of_uint32( &info->unknown8);
-	size+=size_of_uint32( &info->unknown9);
-	size+=size_of_uint32( &info->session_counter);
-	size+=size_of_uint32( &info->unknown11);
-	size+=size_of_uint32( &info->printer_errors);
-	size+=size_of_uint32( &info->unknown13);
-	size+=size_of_uint32( &info->unknown14);
-	size+=size_of_uint32( &info->unknown15);
-	size+=size_of_uint32( &info->unknown16);
-	size+=size_of_uint32( &info->change_id);
-	size+=size_of_uint32( &info->unknown18);
-	size+=size_of_uint32( &info->status);
-	size+=size_of_uint32( &info->unknown20);
-	size+=size_of_uint32( &info->c_setprinter);
-	
-	size+=size_of_uint16( &info->unknown22);
-	size+=size_of_uint16( &info->unknown23);
-	size+=size_of_uint16( &info->unknown24);
-	size+=size_of_uint16( &info->unknown25);
-	size+=size_of_uint16( &info->unknown26);
-	size+=size_of_uint16( &info->unknown27);
-	size+=size_of_uint16( &info->unknown28);
-	size+=size_of_uint16( &info->unknown29);
-	
-	return size;
-}
-
-/*******************************************************************
-return the size required by a struct in the stream
-********************************************************************/  
-
-uint32 spoolss_size_printer_info_1(PRINTER_INFO_1 *info)
-{
-	int size=0;
-		
-	size+=size_of_uint32( &info->flags );	
-	size+=size_of_relative_string( &info->description );
-	size+=size_of_relative_string( &info->name );
-	size+=size_of_relative_string( &info->comment );
-
-	return size;
-}
-
-/*******************************************************************
-return the size required by a struct in the stream
-********************************************************************/
-
-uint32 spoolss_size_printer_info_2(PRINTER_INFO_2 *info)
-{
-	uint32 size=0;	 
-		
-	size += 4;
-	
-	size += sec_desc_size( info->secdesc );
-
-	size+=size_of_device_mode( info->devmode );
-	
-	size+=size_of_relative_string( &info->servername );
-	size+=size_of_relative_string( &info->printername );
-	size+=size_of_relative_string( &info->sharename );
-	size+=size_of_relative_string( &info->portname );
-	size+=size_of_relative_string( &info->drivername );
-	size+=size_of_relative_string( &info->comment );
-	size+=size_of_relative_string( &info->location );
-	
-	size+=size_of_relative_string( &info->sepfile );
-	size+=size_of_relative_string( &info->printprocessor );
-	size+=size_of_relative_string( &info->datatype );
-	size+=size_of_relative_string( &info->parameters );
-
-	size+=size_of_uint32( &info->attributes );
-	size+=size_of_uint32( &info->priority );
-	size+=size_of_uint32( &info->defaultpriority );
-	size+=size_of_uint32( &info->starttime );
-	size+=size_of_uint32( &info->untiltime );
-	size+=size_of_uint32( &info->status );
-	size+=size_of_uint32( &info->cjobs );
-	size+=size_of_uint32( &info->averageppm );	
-		
-	/* 
-	 * add any adjustments for alignment.  This is
-	 * not optimal since we could be calling this
-	 * function from a loop (e.g. enumprinters), but 
-	 * it is easier to maintain the calculation here and
-	 * not place the burden on the caller to remember.   --jerry
-	 */
-	if ((size % 4) != 0) 
-		size += 4 - (size % 4);
-	
-	return size;
-}
-
-/*******************************************************************
-return the size required by a struct in the stream
-********************************************************************/
-
-uint32 spoolss_size_printer_info_4(PRINTER_INFO_4 *info)
-{
-	uint32 size=0;
-		
-	size+=size_of_relative_string( &info->printername );
-	size+=size_of_relative_string( &info->servername );
-
-	size+=size_of_uint32( &info->attributes );
-	return size;
-}
-
-/*******************************************************************
-return the size required by a struct in the stream
-********************************************************************/
-
-uint32 spoolss_size_printer_info_5(PRINTER_INFO_5 *info)
-{
-	uint32 size=0;
-		
-	size+=size_of_relative_string( &info->printername );
-	size+=size_of_relative_string( &info->portname );
-
-	size+=size_of_uint32( &info->attributes );
-	size+=size_of_uint32( &info->device_not_selected_timeout );
-	size+=size_of_uint32( &info->transmission_retry_timeout );
-	return size;
-}
-
-
-/*******************************************************************
-return the size required by a struct in the stream
-********************************************************************/
-
-uint32 spoolss_size_printer_info_3(PRINTER_INFO_3 *info)
-{
-	/* The 4 is for the self relative pointer.. */
-	/* JRA !!!! TESTME - WHAT ABOUT prs_align.... !!! */
-	return 4 + (uint32)sec_desc_size( info->secdesc );
-}
-
-/*******************************************************************
-return the size required by a struct in the stream
-********************************************************************/
-
-uint32 spoolss_size_printer_driver_info_1(DRIVER_INFO_1 *info)
-{
-	int size=0;
-	size+=size_of_relative_string( &info->name );
-
-	return size;
-}
-
-/*******************************************************************
-return the size required by a struct in the stream
-********************************************************************/
-
-uint32 spoolss_size_printer_driver_info_2(DRIVER_INFO_2 *info)
-{
-	int size=0;
-	size+=size_of_uint32( &info->version );	
-	size+=size_of_relative_string( &info->name );
-	size+=size_of_relative_string( &info->architecture );
-	size+=size_of_relative_string( &info->driverpath );
-	size+=size_of_relative_string( &info->datafile );
-	size+=size_of_relative_string( &info->configfile );
-
-	return size;
-}
-
-/*******************************************************************
-return the size required by a string array.
-********************************************************************/
-
-uint32 spoolss_size_string_array(uint16 *string)
-{
-	uint32 i = 0;
-
-	if (string) {
-		for (i=0; (string[i]!=0x0000) || (string[i+1]!=0x0000); i++);
-	}
-	i=i+2; /* to count all chars including the leading zero */
-	i=2*i; /* because we need the value in bytes */
-	i=i+4; /* the offset pointer size */
-
-	return i;
-}
-
-/*******************************************************************
-return the size required by a struct in the stream
-********************************************************************/
-
-uint32 spoolss_size_printer_driver_info_3(DRIVER_INFO_3 *info)
-{
-	int size=0;
-
-	size+=size_of_uint32( &info->version );	
-	size+=size_of_relative_string( &info->name );
-	size+=size_of_relative_string( &info->architecture );
-	size+=size_of_relative_string( &info->driverpath );
-	size+=size_of_relative_string( &info->datafile );
-	size+=size_of_relative_string( &info->configfile );
-	size+=size_of_relative_string( &info->helpfile );
-	size+=size_of_relative_string( &info->monitorname );
-	size+=size_of_relative_string( &info->defaultdatatype );
-	
-	size+=spoolss_size_string_array(info->dependentfiles);
-
-	return size;
-}
-
-/*******************************************************************
-return the size required by a struct in the stream
-********************************************************************/
-
-uint32 spoolss_size_printer_driver_info_6(DRIVER_INFO_6 *info)
-{
-	uint32 size=0;
-
-	size+=size_of_uint32( &info->version );	
-	size+=size_of_relative_string( &info->name );
-	size+=size_of_relative_string( &info->architecture );
-	size+=size_of_relative_string( &info->driverpath );
-	size+=size_of_relative_string( &info->datafile );
-	size+=size_of_relative_string( &info->configfile );
-	size+=size_of_relative_string( &info->helpfile );
-
-	size+=spoolss_size_string_array(info->dependentfiles);
-
-	size+=size_of_relative_string( &info->monitorname );
-	size+=size_of_relative_string( &info->defaultdatatype );
-	
-	size+=spoolss_size_string_array(info->previousdrivernames);
-
-	size+=size_of_nttime(&info->driver_date);
-	size+=size_of_uint32( &info->padding );	
-	size+=size_of_uint32( &info->driver_version_low );	
-	size+=size_of_uint32( &info->driver_version_high );	
-	size+=size_of_relative_string( &info->mfgname );
-	size+=size_of_relative_string( &info->oem_url );
-	size+=size_of_relative_string( &info->hardware_id );
-	size+=size_of_relative_string( &info->provider );
-
-	return size;
-}
-
-/*******************************************************************
-return the size required by a struct in the stream
-********************************************************************/  
-
-uint32 spoolss_size_job_info_1(JOB_INFO_1 *info)
-{
-	int size=0;
-	size+=size_of_uint32( &info->jobid );
-	size+=size_of_relative_string( &info->printername );
-	size+=size_of_relative_string( &info->machinename );
-	size+=size_of_relative_string( &info->username );
-	size+=size_of_relative_string( &info->document );
-	size+=size_of_relative_string( &info->datatype );
-	size+=size_of_relative_string( &info->text_status );
-	size+=size_of_uint32( &info->status );
-	size+=size_of_uint32( &info->priority );
-	size+=size_of_uint32( &info->position );
-	size+=size_of_uint32( &info->totalpages );
-	size+=size_of_uint32( &info->pagesprinted );
-	size+=size_of_systemtime( &info->submitted );
-
-	return size;
-}
-
-/*******************************************************************
-return the size required by a struct in the stream
-********************************************************************/  
-
-uint32 spoolss_size_job_info_2(JOB_INFO_2 *info)
-{
-	int size=0;
-
-	size+=4; /* size of sec desc ptr */
-
-	size+=size_of_uint32( &info->jobid );
-	size+=size_of_relative_string( &info->printername );
-	size+=size_of_relative_string( &info->machinename );
-	size+=size_of_relative_string( &info->username );
-	size+=size_of_relative_string( &info->document );
-	size+=size_of_relative_string( &info->notifyname );
-	size+=size_of_relative_string( &info->datatype );
-	size+=size_of_relative_string( &info->printprocessor );
-	size+=size_of_relative_string( &info->parameters );
-	size+=size_of_relative_string( &info->drivername );
-	size+=size_of_device_mode( info->devmode );
-	size+=size_of_relative_string( &info->text_status );
-/*	SEC_DESC sec_desc;*/
-	size+=size_of_uint32( &info->status );
-	size+=size_of_uint32( &info->priority );
-	size+=size_of_uint32( &info->position );
-	size+=size_of_uint32( &info->starttime );
-	size+=size_of_uint32( &info->untiltime );
-	size+=size_of_uint32( &info->totalpages );
-	size+=size_of_uint32( &info->size );
-	size+=size_of_systemtime( &info->submitted );
-	size+=size_of_uint32( &info->timeelapsed );
-	size+=size_of_uint32( &info->pagesprinted );
-
-	return size;
-}
-
-/*******************************************************************
-return the size required by a struct in the stream
-********************************************************************/
-
-uint32 spoolss_size_form_1(FORM_1 *info)
-{
-	int size=0;
-
-	size+=size_of_uint32( &info->flag );
-	size+=size_of_relative_string( &info->name );
-	size+=size_of_uint32( &info->width );
-	size+=size_of_uint32( &info->length );
-	size+=size_of_uint32( &info->left );
-	size+=size_of_uint32( &info->top );
-	size+=size_of_uint32( &info->right );
-	size+=size_of_uint32( &info->bottom );
-
-	return size;
-}
-
-/*******************************************************************
-return the size required by a struct in the stream
-********************************************************************/  
-
-uint32 spoolss_size_port_info_1(PORT_INFO_1 *info)
-{
-	int size=0;
-
-	size+=size_of_relative_string( &info->port_name );
-
-	return size;
-}
-
-/*******************************************************************
-return the size required by a struct in the stream
-********************************************************************/  
-
-uint32 spoolss_size_driverdir_info_1(DRIVER_DIRECTORY_1 *info)
-{
-	int size=0;
-
-	size=str_len_uni(&info->name);	/* the string length       */
-	size=size+1;			/* add the leading zero    */
-	size=size*2;			/* convert in char         */
-
-	return size;
-}
-
-/*******************************************************************
-return the size required by a struct in the stream
-********************************************************************/  
-
-uint32 spoolss_size_printprocessordirectory_info_1(PRINTPROCESSOR_DIRECTORY_1 *info)
-{
-	int size=0;
-
-	size=str_len_uni(&info->name);	/* the string length       */
-	size=size+1;			/* add the leading zero    */
-	size=size*2;			/* convert in char         */
-
-	return size;
-}
-
-/*******************************************************************
-return the size required by a struct in the stream
-********************************************************************/  
-
-uint32 spoolss_size_port_info_2(PORT_INFO_2 *info)
-{
-	int size=0;
-
-	size+=size_of_relative_string( &info->port_name );
-	size+=size_of_relative_string( &info->monitor_name );
-	size+=size_of_relative_string( &info->description );
-
-	size+=size_of_uint32( &info->port_type );
-	size+=size_of_uint32( &info->reserved );
-
-	return size;
-}
-
-/*******************************************************************
-return the size required by a struct in the stream
-********************************************************************/  
-
-uint32 spoolss_size_printprocessor_info_1(PRINTPROCESSOR_1 *info)
-{
-	int size=0;
-	size+=size_of_relative_string( &info->name );
-
-	return size;
-}
-
-/*******************************************************************
-return the size required by a struct in the stream
-********************************************************************/  
-
-uint32 spoolss_size_printprocdatatype_info_1(PRINTPROCDATATYPE_1 *info)
-{
-	int size=0;
-	size+=size_of_relative_string( &info->name );
-
-	return size;
-}
-
-/*******************************************************************
-return the size required by a struct in the stream
-********************************************************************/  
-uint32 spoolss_size_printer_enum_values(PRINTER_ENUM_VALUES *p)
-{
-	uint32 	size = 0; 
-	
-	if (!p)
-		return 0;
-	
-	/* uint32(offset) + uint32(length) + length) */
-	size += (size_of_uint32(&p->value_len)*2) + p->value_len;
-	size += (size_of_uint32(&p->data_len)*2) + p->data_len + (p->data_len%2) ;
-	
-	size += size_of_uint32(&p->type);
-		       
-	return size;
-}
-
-/*******************************************************************
-return the size required by a struct in the stream
-********************************************************************/  
-
-uint32 spoolss_size_printmonitor_info_1(PRINTMONITOR_1 *info)
-{
-	int size=0;
-	size+=size_of_relative_string( &info->name );
-
-	return size;
-}
-
-/*******************************************************************
-return the size required by a struct in the stream
-********************************************************************/  
-
-uint32 spoolss_size_printmonitor_info_2(PRINTMONITOR_2 *info)
-{
-	int size=0;
-	size+=size_of_relative_string( &info->name);
-	size+=size_of_relative_string( &info->environment);
-	size+=size_of_relative_string( &info->dll_name);
-
-	return size;
-}
-
-/*******************************************************************
- * init a structure.
- ********************************************************************/
-
-BOOL make_spoolss_q_getprinterdriver2(SPOOL_Q_GETPRINTERDRIVER2 *q_u, 
-			       const POLICY_HND *hnd,
-			       const fstring architecture,
-			       uint32 level, uint32 clientmajor, uint32 clientminor,
-			       NEW_BUFFER *buffer, uint32 offered)
-{      
-	if (q_u == NULL)
-		return False;
-
-	memcpy(&q_u->handle, hnd, sizeof(q_u->handle));
-
-	init_buf_unistr2(&q_u->architecture, &q_u->architecture_ptr, architecture);
-
-	q_u->level=level;
-	q_u->clientmajorversion=clientmajor;
-	q_u->clientminorversion=clientminor;
-
-	q_u->buffer=buffer;
-	q_u->offered=offered;
-
-	return True;
-}
-
-/*******************************************************************
- * read a structure.
- * called from spoolss_getprinterdriver2 (srv_spoolss.c)
- ********************************************************************/
-
-BOOL spoolss_io_q_getprinterdriver2(const char *desc, SPOOL_Q_GETPRINTERDRIVER2 *q_u, prs_struct *ps, int depth)
-{
-	prs_debug(ps, depth, desc, "spoolss_io_q_getprinterdriver2");
-	depth++;
-
-	if(!prs_align(ps))
-		return False;
-	
-	if(!smb_io_pol_hnd("printer handle", &q_u->handle, ps, depth))
-		return False;
-	if(!prs_uint32("architecture_ptr", ps, depth, &q_u->architecture_ptr))
-		return False;
-	if(!smb_io_unistr2("architecture", &q_u->architecture, q_u->architecture_ptr, ps, depth))
-		return False;
-	
-	if(!prs_align(ps))
-		return False;
-	if(!prs_uint32("level", ps, depth, &q_u->level))
-		return False;
-		
-	if(!spoolss_io_buffer("", ps, depth, &q_u->buffer))
-		return False;
-
-	if(!prs_align(ps))
-		return False;
-
-	if(!prs_uint32("offered", ps, depth, &q_u->offered))
-		return False;
-		
-	if(!prs_uint32("clientmajorversion", ps, depth, &q_u->clientmajorversion))
-		return False;
-	if(!prs_uint32("clientminorversion", ps, depth, &q_u->clientminorversion))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
- * read a structure.
- * called from spoolss_getprinterdriver2 (srv_spoolss.c)
- ********************************************************************/
-
-BOOL spoolss_io_r_getprinterdriver2(const char *desc, SPOOL_R_GETPRINTERDRIVER2 *r_u, prs_struct *ps, int depth)
-{
-	prs_debug(ps, depth, desc, "spoolss_io_r_getprinterdriver2");
-	depth++;
-
-	if (!prs_align(ps))
-		return False;
-		
-	if (!spoolss_io_buffer("", ps, depth, &r_u->buffer))
-		return False;
-
-	if (!prs_align(ps))
-		return False;
-	if (!prs_uint32("needed", ps, depth, &r_u->needed))
-		return False;
-	if (!prs_uint32("servermajorversion", ps, depth, &r_u->servermajorversion))
-		return False;
-	if (!prs_uint32("serverminorversion", ps, depth, &r_u->serverminorversion))
-		return False;		
-	if (!prs_werror("status", ps, depth, &r_u->status))
-		return False;
-
-	return True;		
-}
-
-/*******************************************************************
- * init a structure.
- ********************************************************************/
-
-BOOL make_spoolss_q_enumprinters(
-	SPOOL_Q_ENUMPRINTERS *q_u, 
-	uint32 flags, 
-	fstring servername, 
-	uint32 level, 
-	NEW_BUFFER *buffer, 
-	uint32 offered
-)
-{
-	q_u->flags=flags;
-	
-	q_u->servername_ptr = (servername != NULL) ? 1 : 0;
-	init_buf_unistr2(&q_u->servername, &q_u->servername_ptr, servername);
-
-	q_u->level=level;
-	q_u->buffer=buffer;
-	q_u->offered=offered;
-
-	return True;
-}
-
-/*******************************************************************
- * init a structure.
- ********************************************************************/
-
-BOOL make_spoolss_q_enumports(SPOOL_Q_ENUMPORTS *q_u, 
-				fstring servername, uint32 level, 
-				NEW_BUFFER *buffer, uint32 offered)
-{
-	q_u->name_ptr = (servername != NULL) ? 1 : 0;
-	init_buf_unistr2(&q_u->name, &q_u->name_ptr, servername);
-
-	q_u->level=level;
-	q_u->buffer=buffer;
-	q_u->offered=offered;
-
-	return True;
-}
-
-/*******************************************************************
- * read a structure.
- * called from spoolss_enumprinters (srv_spoolss.c)
- ********************************************************************/
-
-BOOL spoolss_io_q_enumprinters(const char *desc, SPOOL_Q_ENUMPRINTERS *q_u, prs_struct *ps, int depth)
-{
-	prs_debug(ps, depth, desc, "spoolss_io_q_enumprinters");
-	depth++;
-
-	if (!prs_align(ps))
-		return False;
-
-	if (!prs_uint32("flags", ps, depth, &q_u->flags))
-		return False;
-	if (!prs_uint32("servername_ptr", ps, depth, &q_u->servername_ptr))
-		return False;
-
-	if (!smb_io_unistr2("", &q_u->servername, q_u->servername_ptr, ps, depth))
-		return False;
-		
-	if (!prs_align(ps))
-		return False;
-	if (!prs_uint32("level", ps, depth, &q_u->level))
-		return False;
-
-	if (!spoolss_io_buffer("", ps, depth, &q_u->buffer))
-		return False;
-
-	if (!prs_align(ps))
-		return False;
-	if (!prs_uint32("offered", ps, depth, &q_u->offered))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
- Parse a SPOOL_R_ENUMPRINTERS structure.
- ********************************************************************/
-
-BOOL spoolss_io_r_enumprinters(const char *desc, SPOOL_R_ENUMPRINTERS *r_u, prs_struct *ps, int depth)
-{
-	prs_debug(ps, depth, desc, "spoolss_io_r_enumprinters");
-	depth++;
-
-	if (!prs_align(ps))
-		return False;
-		
-	if (!spoolss_io_buffer("", ps, depth, &r_u->buffer))
-		return False;
-
-	if (!prs_align(ps))
-		return False;
-		
-	if (!prs_uint32("needed", ps, depth, &r_u->needed))
-		return False;
-		
-	if (!prs_uint32("returned", ps, depth, &r_u->returned))
-		return False;
-		
-	if (!prs_werror("status", ps, depth, &r_u->status))
-		return False;
-
-	return True;		
-}
-
-/*******************************************************************
- * write a structure.
- * called from spoolss_r_enum_printers (srv_spoolss.c)
- *
- ********************************************************************/
-
-BOOL spoolss_io_r_getprinter(const char *desc, SPOOL_R_GETPRINTER *r_u, prs_struct *ps, int depth)
-{	
-	prs_debug(ps, depth, desc, "spoolss_io_r_getprinter");
-	depth++;
-
-	if (!prs_align(ps))
-		return False;
-		
-	if (!spoolss_io_buffer("", ps, depth, &r_u->buffer))
-		return False;
-
-	if (!prs_align(ps))
-		return False;
-
-	if (!prs_uint32("needed", ps, depth, &r_u->needed))
-		return False;
-		
-	if (!prs_werror("status", ps, depth, &r_u->status))
-		return False;
-
-	return True;		
-}
-
-/*******************************************************************
- * read a structure.
- * called from spoolss_getprinter (srv_spoolss.c)
- ********************************************************************/
-
-BOOL spoolss_io_q_getprinter(const char *desc, SPOOL_Q_GETPRINTER *q_u, prs_struct *ps, int depth)
-{
-	prs_debug(ps, depth, desc, "spoolss_io_q_getprinter");
-	depth++;
-
-	if (!prs_align(ps))
-		return False;
-
-	if(!smb_io_pol_hnd("printer handle", &q_u->handle, ps, depth))
-		return False;
-	if (!prs_uint32("level", ps, depth, &q_u->level))
-		return False;
-
-	if (!spoolss_io_buffer("", ps, depth, &q_u->buffer))
-		return False;
-
-	if (!prs_align(ps))
-		return False;
-	if (!prs_uint32("offered", ps, depth, &q_u->offered))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
- * init a structure.
- ********************************************************************/
-
-BOOL make_spoolss_q_getprinter(
-	TALLOC_CTX *mem_ctx,
-	SPOOL_Q_GETPRINTER *q_u, 
-	const POLICY_HND *hnd, 
-	uint32 level, 
-	NEW_BUFFER *buffer, 
-	uint32 offered
-)
-{
-	if (q_u == NULL)
-	{
-		return False;
-	}
-	memcpy(&q_u->handle, hnd, sizeof(q_u->handle));
-
-	q_u->level=level;
-	q_u->buffer=buffer;
-	q_u->offered=offered;
-
-	return True;
-}
-
-/*******************************************************************
- * init a structure.
- ********************************************************************/
-BOOL make_spoolss_q_setprinter(TALLOC_CTX *mem_ctx, SPOOL_Q_SETPRINTER *q_u, 
-				const POLICY_HND *hnd, uint32 level, PRINTER_INFO_CTR *info, 
-				uint32 command)
-{
-	SEC_DESC *secdesc;
-	DEVICEMODE *devmode;
-
-	if (q_u == NULL)
-		return False;
-	
-	memcpy(&q_u->handle, hnd, sizeof(q_u->handle));
-
-	q_u->level = level;
-	q_u->info.level = level;
-	q_u->info.info_ptr = (info != NULL) ? 1 : 0;
-	switch (level) {
-
-	  /* There's no such thing as a setprinter level 1 */
-
-	case 2:
-		secdesc = info->printers_2->secdesc;
-		devmode = info->printers_2->devmode;
-		
-		make_spoolss_printer_info_2 (mem_ctx, &q_u->info.info_2, info->printers_2);
-#if 1	/* JERRY TEST */
-		q_u->secdesc_ctr = (SEC_DESC_BUF*)malloc(sizeof(SEC_DESC_BUF));
-		if (!q_u->secdesc_ctr)
-			return False;
-		q_u->secdesc_ctr->ptr = (secdesc != NULL) ? 1: 0;
-		q_u->secdesc_ctr->max_len = (secdesc) ? sizeof(SEC_DESC) + (2*sizeof(uint32)) : 0;
-		q_u->secdesc_ctr->len = (secdesc) ? sizeof(SEC_DESC) + (2*sizeof(uint32)) : 0;
-		q_u->secdesc_ctr->sec = secdesc;
-
-		q_u->devmode_ctr.devmode_ptr = (devmode != NULL) ? 1 : 0;
-		q_u->devmode_ctr.size = (devmode != NULL) ? sizeof(DEVICEMODE) + (3*sizeof(uint32)) : 0;
-		q_u->devmode_ctr.devmode = devmode;
-#else
-		q_u->secdesc_ctr = NULL;
-	
-		q_u->devmode_ctr.devmode_ptr = 0;
-		q_u->devmode_ctr.size = 0;
-		q_u->devmode_ctr.devmode = NULL;
-#endif
-		break;
-	default: 
-		ZERODEBUG(0,("make_spoolss_q_setprinter: Unknown info level [%d]\n", level));
-			break;
-	}
-
-	
-	q_u->command = command;
-
-	return True;
-}
-
-
-/*******************************************************************
-********************************************************************/  
-
-BOOL spoolss_io_r_setprinter(const char *desc, SPOOL_R_SETPRINTER *r_u, prs_struct *ps, int depth)
-{		
-	prs_debug(ps, depth, desc, "spoolss_io_r_setprinter");
-	depth++;
-
-	if(!prs_align(ps))
-		return False;
-	
-	if(!prs_werror("status", ps, depth, &r_u->status))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
- Marshall/unmarshall a SPOOL_Q_SETPRINTER struct.
-********************************************************************/  
-
-BOOL spoolss_io_q_setprinter(const char *desc, SPOOL_Q_SETPRINTER *q_u, prs_struct *ps, int depth)
-{
-	uint32 ptr_sec_desc = 0;
-
-	prs_debug(ps, depth, desc, "spoolss_io_q_setprinter");
-	depth++;
-
-	if(!prs_align(ps))
-		return False;
-
-	if(!smb_io_pol_hnd("printer handle", &q_u->handle ,ps, depth))
-		return False;
-	if(!prs_uint32("level", ps, depth, &q_u->level))
-		return False;
-
-	if(!spool_io_printer_info_level("", &q_u->info, ps, depth))
-		return False;
-
-	if (!spoolss_io_devmode_cont(desc, &q_u->devmode_ctr, ps, depth))
-		return False;
-	
-	if(!prs_align(ps))
-		return False;
-
-	switch (q_u->level)
-	{
-		case 2:
-		{
-			ptr_sec_desc = q_u->info.info_2->secdesc_ptr;
-			break;
-		}
-		case 3:
-		{
-			ptr_sec_desc = q_u->info.info_3->secdesc_ptr;
-			break;
-		}
-	}
-	if (ptr_sec_desc)
-	{
-		if (!sec_io_desc_buf(desc, &q_u->secdesc_ctr, ps, depth))
-			return False;
-	} else {
-		uint32 dummy = 0;
-
-		/* Parse a NULL security descriptor.  This should really
-		   happen inside the sec_io_desc_buf() function. */
-
-		prs_debug(ps, depth, "", "sec_io_desc_buf");
-		if (!prs_uint32("size", ps, depth + 1, &dummy))
-			return False;
-		if (!prs_uint32("ptr", ps, depth + 1, &dummy)) return
-			False;
-	}
-	
-	if(!prs_uint32("command", ps, depth, &q_u->command))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
-********************************************************************/  
-
-BOOL spoolss_io_r_fcpn(const char *desc, SPOOL_R_FCPN *r_u, prs_struct *ps, int depth)
-{		
-	prs_debug(ps, depth, desc, "spoolss_io_r_fcpn");
-	depth++;
-
-	if(!prs_align(ps))
-		return False;
-	
-	if(!prs_werror("status", ps, depth, &r_u->status))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
-********************************************************************/  
-
-BOOL spoolss_io_q_fcpn(const char *desc, SPOOL_Q_FCPN *q_u, prs_struct *ps, int depth)
-{
-
-	prs_debug(ps, depth, desc, "spoolss_io_q_fcpn");
-	depth++;
-
-	if(!prs_align(ps))
-		return False;
-
-	if(!smb_io_pol_hnd("printer handle",&q_u->handle,ps,depth))
-		return False;
-
-	return True;
-}
-
-
-/*******************************************************************
-********************************************************************/  
-
-BOOL spoolss_io_r_addjob(const char *desc, SPOOL_R_ADDJOB *r_u, prs_struct *ps, int depth)
-{		
-	prs_debug(ps, depth, desc, "");
-	depth++;
-
-	if(!prs_align(ps))
-		return False;
-	
-	if(!spoolss_io_buffer("", ps, depth, &r_u->buffer))
-		return False;
-
-	if(!prs_align(ps))
-		return False;
-	
-	if(!prs_uint32("needed", ps, depth, &r_u->needed))
-		return False;
-
-	if(!prs_werror("status", ps, depth, &r_u->status))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
-********************************************************************/  
-
-BOOL spoolss_io_q_addjob(const char *desc, SPOOL_Q_ADDJOB *q_u, prs_struct *ps, int depth)
-{
-	prs_debug(ps, depth, desc, "");
-	depth++;
-
-	if(!prs_align(ps))
-		return False;
-
-	if(!smb_io_pol_hnd("printer handle", &q_u->handle, ps, depth))
-		return False;
-	if(!prs_uint32("level", ps, depth, &q_u->level))
-		return False;
-	
-	if(!spoolss_io_buffer("", ps, depth, &q_u->buffer))
-		return False;
-
-	if(!prs_align(ps))
-		return False;
-	
-	if(!prs_uint32("offered", ps, depth, &q_u->offered))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
-********************************************************************/  
-
-BOOL spoolss_io_r_enumjobs(const char *desc, SPOOL_R_ENUMJOBS *r_u, prs_struct *ps, int depth)
-{		
-	prs_debug(ps, depth, desc, "spoolss_io_r_enumjobs");
-	depth++;
-
-	if (!prs_align(ps))
-		return False;
-		
-	if (!spoolss_io_buffer("", ps, depth, &r_u->buffer))
-		return False;
-
-	if (!prs_align(ps))
-		return False;
-		
-	if (!prs_uint32("needed", ps, depth, &r_u->needed))
-		return False;
-		
-	if (!prs_uint32("returned", ps, depth, &r_u->returned))
-		return False;
-		
-	if (!prs_werror("status", ps, depth, &r_u->status))
-		return False;
-
-	return True;		
-}
-
-/*******************************************************************
-********************************************************************/  
-
-BOOL make_spoolss_q_enumjobs(SPOOL_Q_ENUMJOBS *q_u, const POLICY_HND *hnd,
-				uint32 firstjob,
-				uint32 numofjobs,
-				uint32 level,
-				NEW_BUFFER *buffer,
-				uint32 offered)
-{
-	if (q_u == NULL)
-	{
-		return False;
-	}
-	memcpy(&q_u->handle, hnd, sizeof(q_u->handle));
-	q_u->firstjob = firstjob;
-	q_u->numofjobs = numofjobs;
-	q_u->level = level;
-	q_u->buffer= buffer;
-	q_u->offered = offered;
-	return True;
-}
-
-/*******************************************************************
-********************************************************************/  
-
-BOOL spoolss_io_q_enumjobs(const char *desc, SPOOL_Q_ENUMJOBS *q_u, prs_struct *ps, int depth)
-{
-	prs_debug(ps, depth, desc, "spoolss_io_q_enumjobs");
-	depth++;
-
-	if (!prs_align(ps))
-		return False;
-
-	if (!smb_io_pol_hnd("printer handle",&q_u->handle, ps, depth))
-		return False;
-		
-	if (!prs_uint32("firstjob", ps, depth, &q_u->firstjob))
-		return False;
-	if (!prs_uint32("numofjobs", ps, depth, &q_u->numofjobs))
-		return False;
-	if (!prs_uint32("level", ps, depth, &q_u->level))
-		return False;
-
-	if (!spoolss_io_buffer("", ps, depth, &q_u->buffer))
-		return False;	
-
-	if(!prs_align(ps))
-		return False;
-
-	if (!prs_uint32("offered", ps, depth, &q_u->offered))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
-********************************************************************/  
-
-BOOL spoolss_io_r_schedulejob(const char *desc, SPOOL_R_SCHEDULEJOB *r_u, prs_struct *ps, int depth)
-{		
-	prs_debug(ps, depth, desc, "spoolss_io_r_schedulejob");
-	depth++;
-
-	if(!prs_align(ps))
-		return False;
-	
-	if(!prs_werror("status", ps, depth, &r_u->status))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
-********************************************************************/  
-
-BOOL spoolss_io_q_schedulejob(const char *desc, SPOOL_Q_SCHEDULEJOB *q_u, prs_struct *ps, int depth)
-{
-	prs_debug(ps, depth, desc, "spoolss_io_q_schedulejob");
-	depth++;
-
-	if(!prs_align(ps))
-		return False;
-
-	if(!smb_io_pol_hnd("printer handle",&q_u->handle,ps,depth))
-		return False;
-	if(!prs_uint32("jobid", ps, depth, &q_u->jobid))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
-********************************************************************/  
-
-BOOL spoolss_io_r_setjob(const char *desc, SPOOL_R_SETJOB *r_u, prs_struct *ps, int depth)
-{		
-	prs_debug(ps, depth, desc, "spoolss_io_r_setjob");
-	depth++;
-
-	if(!prs_align(ps))
-		return False;
-	
-	if(!prs_werror("status", ps, depth, &r_u->status))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
-********************************************************************/  
-
-BOOL spoolss_io_q_setjob(const char *desc, SPOOL_Q_SETJOB *q_u, prs_struct *ps, int depth)
-{
-	prs_debug(ps, depth, desc, "spoolss_io_q_setjob");
-	depth++;
-
-	if(!prs_align(ps))
-		return False;
-
-	if(!smb_io_pol_hnd("printer handle",&q_u->handle,ps,depth))
-		return False;
-	if(!prs_uint32("jobid", ps, depth, &q_u->jobid))
-		return False;
-	/* 
-	 * level is usually 0. If (level!=0) then I'm in trouble !
-	 * I will try to generate setjob command with level!=0, one day.
-	 */
-	if(!prs_uint32("level", ps, depth, &q_u->level))
-		return False;
-	if(!prs_uint32("command", ps, depth, &q_u->command))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
- Parse a SPOOL_R_ENUMPRINTERDRIVERS structure.
-********************************************************************/  
-
-BOOL spoolss_io_r_enumprinterdrivers(const char *desc, SPOOL_R_ENUMPRINTERDRIVERS *r_u, prs_struct *ps, int depth)
-{
-	prs_debug(ps, depth, desc, "spoolss_io_r_enumprinterdrivers");
-	depth++;
-
-	if (!prs_align(ps))
-		return False;
-		
-	if (!spoolss_io_buffer("", ps, depth, &r_u->buffer))
-		return False;
-
-	if (!prs_align(ps))
-		return False;
-		
-	if (!prs_uint32("needed", ps, depth, &r_u->needed))
-		return False;
-		
-	if (!prs_uint32("returned", ps, depth, &r_u->returned))
-		return False;
-		
-	if (!prs_werror("status", ps, depth, &r_u->status))
-		return False;
-
-	return True;		
-}
-
-/*******************************************************************
- * init a structure.
- ********************************************************************/
-
-BOOL make_spoolss_q_enumprinterdrivers(SPOOL_Q_ENUMPRINTERDRIVERS *q_u,
-                                const char *name,
-                                const char *environment,
-                                uint32 level,
-                                NEW_BUFFER *buffer, uint32 offered)
-{
-        init_buf_unistr2(&q_u->name, &q_u->name_ptr, name);
-        init_buf_unistr2(&q_u->environment, &q_u->environment_ptr, environment);
-
-        q_u->level=level;
-        q_u->buffer=buffer;
-        q_u->offered=offered;
-
-        return True;
-}
-
-/*******************************************************************
- Parse a SPOOL_Q_ENUMPRINTERDRIVERS structure.
-********************************************************************/  
-
-BOOL spoolss_io_q_enumprinterdrivers(const char *desc, SPOOL_Q_ENUMPRINTERDRIVERS *q_u, prs_struct *ps, int depth)
-{
-
-	prs_debug(ps, depth, desc, "spoolss_io_q_enumprinterdrivers");
-	depth++;
-
-	if (!prs_align(ps))
-		return False;
-		
-	if (!prs_uint32("name_ptr", ps, depth, &q_u->name_ptr))
-		return False;
-	if (!smb_io_unistr2("", &q_u->name, q_u->name_ptr,ps, depth))
-		return False;
-		
-	if (!prs_align(ps))
-		return False;
-	if (!prs_uint32("environment_ptr", ps, depth, &q_u->environment_ptr))
-		return False;
-	if (!smb_io_unistr2("", &q_u->environment, q_u->environment_ptr, ps, depth))
-		return False;
-		
-	if (!prs_align(ps))
-		return False;
-	if (!prs_uint32("level", ps, depth, &q_u->level))
-		return False;
-		
-	if (!spoolss_io_buffer("", ps, depth, &q_u->buffer))
-		return False;
-
-	if (!prs_align(ps))
-		return False;
-		
-	if (!prs_uint32("offered", ps, depth, &q_u->offered))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
-********************************************************************/  
-
-BOOL spoolss_io_q_enumforms(const char *desc, SPOOL_Q_ENUMFORMS *q_u, prs_struct *ps, int depth)
-{
-
-	prs_debug(ps, depth, desc, "spoolss_io_q_enumforms");
-	depth++;
-
-	if (!prs_align(ps))
-		return False;			
-	if (!smb_io_pol_hnd("printer handle",&q_u->handle,ps,depth))
-		return False;		
-	if (!prs_uint32("level", ps, depth, &q_u->level))
-		return False;	
-	
-	if (!spoolss_io_buffer("", ps, depth, &q_u->buffer))
-		return False;
-
-	if (!prs_align(ps))
-		return False;
-	if (!prs_uint32("offered", ps, depth, &q_u->offered))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
-********************************************************************/  
-
-BOOL spoolss_io_r_enumforms(const char *desc, SPOOL_R_ENUMFORMS *r_u, prs_struct *ps, int depth)
-{
-	prs_debug(ps, depth, desc, "spoolss_io_r_enumforms");
-	depth++;
-
-	if (!prs_align(ps))
-		return False;
-		
-	if (!spoolss_io_buffer("", ps, depth, &r_u->buffer))
-		return False;
-
-	if (!prs_align(ps))
-		return False;
-		
-	if (!prs_uint32("size of buffer needed", ps, depth, &r_u->needed))
-		return False;
-		
-	if (!prs_uint32("numofforms", ps, depth, &r_u->numofforms))
-		return False;
-		
-	if (!prs_werror("status", ps, depth, &r_u->status))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
-********************************************************************/  
-
-BOOL spoolss_io_q_getform(const char *desc, SPOOL_Q_GETFORM *q_u, prs_struct *ps, int depth)
-{
-
-	prs_debug(ps, depth, desc, "spoolss_io_q_getform");
-	depth++;
-
-	if (!prs_align(ps))
-		return False;			
-	if (!smb_io_pol_hnd("printer handle",&q_u->handle,ps,depth))
-		return False;		
-	if (!smb_io_unistr2("", &q_u->formname,True,ps,depth))
-		return False;
-
-	if (!prs_align(ps))
-		return False;
-
-	if (!prs_uint32("level", ps, depth, &q_u->level))
-		return False;	
-	
-	if (!spoolss_io_buffer("", ps, depth, &q_u->buffer))
-		return False;
-
-	if (!prs_align(ps))
-		return False;
-	if (!prs_uint32("offered", ps, depth, &q_u->offered))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
-********************************************************************/  
-
-BOOL spoolss_io_r_getform(const char *desc, SPOOL_R_GETFORM *r_u, prs_struct *ps, int depth)
-{
-	prs_debug(ps, depth, desc, "spoolss_io_r_getform");
-	depth++;
-
-	if (!prs_align(ps))
-		return False;
-		
-	if (!spoolss_io_buffer("", ps, depth, &r_u->buffer))
-		return False;
-
-	if (!prs_align(ps))
-		return False;
-		
-	if (!prs_uint32("size of buffer needed", ps, depth, &r_u->needed))
-		return False;
-		
-	if (!prs_werror("status", ps, depth, &r_u->status))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
- Parse a SPOOL_R_ENUMPORTS structure.
-********************************************************************/  
-
-BOOL spoolss_io_r_enumports(const char *desc, SPOOL_R_ENUMPORTS *r_u, prs_struct *ps, int depth)
-{
-	prs_debug(ps, depth, desc, "spoolss_io_r_enumports");
-	depth++;
-
-	if (!prs_align(ps))
-		return False;
-		
-	if (!spoolss_io_buffer("", ps, depth, &r_u->buffer))
-		return False;
-
-	if (!prs_align(ps))
-		return False;
-		
-	if (!prs_uint32("needed", ps, depth, &r_u->needed))
-		return False;
-		
-	if (!prs_uint32("returned", ps, depth, &r_u->returned))
-		return False;
-		
-	if (!prs_werror("status", ps, depth, &r_u->status))
-		return False;
-
-	return True;		
-}
-
-/*******************************************************************
-********************************************************************/  
-
-BOOL spoolss_io_q_enumports(const char *desc, SPOOL_Q_ENUMPORTS *q_u, prs_struct *ps, int depth)
-{
-	prs_debug(ps, depth, desc, "");
-	depth++;
-
-	if (!prs_align(ps))
-		return False;
-
-	if (!prs_uint32("", ps, depth, &q_u->name_ptr))
-		return False;
-	if (!smb_io_unistr2("", &q_u->name,True,ps,depth))
-		return False;
-
-	if (!prs_align(ps))
-		return False;
-	if (!prs_uint32("level", ps, depth, &q_u->level))
-		return False;
-		
-	if (!spoolss_io_buffer("", ps, depth, &q_u->buffer))
-		return False;
-
-	if (!prs_align(ps))
-		return False;
-	if (!prs_uint32("offered", ps, depth, &q_u->offered))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
- Parse a SPOOL_PRINTER_INFO_LEVEL_1 structure.
-********************************************************************/  
-
-BOOL spool_io_printer_info_level_1(const char *desc, SPOOL_PRINTER_INFO_LEVEL_1 *il, prs_struct *ps, int depth)
-{	
-	prs_debug(ps, depth, desc, "spool_io_printer_info_level_1");
-	depth++;
-		
-	if(!prs_align(ps))
-		return False;
-
-	if(!prs_uint32("flags", ps, depth, &il->flags))
-		return False;
-	if(!prs_uint32("description_ptr", ps, depth, &il->description_ptr))
-		return False;
-	if(!prs_uint32("name_ptr", ps, depth, &il->name_ptr))
-		return False;
-	if(!prs_uint32("comment_ptr", ps, depth, &il->comment_ptr))
-		return False;
-		
-	if(!smb_io_unistr2("description", &il->description, il->description_ptr, ps, depth))
-		return False;
-	if(!smb_io_unistr2("name", &il->name, il->name_ptr, ps, depth))
-		return False;
-	if(!smb_io_unistr2("comment", &il->comment, il->comment_ptr, ps, depth))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
- Parse a SPOOL_PRINTER_INFO_LEVEL_3 structure.
-********************************************************************/  
-
-BOOL spool_io_printer_info_level_3(const char *desc, SPOOL_PRINTER_INFO_LEVEL_3 *il, prs_struct *ps, int depth)
-{	
-	prs_debug(ps, depth, desc, "spool_io_printer_info_level_3");
-	depth++;
-		
-	if(!prs_align(ps))
-		return False;
-
-	if(!prs_uint32("secdesc_ptr", ps, depth, &il->secdesc_ptr))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
- Parse a SPOOL_PRINTER_INFO_LEVEL_2 structure.
-********************************************************************/  
-
-BOOL spool_io_printer_info_level_2(const char *desc, SPOOL_PRINTER_INFO_LEVEL_2 *il, prs_struct *ps, int depth)
-{	
-	prs_debug(ps, depth, desc, "spool_io_printer_info_level_2");
-	depth++;
-		
-	if(!prs_align(ps))
-		return False;
-
-	if(!prs_uint32("servername_ptr", ps, depth, &il->servername_ptr))
-		return False;
-	if(!prs_uint32("printername_ptr", ps, depth, &il->printername_ptr))
-		return False;
-	if(!prs_uint32("sharename_ptr", ps, depth, &il->sharename_ptr))
-		return False;
-	if(!prs_uint32("portname_ptr", ps, depth, &il->portname_ptr))
-		return False;
-
-	if(!prs_uint32("drivername_ptr", ps, depth, &il->drivername_ptr))
-		return False;
-	if(!prs_uint32("comment_ptr", ps, depth, &il->comment_ptr))
-		return False;
-	if(!prs_uint32("location_ptr", ps, depth, &il->location_ptr))
-		return False;
-	if(!prs_uint32("devmode_ptr", ps, depth, &il->devmode_ptr))
-		return False;
-	if(!prs_uint32("sepfile_ptr", ps, depth, &il->sepfile_ptr))
-		return False;
-	if(!prs_uint32("printprocessor_ptr", ps, depth, &il->printprocessor_ptr))
-		return False;
-	if(!prs_uint32("datatype_ptr", ps, depth, &il->datatype_ptr))
-		return False;
-	if(!prs_uint32("parameters_ptr", ps, depth, &il->parameters_ptr))
-		return False;
-	if(!prs_uint32("secdesc_ptr", ps, depth, &il->secdesc_ptr))
-		return False;
-
-	if(!prs_uint32("attributes", ps, depth, &il->attributes))
-		return False;
-	if(!prs_uint32("priority", ps, depth, &il->priority))
-		return False;
-	if(!prs_uint32("default_priority", ps, depth, &il->default_priority))
-		return False;
-	if(!prs_uint32("starttime", ps, depth, &il->starttime))
-		return False;
-	if(!prs_uint32("untiltime", ps, depth, &il->untiltime))
-		return False;
-	if(!prs_uint32("status", ps, depth, &il->status))
-		return False;
-	if(!prs_uint32("cjobs", ps, depth, &il->cjobs))
-		return False;
-	if(!prs_uint32("averageppm", ps, depth, &il->averageppm))
-		return False;
-
-	if(!smb_io_unistr2("servername", &il->servername, il->servername_ptr, ps, depth))
-		return False;
-	if(!smb_io_unistr2("printername", &il->printername, il->printername_ptr, ps, depth))
-		return False;
-	if(!smb_io_unistr2("sharename", &il->sharename, il->sharename_ptr, ps, depth))
-		return False;
-	if(!smb_io_unistr2("portname", &il->portname, il->portname_ptr, ps, depth))
-		return False;
-	if(!smb_io_unistr2("drivername", &il->drivername, il->drivername_ptr, ps, depth))
-		return False;
-	if(!smb_io_unistr2("comment", &il->comment, il->comment_ptr, ps, depth))
-		return False;
-	if(!smb_io_unistr2("location", &il->location, il->location_ptr, ps, depth))
-		return False;
-	if(!smb_io_unistr2("sepfile", &il->sepfile, il->sepfile_ptr, ps, depth))
-		return False;
-	if(!smb_io_unistr2("printprocessor", &il->printprocessor, il->printprocessor_ptr, ps, depth))
-		return False;
-	if(!smb_io_unistr2("datatype", &il->datatype, il->datatype_ptr, ps, depth))
-		return False;
-	if(!smb_io_unistr2("parameters", &il->parameters, il->parameters_ptr, ps, depth))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
-********************************************************************/  
-
-BOOL spool_io_printer_info_level(const char *desc, SPOOL_PRINTER_INFO_LEVEL *il, prs_struct *ps, int depth)
-{
-	prs_debug(ps, depth, desc, "spool_io_printer_info_level");
-	depth++;
-
-	if(!prs_align(ps))
-		return False;
-	if(!prs_uint32("level", ps, depth, &il->level))
-		return False;
-	if(!prs_uint32("info_ptr", ps, depth, &il->info_ptr))
-		return False;
-	
-	/* if no struct inside just return */
-	if (il->info_ptr==0) {
-		if (UNMARSHALLING(ps)) {
-			il->info_1=NULL;
-			il->info_2=NULL;
-		}
-		return True;
-	}
-			
-	switch (il->level) {
-		/*
-		 * level 0 is used by setprinter when managing the queue
-		 * (hold, stop, start a queue)
-		 */
-		case 0:
-			break;
-		/* DOCUMENT ME!!! What is level 1 used for? */
-		case 1:
-		{
-			if (UNMARSHALLING(ps)) {
-				if ((il->info_1=(SPOOL_PRINTER_INFO_LEVEL_1 *)prs_alloc_mem(ps,sizeof(SPOOL_PRINTER_INFO_LEVEL_1))) == NULL)
-					return False;
-			}
-			if (!spool_io_printer_info_level_1("", il->info_1, ps, depth))
-				return False;
-			break;		
-		}
-		/* 
-		 * level 2 is used by addprinter
-		 * and by setprinter when updating printer's info
-		 */	
-		case 2:
-			if (UNMARSHALLING(ps)) {
-				if ((il->info_2=(SPOOL_PRINTER_INFO_LEVEL_2 *)prs_alloc_mem(ps,sizeof(SPOOL_PRINTER_INFO_LEVEL_2))) == NULL)
-					return False;
-			}
-			if (!spool_io_printer_info_level_2("", il->info_2, ps, depth))
-				return False;
-			break;		
-		/* DOCUMENT ME!!! What is level 3 used for? */
-		case 3:
-		{
-			if (UNMARSHALLING(ps)) {
-				if ((il->info_3=(SPOOL_PRINTER_INFO_LEVEL_3 *)prs_alloc_mem(ps,sizeof(SPOOL_PRINTER_INFO_LEVEL_3))) == NULL)
-					return False;
-			}
-			if (!spool_io_printer_info_level_3("", il->info_3, ps, depth))
-				return False;
-			break;		
-		}
-	}
-
-	return True;
-}
-
-/*******************************************************************
-********************************************************************/  
-
-BOOL spoolss_io_q_addprinterex(const char *desc, SPOOL_Q_ADDPRINTEREX *q_u, prs_struct *ps, int depth)
-{
-	uint32 ptr_sec_desc = 0;
-
-	prs_debug(ps, depth, desc, "spoolss_io_q_addprinterex");
-	depth++;
-
-	if(!prs_align(ps))
-		return False;
-	if(!prs_uint32("", ps, depth, &q_u->server_name_ptr))
-		return False;
-	if(!smb_io_unistr2("", &q_u->server_name, q_u->server_name_ptr, ps, depth))
-		return False;
-
-	if(!prs_align(ps))
-		return False;
-
-	if(!prs_uint32("info_level", ps, depth, &q_u->level))
-		return False;
-	
-	if(!spool_io_printer_info_level("", &q_u->info, ps, depth))
-		return False;
-	
-	if (!spoolss_io_devmode_cont(desc, &q_u->devmode_ctr, ps, depth))
-		return False;
-
-	if(!prs_align(ps))
-		return False;
-
-	switch (q_u->level) {
-		case 2:
-			ptr_sec_desc = q_u->info.info_2->secdesc_ptr;
-			break;
-		case 3:
-			ptr_sec_desc = q_u->info.info_3->secdesc_ptr;
-			break;
-	}
-	if (ptr_sec_desc) {
-		if (!sec_io_desc_buf(desc, &q_u->secdesc_ctr, ps, depth))
-			return False;
-	} else {
-		uint32 dummy;
-
-		/* Parse a NULL security descriptor.  This should really
-			happen inside the sec_io_desc_buf() function. */
-
-		prs_debug(ps, depth, "", "sec_io_desc_buf");
-		if (!prs_uint32("size", ps, depth + 1, &dummy))
-			return False;
-		if (!prs_uint32("ptr", ps, depth + 1, &dummy))
-			return False;
-	}
-
-	if(!prs_uint32("user_switch", ps, depth, &q_u->user_switch))
-		return False;
-	if(!spool_io_user_level("", &q_u->user_ctr, ps, depth))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
-********************************************************************/  
-
-BOOL spoolss_io_r_addprinterex(const char *desc, SPOOL_R_ADDPRINTEREX *r_u, 
-			       prs_struct *ps, int depth)
-{
-	prs_debug(ps, depth, desc, "spoolss_io_r_addprinterex");
-	depth++;
-	
-	if(!smb_io_pol_hnd("printer handle",&r_u->handle,ps,depth))
-		return False;
-
-	if(!prs_werror("status", ps, depth, &r_u->status))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
-********************************************************************/  
-
-BOOL spool_io_printer_driver_info_level_3(const char *desc, SPOOL_PRINTER_DRIVER_INFO_LEVEL_3 **q_u, 
-                                          prs_struct *ps, int depth)
-{	
-	SPOOL_PRINTER_DRIVER_INFO_LEVEL_3 *il;
-	
-	prs_debug(ps, depth, desc, "spool_io_printer_driver_info_level_3");
-	depth++;
-		
-	/* reading */
-	if (UNMARSHALLING(ps)) {
-		il=(SPOOL_PRINTER_DRIVER_INFO_LEVEL_3 *)prs_alloc_mem(ps,sizeof(SPOOL_PRINTER_DRIVER_INFO_LEVEL_3));
-		if(il == NULL)
-			return False;
-		*q_u=il;
-	}
-	else {
-		il=*q_u;
-	}
-	
-	if(!prs_align(ps))
-		return False;
-
-	if(!prs_uint32("cversion", ps, depth, &il->cversion))
-		return False;
-	if(!prs_uint32("name", ps, depth, &il->name_ptr))
-		return False;
-	if(!prs_uint32("environment", ps, depth, &il->environment_ptr))
-		return False;
-	if(!prs_uint32("driverpath", ps, depth, &il->driverpath_ptr))
-		return False;
-	if(!prs_uint32("datafile", ps, depth, &il->datafile_ptr))
-		return False;
-	if(!prs_uint32("configfile", ps, depth, &il->configfile_ptr))
-		return False;
-	if(!prs_uint32("helpfile", ps, depth, &il->helpfile_ptr))
-		return False;
-	if(!prs_uint32("monitorname", ps, depth, &il->monitorname_ptr))
-		return False;
-	if(!prs_uint32("defaultdatatype", ps, depth, &il->defaultdatatype_ptr))
-		return False;
-	if(!prs_uint32("dependentfilessize", ps, depth, &il->dependentfilessize))
-		return False;
-	if(!prs_uint32("dependentfiles", ps, depth, &il->dependentfiles_ptr))
-		return False;
-
-	if(!prs_align(ps))
-		return False;
-	
-	if(!smb_io_unistr2("name", &il->name, il->name_ptr, ps, depth))
-		return False;
-	if(!smb_io_unistr2("environment", &il->environment, il->environment_ptr, ps, depth))
-		return False;
-	if(!smb_io_unistr2("driverpath", &il->driverpath, il->driverpath_ptr, ps, depth))
-		return False;
-	if(!smb_io_unistr2("datafile", &il->datafile, il->datafile_ptr, ps, depth))
-		return False;
-	if(!smb_io_unistr2("configfile", &il->configfile, il->configfile_ptr, ps, depth))
-		return False;
-	if(!smb_io_unistr2("helpfile", &il->helpfile, il->helpfile_ptr, ps, depth))
-		return False;
-	if(!smb_io_unistr2("monitorname", &il->monitorname, il->monitorname_ptr, ps, depth))
-		return False;
-	if(!smb_io_unistr2("defaultdatatype", &il->defaultdatatype, il->defaultdatatype_ptr, ps, depth))
-		return False;
-
-	if(!prs_align(ps))
-		return False;
-		
-	if (il->dependentfiles_ptr)
-		smb_io_buffer5("", &il->dependentfiles, ps, depth);
-
-	return True;
-}
-
-/*******************************************************************
-parse a SPOOL_PRINTER_DRIVER_INFO_LEVEL_6 structure
-********************************************************************/  
-
-BOOL spool_io_printer_driver_info_level_6(const char *desc, SPOOL_PRINTER_DRIVER_INFO_LEVEL_6 **q_u, 
-                                          prs_struct *ps, int depth)
-{	
-	SPOOL_PRINTER_DRIVER_INFO_LEVEL_6 *il;
-	
-	prs_debug(ps, depth, desc, "spool_io_printer_driver_info_level_6");
-	depth++;
-		
-	/* reading */
-	if (UNMARSHALLING(ps)) {
-		il=(SPOOL_PRINTER_DRIVER_INFO_LEVEL_6 *)prs_alloc_mem(ps,sizeof(SPOOL_PRINTER_DRIVER_INFO_LEVEL_6));
-		if(il == NULL)
-			return False;
-		*q_u=il;
-	}
-	else {
-		il=*q_u;
-	}
-	
-	if(!prs_align(ps))
-		return False;
-
-	/* 
-	 * I know this seems weird, but I have no other explanation.
-	 * This is observed behavior on both NT4 and 2K servers.
-	 * --jerry
-	 */
-	 
-	if (!prs_align_uint64(ps))
-		return False;
-
-	/* parse the main elements the packet */
-
-	if(!prs_uint32("cversion       ", ps, depth, &il->version))
-		return False;
-	if(!prs_uint32("name           ", ps, depth, &il->name_ptr))
-		return False;	
-	if(!prs_uint32("environment    ", ps, depth, &il->environment_ptr))
-			return False;	
-	if(!prs_uint32("driverpath     ", ps, depth, &il->driverpath_ptr))
-		return False;
-	if(!prs_uint32("datafile       ", ps, depth, &il->datafile_ptr))
-		return False;
-	if(!prs_uint32("configfile     ", ps, depth, &il->configfile_ptr))
-		return False;
-	if(!prs_uint32("helpfile       ", ps, depth, &il->helpfile_ptr))
-		return False;
-	if(!prs_uint32("monitorname    ", ps, depth, &il->monitorname_ptr))
-		return False;
-	if(!prs_uint32("defaultdatatype", ps, depth, &il->defaultdatatype_ptr))
-		return False;
-	if(!prs_uint32("dependentfiles ", ps, depth, &il->dependentfiles_len))
-		return False;
-	if(!prs_uint32("dependentfiles ", ps, depth, &il->dependentfiles_ptr))
-		return False;
-	if(!prs_uint32("previousnames  ", ps, depth, &il->previousnames_len))
-		return False;
-	if(!prs_uint32("previousnames  ", ps, depth, &il->previousnames_ptr))
-		return False;
-	if(!smb_io_time("driverdate    ", &il->driverdate, ps, depth))
-		return False;
-	if(!prs_uint32("dummy4         ", ps, depth, &il->dummy4))
-		return False;
-	if(!prs_uint64("driverversion  ", ps, depth, &il->driverversion))
-		return False;
-	if(!prs_uint32("mfgname        ", ps, depth, &il->mfgname_ptr))
-		return False;
-	if(!prs_uint32("oemurl         ", ps, depth, &il->oemurl_ptr))
-		return False;
-	if(!prs_uint32("hardwareid     ", ps, depth, &il->hardwareid_ptr))
-		return False;
-	if(!prs_uint32("provider       ", ps, depth, &il->provider_ptr))
-		return False;
-
-	/* parse the structures in the packet */
-
-	if(!smb_io_unistr2("name", &il->name, il->name_ptr, ps, depth))
-		return False;
-	if(!prs_align(ps))
-		return False;
-
-	if(!smb_io_unistr2("environment", &il->environment, il->environment_ptr, ps, depth))
-		return False;
-	if(!prs_align(ps))
-		return False;
-
-	if(!smb_io_unistr2("driverpath", &il->driverpath, il->driverpath_ptr, ps, depth))
-		return False;
-	if(!prs_align(ps))
-		return False;
-
-	if(!smb_io_unistr2("datafile", &il->datafile, il->datafile_ptr, ps, depth))
-		return False;
-	if(!prs_align(ps))
-		return False;
-
-	if(!smb_io_unistr2("configfile", &il->configfile, il->configfile_ptr, ps, depth))
-		return False;
-	if(!prs_align(ps))
-		return False;
-
-	if(!smb_io_unistr2("helpfile", &il->helpfile, il->helpfile_ptr, ps, depth))
-		return False;
-	if(!prs_align(ps))
-		return False;
-
-	if(!smb_io_unistr2("monitorname", &il->monitorname, il->monitorname_ptr, ps, depth))
-		return False;
-	if(!prs_align(ps))
-		return False;
-
-	if(!smb_io_unistr2("defaultdatatype", &il->defaultdatatype, il->defaultdatatype_ptr, ps, depth))
-		return False;
-	if(!prs_align(ps))
-		return False;
-	if (il->dependentfiles_ptr) {
-		if(!smb_io_buffer5("dependentfiles", &il->dependentfiles, ps, depth))
-			return False;
-		if(!prs_align(ps))
-			return False;
-	}
-	if (il->previousnames_ptr) {
-		if(!smb_io_buffer5("previousnames", &il->previousnames, ps, depth))
-			return False;
-		if(!prs_align(ps))
-			return False;
-	}
-	if(!smb_io_unistr2("mfgname", &il->mfgname, il->mfgname_ptr, ps, depth))
-		return False;
-	if(!prs_align(ps))
-		return False;
-	if(!smb_io_unistr2("oemurl", &il->oemurl, il->oemurl_ptr, ps, depth))
-		return False;
-	if(!prs_align(ps))
-		return False;
-	if(!smb_io_unistr2("hardwareid", &il->hardwareid, il->hardwareid_ptr, ps, depth))
-		return False;
-	if(!prs_align(ps))
-		return False;
-	if(!smb_io_unistr2("provider", &il->provider, il->provider_ptr, ps, depth))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
- convert a buffer of UNICODE strings null terminated
- the buffer is terminated by a NULL
- 
- convert to an dos codepage array (null terminated)
- 
- dynamically allocate memory
- 
-********************************************************************/  
-static BOOL uniarray_2_dosarray(BUFFER5 *buf5, fstring **ar)
-{
-	fstring f, *tar;
-	int n = 0;
-	char *src;
-
-	if (buf5==NULL)
-		return False;
-
-	src = (char *)buf5->buffer;
-	*ar = NULL;
-
-	while (src < ((char *)buf5->buffer) + buf5->buf_len*2) {
-		unistr_to_dos(f, src, sizeof(f)-1);
-		src = skip_unibuf(src, 2*buf5->buf_len - PTR_DIFF(src,buf5->buffer));
-		tar = (fstring *)Realloc(*ar, sizeof(fstring)*(n+2));
-		if (!tar)
-			return False;
-		else
-			*ar = tar;
-		fstrcpy((*ar)[n], f);
-		n++;
-	}
-	fstrcpy((*ar)[n], "");
- 
-	return True;
-}
-
-
-
-
-/*******************************************************************
- read a UNICODE array with null terminated strings 
- and null terminated array 
- and size of array at beginning
-********************************************************************/  
-
-BOOL smb_io_unibuffer(const char *desc, UNISTR2 *buffer, prs_struct *ps, int depth)
-{
-	if (buffer==NULL) return False;
-
-	buffer->undoc=0;
-	buffer->uni_str_len=buffer->uni_max_len;
-	
-	if(!prs_uint32("buffer_size", ps, depth, &buffer->uni_max_len))
-		return False;
-
-	if(!prs_unistr2(True, "buffer     ", ps, depth, buffer))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
-********************************************************************/  
-
-BOOL spool_io_printer_driver_info_level(const char *desc, SPOOL_PRINTER_DRIVER_INFO_LEVEL *il, prs_struct *ps, int depth)
-{
-	prs_debug(ps, depth, desc, "spool_io_printer_driver_info_level");
-	depth++;
-
-	if(!prs_align(ps))
-		return False;
-	if(!prs_uint32("level", ps, depth, &il->level))
-		return False;
-	if(!prs_uint32("ptr", ps, depth, &il->ptr))
-		return False;
-
-	if (il->ptr==0)
-		return True;
-		
-	switch (il->level) {
-		case 3:
-			if(!spool_io_printer_driver_info_level_3("", &il->info_3, ps, depth))
-				return False;
-			break;		
-		case 6:
-			if(!spool_io_printer_driver_info_level_6("", &il->info_6, ps, depth))
-				return False;
-			break;		
-	default:
-		return False;
-	}
-
-	return True;
-}
-
-/*******************************************************************
- init a SPOOL_Q_ADDPRINTERDRIVER struct
- ******************************************************************/
-
-BOOL make_spoolss_q_addprinterdriver(TALLOC_CTX *mem_ctx,
-				SPOOL_Q_ADDPRINTERDRIVER *q_u, const char* srv_name, 
-				uint32 level, PRINTER_DRIVER_CTR *info)
-{
-	DEBUG(5,("make_spoolss_q_addprinterdriver\n"));
-	
-	q_u->server_name_ptr = (srv_name!=NULL)?1:0;
-	init_unistr2(&q_u->server_name, srv_name, strlen(srv_name)+1);
-	
-	q_u->level = level;
-	
-	q_u->info.level = level;
-	q_u->info.ptr = (info!=NULL)?1:0;
-	switch (level)
-	{
-	/* info level 3 is supported by Windows 95/98, WinNT and Win2k */
-	case 3 :
-		make_spoolss_driver_info_3(mem_ctx, &q_u->info.info_3, info->info3);
-		break;
-				
-	default:
-		ZERODEBUG(0,("make_spoolss_q_addprinterdriver: Unknown info level [%d]\n", level));
-		break;
-	}
-	
-	return True;
-}
-
-BOOL make_spoolss_driver_info_3(TALLOC_CTX *mem_ctx, 
-				SPOOL_PRINTER_DRIVER_INFO_LEVEL_3 **spool_drv_info,
-				DRIVER_INFO_3 *info3)
-{
-	uint32		len = 0;
-	uint16		*ptr = info3->dependentfiles;
-	BOOL		done = False;
-	BOOL		null_char = False;
-	SPOOL_PRINTER_DRIVER_INFO_LEVEL_3 *inf;
-
-	if (!(inf=(SPOOL_PRINTER_DRIVER_INFO_LEVEL_3*)talloc_zero(mem_ctx, sizeof(SPOOL_PRINTER_DRIVER_INFO_LEVEL_3))))
-		return False;
-	
-	inf->cversion	= info3->version;
-	inf->name_ptr	= (info3->name.buffer!=NULL)?1:0;
-	inf->environment_ptr	= (info3->architecture.buffer!=NULL)?1:0;
-	inf->driverpath_ptr	= (info3->driverpath.buffer!=NULL)?1:0;
-	inf->datafile_ptr	= (info3->datafile.buffer!=NULL)?1:0;
-	inf->configfile_ptr	= (info3->configfile.buffer!=NULL)?1:0;
-	inf->helpfile_ptr	= (info3->helpfile.buffer!=NULL)?1:0;
-	inf->monitorname_ptr	= (info3->monitorname.buffer!=NULL)?1:0;
-	inf->defaultdatatype_ptr	= (info3->defaultdatatype.buffer!=NULL)?1:0;
-
-	init_unistr2_from_unistr(&inf->name, &info3->name);
-	init_unistr2_from_unistr(&inf->environment, &info3->architecture);
-	init_unistr2_from_unistr(&inf->driverpath, &info3->driverpath);
-	init_unistr2_from_unistr(&inf->datafile, &info3->datafile);
-	init_unistr2_from_unistr(&inf->configfile, &info3->configfile);
-	init_unistr2_from_unistr(&inf->helpfile, &info3->helpfile);
-	init_unistr2_from_unistr(&inf->monitorname, &info3->monitorname);
-	init_unistr2_from_unistr(&inf->defaultdatatype, &info3->defaultdatatype);
-
-	while (!done)
-	{
-		switch (*ptr)
-		{
-			case 0:
-				/* the null_char BOOL is used to help locate
-				   two '\0's back to back */
-				if (null_char)
-					done = True;
-				else
-					null_char = True;
-				break;
-					
-			default:
-				null_char = False;
-				;;
-				break;				
-		}
-		len++;
-		ptr++;
-	}
-	inf->dependentfiles_ptr = (info3->dependentfiles != NULL) ? 1 : 0;
-	inf->dependentfilessize = len;
-	if(!make_spoolss_buffer5(mem_ctx, &inf->dependentfiles, len, info3->dependentfiles))
-	{
-		SAFE_FREE(inf);
-		return False;
-	}
-	
-	*spool_drv_info = inf;
-	
-	return True;
-}
-
-/*******************************************************************
- make a BUFFER5 struct from a uint16*
- ******************************************************************/
-BOOL make_spoolss_buffer5(TALLOC_CTX *mem_ctx, BUFFER5 *buf5, uint32 len, uint16 *src)
-{
-
-	buf5->buf_len = len;
-	if((buf5->buffer=(uint16*)talloc_memdup(mem_ctx, src, sizeof(uint16)*len)) == NULL)
-	{
-		ZERODEBUG(0,("make_spoolss_buffer5: Unable to malloc memory for buffer!\n"));
-		return False;
-	}
-	
-	return True;
-}
-
-/*******************************************************************
- fill in the prs_struct for a ADDPRINTERDRIVER request PDU
- ********************************************************************/  
-
-BOOL spoolss_io_q_addprinterdriver(const char *desc, SPOOL_Q_ADDPRINTERDRIVER *q_u, prs_struct *ps, int depth)
-{
-	prs_debug(ps, depth, desc, "spoolss_io_q_addprinterdriver");
-	depth++;
-
-	if(!prs_align(ps))
-		return False;
-
-	if(!prs_uint32("server_name_ptr", ps, depth, &q_u->server_name_ptr))
-		return False;
-	if(!smb_io_unistr2("server_name", &q_u->server_name, q_u->server_name_ptr, ps, depth))
-		return False;
-		
-	if(!prs_align(ps))
-		return False;
-	if(!prs_uint32("info_level", ps, depth, &q_u->level))
-		return False;
-
-	if(!spool_io_printer_driver_info_level("", &q_u->info, ps, depth))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
-********************************************************************/  
-
-BOOL spoolss_io_r_addprinterdriver(const char *desc, SPOOL_R_ADDPRINTERDRIVER *q_u, prs_struct *ps, int depth)
-{
-	prs_debug(ps, depth, desc, "spoolss_io_r_addprinterdriver");
-	depth++;
-
-	if(!prs_werror("status", ps, depth, &q_u->status))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
-********************************************************************/  
-
-BOOL uni_2_asc_printer_driver_3(SPOOL_PRINTER_DRIVER_INFO_LEVEL_3 *uni,
-                                NT_PRINTER_DRIVER_INFO_LEVEL_3 **asc)
-{
-	NT_PRINTER_DRIVER_INFO_LEVEL_3 *d;
-	
-	DEBUG(7,("uni_2_asc_printer_driver_3: Converting from UNICODE to ASCII\n"));
-	
-	if (*asc==NULL)
-	{
-		*asc=(NT_PRINTER_DRIVER_INFO_LEVEL_3 *)malloc(sizeof(NT_PRINTER_DRIVER_INFO_LEVEL_3));
-		if(*asc == NULL)
-			return False;
-		ZERO_STRUCTP(*asc);
-	}	
-
-	d=*asc;
-
-	d->cversion=uni->cversion;
-
-	unistr2_to_dos(d->name,            &uni->name,            sizeof(d->name)-1);
-	unistr2_to_dos(d->environment,     &uni->environment,     sizeof(d->environment)-1);
-	unistr2_to_dos(d->driverpath,      &uni->driverpath,      sizeof(d->driverpath)-1);
-	unistr2_to_dos(d->datafile,        &uni->datafile,        sizeof(d->datafile)-1);
-	unistr2_to_dos(d->configfile,      &uni->configfile,      sizeof(d->configfile)-1);
-	unistr2_to_dos(d->helpfile,        &uni->helpfile,        sizeof(d->helpfile)-1);
-	unistr2_to_dos(d->monitorname,     &uni->monitorname,     sizeof(d->monitorname)-1);
-	unistr2_to_dos(d->defaultdatatype, &uni->defaultdatatype, sizeof(d->defaultdatatype)-1);
-
-	DEBUGADD(8,( "version:         %d\n", d->cversion));
-	DEBUGADD(8,( "name:            %s\n", d->name));
-	DEBUGADD(8,( "environment:     %s\n", d->environment));
-	DEBUGADD(8,( "driverpath:      %s\n", d->driverpath));
-	DEBUGADD(8,( "datafile:        %s\n", d->datafile));
-	DEBUGADD(8,( "configfile:      %s\n", d->configfile));
-	DEBUGADD(8,( "helpfile:        %s\n", d->helpfile));
-	DEBUGADD(8,( "monitorname:     %s\n", d->monitorname));
-	DEBUGADD(8,( "defaultdatatype: %s\n", d->defaultdatatype));
-
-	if (uniarray_2_dosarray(&uni->dependentfiles, &d->dependentfiles ))
-		return True;
-	
-	SAFE_FREE(*asc);
-	return False;
-}
-
-/*******************************************************************
-********************************************************************/  
-BOOL uni_2_asc_printer_driver_6(SPOOL_PRINTER_DRIVER_INFO_LEVEL_6 *uni,
-                                NT_PRINTER_DRIVER_INFO_LEVEL_6 **asc)
-{
-	NT_PRINTER_DRIVER_INFO_LEVEL_6 *d;
-	
-	DEBUG(7,("uni_2_asc_printer_driver_6: Converting from UNICODE to ASCII\n"));
-	
-	if (*asc==NULL)
-	{
-		*asc=(NT_PRINTER_DRIVER_INFO_LEVEL_6 *)malloc(sizeof(NT_PRINTER_DRIVER_INFO_LEVEL_6));
-		if(*asc == NULL)
-			return False;
-		ZERO_STRUCTP(*asc);
-	}	
-
-	d=*asc;
-
-	d->version=uni->version;
-
-	unistr2_to_dos(d->name,            &uni->name,            sizeof(d->name)-1);
-	unistr2_to_dos(d->environment,     &uni->environment,     sizeof(d->environment)-1);
-	unistr2_to_dos(d->driverpath,      &uni->driverpath,      sizeof(d->driverpath)-1);
-	unistr2_to_dos(d->datafile,        &uni->datafile,        sizeof(d->datafile)-1);
-	unistr2_to_dos(d->configfile,      &uni->configfile,      sizeof(d->configfile)-1);
-	unistr2_to_dos(d->helpfile,        &uni->helpfile,        sizeof(d->helpfile)-1);
-	unistr2_to_dos(d->monitorname,     &uni->monitorname,     sizeof(d->monitorname)-1);
-	unistr2_to_dos(d->defaultdatatype, &uni->defaultdatatype, sizeof(d->defaultdatatype)-1);
-
-	DEBUGADD(8,( "version:         %d\n", d->version));
-	DEBUGADD(8,( "name:            %s\n", d->name));
-	DEBUGADD(8,( "environment:     %s\n", d->environment));
-	DEBUGADD(8,( "driverpath:      %s\n", d->driverpath));
-	DEBUGADD(8,( "datafile:        %s\n", d->datafile));
-	DEBUGADD(8,( "configfile:      %s\n", d->configfile));
-	DEBUGADD(8,( "helpfile:        %s\n", d->helpfile));
-	DEBUGADD(8,( "monitorname:     %s\n", d->monitorname));
-	DEBUGADD(8,( "defaultdatatype: %s\n", d->defaultdatatype));
-
-	if (!uniarray_2_dosarray(&uni->dependentfiles, &d->dependentfiles ))
-		goto error;
-	if (!uniarray_2_dosarray(&uni->previousnames, &d->previousnames ))
-		goto error;
-	
-	return True;
-	
-error:
-	SAFE_FREE(*asc);
-	return False;
-}
-
-BOOL uni_2_asc_printer_info_2(const SPOOL_PRINTER_INFO_LEVEL_2 *uni,
-                              NT_PRINTER_INFO_LEVEL_2  **asc)
-{
-	NT_PRINTER_INFO_LEVEL_2 *d;
-	time_t time_unix;
-	
-	DEBUG(7,("Converting from UNICODE to ASCII\n"));
-	time_unix=time(NULL);
-	
-	if (*asc==NULL) {
-		DEBUGADD(8,("allocating memory\n"));
-
-		*asc=(NT_PRINTER_INFO_LEVEL_2 *)malloc(sizeof(NT_PRINTER_INFO_LEVEL_2));
-		if(*asc == NULL)
-			return False;
-		ZERO_STRUCTP(*asc);
-		
-		/* we allocate memory iff called from 
-		 * addprinter(ex) so we can do one time stuff here.
-		 */
-		(*asc)->setuptime=time_unix;
-	}	
-	DEBUGADD(8,("start converting\n"));
-
-	d=*asc;
-		
-	d->attributes=uni->attributes;
-	d->priority=uni->priority;
-	d->default_priority=uni->default_priority;
-	d->starttime=uni->starttime;
-	d->untiltime=uni->untiltime;
-	d->status=uni->status;
-	d->cjobs=uni->cjobs;
-	
-	unistr2_to_dos(d->servername, &uni->servername, sizeof(d->servername)-1);
-	unistr2_to_dos(d->printername, &uni->printername, sizeof(d->printername)-1);
-	unistr2_to_dos(d->sharename, &uni->sharename, sizeof(d->sharename)-1);
-	unistr2_to_dos(d->portname, &uni->portname, sizeof(d->portname)-1);
-	unistr2_to_dos(d->drivername, &uni->drivername, sizeof(d->drivername)-1);
-	unistr2_to_dos(d->comment, &uni->comment, sizeof(d->comment)-1);
-	unistr2_to_dos(d->location, &uni->location, sizeof(d->location)-1);
-	unistr2_to_dos(d->sepfile, &uni->sepfile, sizeof(d->sepfile)-1);
-	unistr2_to_dos(d->printprocessor, &uni->printprocessor, sizeof(d->printprocessor)-1);
-	unistr2_to_dos(d->datatype, &uni->datatype, sizeof(d->datatype)-1);
-	unistr2_to_dos(d->parameters, &uni->parameters, sizeof(d->parameters)-1);
-
-	return True;
-}
-
-/*******************************************************************
- * init a structure.
- ********************************************************************/
-
-BOOL make_spoolss_q_getprinterdriverdir(SPOOL_Q_GETPRINTERDRIVERDIR *q_u,
-                                fstring servername, fstring env_name, uint32 level,
-                                NEW_BUFFER *buffer, uint32 offered)
-{
-	init_buf_unistr2(&q_u->name, &q_u->name_ptr, servername);
-	init_buf_unistr2(&q_u->environment, &q_u->environment_ptr, env_name);
-
-	q_u->level=level;
-	q_u->buffer=buffer;
-	q_u->offered=offered;
-
-	return True;
-}
-
-/*******************************************************************
- Parse a SPOOL_Q_GETPRINTERDRIVERDIR structure.
-********************************************************************/  
-
-BOOL spoolss_io_q_getprinterdriverdir(const char *desc, SPOOL_Q_GETPRINTERDRIVERDIR *q_u, prs_struct *ps, int depth)
-{
-	prs_debug(ps, depth, desc, "spoolss_io_q_getprinterdriverdir");
-	depth++;
-
-	if(!prs_align(ps))
-		return False;
-	if(!prs_uint32("name_ptr", ps, depth, &q_u->name_ptr))
-		return False;
-	if(!smb_io_unistr2("", &q_u->name, q_u->name_ptr, ps, depth))
-		return False;
-
-	if(!prs_align(ps))
-		return False;
-		
-	if(!prs_uint32("", ps, depth, &q_u->environment_ptr))
-		return False;
-	if(!smb_io_unistr2("", &q_u->environment, q_u->environment_ptr, ps, depth))
-		return False;
-		
-	if(!prs_align(ps))
-		return False;
-
-	if(!prs_uint32("level", ps, depth, &q_u->level))
-		return False;
-		
-	if(!spoolss_io_buffer("", ps, depth, &q_u->buffer))
-		return False;
-		
-	if(!prs_align(ps))
-		return False;
-		
-	if(!prs_uint32("offered", ps, depth, &q_u->offered))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
- Parse a SPOOL_R_GETPRINTERDRIVERDIR structure.
-********************************************************************/  
-
-BOOL spoolss_io_r_getprinterdriverdir(const char *desc, SPOOL_R_GETPRINTERDRIVERDIR *r_u, prs_struct *ps, int depth)
-{		
-	prs_debug(ps, depth, desc, "spoolss_io_r_getprinterdriverdir");
-	depth++;
-
-	if (!prs_align(ps))
-		return False;
-		
-	if (!spoolss_io_buffer("", ps, depth, &r_u->buffer))
-		return False;
-
-	if (!prs_align(ps))
-		return False;
-		
-	if (!prs_uint32("needed", ps, depth, &r_u->needed))
-		return False;
-		
-	if (!prs_werror("status", ps, depth, &r_u->status))
-		return False;
-
-	return True;		
-}
-
-/*******************************************************************
-********************************************************************/  
-
-BOOL spoolss_io_r_enumprintprocessors(const char *desc, SPOOL_R_ENUMPRINTPROCESSORS *r_u, prs_struct *ps, int depth)
-{		
-	prs_debug(ps, depth, desc, "spoolss_io_r_enumprintprocessors");
-	depth++;
-
-	if (!prs_align(ps))
-		return False;
-		
-	if (!spoolss_io_buffer("", ps, depth, &r_u->buffer))
-		return False;
-
-	if (!prs_align(ps))
-		return False;
-		
-	if (!prs_uint32("needed", ps, depth, &r_u->needed))
-		return False;
-		
-	if (!prs_uint32("returned", ps, depth, &r_u->returned))
-		return False;
-		
-	if (!prs_werror("status", ps, depth, &r_u->status))
-		return False;
-
-	return True;		
-}
-
-/*******************************************************************
-********************************************************************/  
-
-BOOL spoolss_io_q_enumprintprocessors(const char *desc, SPOOL_Q_ENUMPRINTPROCESSORS *q_u, prs_struct *ps, int depth)
-{
-	prs_debug(ps, depth, desc, "spoolss_io_q_enumprintprocessors");
-	depth++;
-
-	if (!prs_align(ps))
-		return False;
-		
-	if (!prs_uint32("name_ptr", ps, depth, &q_u->name_ptr))
-		return False;
-	if (!smb_io_unistr2("name", &q_u->name, True, ps, depth))
-		return False;
-		
-	if (!prs_align(ps))
-		return False;
-		
-	if (!prs_uint32("", ps, depth, &q_u->environment_ptr))
-		return False;
-	if (!smb_io_unistr2("", &q_u->environment, q_u->environment_ptr, ps, depth))
-		return False;
-	
-	if (!prs_align(ps))
-		return False;
-		
-	if (!prs_uint32("level", ps, depth, &q_u->level))
-		return False;
-		
-	if(!spoolss_io_buffer("", ps, depth, &q_u->buffer))
-		return False;
-
-	if (!prs_align(ps))
-		return False;
-
-	if (!prs_uint32("offered", ps, depth, &q_u->offered))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
-********************************************************************/  
-
-BOOL spoolss_io_q_addprintprocessor(const char *desc, SPOOL_Q_ADDPRINTPROCESSOR *q_u, prs_struct *ps, int depth)
-{
-	prs_debug(ps, depth, desc, "spoolss_io_q_addprintprocessor");
-	depth++;
-
-	if (!prs_align(ps))
-		return False;
-		
-	if (!prs_uint32("server_ptr", ps, depth, &q_u->server_ptr))
-		return False;
-	if (!smb_io_unistr2("server", &q_u->server, q_u->server_ptr, ps, depth))
-		return False;
-		
-	if (!prs_align(ps))
-		return False;
-	if (!smb_io_unistr2("environment", &q_u->environment, True, ps, depth))
-		return False;
-		
-	if (!prs_align(ps))
-		return False;
-	if (!smb_io_unistr2("path", &q_u->path, True, ps, depth))
-		return False;
-
-	if (!prs_align(ps))
-		return False;
-	if (!smb_io_unistr2("name", &q_u->name, True, ps, depth))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
-********************************************************************/  
-
-BOOL spoolss_io_r_addprintprocessor(const char *desc, SPOOL_R_ADDPRINTPROCESSOR *r_u, prs_struct *ps, int depth)
-{		
-	prs_debug(ps, depth, desc, "spoolss_io_r_addprintproicessor");
-	depth++;
-
-	if (!prs_align(ps))
-		return False;
-		
-	if (!prs_werror("status", ps, depth, &r_u->status))
-		return False;
-
-	return True;		
-}
-
-/*******************************************************************
-********************************************************************/  
-
-BOOL spoolss_io_r_enumprintprocdatatypes(const char *desc, SPOOL_R_ENUMPRINTPROCDATATYPES *r_u, prs_struct *ps, int depth)
-{		
-	prs_debug(ps, depth, desc, "spoolss_io_r_enumprintprocdatatypes");
-	depth++;
-
-	if (!prs_align(ps))
-		return False;
-		
-	if (!spoolss_io_buffer("", ps, depth, &r_u->buffer))
-		return False;
-
-	if (!prs_align(ps))
-		return False;
-		
-	if (!prs_uint32("needed", ps, depth, &r_u->needed))
-		return False;
-		
-	if (!prs_uint32("returned", ps, depth, &r_u->returned))
-		return False;
-		
-	if (!prs_werror("status", ps, depth, &r_u->status))
-		return False;
-
-	return True;		
-}
-
-/*******************************************************************
-********************************************************************/  
-
-BOOL spoolss_io_q_enumprintprocdatatypes(const char *desc, SPOOL_Q_ENUMPRINTPROCDATATYPES *q_u, prs_struct *ps, int depth)
-{
-	prs_debug(ps, depth, desc, "spoolss_io_q_enumprintprocdatatypes");
-	depth++;
-
-	if (!prs_align(ps))
-		return False;
-		
-	if (!prs_uint32("name_ptr", ps, depth, &q_u->name_ptr))
-		return False;
-	if (!smb_io_unistr2("name", &q_u->name, True, ps, depth))
-		return False;
-		
-	if (!prs_align(ps))
-		return False;
-		
-	if (!prs_uint32("processor_ptr", ps, depth, &q_u->processor_ptr))
-		return False;
-	if (!smb_io_unistr2("processor", &q_u->processor, q_u->processor_ptr, ps, depth))
-		return False;
-	
-	if (!prs_align(ps))
-		return False;
-		
-	if (!prs_uint32("level", ps, depth, &q_u->level))
-		return False;
-		
-	if(!spoolss_io_buffer("buffer", ps, depth, &q_u->buffer))
-		return False;
-
-	if (!prs_align(ps))
-		return False;
-
-	if (!prs_uint32("offered", ps, depth, &q_u->offered))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
- Parse a SPOOL_Q_ENUMPRINTMONITORS structure.
-********************************************************************/  
-
-BOOL spoolss_io_q_enumprintmonitors(const char *desc, SPOOL_Q_ENUMPRINTMONITORS *q_u, prs_struct *ps, int depth)
-{
-	prs_debug(ps, depth, desc, "spoolss_io_q_enumprintmonitors");
-	depth++;
-
-	if (!prs_align(ps))
-		return False;
-		
-	if (!prs_uint32("name_ptr", ps, depth, &q_u->name_ptr))
-		return False;
-	if (!smb_io_unistr2("name", &q_u->name, True, ps, depth))
-		return False;
-		
-	if (!prs_align(ps))
-		return False;
-				
-	if (!prs_uint32("level", ps, depth, &q_u->level))
-		return False;
-		
-	if(!spoolss_io_buffer("", ps, depth, &q_u->buffer))
-		return False;
-
-	if (!prs_align(ps))
-		return False;
-
-	if (!prs_uint32("offered", ps, depth, &q_u->offered))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
-********************************************************************/  
-
-BOOL spoolss_io_r_enumprintmonitors(const char *desc, SPOOL_R_ENUMPRINTMONITORS *r_u, prs_struct *ps, int depth)
-{		
-	prs_debug(ps, depth, desc, "spoolss_io_r_enumprintmonitors");
-	depth++;
-
-	if (!prs_align(ps))
-		return False;
-		
-	if (!spoolss_io_buffer("", ps, depth, &r_u->buffer))
-		return False;
-
-	if (!prs_align(ps))
-		return False;
-		
-	if (!prs_uint32("needed", ps, depth, &r_u->needed))
-		return False;
-		
-	if (!prs_uint32("returned", ps, depth, &r_u->returned))
-		return False;
-		
-	if (!prs_werror("status", ps, depth, &r_u->status))
-		return False;
-
-	return True;		
-}
-
-/*******************************************************************
-********************************************************************/  
-
-BOOL spoolss_io_r_enumprinterdata(const char *desc, SPOOL_R_ENUMPRINTERDATA *r_u, prs_struct *ps, int depth)
-{	
-	prs_debug(ps, depth, desc, "spoolss_io_r_enumprinterdata");
-	depth++;
-
-	if(!prs_align(ps))
-		return False;
-	if(!prs_uint32("valuesize", ps, depth, &r_u->valuesize))
-		return False;
-
-	if (UNMARSHALLING(ps) && r_u->valuesize) {
-		r_u->value = (uint16 *)prs_alloc_mem(ps, r_u->valuesize * 2);
-		if (!r_u->value) {
-			ZERODEBUG(0, ("spoolss_io_r_enumprinterdata: out of memory for printerdata value\n"));
-			return False;
-		}
-	}
-
-	if(!prs_uint16uni(False, "value", ps, depth, r_u->value, r_u->valuesize ))
-		return False;
-
-	if(!prs_align(ps))
-		return False;
-
-	if(!prs_uint32("realvaluesize", ps, depth, &r_u->realvaluesize))
-		return False;
-
-	if(!prs_uint32("type", ps, depth, &r_u->type))
-		return False;
-
-	if(!prs_uint32("datasize", ps, depth, &r_u->datasize))
-		return False;
-
-	if (UNMARSHALLING(ps) && r_u->datasize) {
-		r_u->data = (uint8 *)prs_alloc_mem(ps, r_u->datasize);
-		if (!r_u->data) {
-			ZERODEBUG(0, ("spoolss_io_r_enumprinterdata: out of memory for printerdata data\n"));
-			return False;
-		}
-	}
-
-	if(!prs_uint8s(False, "data", ps, depth, r_u->data, r_u->datasize))
-		return False;
-	if(!prs_align(ps))
-		return False;
-
-	if(!prs_uint32("realdatasize", ps, depth, &r_u->realdatasize))
-		return False;
-	if(!prs_werror("status", ps, depth, &r_u->status))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
-********************************************************************/  
-
-BOOL spoolss_io_q_enumprinterdata(const char *desc, SPOOL_Q_ENUMPRINTERDATA *q_u, prs_struct *ps, int depth)
-{
-	prs_debug(ps, depth, desc, "spoolss_io_q_enumprinterdata");
-	depth++;
-
-	if(!prs_align(ps))
-		return False;
-	if(!smb_io_pol_hnd("printer handle",&q_u->handle,ps,depth))
-		return False;
-	if(!prs_uint32("index", ps, depth, &q_u->index))
-		return False;
-	if(!prs_uint32("valuesize", ps, depth, &q_u->valuesize))
-		return False;
-	if(!prs_uint32("datasize", ps, depth, &q_u->datasize))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
-********************************************************************/  
-
-BOOL make_spoolss_q_enumprinterdata(SPOOL_Q_ENUMPRINTERDATA *q_u,
-		const POLICY_HND *hnd,
-		uint32 idx, uint32 valuelen, uint32 datalen)
-{
-	memcpy(&q_u->handle, hnd, sizeof(q_u->handle));
-	q_u->index=idx;
-	q_u->valuesize=valuelen;
-	q_u->datasize=datalen;
-
-	return True;
-}
-
-/*******************************************************************
-********************************************************************/  
-BOOL make_spoolss_q_setprinterdata(SPOOL_Q_SETPRINTERDATA *q_u, TALLOC_CTX *ctx, const POLICY_HND *hnd,
-				char* value, char* data)
-{
-	UNISTR2 tmp;
-
-	memcpy(&q_u->handle, hnd, sizeof(q_u->handle));
-	q_u->type = REG_SZ;
-	init_unistr2(&q_u->value, value, strlen(value)+1);
-
-	init_unistr2(&tmp, data, strlen(data)+1);
-	q_u->max_len = q_u->real_len = tmp.uni_max_len*2;
-	q_u->data = talloc(ctx, q_u->real_len);
-	memcpy(q_u->data, tmp.buffer, q_u->real_len);
-	
-	return True;
-}
-/*******************************************************************
-********************************************************************/  
-
-BOOL spoolss_io_q_setprinterdata(const char *desc, SPOOL_Q_SETPRINTERDATA *q_u, prs_struct *ps, int depth)
-{
-	prs_debug(ps, depth, desc, "spoolss_io_q_setprinterdata");
-	depth++;
-
-	if(!prs_align(ps))
-		return False;
-	if(!smb_io_pol_hnd("printer handle", &q_u->handle, ps, depth))
-		return False;
-	if(!smb_io_unistr2("", &q_u->value, True, ps, depth))
-		return False;
-
-	if(!prs_align(ps))
-		return False;
-
-	if(!prs_uint32("type", ps, depth, &q_u->type))
-		return False;
-
-	if(!prs_uint32("max_len", ps, depth, &q_u->max_len))
-		return False;
-
-	switch (q_u->type)
-	{
-		case REG_SZ:
-		case REG_BINARY:
-		case REG_DWORD:
-		case REG_MULTI_SZ:
-            if (q_u->max_len) {
-                if (UNMARSHALLING(ps))
-    				q_u->data=(uint8 *)prs_alloc_mem(ps, q_u->max_len * sizeof(uint8));
-    			if(q_u->data == NULL)
-    				return False;
-    			if(!prs_uint8s(False,"data", ps, depth, q_u->data, q_u->max_len))
-    				return False;
-            }
-			if(!prs_align(ps))
-				return False;
-			break;
-	}	
-	
-	if(!prs_uint32("real_len", ps, depth, &q_u->real_len))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
-********************************************************************/  
-
-BOOL spoolss_io_r_setprinterdata(const char *desc, SPOOL_R_SETPRINTERDATA *r_u, prs_struct *ps, int depth)
-{
-	prs_debug(ps, depth, desc, "spoolss_io_r_setprinterdata");
-	depth++;
-
-	if(!prs_align(ps))
-		return False;
-	if(!prs_werror("status",     ps, depth, &r_u->status))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
-********************************************************************/  
-BOOL spoolss_io_q_resetprinter(const char *desc, SPOOL_Q_RESETPRINTER *q_u, prs_struct *ps, int depth)
-{
-	prs_debug(ps, depth, desc, "spoolss_io_q_resetprinter");
-	depth++;
-
-	if (!prs_align(ps))
-		return False;
-	if (!smb_io_pol_hnd("printer handle", &q_u->handle, ps, depth))
-		return False;
-
-	if (!prs_uint32("datatype_ptr", ps, depth, &q_u->datatype_ptr))
-		return False;
-		
-	if (q_u->datatype_ptr) {
-		if (!smb_io_unistr2("datatype", &q_u->datatype, q_u->datatype_ptr?True:False, ps, depth))
-			return False;
-	}
-
-	if (!spoolss_io_devmode_cont(desc, &q_u->devmode_ctr, ps, depth))
-		return False;
-
-	return True;
-}
-
-
-/*******************************************************************
-********************************************************************/  
-BOOL spoolss_io_r_resetprinter(const char *desc, SPOOL_R_RESETPRINTER *r_u, prs_struct *ps, int depth)
-{
-	prs_debug(ps, depth, desc, "spoolss_io_r_resetprinter");
-	depth++;
-
-	if(!prs_align(ps))
-		return False;
-	if(!prs_werror("status",     ps, depth, &r_u->status))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
-********************************************************************/  
-BOOL convert_specific_param(NT_PRINTER_PARAM **param, const UNISTR2 *value,
-				uint32 type, const uint8 *data, uint32 len)
-{
-	DEBUG(5,("converting a specific param struct\n"));
-
-	if (*param == NULL)
-	{
-		*param=(NT_PRINTER_PARAM *)malloc(sizeof(NT_PRINTER_PARAM));
-		if(*param == NULL)
-			return False;
-		memset((char *)*param, '\0', sizeof(NT_PRINTER_PARAM));
-		DEBUGADD(6,("Allocated a new PARAM struct\n"));
-	}
-	unistr2_to_dos((*param)->value, value, sizeof((*param)->value)-1);
-	(*param)->type = type;
-	
-	/* le champ data n'est pas NULL termine */
-	/* on stocke donc la longueur */
-	
-	(*param)->data_len=len;
-	
-	if (len) {
-		(*param)->data=(uint8 *)malloc(len * sizeof(uint8));
-		if((*param)->data == NULL)
-			return False;
-		memcpy((*param)->data, data, len);
-	}
-		
-	DEBUGADD(6,("\tvalue:[%s], len:[%d]\n",(*param)->value, (*param)->data_len));
-	dump_data(10, (char *)(*param)->data, (*param)->data_len);
-
-	return True;
-}
-
-/*******************************************************************
-********************************************************************/  
-
-static BOOL spoolss_io_addform(const char *desc, FORM *f, uint32 ptr, prs_struct *ps, int depth)
-{
-	prs_debug(ps, depth, desc, "spoolss_io_addform");
-	depth++;
-	if(!prs_align(ps))
-		return False;
-
-	if (ptr!=0)
-	{
-		if(!prs_uint32("flags",    ps, depth, &f->flags))
-			return False;
-		if(!prs_uint32("name_ptr", ps, depth, &f->name_ptr))
-			return False;
-		if(!prs_uint32("size_x",   ps, depth, &f->size_x))
-			return False;
-		if(!prs_uint32("size_y",   ps, depth, &f->size_y))
-			return False;
-		if(!prs_uint32("left",     ps, depth, &f->left))
-			return False;
-		if(!prs_uint32("top",      ps, depth, &f->top))
-			return False;
-		if(!prs_uint32("right",    ps, depth, &f->right))
-			return False;
-		if(!prs_uint32("bottom",   ps, depth, &f->bottom))
-			return False;
-
-		if(!smb_io_unistr2("", &f->name, f->name_ptr, ps, depth))
-			return False;
-	}
-
-	return True;
-}
-
-/*******************************************************************
-********************************************************************/  
-
-BOOL spoolss_io_q_deleteform(const char *desc, SPOOL_Q_DELETEFORM *q_u, prs_struct *ps, int depth)
-{
-	prs_debug(ps, depth, desc, "spoolss_io_q_deleteform");
-	depth++;
-
-	if(!prs_align(ps))
-		return False;
-	if(!smb_io_pol_hnd("printer handle", &q_u->handle, ps, depth))
-		return False;
-	if(!smb_io_unistr2("form name", &q_u->name, True, ps, depth))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
-********************************************************************/  
-
-BOOL spoolss_io_r_deleteform(const char *desc, SPOOL_R_DELETEFORM *r_u, prs_struct *ps, int depth)
-{
-	prs_debug(ps, depth, desc, "spoolss_io_r_deleteform");
-	depth++;
-
-	if(!prs_align(ps))
-		return False;
-	if(!prs_werror("status",	ps, depth, &r_u->status))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
-********************************************************************/  
-
-BOOL spoolss_io_q_addform(const char *desc, SPOOL_Q_ADDFORM *q_u, prs_struct *ps, int depth)
-{
-	uint32 useless_ptr=1;
-	prs_debug(ps, depth, desc, "spoolss_io_q_addform");
-	depth++;
-
-	if(!prs_align(ps))
-		return False;
-	if(!smb_io_pol_hnd("printer handle", &q_u->handle, ps, depth))
-		return False;
-	if(!prs_uint32("level",  ps, depth, &q_u->level))
-		return False;
-	if(!prs_uint32("level2", ps, depth, &q_u->level2))
-		return False;
-
-	if (q_u->level==1)
-	{
-		if(!prs_uint32("useless_ptr", ps, depth, &useless_ptr))
-			return False;
-		if(!spoolss_io_addform("", &q_u->form, useless_ptr, ps, depth))
-			return False;
-	}
-
-	return True;
-}
-
-/*******************************************************************
-********************************************************************/  
-
-BOOL spoolss_io_r_addform(const char *desc, SPOOL_R_ADDFORM *r_u, prs_struct *ps, int depth)
-{
-	prs_debug(ps, depth, desc, "spoolss_io_r_addform");
-	depth++;
-
-	if(!prs_align(ps))
-		return False;
-	if(!prs_werror("status",	ps, depth, &r_u->status))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
-********************************************************************/  
-
-BOOL spoolss_io_q_setform(const char *desc, SPOOL_Q_SETFORM *q_u, prs_struct *ps, int depth)
-{
-	uint32 useless_ptr=1;
-	prs_debug(ps, depth, desc, "spoolss_io_q_setform");
-	depth++;
-
-	if(!prs_align(ps))
-		return False;
-	if(!smb_io_pol_hnd("printer handle", &q_u->handle, ps, depth))
-		return False;
-	if(!smb_io_unistr2("", &q_u->name, True, ps, depth))
-		return False;
-	      
-	if(!prs_align(ps))
-		return False;
-	
-	if(!prs_uint32("level",  ps, depth, &q_u->level))
-		return False;
-	if(!prs_uint32("level2", ps, depth, &q_u->level2))
-		return False;
-
-	if (q_u->level==1)
-	{
-		if(!prs_uint32("useless_ptr", ps, depth, &useless_ptr))
-			return False;
-		if(!spoolss_io_addform("", &q_u->form, useless_ptr, ps, depth))
-			return False;
-	}
-
-	return True;
-}
-
-/*******************************************************************
-********************************************************************/  
-
-BOOL spoolss_io_r_setform(const char *desc, SPOOL_R_SETFORM *r_u, prs_struct *ps, int depth)
-{
-	prs_debug(ps, depth, desc, "spoolss_io_r_setform");
-	depth++;
-
-	if(!prs_align(ps))
-		return False;
-	if(!prs_werror("status",	ps, depth, &r_u->status))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
- Parse a SPOOL_R_GETJOB structure.
-********************************************************************/  
-
-BOOL spoolss_io_r_getjob(const char *desc, SPOOL_R_GETJOB *r_u, prs_struct *ps, int depth)
-{		
-	prs_debug(ps, depth, desc, "spoolss_io_r_getjob");
-	depth++;
-
-	if (!prs_align(ps))
-		return False;
-		
-	if (!spoolss_io_buffer("", ps, depth, &r_u->buffer))
-		return False;
-
-	if (!prs_align(ps))
-		return False;
-		
-	if (!prs_uint32("needed", ps, depth, &r_u->needed))
-		return False;
-		
-	if (!prs_werror("status", ps, depth, &r_u->status))
-		return False;
-
-	return True;		
-}
-
-/*******************************************************************
- Parse a SPOOL_Q_GETJOB structure.
-********************************************************************/  
-
-BOOL spoolss_io_q_getjob(const char *desc, SPOOL_Q_GETJOB *q_u, prs_struct *ps, int depth)
-{
-	prs_debug(ps, depth, desc, "");
-	depth++;
-
-	if(!prs_align(ps))
-		return False;
-
-	if(!smb_io_pol_hnd("printer handle",&q_u->handle,ps,depth))
-		return False;
-	if(!prs_uint32("jobid", ps, depth, &q_u->jobid))
-		return False;
-	if(!prs_uint32("level", ps, depth, &q_u->level))
-		return False;
-	
-	if(!spoolss_io_buffer("", ps, depth, &q_u->buffer))
-		return False;
-
-	if(!prs_align(ps))
-		return False;
-	
-	if(!prs_uint32("offered", ps, depth, &q_u->offered))
-		return False;
-
-	return True;
-}
-
-void free_devmode(DEVICEMODE *devmode)
-{
-	if (devmode!=NULL) {
-		SAFE_FREE(devmode->private);
-		SAFE_FREE(devmode);
-	}
-}
-
-void free_printer_info_1(PRINTER_INFO_1 *printer)
-{
-	SAFE_FREE(printer);
-}
-
-void free_printer_info_2(PRINTER_INFO_2 *printer)
-{
-	if (printer!=NULL) {
-		free_devmode(printer->devmode);
-		printer->devmode = NULL;
-		SAFE_FREE(printer);
-	}
-}
-
-void free_printer_info_3(PRINTER_INFO_3 *printer)
-{
-	SAFE_FREE(printer);
-}
-
-void free_printer_info_4(PRINTER_INFO_4 *printer)
-{
-	SAFE_FREE(printer);
-}
-
-void free_printer_info_5(PRINTER_INFO_5 *printer)
-{
-	SAFE_FREE(printer);
-}
-
-void free_job_info_2(JOB_INFO_2 *job)
-{
-    if (job!=NULL)
-        free_devmode(job->devmode);
-}
-
-/*******************************************************************
- * init a structure.
- ********************************************************************/
-
-BOOL make_spoolss_q_replyopenprinter(SPOOL_Q_REPLYOPENPRINTER *q_u, 
-			       const fstring string, uint32 printer, uint32 type)
-{      
-	if (q_u == NULL)
-		return False;
-
-	init_unistr2(&q_u->string, string, strlen(string)+1);
-
-	q_u->printer=printer;
-	q_u->type=type;
-
-	q_u->unknown0=0x0;
-	q_u->unknown1=0x0;
-
-	return True;
-}
-
-/*******************************************************************
- Parse a SPOOL_Q_REPLYOPENPRINTER structure.
-********************************************************************/  
-
-BOOL spoolss_io_q_replyopenprinter(const char *desc, SPOOL_Q_REPLYOPENPRINTER *q_u, prs_struct *ps, int depth)
-{
-	prs_debug(ps, depth, desc, "spoolss_io_q_replyopenprinter");
-	depth++;
-
-	if(!prs_align(ps))
-		return False;
-
-	if(!smb_io_unistr2("", &q_u->string, True, ps, depth))
-		return False;
-
-	if(!prs_align(ps))
-		return False;
-
-	if(!prs_uint32("printer", ps, depth, &q_u->printer))
-		return False;
-	if(!prs_uint32("type", ps, depth, &q_u->type))
-		return False;
-	
-	if(!prs_uint32("unknown0", ps, depth, &q_u->unknown0))
-		return False;
-	if(!prs_uint32("unknown1", ps, depth, &q_u->unknown1))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
- Parse a SPOOL_R_REPLYOPENPRINTER structure.
-********************************************************************/  
-
-BOOL spoolss_io_r_replyopenprinter(const char *desc, SPOOL_R_REPLYOPENPRINTER *r_u, prs_struct *ps, int depth)
-{		
-	prs_debug(ps, depth, desc, "spoolss_io_r_replyopenprinter");
-	depth++;
-
-	if (!prs_align(ps))
-		return False;
-
-	if(!smb_io_pol_hnd("printer handle",&r_u->handle,ps,depth))
-		return False;
-
-	if (!prs_werror("status", ps, depth, &r_u->status))
-		return False;
-
-	return True;		
-}
-
-/*******************************************************************
- * init a structure.
- ********************************************************************/
-BOOL make_spoolss_q_routerreplyprinter(SPOOL_Q_ROUTERREPLYPRINTER *q_u, POLICY_HND *hnd, 
-					uint32 condition, uint32 change_id)
-{
-
-	memcpy(&q_u->handle, hnd, sizeof(q_u->handle));
-
-	q_u->condition = condition;
-	q_u->change_id = change_id;
-
-	/* magic values */
-	q_u->unknown1 = 0x1;
-	memset(q_u->unknown2, 0x0, 5);
-	q_u->unknown2[0] = 0x1;
-
-	return True;
-}
-
-/*******************************************************************
- Parse a SPOOL_Q_ROUTERREPLYPRINTER structure.
-********************************************************************/
-BOOL spoolss_io_q_routerreplyprinter (const char *desc, SPOOL_Q_ROUTERREPLYPRINTER *q_u, prs_struct *ps, int depth)
-{
-
-	prs_debug(ps, depth, desc, "spoolss_io_q_routerreplyprinter");
-	depth++;
-
-	if (!prs_align(ps))
-		return False;
-
-	if(!smb_io_pol_hnd("printer handle",&q_u->handle,ps,depth))
-		return False;
-
-	if (!prs_uint32("condition", ps, depth, &q_u->condition))
-		return False;
-
-	if (!prs_uint32("unknown1", ps, depth, &q_u->unknown1))
-		return False;
-
-	if (!prs_uint32("change_id", ps, depth, &q_u->change_id))
-		return False;
-
-	if (!prs_uint8s(False, "private",  ps, depth, q_u->unknown2, 5))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
- Parse a SPOOL_R_ROUTERREPLYPRINTER structure.
-********************************************************************/
-BOOL spoolss_io_r_routerreplyprinter (const char *desc, SPOOL_R_ROUTERREPLYPRINTER *r_u, prs_struct *ps, int depth)
-{
-	prs_debug(ps, depth, desc, "spoolss_io_r_routerreplyprinter");
-	depth++;
-
-	if (!prs_align(ps))
-		return False;
-
-	if (!prs_werror("status", ps, depth, &r_u->status))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
- * init a structure.
- ********************************************************************/
-
-BOOL make_spoolss_q_reply_closeprinter(SPOOL_Q_REPLYCLOSEPRINTER *q_u, POLICY_HND *hnd)
-{      
-	if (q_u == NULL)
-		return False;
-
-	memcpy(&q_u->handle, hnd, sizeof(q_u->handle));
-
-	return True;
-}
-
-/*******************************************************************
- Parse a SPOOL_Q_REPLYCLOSEPRINTER structure.
-********************************************************************/  
-
-BOOL spoolss_io_q_replycloseprinter(const char *desc, SPOOL_Q_REPLYCLOSEPRINTER *q_u, prs_struct *ps, int depth)
-{
-	prs_debug(ps, depth, desc, "spoolss_io_q_replycloseprinter");
-	depth++;
-
-	if(!prs_align(ps))
-		return False;
-
-	if(!smb_io_pol_hnd("printer handle",&q_u->handle,ps,depth))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
- Parse a SPOOL_R_REPLYCLOSEPRINTER structure.
-********************************************************************/  
-
-BOOL spoolss_io_r_replycloseprinter(const char *desc, SPOOL_R_REPLYCLOSEPRINTER *r_u, prs_struct *ps, int depth)
-{		
-	prs_debug(ps, depth, desc, "spoolss_io_r_replycloseprinter");
-	depth++;
-
-	if (!prs_align(ps))
-		return False;
-
-	if(!smb_io_pol_hnd("printer handle",&r_u->handle,ps,depth))
-		return False;
-
-	if (!prs_werror("status", ps, depth, &r_u->status))
-		return False;
-
-	return True;		
-}
-
-#if 0	/* JERRY - not currently used but could be :-) */
-
-/*******************************************************************
- Deep copy a SPOOL_NOTIFY_INFO_DATA structure
- ******************************************************************/
-static BOOL copy_spool_notify_info_data(SPOOL_NOTIFY_INFO_DATA *dst, 
-				SPOOL_NOTIFY_INFO_DATA *src, int n)
-{
-	int i;
-
-	memcpy(dst, src, sizeof(SPOOL_NOTIFY_INFO_DATA)*n);
-	
-	for (i=0; i<n; i++) {
-		int len;
-		uint16 *s = NULL;
-		
-		if (src->size != POINTER) 
-			continue;
-		len = src->notify_data.data.length;
-		s = malloc(sizeof(uint16)*len);
-		if (s == NULL) {
-			ZERODEBUG(0,("copy_spool_notify_info_data: malloc() failed!\n"));
-			return False;
-		}
-		
-		memcpy(s, src->notify_data.data.string, len*2);
-		dst->notify_data.data.string = s;
-	}
-	
-	return True;
-}
-
-/*******************************************************************
- Deep copy a SPOOL_NOTIFY_INFO structure
- ******************************************************************/
-static BOOL copy_spool_notify_info(SPOOL_NOTIFY_INFO *dst, SPOOL_NOTIFY_INFO *src)
-{
-	if (!dst) {
-		ZERODEBUG(0,("copy_spool_notify_info: NULL destination pointer!\n"));
-		return False;
-	}
-		
-	dst->version = src->version;
-	dst->flags   = src->flags;
-	dst->count   = src->count;
-	
-	if (dst->count) 
-	{
-		dst->data = malloc(dst->count * sizeof(SPOOL_NOTIFY_INFO_DATA));
-		
-		DEBUG(10,("copy_spool_notify_info: allocating space for [%d] PRINTER_NOTIFY_INFO_DATA entries\n",
-			dst->count));
-
-		if (dst->data == NULL) {
-			ZERODEBUG(0,("copy_spool_notify_info: malloc() failed for [%d] entries!\n", 
-				dst->count));
-			return False;
-		}
-		
-		return (copy_spool_notify_info_data(dst->data, src->data, src->count));
-	}
-	
-	return True;
-}
-#endif	/* JERRY */
-
-/*******************************************************************
- * init a structure.
- ********************************************************************/
-
-BOOL make_spoolss_q_reply_rrpcn(SPOOL_Q_REPLY_RRPCN *q_u, POLICY_HND *hnd,
-			        uint32 change_low, uint32 change_high,
-				SPOOL_NOTIFY_INFO *info)
-{      
-	if (q_u == NULL)
-		return False;
-
-	memcpy(&q_u->handle, hnd, sizeof(q_u->handle));
-
-	q_u->change_low=change_low;
-	q_u->change_high=change_high;
-
-	q_u->unknown0=0x0;
-	q_u->unknown1=0x0;
-
-	q_u->info_ptr=0xaddee11e;
-
-	q_u->info.version=2;
-	
-	if (info->count) {
-		DEBUG(10,("make_spoolss_q_reply_rrpcn: [%d] PRINTER_NOTIFY_INFO_DATA\n",
-			info->count));
-		q_u->info.version = info->version;
-		q_u->info.flags   = info->flags;
-		q_u->info.count   = info->count;
-		/* pointer field - be careful! */
-		q_u->info.data    = info->data;
-	}
-	else  {
-		q_u->info.flags=PRINTER_NOTIFY_INFO_DISCARDED;
-		q_u->info.count=0;
-	}
-
-	return True;
-}
-
-/*******************************************************************
- Parse a SPOOL_Q_REPLY_RRPCN structure.
-********************************************************************/  
-
-BOOL spoolss_io_q_reply_rrpcn(const char *desc, SPOOL_Q_REPLY_RRPCN *q_u, prs_struct *ps, int depth)
-{
-	prs_debug(ps, depth, desc, "spoolss_io_q_reply_rrpcn");
-	depth++;
-
-	if(!prs_align(ps))
-		return False;
-
-	if(!smb_io_pol_hnd("printer handle",&q_u->handle,ps,depth))
-		return False;
-
-	if (!prs_uint32("change_low", ps, depth, &q_u->change_low))
-		return False;
-
-	if (!prs_uint32("change_high", ps, depth, &q_u->change_high))
-		return False;
-
-	if (!prs_uint32("unknown0", ps, depth, &q_u->unknown0))
-		return False;
-
-	if (!prs_uint32("unknown1", ps, depth, &q_u->unknown1))
-		return False;
-
-	if (!prs_uint32("info_ptr", ps, depth, &q_u->info_ptr))
-		return False;
-
-	if(q_u->info_ptr!=0)
-		if(!smb_io_notify_info(desc, &q_u->info, ps, depth))
-			return False;
-		
-	return True;
-}
-
-/*******************************************************************
- Parse a SPOOL_R_REPLY_RRPCN structure.
-********************************************************************/  
-
-BOOL spoolss_io_r_reply_rrpcn(const char *desc, SPOOL_R_REPLY_RRPCN *r_u, prs_struct *ps, int depth)
-{		
-	prs_debug(ps, depth, desc, "spoolss_io_r_reply_rrpcn");
-	depth++;
-
-	if (!prs_align(ps))
-		return False;
-
-	if (!prs_uint32("unknown0", ps, depth, &r_u->unknown0))
-		return False;
-
-	if (!prs_werror("status", ps, depth, &r_u->status))
-		return False;
-
-	return True;		
-}
-
-/*******************************************************************
- * read a structure.
- * called from spoolss_q_getprinterdataex (srv_spoolss.c)
- ********************************************************************/
-
-BOOL spoolss_io_q_getprinterdataex(const char *desc, SPOOL_Q_GETPRINTERDATAEX *q_u, prs_struct *ps, int depth)
-{
-	if (q_u == NULL)
-		return False;
-
-	prs_debug(ps, depth, desc, "spoolss_io_q_getprinterdataex");
-	depth++;
-
-	if (!prs_align(ps))
-		return False;
-	if (!smb_io_pol_hnd("printer handle",&q_u->handle,ps,depth))
-		return False;
-	if (!prs_align(ps))
-		return False;
-	if (!smb_io_unistr2("keyname", &q_u->keyname,True,ps,depth))
-		return False;
-	if (!prs_align(ps))
-		return False;
-	if (!smb_io_unistr2("valuename", &q_u->valuename,True,ps,depth))
-		return False;
-	if (!prs_align(ps))
-		return False;
-	if (!prs_uint32("size", ps, depth, &q_u->size))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
- * write a structure.
- * called from spoolss_r_getprinterdataex (srv_spoolss.c)
- ********************************************************************/
-
-BOOL spoolss_io_r_getprinterdataex(const char *desc, SPOOL_R_GETPRINTERDATAEX *r_u, prs_struct *ps, int depth)
-{
-	if (r_u == NULL)
-		return False;
-
-	prs_debug(ps, depth, desc, "spoolss_io_r_getprinterdataex");
-	depth++;
-
-	if (!prs_align(ps))
-		return False;
-	if (!prs_uint32("type", ps, depth, &r_u->type))
-		return False;
-	if (!prs_uint32("size", ps, depth, &r_u->size))
-		return False;
-	
-	if (UNMARSHALLING(ps) && r_u->size) {
-		r_u->data = prs_alloc_mem(ps, r_u->size);
-		if(!r_u->data)
-			return False;
-	}
-
-	if (!prs_uint8s(False,"data", ps, depth, r_u->data, r_u->size))
-		return False;
-		
-	if (!prs_align(ps))
-		return False;
-	
-	if (!prs_uint32("needed", ps, depth, &r_u->needed))
-		return False;
-	if (!prs_werror("status", ps, depth, &r_u->status))
-		return False;
-		
-	return True;
-}
-
-/*******************************************************************
- * read a structure.
- ********************************************************************/  
-
-BOOL spoolss_io_q_setprinterdataex(const char *desc, SPOOL_Q_SETPRINTERDATAEX *q_u, prs_struct *ps, int depth)
-{
-	prs_debug(ps, depth, desc, "spoolss_io_q_setprinterdataex");
-	depth++;
-
-	if(!prs_align(ps))
-		return False;
-	if(!smb_io_pol_hnd("printer handle", &q_u->handle, ps, depth))
-		return False;
-	if(!smb_io_unistr2("", &q_u->key, True, ps, depth))
-		return False;
-
-	if(!prs_align(ps))
-		return False;
-
-	if(!smb_io_unistr2("", &q_u->value, True, ps, depth))
-		return False;
-
-	if(!prs_align(ps))
-		return False;
-
-	if(!prs_uint32("type", ps, depth, &q_u->type))
-		return False;
-
-	if(!prs_uint32("max_len", ps, depth, &q_u->max_len))
-		return False;
-
-	switch (q_u->type)
-	{
-		case 0x1:
-		case 0x3:
-		case 0x4:
-		case 0x7:
-			if (q_u->max_len) {
-				if (UNMARSHALLING(ps))
-    					q_u->data=(uint8 *)prs_alloc_mem(ps, q_u->max_len * sizeof(uint8));
-    				if(q_u->data == NULL)
-    					return False;
-    				if(!prs_uint8s(False,"data", ps, depth, q_u->data, q_u->max_len))
-    					return False;
-			}
-			if(!prs_align(ps))
-				return False;
-			break;
-	}	
-	
-	if(!prs_uint32("real_len", ps, depth, &q_u->real_len))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
- * write a structure.
- ********************************************************************/  
-
-BOOL spoolss_io_r_setprinterdataex(const char *desc, SPOOL_R_SETPRINTERDATAEX *r_u, prs_struct *ps, int depth)
-{
-	prs_debug(ps, depth, desc, "spoolss_io_r_setprinterdataex");
-	depth++;
-
-	if(!prs_align(ps))
-		return False;
-	if(!prs_werror("status",     ps, depth, &r_u->status))
-		return False;
-
-	return True;
-}
-
-
-/*******************************************************************
- * read a structure.
- ********************************************************************/  
-
-BOOL spoolss_io_q_enumprinterkey(const char *desc, SPOOL_Q_ENUMPRINTERKEY *q_u, prs_struct *ps, int depth)
-{
-	prs_debug(ps, depth, desc, "spoolss_io_q_enumprinterkey");
-	depth++;
-
-	if(!prs_align(ps))
-		return False;
-	if(!smb_io_pol_hnd("printer handle", &q_u->handle, ps, depth))
-		return False;
-		
-	if(!smb_io_unistr2("", &q_u->key, True, ps, depth))
-		return False;
-
-	if(!prs_align(ps))
-		return False;
-	
-	if(!prs_uint32("size", ps, depth, &q_u->size))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
- * write a structure.
- ********************************************************************/  
-
-BOOL spoolss_io_r_enumprinterkey(const char *desc, SPOOL_R_ENUMPRINTERKEY *r_u, prs_struct *ps, int depth)
-{
-	prs_debug(ps, depth, desc, "spoolss_io_r_enumprinterkey");
-	depth++;
-
-	if(!prs_align(ps))
-		return False;
-
-	if (!smb_io_buffer5("", &r_u->keys, ps, depth))
-		return False;
-	
-	if(!prs_align(ps))
-		return False;
-
-	if(!prs_uint32("needed",     ps, depth, &r_u->needed))
-		return False;
-
-	if(!prs_werror("status",     ps, depth, &r_u->status))
-		return False;
-
-	return True;
-}
-
-
-/*******************************************************************
- * read a structure.
- ********************************************************************/  
-
-BOOL spoolss_io_q_enumprinterdataex(const char *desc, SPOOL_Q_ENUMPRINTERDATAEX *q_u, prs_struct *ps, int depth)
-{
-	prs_debug(ps, depth, desc, "spoolss_io_q_enumprinterdataex");
-	depth++;
-
-	if(!prs_align(ps))
-		return False;
-	if(!smb_io_pol_hnd("printer handle", &q_u->handle, ps, depth))
-		return False;
-		
-	if(!smb_io_unistr2("", &q_u->key, True, ps, depth))
-		return False;
-
-	if(!prs_align(ps))
-		return False;
-	
-	if(!prs_uint32("size", ps, depth, &q_u->size))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
-********************************************************************/  
-
-static BOOL spoolss_io_printer_enum_values_ctr(const char *desc, prs_struct *ps, 
-				PRINTER_ENUM_VALUES_CTR *ctr, int depth)
-{
-	int 	i;
-	uint32	valuename_offset,
-		data_offset,
-		current_offset;
-	const uint32 basic_unit = 20; /* size of static portion of enum_values */
-	
-	prs_debug(ps, depth, desc, "spoolss_io_printer_enum_values_ctr");
-	depth++;	
-	
-	/* 
-	 * offset data begins at 20 bytes per structure * size_of_array.
-	 * Don't forget the uint32 at the beginning 
-	 * */
-	
-	current_offset = basic_unit * ctr->size_of_array;
-	
-	/* first loop to write basic enum_value information */
-	
-	if (UNMARSHALLING(ps)) {
-		ctr->values = (PRINTER_ENUM_VALUES *)prs_alloc_mem(
-			ps, ctr->size_of_array * sizeof(PRINTER_ENUM_VALUES));
-		if (!ctr->values)
-			return False;
-	}
-
-	for (i=0; i<ctr->size_of_array; i++) {
-		valuename_offset = current_offset;
-		if (!prs_uint32("valuename_offset", ps, depth, &valuename_offset))
-			return False;
-
-		if (!prs_uint32("value_len", ps, depth, &ctr->values[i].value_len))
-			return False;
-	
-		if (!prs_uint32("type", ps, depth, &ctr->values[i].type))
-			return False;
-	
-		data_offset = ctr->values[i].value_len + valuename_offset;
-		
-		if (!prs_uint32("data_offset", ps, depth, &data_offset))
-			return False;
-
-		if (!prs_uint32("data_len", ps, depth, &ctr->values[i].data_len))
-			return False;
-			
-		current_offset  = data_offset + ctr->values[i].data_len - basic_unit;
-		/* account for 2 byte alignment */
-		current_offset += (current_offset % 2);
-	}
-
-	/* 
-	 * loop #2 for writing the dynamically size objects; pay 
-	 * attention to 2-byte alignment here....
-	 */
-	
-	for (i=0; i<ctr->size_of_array; i++) {
-	
-		if (!prs_unistr("valuename", ps, depth, &ctr->values[i].valuename))
-			return False;
-		
-		if (UNMARSHALLING(ps)) {
-			ctr->values[i].data = (uint8 *)prs_alloc_mem(
-				ps, ctr->values[i].data_len);
-			if (!ctr->values[i].data)
-				return False;
-		}
-
-		if (!prs_uint8s(False, "data", ps, depth, ctr->values[i].data, ctr->values[i].data_len))
-			return False;
-			
-		if ( !prs_align_uint16(ps) )
-			return False;
-	}
-
-	return True;	
-}
-
-/*******************************************************************
- * write a structure.
- ********************************************************************/  
-
-BOOL spoolss_io_r_enumprinterdataex(const char *desc, SPOOL_R_ENUMPRINTERDATAEX *r_u, prs_struct *ps, int depth)
-{
-	uint32 data_offset, end_offset;
-	prs_debug(ps, depth, desc, "spoolss_io_r_enumprinterdataex");
-	depth++;
-
-	if(!prs_align(ps))
-		return False;
-
-	if (!prs_uint32("size", ps, depth, &r_u->ctr.size))
-		return False;
-
-	data_offset = prs_offset(ps);
-
-	if (!prs_set_offset(ps, data_offset + r_u->ctr.size))
-		return False;
-
-	if(!prs_align(ps))
-		return False;
-
-	if(!prs_uint32("needed",     ps, depth, &r_u->needed))
-		return False;
-
-	if(!prs_uint32("returned",   ps, depth, &r_u->returned))
-		return False;
-
-	if(!prs_werror("status",     ps, depth, &r_u->status))
-		return False;
-
-	r_u->ctr.size_of_array = r_u->returned;
-
-	end_offset = prs_offset(ps);
-
-	if (!prs_set_offset(ps, data_offset))
-		return False;
-
-	if (r_u->ctr.size)
-		if (!spoolss_io_printer_enum_values_ctr("", ps, &r_u->ctr, depth ))
-			return False;
-
-	if (!prs_set_offset(ps, end_offset))
-		return False;
-																	        	return True;
-}
-
-/*******************************************************************
- * write a structure.
- ********************************************************************/  
-
-/* 
-   uint32 GetPrintProcessorDirectory(
-       [in] unistr2 *name,
-       [in] unistr2 *environment,
-       [in] uint32 level,
-       [in,out] NEW_BUFFER buffer,
-       [in] uint32 offered,
-       [out] uint32 needed,
-       [out] uint32 returned
-   );
-
-*/
-
-BOOL make_spoolss_q_getprintprocessordirectory(SPOOL_Q_GETPRINTPROCESSORDIRECTORY *q_u, const char *name, char *environment, int level, NEW_BUFFER *buffer, uint32 offered)
-{
-	DEBUG(5,("make_spoolss_q_getprintprocessordirectory\n"));
-
-	init_unistr2(&q_u->name, name, strlen(name)+1);
-	init_unistr2(&q_u->environment, environment, strlen(environment)+1);
-
-	q_u->level = level;
-
-	q_u->buffer = buffer;
-	q_u->offered = offered;
-
-	return True;
-}
-
-BOOL spoolss_io_q_getprintprocessordirectory(const char *desc, SPOOL_Q_GETPRINTPROCESSORDIRECTORY *q_u, prs_struct *ps, int depth)
-{
-	uint32 ptr;
-
-	prs_debug(ps, depth, desc, "spoolss_io_q_getprintprocessordirectory");
-	depth++;
-
-	if(!prs_align(ps))
-		return False;	
-
-	if (!prs_uint32("ptr", ps, depth, &ptr)) 
-		return False;
-
-	if (ptr) {
-		if(!smb_io_unistr2("name", &q_u->name, True, ps, depth))
-			return False;
-	}
-
-	if (!prs_align(ps))
-		return False;
-
-	if (!prs_uint32("ptr", ps, depth, &ptr))
-		return False;
-
-	if (ptr) {
-		if(!smb_io_unistr2("environment", &q_u->environment, True, 
-				   ps, depth))
-			return False;
-	}
-
-	if (!prs_align(ps))
-		return False;
-
-	if(!prs_uint32("level",   ps, depth, &q_u->level))
-		return False;
-
-	if(!spoolss_io_buffer("", ps, depth, &q_u->buffer))
-		return False;
-	
-	if(!prs_align(ps))
-		return False;
-
-	if(!prs_uint32("offered", ps, depth, &q_u->offered))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
- * write a structure.
- ********************************************************************/  
-
-BOOL spoolss_io_r_getprintprocessordirectory(const char *desc, SPOOL_R_GETPRINTPROCESSORDIRECTORY *r_u, prs_struct *ps, int depth)
-{
-	prs_debug(ps, depth, desc, "spoolss_io_r_getprintprocessordirectory");
-	depth++;
-
-	if(!prs_align(ps))
-		return False;
-
-	if(!spoolss_io_buffer("", ps, depth, &r_u->buffer))
-		return False;
-	
-	if(!prs_align(ps))
-		return False;
-
-	if(!prs_uint32("needed",     ps, depth, &r_u->needed))
-		return False;
-		
-	if(!prs_werror("status",     ps, depth, &r_u->status))
-		return False;
-
-	return True;
-}
-
-BOOL smb_io_printprocessordirectory_1(const char *desc, NEW_BUFFER *buffer, PRINTPROCESSOR_DIRECTORY_1 *info, int depth)
-{
-	prs_struct *ps=&buffer->prs;
-
-	prs_debug(ps, depth, desc, "smb_io_printprocessordirectory_1");
-	depth++;
-
-	buffer->struct_start=prs_offset(ps);
-
-	if (!smb_io_unistr(desc, &info->name, ps, depth))
-		return False;
-
-	return True;
-}
-
-/*******************************************************************
- * init a structure.
- ********************************************************************/
-
-BOOL make_spoolss_q_addform(SPOOL_Q_ADDFORM *q_u, POLICY_HND *handle, 
-			    int level, FORM *form)
-{
-	memcpy(&q_u->handle, handle, sizeof(POLICY_HND));
-	q_u->level = level;
-	q_u->level2 = level;
-	memcpy(&q_u->form, form, sizeof(FORM));
-
-	return True;
-}
-
-/*******************************************************************
- * init a structure.
- ********************************************************************/
-
-BOOL make_spoolss_q_setform(SPOOL_Q_SETFORM *q_u, POLICY_HND *handle, 
-			    int level, char *form_name, FORM *form)
-{
-	memcpy(&q_u->handle, handle, sizeof(POLICY_HND));
-	q_u->level = level;
-	q_u->level2 = level;
-	memcpy(&q_u->form, form, sizeof(FORM));
-	init_unistr2(&q_u->name, form_name, strlen(form_name) + 1);
-
-	return True;
-}
-
-/*******************************************************************
- * init a structure.
- ********************************************************************/
-
-BOOL make_spoolss_q_deleteform(SPOOL_Q_DELETEFORM *q_u, POLICY_HND *handle, char *form)
-{
-	memcpy(&q_u->handle, handle, sizeof(POLICY_HND));
-	init_unistr2(&q_u->name, form, strlen(form) + 1);
-	return True;
-}
-
-/*******************************************************************
- * init a structure.
- ********************************************************************/
-
-BOOL make_spoolss_q_getform(SPOOL_Q_GETFORM *q_u, POLICY_HND *handle, 
-                            char *formname, uint32 level, NEW_BUFFER *buffer,
-			    uint32 offered)
-{
-        memcpy(&q_u->handle, handle, sizeof(POLICY_HND));
-        q_u->level = level;
-        init_unistr2(&q_u->formname, formname, strlen(formname) + 1);
-        q_u->buffer=buffer;
-        q_u->offered=offered;
-
-        return True;
-}
-
-/*******************************************************************
- * init a structure.
- ********************************************************************/
-
-BOOL make_spoolss_q_enumforms(SPOOL_Q_ENUMFORMS *q_u, POLICY_HND *handle, 
-			      uint32 level, NEW_BUFFER *buffer,
-			      uint32 offered)
-{
-        memcpy(&q_u->handle, handle, sizeof(POLICY_HND));
-        q_u->level = level;
-        q_u->buffer=buffer;
-        q_u->offered=offered;
-
-	return True;
-}
diff -Naur samba-2.2.12-orig/source/rpc_server/srv_pipe.c samba-2.2.12/source/rpc_server/srv_pipe.c
--- samba-2.2.12-orig/source/rpc_server/srv_pipe.c	2011-03-04 13:51:45.000000000 +0100
+++ samba-2.2.12/source/rpc_server/srv_pipe.c	2011-03-04 13:16:13.000000000 +0100
@@ -515,7 +515,6 @@
     { "wkssvc",   "ntsvcs",  api_wkssvc_rpc },
     { "NETLOGON", "lsass",   api_netlog_rpc },
     { "winreg",   "winreg",  api_reg_rpc },
-    { "spoolss",  "spoolss", api_spoolss_rpc },
 #ifdef WITH_MSDFS
     { "netdfs",   "netdfs" , api_netdfs_rpc },
 #endif
diff -Naur samba-2.2.12-orig/source/rpc_server/srv_spoolss.c samba-2.2.12/source/rpc_server/srv_spoolss.c
--- samba-2.2.12-orig/source/rpc_server/srv_spoolss.c	2011-03-04 13:51:45.000000000 +0100
+++ samba-2.2.12/source/rpc_server/srv_spoolss.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1464 +0,0 @@
-/* 
- *  Unix SMB/CIFS implementation.
- *  RPC Pipe client / server routines
- *  Copyright (C) Andrew Tridgell              1992-2000,
- *  Copyright (C) Luke Kenneth Casson Leighton 1996-2000,
- *  Copyright (C) Jean Franois Micouleau      1998-2000.
- *  Copyright (C) Jeremy Allison					2001.
- *  
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *  
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *  
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- */
-
-#include "includes.h"
-
-/********************************************************************
- * api_spoolss_open_printer_ex (rarely seen - older call)
- ********************************************************************/
-
-static BOOL api_spoolss_open_printer(pipes_struct *p)
-{
-	SPOOL_Q_OPEN_PRINTER q_u;
-	SPOOL_R_OPEN_PRINTER r_u;
-	prs_struct *data = &p->in_data.data;
-	prs_struct *rdata = &p->out_data.rdata;
-
-	ZERO_STRUCT(q_u);
-	ZERO_STRUCT(r_u);
-
-	if (!spoolss_io_q_open_printer("", &q_u, data, 0)) {
-		ZERODEBUG(0,("spoolss_io_q_open_printer: unable to unmarshall SPOOL_Q_OPEN_PRINTER.\n"));
-		return False;
-	}
-
-	r_u.status = _spoolss_open_printer( p, &q_u, &r_u);
-	
-	if (!spoolss_io_r_open_printer("",&r_u,rdata,0)){
-		ZERODEBUG(0,("spoolss_io_r_open_printer: unable to marshall SPOOL_R_OPEN_PRINTER.\n"));
-		return False;
-	}
-
-	return True;
-}
-
-
-/********************************************************************
- * api_spoolss_open_printer_ex
- ********************************************************************/
-
-static BOOL api_spoolss_open_printer_ex(pipes_struct *p)
-{
-	SPOOL_Q_OPEN_PRINTER_EX q_u;
-	SPOOL_R_OPEN_PRINTER_EX r_u;
-	prs_struct *data = &p->in_data.data;
-	prs_struct *rdata = &p->out_data.rdata;
-
-	ZERO_STRUCT(q_u);
-	ZERO_STRUCT(r_u);
-
-	if (!spoolss_io_q_open_printer_ex("", &q_u, data, 0)) {
-		ZERODEBUG(0,("spoolss_io_q_open_printer_ex: unable to unmarshall SPOOL_Q_OPEN_PRINTER_EX.\n"));
-		return False;
-	}
-
-	r_u.status = _spoolss_open_printer_ex( p, &q_u, &r_u);
-
-	if (!spoolss_io_r_open_printer_ex("",&r_u,rdata,0)){
-		ZERODEBUG(0,("spoolss_io_r_open_printer_ex: unable to marshall SPOOL_R_OPEN_PRINTER_EX.\n"));
-		return False;
-	}
-
-	return True;
-}
-
-/********************************************************************
- * api_spoolss_getprinterdata
- *
- * called from the spoolss dispatcher
- ********************************************************************/
-
-static BOOL api_spoolss_getprinterdata(pipes_struct *p)
-{
-	SPOOL_Q_GETPRINTERDATA q_u;
-	SPOOL_R_GETPRINTERDATA r_u;
-	prs_struct *data = &p->in_data.data;
-	prs_struct *rdata = &p->out_data.rdata;
-
-	ZERO_STRUCT(q_u);
-	ZERO_STRUCT(r_u);
-
-	/* read the stream and fill the struct */
-	if (!spoolss_io_q_getprinterdata("", &q_u, data, 0)) {
-		ZERODEBUG(0,("spoolss_io_q_getprinterdata: unable to unmarshall SPOOL_Q_GETPRINTERDATA.\n"));
-		return False;
-	}
-	
-	r_u.status = _spoolss_getprinterdata( p, &q_u, &r_u);
-
-	if (!spoolss_io_r_getprinterdata("", &r_u, rdata, 0)) {
-		ZERODEBUG(0,("spoolss_io_r_getprinterdata: unable to marshall SPOOL_R_GETPRINTERDATA.\n"));
-		return False;
-	}
-
-	return True;
-}
-
-/********************************************************************
- * api_spoolss_deleteprinterdata
- *
- * called from the spoolss dispatcher
- ********************************************************************/
-
-static BOOL api_spoolss_deleteprinterdata(pipes_struct *p)
-{
-	SPOOL_Q_DELETEPRINTERDATA q_u;
-	SPOOL_R_DELETEPRINTERDATA r_u;
-	prs_struct *data = &p->in_data.data;
-	prs_struct *rdata = &p->out_data.rdata;
-
-	ZERO_STRUCT(q_u);
-	ZERO_STRUCT(r_u);
-
-	/* read the stream and fill the struct */
-	if (!spoolss_io_q_deleteprinterdata("", &q_u, data, 0)) {
-		ZERODEBUG(0,("spoolss_io_q_deleteprinterdata: unable to unmarshall SPOOL_Q_DELETEPRINTERDATA.\n"));
-		return False;
-	}
-	
-	r_u.status = _spoolss_deleteprinterdata( p, &q_u, &r_u);
-
-	if (!spoolss_io_r_deleteprinterdata("", &r_u, rdata, 0)) {
-		ZERODEBUG(0,("spoolss_io_r_deleteprinterdata: unable to marshall SPOOL_R_DELETEPRINTERDATA.\n"));
-		return False;
-	}
-
-	return True;
-}
-
-/********************************************************************
- * api_spoolss_closeprinter
- *
- * called from the spoolss dispatcher
- ********************************************************************/
-
-static BOOL api_spoolss_closeprinter(pipes_struct *p)
-{
-	SPOOL_Q_CLOSEPRINTER q_u;
-	SPOOL_R_CLOSEPRINTER r_u;
-	prs_struct *data = &p->in_data.data;
-	prs_struct *rdata = &p->out_data.rdata;
-
-	ZERO_STRUCT(q_u);
-	ZERO_STRUCT(r_u);
-
-	if (!spoolss_io_q_closeprinter("", &q_u, data, 0)) {
-		ZERODEBUG(0,("spoolss_io_q_closeprinter: unable to unmarshall SPOOL_Q_CLOSEPRINTER.\n"));
-		return False;
-	}
-
-	r_u.status = _spoolss_closeprinter(p, &q_u, &r_u);
-
-	if (!spoolss_io_r_closeprinter("",&r_u,rdata,0)) {
-		ZERODEBUG(0,("spoolss_io_r_closeprinter: unable to marshall SPOOL_R_CLOSEPRINTER.\n"));
-		return False;
-	}
-
-	return True;
-}
-
-/********************************************************************
- * api_spoolss_abortprinter
- *
- * called from the spoolss dispatcher
- ********************************************************************/
-
-static BOOL api_spoolss_abortprinter(pipes_struct *p)
-{
-	SPOOL_Q_ABORTPRINTER q_u;
-	SPOOL_R_ABORTPRINTER r_u;
-	prs_struct *data = &p->in_data.data;
-	prs_struct *rdata = &p->out_data.rdata;
-
-	ZERO_STRUCT(q_u);
-	ZERO_STRUCT(r_u);
-
-	if (!spoolss_io_q_abortprinter("", &q_u, data, 0)) {
-		ZERODEBUG(0,("spoolss_io_q_abortprinter: unable to unmarshall SPOOL_Q_ABORTPRINTER.\n"));
-		return False;
-	}
-
-	r_u.status = _spoolss_abortprinter(p, &q_u, &r_u);
-
-	if (!spoolss_io_r_abortprinter("",&r_u,rdata,0)) {
-		ZERODEBUG(0,("spoolss_io_r_abortprinter: unable to marshall SPOOL_R_ABORTPRINTER.\n"));
-		return False;
-	}
-
-	return True;
-}
-
-/********************************************************************
- * api_spoolss_deleteprinter
- *
- * called from the spoolss dispatcher
- ********************************************************************/
-
-static BOOL api_spoolss_deleteprinter(pipes_struct *p)
-{
-	SPOOL_Q_DELETEPRINTER q_u;
-	SPOOL_R_DELETEPRINTER r_u;
-	prs_struct *data = &p->in_data.data;
-	prs_struct *rdata = &p->out_data.rdata;
-
-	ZERO_STRUCT(q_u);
-	ZERO_STRUCT(r_u);
-
-	if (!spoolss_io_q_deleteprinter("", &q_u, data, 0)) {
-		ZERODEBUG(0,("spoolss_io_q_deleteprinter: unable to unmarshall SPOOL_Q_DELETEPRINTER.\n"));
-		return False;
-	}
-
-	r_u.status = _spoolss_deleteprinter(p, &q_u, &r_u);
-
-	if (!spoolss_io_r_deleteprinter("",&r_u,rdata,0)) {
-		ZERODEBUG(0,("spoolss_io_r_deleteprinter: unable to marshall SPOOL_R_DELETEPRINTER.\n"));
-		return False;
-	}
-
-	return True;
-}
-
-
-/********************************************************************
- * api_spoolss_deleteprinterdriver
- *
- * called from the spoolss dispatcher
- ********************************************************************/
-
-static BOOL api_spoolss_deleteprinterdriver(pipes_struct *p)
-{
-	SPOOL_Q_DELETEPRINTERDRIVER q_u;
-	SPOOL_R_DELETEPRINTERDRIVER r_u;
-	prs_struct *data = &p->in_data.data;
-	prs_struct *rdata = &p->out_data.rdata;
-
-	ZERO_STRUCT(q_u);
-	ZERO_STRUCT(r_u);
-
-	if (!spoolss_io_q_deleteprinterdriver("", &q_u, data, 0)) {
-		ZERODEBUG(0,("spoolss_io_q_deleteprinterdriver: unable to unmarshall SPOOL_Q_DELETEPRINTERDRIVER.\n"));
-		return False;
-	}
-
-	r_u.status = _spoolss_deleteprinterdriver(p, &q_u, &r_u);
-
-	if (!spoolss_io_r_deleteprinterdriver("",&r_u,rdata,0)) {
-		ZERODEBUG(0,("spoolss_io_r_deleteprinter: unable to marshall SPOOL_R_DELETEPRINTER.\n"));
-		return False;
-	}
-
-	return True;
-}
-
-
-/********************************************************************
- * api_spoolss_rffpcnex
- * ReplyFindFirstPrinterChangeNotifyEx
- ********************************************************************/
-
-static BOOL api_spoolss_rffpcnex(pipes_struct *p)
-{
-	SPOOL_Q_RFFPCNEX q_u;
-	SPOOL_R_RFFPCNEX r_u;
-	prs_struct *data = &p->in_data.data;
-	prs_struct *rdata = &p->out_data.rdata;
-
-	ZERO_STRUCT(q_u);
-	ZERO_STRUCT(r_u);
-
-	if (!spoolss_io_q_rffpcnex("", &q_u, data, 0)) {
-		ZERODEBUG(0,("spoolss_io_q_rffpcnex: unable to unmarshall SPOOL_Q_RFFPCNEX.\n"));
-		return False;
-	}
-
-	r_u.status = _spoolss_rffpcnex(p, &q_u, &r_u);
-
-	if (!spoolss_io_r_rffpcnex("", &r_u, rdata, 0)) {
-		ZERODEBUG(0,("spoolss_io_r_rffpcnex: unable to marshall SPOOL_R_RFFPCNEX.\n"));
-		return False;
-	}
-
-	return True;
-}
-
-
-/********************************************************************
- * api_spoolss_rfnpcnex
- * ReplyFindNextPrinterChangeNotifyEx
- * called from the spoolss dispatcher
-
- * Note - this is the *ONLY* function that breaks the RPC call
- * symmetry in all the other calls. We need to do this to fix
- * the massive memory allocation problem with thousands of jobs...
- * JRA.
- ********************************************************************/
-
-static BOOL api_spoolss_rfnpcnex(pipes_struct *p)
-{
-	SPOOL_Q_RFNPCNEX q_u;
-	SPOOL_R_RFNPCNEX r_u;
-	prs_struct *data = &p->in_data.data;
-	prs_struct *rdata = &p->out_data.rdata;
-
-	ZERO_STRUCT(q_u);
-	ZERO_STRUCT(r_u);
-
-	if (!spoolss_io_q_rfnpcnex("", &q_u, data, 0)) {
-		ZERODEBUG(0,("spoolss_io_q_rfnpcnex: unable to unmarshall SPOOL_Q_RFNPCNEX.\n"));
-		return False;
-	}
-
-	r_u.status = _spoolss_rfnpcnex(p, &q_u, &r_u);
-
-	if (!spoolss_io_r_rfnpcnex("", &r_u, rdata, 0)) {
-		SAFE_FREE(r_u.info.data);
-		ZERODEBUG(0,("spoolss_io_r_rfnpcnex: unable to marshall SPOOL_R_RFNPCNEX.\n"));
-		return False;
-	}
-
-	SAFE_FREE(r_u.info.data);
-
-	return True;
-}
-
-
-/********************************************************************
- * api_spoolss_enumprinters
- * called from the spoolss dispatcher
- *
- ********************************************************************/
-
-static BOOL api_spoolss_enumprinters(pipes_struct *p)
-{
-	SPOOL_Q_ENUMPRINTERS q_u;
-	SPOOL_R_ENUMPRINTERS r_u;
-	prs_struct *data = &p->in_data.data;
-	prs_struct *rdata = &p->out_data.rdata;
-
-	ZERO_STRUCT(q_u);
-	ZERO_STRUCT(r_u);
-
-	if (!spoolss_io_q_enumprinters("", &q_u, data, 0)) {
-		ZERODEBUG(0,("spoolss_io_q_enumprinters: unable to unmarshall SPOOL_Q_ENUMPRINTERS.\n"));
-		return False;
-	}
-
-	r_u.status = _spoolss_enumprinters( p, &q_u, &r_u);
-
-	if (!spoolss_io_r_enumprinters("", &r_u, rdata, 0)) {
-		ZERODEBUG(0,("spoolss_io_r_enumprinters: unable to marshall SPOOL_R_ENUMPRINTERS.\n"));
-		return False;
-	}
-
-	return True;
-}
-
-/********************************************************************
- * api_spoolss_getprinter
- * called from the spoolss dispatcher
- *
- ********************************************************************/
-
-static BOOL api_spoolss_getprinter(pipes_struct *p)
-{
-	SPOOL_Q_GETPRINTER q_u;
-	SPOOL_R_GETPRINTER r_u;
-	prs_struct *data = &p->in_data.data;
-	prs_struct *rdata = &p->out_data.rdata;
-
-	ZERO_STRUCT(q_u);
-	ZERO_STRUCT(r_u);
-
-	if(!spoolss_io_q_getprinter("", &q_u, data, 0)) {
-		ZERODEBUG(0,("spoolss_io_q_getprinter: unable to unmarshall SPOOL_Q_GETPRINTER.\n"));
-		return False;
-	}
-
-	r_u.status = _spoolss_getprinter(p, &q_u, &r_u);
-
-	if(!spoolss_io_r_getprinter("",&r_u,rdata,0)) {
-		ZERODEBUG(0,("spoolss_io_r_getprinter: unable to marshall SPOOL_R_GETPRINTER.\n"));
-		return False;
-	}
-
-	return True;
-}
-
-/********************************************************************
- * api_spoolss_getprinter
- * called from the spoolss dispatcher
- *
- ********************************************************************/
-
-static BOOL api_spoolss_getprinterdriver2(pipes_struct *p)
-{
-	SPOOL_Q_GETPRINTERDRIVER2 q_u;
-	SPOOL_R_GETPRINTERDRIVER2 r_u;
-	prs_struct *data = &p->in_data.data;
-	prs_struct *rdata = &p->out_data.rdata;
-
-	ZERO_STRUCT(q_u);
-	ZERO_STRUCT(r_u);
-
-	if(!spoolss_io_q_getprinterdriver2("", &q_u, data, 0)) {
-		ZERODEBUG(0,("spoolss_io_q_getprinterdriver2: unable to unmarshall SPOOL_Q_GETPRINTERDRIVER2.\n"));
-		return False;
-	}
-
-	r_u.status = _spoolss_getprinterdriver2(p, &q_u, &r_u);
-	
-	if(!spoolss_io_r_getprinterdriver2("",&r_u,rdata,0)) {
-		ZERODEBUG(0,("spoolss_io_r_getprinterdriver2: unable to marshall SPOOL_R_GETPRINTERDRIVER2.\n"));
-		return False;
-	}
-	
-	return True;
-}
-
-/********************************************************************
- * api_spoolss_getprinter
- * called from the spoolss dispatcher
- *
- ********************************************************************/
-
-static BOOL api_spoolss_startpageprinter(pipes_struct *p)
-{
-	SPOOL_Q_STARTPAGEPRINTER q_u;
-	SPOOL_R_STARTPAGEPRINTER r_u;
-	prs_struct *data = &p->in_data.data;
-	prs_struct *rdata = &p->out_data.rdata;
-
-	ZERO_STRUCT(q_u);
-	ZERO_STRUCT(r_u);
-
-	if(!spoolss_io_q_startpageprinter("", &q_u, data, 0)) {
-		ZERODEBUG(0,("spoolss_io_q_startpageprinter: unable to unmarshall SPOOL_Q_STARTPAGEPRINTER.\n"));
-		return False;
-	}
-
-	r_u.status = _spoolss_startpageprinter(p, &q_u, &r_u);
-
-	if(!spoolss_io_r_startpageprinter("",&r_u,rdata,0)) {
-		ZERODEBUG(0,("spoolss_io_r_startpageprinter: unable to marshall SPOOL_R_STARTPAGEPRINTER.\n"));
-		return False;
-	}
-
-	return True;
-}
-
-/********************************************************************
- * api_spoolss_getprinter
- * called from the spoolss dispatcher
- *
- ********************************************************************/
-
-static BOOL api_spoolss_endpageprinter(pipes_struct *p)
-{
-	SPOOL_Q_ENDPAGEPRINTER q_u;
-	SPOOL_R_ENDPAGEPRINTER r_u;
-	prs_struct *data = &p->in_data.data;
-	prs_struct *rdata = &p->out_data.rdata;
-
-	ZERO_STRUCT(q_u);
-	ZERO_STRUCT(r_u);
-
-	if(!spoolss_io_q_endpageprinter("", &q_u, data, 0)) {
-		ZERODEBUG(0,("spoolss_io_q_endpageprinter: unable to unmarshall SPOOL_Q_ENDPAGEPRINTER.\n"));
-		return False;
-	}
-
-	r_u.status = _spoolss_endpageprinter(p, &q_u, &r_u);
-
-	if(!spoolss_io_r_endpageprinter("",&r_u,rdata,0)) {
-		ZERODEBUG(0,("spoolss_io_r_endpageprinter: unable to marshall SPOOL_R_ENDPAGEPRINTER.\n"));
-		return False;
-	}
-
-	return True;
-}
-
-/********************************************************************
-********************************************************************/
-
-static BOOL api_spoolss_startdocprinter(pipes_struct *p)
-{
-	SPOOL_Q_STARTDOCPRINTER q_u;
-	SPOOL_R_STARTDOCPRINTER r_u;
-	prs_struct *data = &p->in_data.data;
-	prs_struct *rdata = &p->out_data.rdata;
-
-	ZERO_STRUCT(q_u);
-	ZERO_STRUCT(r_u);
-
-	if(!spoolss_io_q_startdocprinter("", &q_u, data, 0)) {
-		ZERODEBUG(0,("spoolss_io_q_startdocprinter: unable to unmarshall SPOOL_Q_STARTDOCPRINTER.\n"));
-		return False;
-	}
-
-	r_u.status = _spoolss_startdocprinter(p, &q_u, &r_u);
-
-	if(!spoolss_io_r_startdocprinter("",&r_u,rdata,0)) {
-		ZERODEBUG(0,("spoolss_io_r_startdocprinter: unable to marshall SPOOL_R_STARTDOCPRINTER.\n"));
-		return False;
-	}
-
-	return True;
-}
-
-/********************************************************************
-********************************************************************/
-
-static BOOL api_spoolss_enddocprinter(pipes_struct *p)
-{
-	SPOOL_Q_ENDDOCPRINTER q_u;
-	SPOOL_R_ENDDOCPRINTER r_u;
-	prs_struct *data = &p->in_data.data;
-	prs_struct *rdata = &p->out_data.rdata;
-
-	ZERO_STRUCT(q_u);
-	ZERO_STRUCT(r_u);
-
-	if(!spoolss_io_q_enddocprinter("", &q_u, data, 0)) {
-		ZERODEBUG(0,("spoolss_io_q_enddocprinter: unable to unmarshall SPOOL_Q_ENDDOCPRINTER.\n"));
-		return False;
-	}
-
-	r_u.status = _spoolss_enddocprinter(p, &q_u, &r_u);
-
-	if(!spoolss_io_r_enddocprinter("",&r_u,rdata,0)) {
-		ZERODEBUG(0,("spoolss_io_r_enddocprinter: unable to marshall SPOOL_R_ENDDOCPRINTER.\n"));
-		return False;
-	}
-
-	return True;		
-}
-
-/********************************************************************
-********************************************************************/
-
-static BOOL api_spoolss_writeprinter(pipes_struct *p)
-{
-	SPOOL_Q_WRITEPRINTER q_u;
-	SPOOL_R_WRITEPRINTER r_u;
-	prs_struct *data = &p->in_data.data;
-	prs_struct *rdata = &p->out_data.rdata;
-
-	ZERO_STRUCT(q_u);
-	ZERO_STRUCT(r_u);
-
-	if(!spoolss_io_q_writeprinter("", &q_u, data, 0)) {
-		ZERODEBUG(0,("spoolss_io_q_writeprinter: unable to unmarshall SPOOL_Q_WRITEPRINTER.\n"));
-		return False;
-	}
-
-	r_u.status = _spoolss_writeprinter(p, &q_u, &r_u);
-
-	if(!spoolss_io_r_writeprinter("",&r_u,rdata,0)) {
-		ZERODEBUG(0,("spoolss_io_r_writeprinter: unable to marshall SPOOL_R_WRITEPRINTER.\n"));
-		return False;
-	}
-
-	return True;
-}
-
-/****************************************************************************
-
-****************************************************************************/
-
-static BOOL api_spoolss_setprinter(pipes_struct *p)
-{
-	SPOOL_Q_SETPRINTER q_u;
-	SPOOL_R_SETPRINTER r_u;
-	prs_struct *data = &p->in_data.data;
-	prs_struct *rdata = &p->out_data.rdata;
-
-	ZERO_STRUCT(q_u);
-	ZERO_STRUCT(r_u);
-
-	if(!spoolss_io_q_setprinter("", &q_u, data, 0)) {
-		ZERODEBUG(0,("spoolss_io_q_setprinter: unable to unmarshall SPOOL_Q_SETPRINTER.\n"));
-		return False;
-	}
-	
-	r_u.status = _spoolss_setprinter(p, &q_u, &r_u);
-	
-	if(!spoolss_io_r_setprinter("",&r_u,rdata,0)) {
-		ZERODEBUG(0,("spoolss_io_r_setprinter: unable to marshall SPOOL_R_SETPRINTER.\n"));
-		return False;
-	}
-
-	return True;
-}
-
-/****************************************************************************
-****************************************************************************/
-
-static BOOL api_spoolss_fcpn(pipes_struct *p)
-{
-	SPOOL_Q_FCPN q_u;
-	SPOOL_R_FCPN r_u;
-	prs_struct *data = &p->in_data.data;
-	prs_struct *rdata = &p->out_data.rdata;
-
-	ZERO_STRUCT(q_u);
-	ZERO_STRUCT(r_u);
-
-	if(!spoolss_io_q_fcpn("", &q_u, data, 0)) {
-		ZERODEBUG(0,("spoolss_io_q_fcpn: unable to unmarshall SPOOL_Q_FCPN.\n"));
-		return False;
-	}
-
-	r_u.status = _spoolss_fcpn(p, &q_u, &r_u);
-
-	if(!spoolss_io_r_fcpn("",&r_u,rdata,0)) {
-		ZERODEBUG(0,("spoolss_io_r_fcpn: unable to marshall SPOOL_R_FCPN.\n"));
-		return False;
-	}
-
-	return True;
-}
-
-/****************************************************************************
-****************************************************************************/
-
-static BOOL api_spoolss_addjob(pipes_struct *p)
-{
-	SPOOL_Q_ADDJOB q_u;
-	SPOOL_R_ADDJOB r_u;
-	prs_struct *data = &p->in_data.data;
-	prs_struct *rdata = &p->out_data.rdata;
-
-	ZERO_STRUCT(q_u);
-	ZERO_STRUCT(r_u);
-
-	if(!spoolss_io_q_addjob("", &q_u, data, 0)) {
-		ZERODEBUG(0,("spoolss_io_q_addjob: unable to unmarshall SPOOL_Q_ADDJOB.\n"));
-		return False;
-	}
-
-	r_u.status = _spoolss_addjob(p, &q_u, &r_u);
-		
-	if(!spoolss_io_r_addjob("",&r_u,rdata,0)) {
-		ZERODEBUG(0,("spoolss_io_r_addjob: unable to marshall SPOOL_R_ADDJOB.\n"));
-		return False;
-	}
-
-	return True;		
-}
-
-/****************************************************************************
-****************************************************************************/
-
-static BOOL api_spoolss_enumjobs(pipes_struct *p)
-{
-	SPOOL_Q_ENUMJOBS q_u;
-	SPOOL_R_ENUMJOBS r_u;
-	prs_struct *data = &p->in_data.data;
-	prs_struct *rdata = &p->out_data.rdata;
-
-	ZERO_STRUCT(q_u);
-	ZERO_STRUCT(r_u);
-
-	if (!spoolss_io_q_enumjobs("", &q_u, data, 0)) {
-		ZERODEBUG(0,("spoolss_io_q_enumjobs: unable to unmarshall SPOOL_Q_ENUMJOBS.\n"));
-		return False;
-	}
-
-	r_u.status = _spoolss_enumjobs(p, &q_u, &r_u);
-
-	if (!spoolss_io_r_enumjobs("",&r_u,rdata,0)) {
-		ZERODEBUG(0,("spoolss_io_r_enumjobs: unable to marshall SPOOL_R_ENUMJOBS.\n"));
-		return False;
-	}
-
-	return True;
-}
-
-/****************************************************************************
-****************************************************************************/
-
-static BOOL api_spoolss_schedulejob(pipes_struct *p)
-{
-	SPOOL_Q_SCHEDULEJOB q_u;
-	SPOOL_R_SCHEDULEJOB r_u;
-	prs_struct *data = &p->in_data.data;
-	prs_struct *rdata = &p->out_data.rdata;
-
-	ZERO_STRUCT(q_u);
-	ZERO_STRUCT(r_u);
-
-	if(!spoolss_io_q_schedulejob("", &q_u, data, 0)) {
-		ZERODEBUG(0,("spoolss_io_q_schedulejob: unable to unmarshall SPOOL_Q_SCHEDULEJOB.\n"));
-		return False;
-	}
-
-	r_u.status = _spoolss_schedulejob(p, &q_u, &r_u);
-
-	if(!spoolss_io_r_schedulejob("",&r_u,rdata,0)) {
-		ZERODEBUG(0,("spoolss_io_r_schedulejob: unable to marshall SPOOL_R_SCHEDULEJOB.\n"));
-		return False;
-	}
-
-	return True;
-}
-
-/****************************************************************************
-****************************************************************************/
-
-static BOOL api_spoolss_setjob(pipes_struct *p)
-{
-	SPOOL_Q_SETJOB q_u;
-	SPOOL_R_SETJOB r_u;
-	prs_struct *data = &p->in_data.data;
-	prs_struct *rdata = &p->out_data.rdata;
-
-	ZERO_STRUCT(q_u);
-	ZERO_STRUCT(r_u);
-
-	if(!spoolss_io_q_setjob("", &q_u, data, 0)) {
-		ZERODEBUG(0,("spoolss_io_q_setjob: unable to unmarshall SPOOL_Q_SETJOB.\n"));
-		return False;
-	}
-
-	r_u.status = _spoolss_setjob(p, &q_u, &r_u);
-
-	if(!spoolss_io_r_setjob("",&r_u,rdata,0)) {
-		ZERODEBUG(0,("spoolss_io_r_setjob: unable to marshall SPOOL_R_SETJOB.\n"));
-		return False;
-	}
-
-	return True;
-}
-
-/****************************************************************************
-****************************************************************************/
-
-static BOOL api_spoolss_enumprinterdrivers(pipes_struct *p)
-{
-	SPOOL_Q_ENUMPRINTERDRIVERS q_u;
-	SPOOL_R_ENUMPRINTERDRIVERS r_u;
-	prs_struct *data = &p->in_data.data;
-	prs_struct *rdata = &p->out_data.rdata;
-
-	ZERO_STRUCT(q_u);
-	ZERO_STRUCT(r_u);
-
-	if (!spoolss_io_q_enumprinterdrivers("", &q_u, data, 0)) {
-		ZERODEBUG(0,("spoolss_io_q_enumprinterdrivers: unable to unmarshall SPOOL_Q_ENUMPRINTERDRIVERS.\n"));
-		return False;
-	}
-
-	r_u.status = _spoolss_enumprinterdrivers(p, &q_u, &r_u);
-
-	if (!spoolss_io_r_enumprinterdrivers("",&r_u,rdata,0)) {
-		ZERODEBUG(0,("spoolss_io_r_enumprinterdrivers: unable to marshall SPOOL_R_ENUMPRINTERDRIVERS.\n"));
-		return False;
-	}
-
-	return True;
-}
-
-/****************************************************************************
-****************************************************************************/
-
-static BOOL api_spoolss_getform(pipes_struct *p)
-{
-	SPOOL_Q_GETFORM q_u;
-	SPOOL_R_GETFORM r_u;
-	prs_struct *data = &p->in_data.data;
-	prs_struct *rdata = &p->out_data.rdata;
-
-	ZERO_STRUCT(q_u);
-	ZERO_STRUCT(r_u);
-
-	if (!spoolss_io_q_getform("", &q_u, data, 0)) {
-		ZERODEBUG(0,("spoolss_io_q_getform: unable to unmarshall SPOOL_Q_GETFORM.\n"));
-		return False;
-	}
-
-	r_u.status = _spoolss_getform(p, &q_u, &r_u);
-
-	if (!spoolss_io_r_getform("",&r_u,rdata,0)) {
-		ZERODEBUG(0,("spoolss_io_r_getform: unable to marshall SPOOL_R_GETFORM.\n"));
-		return False;
-	}
-
-	return True;
-}
-
-/****************************************************************************
-****************************************************************************/
-
-static BOOL api_spoolss_enumforms(pipes_struct *p)
-{
-	SPOOL_Q_ENUMFORMS q_u;
-	SPOOL_R_ENUMFORMS r_u;
-	prs_struct *data = &p->in_data.data;
-	prs_struct *rdata = &p->out_data.rdata;
-
-	ZERO_STRUCT(q_u);
-	ZERO_STRUCT(r_u);
-
-	if (!spoolss_io_q_enumforms("", &q_u, data, 0)) {
-		ZERODEBUG(0,("spoolss_io_q_enumforms: unable to unmarshall SPOOL_Q_ENUMFORMS.\n"));
-		return False;
-	}
-
-	r_u.status = _spoolss_enumforms(p, &q_u, &r_u);
-
-	if (!spoolss_io_r_enumforms("",&r_u,rdata,0)) {
-		ZERODEBUG(0,("spoolss_io_r_enumforms: unable to marshall SPOOL_R_ENUMFORMS.\n"));
-		return False;
-	}
-
-	return True;
-}
-
-/****************************************************************************
-****************************************************************************/
-
-static BOOL api_spoolss_enumports(pipes_struct *p)
-{
-	SPOOL_Q_ENUMPORTS q_u;
-	SPOOL_R_ENUMPORTS r_u;
-	prs_struct *data = &p->in_data.data;
-	prs_struct *rdata = &p->out_data.rdata;
-
-	ZERO_STRUCT(q_u);
-	ZERO_STRUCT(r_u);
-
-	if(!spoolss_io_q_enumports("", &q_u, data, 0)) {
-		ZERODEBUG(0,("spoolss_io_q_enumports: unable to unmarshall SPOOL_Q_ENUMPORTS.\n"));
-		return False;
-	}
-
-	r_u.status = _spoolss_enumports(p, &q_u, &r_u);
-
-	if (!spoolss_io_r_enumports("",&r_u,rdata,0)) {
-		ZERODEBUG(0,("spoolss_io_r_enumports: unable to marshall SPOOL_R_ENUMPORTS.\n"));
-		return False;
-	}
-
-	return True;
-}
-
-/****************************************************************************
-****************************************************************************/
-
-static BOOL api_spoolss_addprinterex(pipes_struct *p)
-{
-	SPOOL_Q_ADDPRINTEREX q_u;
-	SPOOL_R_ADDPRINTEREX r_u;
-	prs_struct *data = &p->in_data.data;
-	prs_struct *rdata = &p->out_data.rdata;
-	
-	ZERO_STRUCT(q_u);
-	ZERO_STRUCT(r_u);
-	
-	if(!spoolss_io_q_addprinterex("", &q_u, data, 0)) {
-		ZERODEBUG(0,("spoolss_io_q_addprinterex: unable to unmarshall SPOOL_Q_ADDPRINTEREX.\n"));
-		return False;
-	}
-	
-	r_u.status = _spoolss_addprinterex(p, &q_u, &r_u);
-				
-	if(!spoolss_io_r_addprinterex("", &r_u, rdata, 0)) {
-		ZERODEBUG(0,("spoolss_io_r_addprinterex: unable to marshall SPOOL_R_ADDPRINTEREX.\n"));
-		return False;
-	}
-	
-	return True;
-}
-
-/****************************************************************************
-****************************************************************************/
-
-static BOOL api_spoolss_addprinterdriver(pipes_struct *p)
-{
-	SPOOL_Q_ADDPRINTERDRIVER q_u;
-	SPOOL_R_ADDPRINTERDRIVER r_u;
-	prs_struct *data = &p->in_data.data;
-	prs_struct *rdata = &p->out_data.rdata;
-	
-	ZERO_STRUCT(q_u);
-	ZERO_STRUCT(r_u);
-	
-	if(!spoolss_io_q_addprinterdriver("", &q_u, data, 0)) {
-		ZERODEBUG(0,("spoolss_io_q_addprinterdriver: unable to unmarshall SPOOL_Q_ADDPRINTERDRIVER.\n"));
-		return False;
-	}
-	
-	r_u.status = _spoolss_addprinterdriver(p, &q_u, &r_u);
-				
-	if(!spoolss_io_r_addprinterdriver("", &r_u, rdata, 0)) {
-		ZERODEBUG(0,("spoolss_io_r_addprinterdriver: unable to marshall SPOOL_R_ADDPRINTERDRIVER.\n"));
-		return False;
-	}
-	
-	return True;
-}
-
-/****************************************************************************
-****************************************************************************/
-
-static BOOL api_spoolss_getprinterdriverdirectory(pipes_struct *p)
-{
-	SPOOL_Q_GETPRINTERDRIVERDIR q_u;
-	SPOOL_R_GETPRINTERDRIVERDIR r_u;
-	prs_struct *data = &p->in_data.data;
-	prs_struct *rdata = &p->out_data.rdata;
-
-	ZERO_STRUCT(q_u);
-	ZERO_STRUCT(r_u);
-
-	if(!spoolss_io_q_getprinterdriverdir("", &q_u, data, 0)) {
-		ZERODEBUG(0,("spoolss_io_q_getprinterdriverdir: unable to unmarshall SPOOL_Q_GETPRINTERDRIVERDIR.\n"));
-		return False;
-	}
-
-	r_u.status = _spoolss_getprinterdriverdirectory(p, &q_u, &r_u);
-
-	if(!spoolss_io_r_getprinterdriverdir("", &r_u, rdata, 0)) {
-		ZERODEBUG(0,("spoolss_io_r_getprinterdriverdir: unable to marshall SPOOL_R_GETPRINTERDRIVERDIR.\n"));
-		return False;
-	}
-
-	return True;
-}
-
-/****************************************************************************
-****************************************************************************/
-
-static BOOL api_spoolss_enumprinterdata(pipes_struct *p)
-{
-	SPOOL_Q_ENUMPRINTERDATA q_u;
-	SPOOL_R_ENUMPRINTERDATA r_u;
-	prs_struct *data = &p->in_data.data;
-	prs_struct *rdata = &p->out_data.rdata;
-	
-	ZERO_STRUCT(q_u);
-	ZERO_STRUCT(r_u);
-	
-	if(!spoolss_io_q_enumprinterdata("", &q_u, data, 0)) {
-		ZERODEBUG(0,("spoolss_io_q_enumprinterdata: unable to unmarshall SPOOL_Q_ENUMPRINTERDATA.\n"));
-		return False;
-	}
-	
-	r_u.status = _spoolss_enumprinterdata(p, &q_u, &r_u);
-				
-	if(!spoolss_io_r_enumprinterdata("", &r_u, rdata, 0)) {
-		ZERODEBUG(0,("spoolss_io_r_enumprinterdata: unable to marshall SPOOL_R_ENUMPRINTERDATA.\n"));
-		return False;
-	}
-
-	return True;
-}
-
-/****************************************************************************
-****************************************************************************/
-
-static BOOL api_spoolss_setprinterdata(pipes_struct *p)
-{
-	SPOOL_Q_SETPRINTERDATA q_u;
-	SPOOL_R_SETPRINTERDATA r_u;
-	prs_struct *data = &p->in_data.data;
-	prs_struct *rdata = &p->out_data.rdata;
-	
-	ZERO_STRUCT(q_u);
-	ZERO_STRUCT(r_u);
-	
-	if(!spoolss_io_q_setprinterdata("", &q_u, data, 0)) {
-		ZERODEBUG(0,("spoolss_io_q_setprinterdata: unable to unmarshall SPOOL_Q_SETPRINTERDATA.\n"));
-		return False;
-	}
-	
-	r_u.status = _spoolss_setprinterdata(p, &q_u, &r_u);
-				
-	if(!spoolss_io_r_setprinterdata("", &r_u, rdata, 0)) {
-		ZERODEBUG(0,("spoolss_io_r_setprinterdata: unable to marshall SPOOL_R_SETPRINTERDATA.\n"));
-		return False;
-	}
-
-	return True;
-}
-
-/****************************************************************************
-****************************************************************************/
-static BOOL api_spoolss_reset_printer(pipes_struct *p)
-{
-	SPOOL_Q_RESETPRINTER q_u;
-	SPOOL_R_RESETPRINTER r_u;
-	prs_struct *data = &p->in_data.data;
-	prs_struct *rdata = &p->out_data.rdata;
-
-	ZERO_STRUCT(q_u);
-	ZERO_STRUCT(r_u);
-
-	if(!spoolss_io_q_resetprinter("", &q_u, data, 0)) {
-		ZERODEBUG(0,("spoolss_io_q_setprinterdata: unable to unmarshall SPOOL_Q_SETPRINTERDATA.\n"));
-		return False;
-	}
-	
-	r_u.status = _spoolss_resetprinter(p, &q_u, &r_u);
-				
-	if(!spoolss_io_r_resetprinter("", &r_u, rdata, 0)) {
-		ZERODEBUG(0,("spoolss_io_r_setprinterdata: unable to marshall SPOOL_R_RESETPRINTER.\n"));
-		return False;
-	}
-
-	return True;
-}
-
-/****************************************************************************
-****************************************************************************/
-static BOOL api_spoolss_addform(pipes_struct *p)
-{
-	SPOOL_Q_ADDFORM q_u;
-	SPOOL_R_ADDFORM r_u;
-	prs_struct *data = &p->in_data.data;
-	prs_struct *rdata = &p->out_data.rdata;
-
-	ZERO_STRUCT(q_u);
-	ZERO_STRUCT(r_u);
-	
-	if(!spoolss_io_q_addform("", &q_u, data, 0)) {
-		ZERODEBUG(0,("spoolss_io_q_addform: unable to unmarshall SPOOL_Q_ADDFORM.\n"));
-		return False;
-	}
-	
-	r_u.status = _spoolss_addform(p, &q_u, &r_u);
-	
-	if(!spoolss_io_r_addform("", &r_u, rdata, 0)) {
-		ZERODEBUG(0,("spoolss_io_r_addform: unable to marshall SPOOL_R_ADDFORM.\n"));
-		return False;
-	}
-
-	return True;
-}
-
-/****************************************************************************
-****************************************************************************/
-
-static BOOL api_spoolss_deleteform(pipes_struct *p)
-{
-	SPOOL_Q_DELETEFORM q_u;
-	SPOOL_R_DELETEFORM r_u;
-	prs_struct *data = &p->in_data.data;
-	prs_struct *rdata = &p->out_data.rdata;
-
-	ZERO_STRUCT(q_u);
-	ZERO_STRUCT(r_u);
-	
-	if(!spoolss_io_q_deleteform("", &q_u, data, 0)) {
-		ZERODEBUG(0,("spoolss_io_q_deleteform: unable to unmarshall SPOOL_Q_DELETEFORM.\n"));
-		return False;
-	}
-	
-	r_u.status = _spoolss_deleteform(p, &q_u, &r_u);
-	
-	if(!spoolss_io_r_deleteform("", &r_u, rdata, 0)) {
-		ZERODEBUG(0,("spoolss_io_r_deleteform: unable to marshall SPOOL_R_DELETEFORM.\n"));
-		return False;
-	}
-
-	return True;
-}
-
-/****************************************************************************
-****************************************************************************/
-
-static BOOL api_spoolss_setform(pipes_struct *p)
-{
-	SPOOL_Q_SETFORM q_u;
-	SPOOL_R_SETFORM r_u;
-	prs_struct *data = &p->in_data.data;
-	prs_struct *rdata = &p->out_data.rdata;
-
-	ZERO_STRUCT(q_u);
-	ZERO_STRUCT(r_u);
-	
-	if(!spoolss_io_q_setform("", &q_u, data, 0)) {
-		ZERODEBUG(0,("spoolss_io_q_setform: unable to unmarshall SPOOL_Q_SETFORM.\n"));
-		return False;
-	}
-	
-	r_u.status = _spoolss_setform(p, &q_u, &r_u);
-				      
-	if(!spoolss_io_r_setform("", &r_u, rdata, 0)) {
-		ZERODEBUG(0,("spoolss_io_r_setform: unable to marshall SPOOL_R_SETFORM.\n"));
-		return False;
-	}
-
-	return True;
-}
-
-/****************************************************************************
-****************************************************************************/
-
-static BOOL api_spoolss_enumprintprocessors(pipes_struct *p)
-{
-	SPOOL_Q_ENUMPRINTPROCESSORS q_u;
-	SPOOL_R_ENUMPRINTPROCESSORS r_u;
-	prs_struct *data = &p->in_data.data;
-	prs_struct *rdata = &p->out_data.rdata;
-
-	ZERO_STRUCT(q_u);
-	ZERO_STRUCT(r_u);
-	
-	if(!spoolss_io_q_enumprintprocessors("", &q_u, data, 0)) {
-		ZERODEBUG(0,("spoolss_io_q_enumprintprocessors: unable to unmarshall SPOOL_Q_ENUMPRINTPROCESSORS.\n"));
-		return False;
-	}
-	
-	r_u.status = _spoolss_enumprintprocessors(p, &q_u, &r_u);
-
-	if(!spoolss_io_r_enumprintprocessors("", &r_u, rdata, 0)) {
-		ZERODEBUG(0,("spoolss_io_r_enumprintprocessors: unable to marshall SPOOL_R_ENUMPRINTPROCESSORS.\n"));
-		return False;
-	}
-	
-	return True;
-}
-
-/****************************************************************************
-****************************************************************************/
-
-static BOOL api_spoolss_addprintprocessor(pipes_struct *p)
-{
-	SPOOL_Q_ADDPRINTPROCESSOR q_u;
-	SPOOL_R_ADDPRINTPROCESSOR r_u;
-	prs_struct *data = &p->in_data.data;
-	prs_struct *rdata = &p->out_data.rdata;
-
-	ZERO_STRUCT(q_u);
-	ZERO_STRUCT(r_u);
-	
-	if(!spoolss_io_q_addprintprocessor("", &q_u, data, 0)) {
-		ZERODEBUG(0,("spoolss_io_q_addprintprocessor: unable to unmarshall SPOOL_Q_ADDPRINTPROCESSOR.\n"));
-		return False;
-	}
-	
-	/* for now, just indicate success and ignore the add.  We'll
-	   automatically set the winprint processor for printer
-	   entries later.  Used to debug the LexMark Optra S 1855 PCL
-	   driver --jerry */
-	r_u.status = WERR_OK;
-
-	if(!spoolss_io_r_addprintprocessor("", &r_u, rdata, 0)) {
-		ZERODEBUG(0,("spoolss_io_r_addprintprocessor: unable to marshall SPOOL_R_ADDPRINTPROCESSOR.\n"));
-		return False;
-	}
-	
-	return True;
-}
-
-/****************************************************************************
-****************************************************************************/
-
-static BOOL api_spoolss_enumprintprocdatatypes(pipes_struct *p)
-{
-	SPOOL_Q_ENUMPRINTPROCDATATYPES q_u;
-	SPOOL_R_ENUMPRINTPROCDATATYPES r_u;
-	prs_struct *data = &p->in_data.data;
-	prs_struct *rdata = &p->out_data.rdata;
-
-	ZERO_STRUCT(q_u);
-	ZERO_STRUCT(r_u);
-	
-	if(!spoolss_io_q_enumprintprocdatatypes("", &q_u, data, 0)) {
-		ZERODEBUG(0,("spoolss_io_q_enumprintprocdatatypes: unable to unmarshall SPOOL_Q_ENUMPRINTPROCDATATYPES.\n"));
-		return False;
-	}
-	
-	r_u.status = _spoolss_enumprintprocdatatypes(p, &q_u, &r_u);
-
-	if(!spoolss_io_r_enumprintprocdatatypes("", &r_u, rdata, 0)) {
-		ZERODEBUG(0,("spoolss_io_r_enumprintprocdatatypes: unable to marshall SPOOL_R_ENUMPRINTPROCDATATYPES.\n"));
-		return False;
-	}
-	
-	return True;
-}
-
-/****************************************************************************
-****************************************************************************/
-
-static BOOL api_spoolss_enumprintmonitors(pipes_struct *p)
-{
-	SPOOL_Q_ENUMPRINTMONITORS q_u;
-	SPOOL_R_ENUMPRINTMONITORS r_u;
-	prs_struct *data = &p->in_data.data;
-	prs_struct *rdata = &p->out_data.rdata;
-
-	ZERO_STRUCT(q_u);
-	ZERO_STRUCT(r_u);
-	
-	if (!spoolss_io_q_enumprintmonitors("", &q_u, data, 0)) {
-		ZERODEBUG(0,("spoolss_io_q_enumprintmonitors: unable to unmarshall SPOOL_Q_ENUMPRINTMONITORS.\n"));
-		return False;
-	}
-		
-	r_u.status = _spoolss_enumprintmonitors(p, &q_u, &r_u);
-
-	if (!spoolss_io_r_enumprintmonitors("", &r_u, rdata, 0)) {
-		ZERODEBUG(0,("spoolss_io_r_enumprintmonitors: unable to marshall SPOOL_R_ENUMPRINTMONITORS.\n"));
-		return False;
-	}
-	
-	return True;
-}
-
-/****************************************************************************
-****************************************************************************/
-
-static BOOL api_spoolss_getjob(pipes_struct *p)
-{
-	SPOOL_Q_GETJOB q_u;
-	SPOOL_R_GETJOB r_u;
-	prs_struct *data = &p->in_data.data;
-	prs_struct *rdata = &p->out_data.rdata;
-	
-	if(!spoolss_io_q_getjob("", &q_u, data, 0)) {
-		ZERODEBUG(0,("spoolss_io_q_getjob: unable to unmarshall SPOOL_Q_GETJOB.\n"));
-		return False;
-	}
-
-	r_u.status = _spoolss_getjob(p, &q_u, &r_u);
-	
-	if(!spoolss_io_r_getjob("",&r_u,rdata,0)) {
-		ZERODEBUG(0,("spoolss_io_r_getjob: unable to marshall SPOOL_R_GETJOB.\n"));
-		return False;
-	}
-		
-	return True;
-}
-
-/********************************************************************
- * api_spoolss_getprinterdataex
- *
- * called from the spoolss dispatcher
- ********************************************************************/
-
-static BOOL api_spoolss_getprinterdataex(pipes_struct *p)
-{
-	SPOOL_Q_GETPRINTERDATAEX q_u;
-	SPOOL_R_GETPRINTERDATAEX r_u;
-	prs_struct *data = &p->in_data.data;
-	prs_struct *rdata = &p->out_data.rdata;
-
-	ZERO_STRUCT(q_u);
-	ZERO_STRUCT(r_u);
-
-	/* read the stream and fill the struct */
-	if (!spoolss_io_q_getprinterdataex("", &q_u, data, 0)) {
-		ZERODEBUG(0,("spoolss_io_q_getprinterdataex: unable to unmarshall SPOOL_Q_GETPRINTERDATAEX.\n"));
-		return False;
-	}
-	
-	r_u.status = _spoolss_getprinterdataex( p, &q_u, &r_u);
-
-	if (!spoolss_io_r_getprinterdataex("", &r_u, rdata, 0)) {
-		ZERODEBUG(0,("spoolss_io_r_getprinterdataex: unable to marshall SPOOL_R_GETPRINTERDATAEX.\n"));
-		return False;
-	}
-
-	return True;
-}
-
-/****************************************************************************
-****************************************************************************/
-
-static BOOL api_spoolss_setprinterdataex(pipes_struct *p)
-{
-	SPOOL_Q_SETPRINTERDATAEX q_u;
-	SPOOL_R_SETPRINTERDATAEX r_u;
-	prs_struct *data = &p->in_data.data;
-	prs_struct *rdata = &p->out_data.rdata;
-	
-	ZERO_STRUCT(q_u);
-	ZERO_STRUCT(r_u);
-	
-	if(!spoolss_io_q_setprinterdataex("", &q_u, data, 0)) {
-		ZERODEBUG(0,("spoolss_io_q_setprinterdataex: unable to unmarshall SPOOL_Q_SETPRINTERDATAEX.\n"));
-		return False;
-	}
-	
-	r_u.status = _spoolss_setprinterdataex(p, &q_u, &r_u);
-				
-	if(!spoolss_io_r_setprinterdataex("", &r_u, rdata, 0)) {
-		ZERODEBUG(0,("spoolss_io_r_setprinterdataex: unable to marshall SPOOL_R_SETPRINTERDATAEX.\n"));
-		return False;
-	}
-
-	return True;
-}
-
-
-/****************************************************************************
-****************************************************************************/
-
-static BOOL api_spoolss_enumprinterkey(pipes_struct *p)
-{
-	SPOOL_Q_ENUMPRINTERKEY q_u;
-	SPOOL_R_ENUMPRINTERKEY r_u;
-	prs_struct *data = &p->in_data.data;
-	prs_struct *rdata = &p->out_data.rdata;
-	
-	ZERO_STRUCT(q_u);
-	ZERO_STRUCT(r_u);
-	
-	if(!spoolss_io_q_enumprinterkey("", &q_u, data, 0)) {
-		ZERODEBUG(0,("spoolss_io_q_setprinterkey: unable to unmarshall SPOOL_Q_ENUMPRINTERKEY.\n"));
-		return False;
-	}
-	
-	r_u.status = _spoolss_enumprinterkey(p, &q_u, &r_u);
-				
-	if(!spoolss_io_r_enumprinterkey("", &r_u, rdata, 0)) {
-		ZERODEBUG(0,("spoolss_io_r_enumprinterkey: unable to marshall SPOOL_R_ENUMPRINTERKEY.\n"));
-		return False;
-	}
-
-	return True;
-}
-
-/****************************************************************************
-****************************************************************************/
-
-static BOOL api_spoolss_enumprinterdataex(pipes_struct *p)
-{
-	SPOOL_Q_ENUMPRINTERDATAEX q_u;
-	SPOOL_R_ENUMPRINTERDATAEX r_u;
-	prs_struct *data = &p->in_data.data;
-	prs_struct *rdata = &p->out_data.rdata;
-	
-	ZERO_STRUCT(q_u);
-	ZERO_STRUCT(r_u);
-	
-	if(!spoolss_io_q_enumprinterdataex("", &q_u, data, 0)) {
-		ZERODEBUG(0,("spoolss_io_q_enumprinterdataex: unable to unmarshall SPOOL_Q_ENUMPRINTERDATAEX.\n"));
-		return False;
-	}
-	
-	r_u.status = _spoolss_enumprinterdataex(p, &q_u, &r_u);
-				
-	if(!spoolss_io_r_enumprinterdataex("", &r_u, rdata, 0)) {
-		ZERODEBUG(0,("spoolss_io_r_enumprinterdataex: unable to marshall SPOOL_R_ENUMPRINTERDATAEX.\n"));
-		return False;
-	}
-
-	return True;
-}
-
-/****************************************************************************
-****************************************************************************/
-
-static BOOL api_spoolss_getprintprocessordirectory(pipes_struct *p)
-{
-	SPOOL_Q_GETPRINTPROCESSORDIRECTORY q_u;
-	SPOOL_R_GETPRINTPROCESSORDIRECTORY r_u;
-	prs_struct *data = &p->in_data.data;
-	prs_struct *rdata = &p->out_data.rdata;
-	
-	ZERO_STRUCT(q_u);
-	ZERO_STRUCT(r_u);
-	
-	if(!spoolss_io_q_getprintprocessordirectory("", &q_u, data, 0)) {
-		ZERODEBUG(0,("spoolss_io_q_getprintprocessordirectory: unable to unmarshall SPOOL_Q_GETPRINTPROCESSORDIRECTORY.\n"));
-		return False;
-	}
-	
-	r_u.status = _spoolss_getprintprocessordirectory(p, &q_u, &r_u);
-				
-	if(!spoolss_io_r_getprintprocessordirectory("", &r_u, rdata, 0)) {
-		ZERODEBUG(0,("spoolss_io_r_getprintprocessordirectory: unable to marshall SPOOL_R_GETPRINTPROCESSORDIRECTORY.\n"));
-		return False;
-	}
-	
-	return True;
-}
-
-/*******************************************************************
-\pipe\spoolss commands
-********************************************************************/
-
-struct api_struct api_spoolss_cmds[] = 
-{
- {"SPOOLSS_OPENPRINTER",               SPOOLSS_OPENPRINTER,               api_spoolss_open_printer              },
- {"SPOOLSS_OPENPRINTEREX",             SPOOLSS_OPENPRINTEREX,             api_spoolss_open_printer_ex           },
- {"SPOOLSS_GETPRINTERDATA",            SPOOLSS_GETPRINTERDATA,            api_spoolss_getprinterdata            },
- {"SPOOLSS_CLOSEPRINTER",              SPOOLSS_CLOSEPRINTER,              api_spoolss_closeprinter              },
- {"SPOOLSS_DELETEPRINTER",             SPOOLSS_DELETEPRINTER,             api_spoolss_deleteprinter             },
- {"SPOOLSS_ABORTPRINTER",              SPOOLSS_ABORTPRINTER,              api_spoolss_abortprinter              },
- {"SPOOLSS_RFFPCNEX",                  SPOOLSS_RFFPCNEX,                  api_spoolss_rffpcnex                  },
- {"SPOOLSS_RFNPCNEX",                  SPOOLSS_RFNPCNEX,                  api_spoolss_rfnpcnex                  },
- {"SPOOLSS_ENUMPRINTERS",              SPOOLSS_ENUMPRINTERS,              api_spoolss_enumprinters              },
- {"SPOOLSS_GETPRINTER",                SPOOLSS_GETPRINTER,                api_spoolss_getprinter                },
- {"SPOOLSS_GETPRINTERDRIVER2",         SPOOLSS_GETPRINTERDRIVER2,         api_spoolss_getprinterdriver2         }, 
- {"SPOOLSS_STARTPAGEPRINTER",          SPOOLSS_STARTPAGEPRINTER,          api_spoolss_startpageprinter          },
- {"SPOOLSS_ENDPAGEPRINTER",            SPOOLSS_ENDPAGEPRINTER,            api_spoolss_endpageprinter            }, 
- {"SPOOLSS_STARTDOCPRINTER",           SPOOLSS_STARTDOCPRINTER,           api_spoolss_startdocprinter           },
- {"SPOOLSS_ENDDOCPRINTER",             SPOOLSS_ENDDOCPRINTER,             api_spoolss_enddocprinter             },
- {"SPOOLSS_WRITEPRINTER",              SPOOLSS_WRITEPRINTER,              api_spoolss_writeprinter              },
- {"SPOOLSS_SETPRINTER",                SPOOLSS_SETPRINTER,                api_spoolss_setprinter                },
- {"SPOOLSS_FCPN",                      SPOOLSS_FCPN,                      api_spoolss_fcpn		        },
- {"SPOOLSS_ADDJOB",                    SPOOLSS_ADDJOB,                    api_spoolss_addjob                    },
- {"SPOOLSS_ENUMJOBS",                  SPOOLSS_ENUMJOBS,                  api_spoolss_enumjobs                  },
- {"SPOOLSS_SCHEDULEJOB",               SPOOLSS_SCHEDULEJOB,               api_spoolss_schedulejob               },
- {"SPOOLSS_SETJOB",                    SPOOLSS_SETJOB,                    api_spoolss_setjob                    },
- {"SPOOLSS_ENUMFORMS",                 SPOOLSS_ENUMFORMS,                 api_spoolss_enumforms                 },
- {"SPOOLSS_ENUMPORTS",                 SPOOLSS_ENUMPORTS,                 api_spoolss_enumports                 },
- {"SPOOLSS_ENUMPRINTERDRIVERS",        SPOOLSS_ENUMPRINTERDRIVERS,        api_spoolss_enumprinterdrivers        },
- {"SPOOLSS_ADDPRINTEREX",              SPOOLSS_ADDPRINTEREX,              api_spoolss_addprinterex              },
- {"SPOOLSS_ADDPRINTERDRIVER",          SPOOLSS_ADDPRINTERDRIVER,          api_spoolss_addprinterdriver          },
- {"SPOOLSS_DELETEPRINTERDRIVER",       SPOOLSS_DELETEPRINTERDRIVER,       api_spoolss_deleteprinterdriver       },
- {"SPOOLSS_GETPRINTERDRIVERDIRECTORY", SPOOLSS_GETPRINTERDRIVERDIRECTORY, api_spoolss_getprinterdriverdirectory },
- {"SPOOLSS_ENUMPRINTERDATA",           SPOOLSS_ENUMPRINTERDATA,           api_spoolss_enumprinterdata           },
- {"SPOOLSS_SETPRINTERDATA",            SPOOLSS_SETPRINTERDATA,            api_spoolss_setprinterdata            },
- {"SPOOLSS_RESETPRINTER",              SPOOLSS_RESETPRINTER,              api_spoolss_reset_printer             },
- {"SPOOLSS_DELETEPRINTERDATA",         SPOOLSS_DELETEPRINTERDATA,         api_spoolss_deleteprinterdata         },
- {"SPOOLSS_ADDFORM",                   SPOOLSS_ADDFORM,                   api_spoolss_addform                   },
- {"SPOOLSS_DELETEFORM",                SPOOLSS_DELETEFORM,                api_spoolss_deleteform                },
- {"SPOOLSS_GETFORM",                   SPOOLSS_GETFORM,                   api_spoolss_getform                   },
- {"SPOOLSS_SETFORM",                   SPOOLSS_SETFORM,                   api_spoolss_setform                   },
- {"SPOOLSS_ADDPRINTPROCESSOR",         SPOOLSS_ADDPRINTPROCESSOR,         api_spoolss_addprintprocessor         },
- {"SPOOLSS_ENUMPRINTPROCESSORS",       SPOOLSS_ENUMPRINTPROCESSORS,       api_spoolss_enumprintprocessors       },
- {"SPOOLSS_ENUMMONITORS",              SPOOLSS_ENUMMONITORS,              api_spoolss_enumprintmonitors         },
- {"SPOOLSS_GETJOB",                    SPOOLSS_GETJOB,                    api_spoolss_getjob                    },
- {"SPOOLSS_ENUMPRINTPROCDATATYPES",    SPOOLSS_ENUMPRINTPROCDATATYPES,    api_spoolss_enumprintprocdatatypes    },
- {"SPOOLSS_GETPRINTERDATAEX",          SPOOLSS_GETPRINTERDATAEX,          api_spoolss_getprinterdataex          },
- {"SPOOLSS_SETPRINTERDATAEX",          SPOOLSS_SETPRINTERDATAEX,          api_spoolss_setprinterdataex          },
- {"SPOOLSS_ENUMPRINTERKEY",            SPOOLSS_ENUMPRINTERKEY,            api_spoolss_enumprinterkey            },
- {"SPOOLSS_ENUMPRINTERDATAEX",         SPOOLSS_ENUMPRINTERDATAEX,         api_spoolss_enumprinterdataex         },
- {"SPOOLSS_GETPRINTPROCESSORDIRECTORY",SPOOLSS_GETPRINTPROCESSORDIRECTORY,api_spoolss_getprintprocessordirectory},
- { NULL,                               0,                                 NULL                                  }
-};
-
-/*******************************************************************
-receives a spoolss pipe and responds.
-********************************************************************/
-BOOL api_spoolss_rpc(pipes_struct *p)
-{
-	return api_rpcTNP(p, "api_spoolss_rpc", api_spoolss_cmds);
-}
diff -Naur samba-2.2.12-orig/source/rpc_server/srv_spoolss_nt.c samba-2.2.12/source/rpc_server/srv_spoolss_nt.c
--- samba-2.2.12-orig/source/rpc_server/srv_spoolss_nt.c	2011-03-04 13:51:45.000000000 +0100
+++ samba-2.2.12/source/rpc_server/srv_spoolss_nt.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,8144 +0,0 @@
-/*
- *  Unix SMB/CIFS implementation.
- *  RPC Pipe client / server routines
- *  Copyright (C) Andrew Tridgell              1992-2000,
- *  Copyright (C) Luke Kenneth Casson Leighton 1996-2000,
- *  Copyright (C) Jean Franois Micouleau      1998-2000,
- *  Copyright (C) Jeremy Allison		    2001,
- *  Copyright (C) Gerald Carter		       2000-2001,
- *  Copyright (C) Tim Potter                   2001-2002.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- */
-
-/* Since the SPOOLSS rpc routines are basically DOS 16-bit calls wrapped
-   up, all the errors returned are DOS errors, not NT status codes. */
-
-#include "includes.h"
-
-#ifndef MAX_OPEN_PRINTER_EXS
-#define MAX_OPEN_PRINTER_EXS 50
-#endif
-
-#define MAGIC_DISPLAY_FREQUENCY 0xfade2bad
-#define PHANTOM_DEVMODE_KEY "_p_f_a_n_t_0_m_"
-#define PRINTER_HANDLE_IS_PRINTER	0
-#define PRINTER_HANDLE_IS_PRINTSERVER	1
-
-/* Table to map the driver version */
-/* to OS */
-const char * drv_ver_to_os[] = {
-	"WIN9X",   /* driver version/cversion 0 */
-	"",        /* unused ? */
-	"WINNT",   /* driver version/cversion 2 */
-	"WIN2K",   /* driver version/cversion 3 */
-};
-
-struct table_node {
-	const char    *long_archi;
-	const char    *short_archi;
-	int     version;
-};
-
-
-/* structure to store the printer handles */
-/* and a reference to what it's pointing to */
-/* and the notify info asked about */
-/* that's the central struct */
-typedef struct _Printer{
-	struct _Printer *prev, *next;
-	BOOL document_started;
-	BOOL page_started;
-	int jobid; /* jobid in printing backend */
-	BOOL printer_type;
-	union {
-	  	fstring handlename;
-		fstring printerservername;
-	} dev;
-	uint32 type;
-	uint32 access_granted;
-	struct {
-		uint32 flags;
-		uint32 options;
-		fstring localmachine;
-		uint32 printerlocal;
-		SPOOL_NOTIFY_OPTION *option;
-		POLICY_HND client_hnd;
-		uint32 client_connected;
-		uint32 change;
-	} notify;
-	struct {
-		fstring machine;
-		fstring user;
-	} client;
-} Printer_entry;
-
-static Printer_entry *printers_list;
-
-typedef struct _counter_printer_0 {
-	ubi_dlNode Next;
-	ubi_dlNode Prev;
-	
-	int snum;
-	uint32 counter;
-} counter_printer_0;
-
-static ubi_dlList counter_list;
-
-static struct cli_state cli;
-static uint32 smb_connections=0;
-
-
-/* in printing/nt_printing.c */
-
-extern STANDARD_MAPPING printer_std_mapping, printserver_std_mapping;
-
-#define OUR_HANDLE(hnd) (((hnd)==NULL)?"NULL":(IVAL((hnd)->data5,4)==(uint32)sys_getpid()?"OURS":"OTHER")), \
-((unsigned int)IVAL((hnd)->data5,4)),((unsigned int)sys_getpid())
-
-/* translate between internal status numbers and NT status numbers */
-static int nt_printj_status(int v)
-{
-	switch (v) {
-	case LPQ_QUEUED:
-		return 0;
-	case LPQ_PAUSED:
-		return JOB_STATUS_PAUSED;
-	case LPQ_SPOOLING:
-		return JOB_STATUS_SPOOLING;
-	case LPQ_PRINTING:
-		return JOB_STATUS_PRINTING;
-	case LPQ_ERROR:
-		return JOB_STATUS_ERROR;
-	case LPQ_DELETING:
-		return JOB_STATUS_DELETING;
-	case LPQ_OFFLINE:
-		return JOB_STATUS_OFFLINE;
-	case LPQ_PAPEROUT:
-		return JOB_STATUS_PAPEROUT;
-	case LPQ_PRINTED:
-		return JOB_STATUS_PRINTED;
-	case LPQ_DELETED:
-		return JOB_STATUS_DELETED;
-	case LPQ_BLOCKED:
-		return JOB_STATUS_BLOCKED;
-	case LPQ_USER_INTERVENTION:
-		return JOB_STATUS_USER_INTERVENTION;
-	}
-	return 0;
-}
-
-static int nt_printq_status(int v)
-{
-	switch (v) {
-	case LPQ_PAUSED:
-		return PRINTER_STATUS_PAUSED;
-	case LPQ_QUEUED:
-	case LPQ_SPOOLING:
-	case LPQ_PRINTING:
-		return 0;
-	}
-	return 0;
-}
-
-/****************************************************************************
- Functions to handle SPOOL_NOTIFY_OPTION struct stored in Printer_entry.
-****************************************************************************/
-
-static void free_spool_notify_option(SPOOL_NOTIFY_OPTION **pp)
-{
-	if (*pp == NULL)
-		return;
-
-	SAFE_FREE((*pp)->ctr.type);
-	SAFE_FREE(*pp);
-}
-
-/***************************************************************************
- Disconnect from the client
-****************************************************************************/
-
-static void srv_spoolss_replycloseprinter(POLICY_HND *handle)
-{
-	WERROR result;
-
-	/* weird if the test succeds !!! */
-	if (smb_connections==0) {
-		ZERODEBUG(0,("srv_spoolss_replycloseprinter:Trying to close non-existant notify backchannel !\n"));
-		return;
-	}
-
-	result = cli_spoolss_reply_close_printer(&cli, cli.mem_ctx, handle);
-	
-	if (!W_ERROR_IS_OK(result))
-		ZERODEBUG(0,("srv_spoolss_replycloseprinter: reply_close_printer failed [%s].\n",
-			dos_errstr(result)));
-
-	/* if it's the last connection, deconnect the IPC$ share */
-	if (smb_connections==1) {
-		if(!spoolss_disconnect_from_client(&cli))
-			return;
-
-		message_deregister(MSG_PRINTER_NOTIFY);
-	}
-
-	smb_connections--;
-}
-
-/****************************************************************************
- Functions to free a printer entry datastruct.
-****************************************************************************/
-
-static void free_printer_entry(void *ptr)
-{
-	Printer_entry *Printer = (Printer_entry *)ptr;
-
-	if (Printer->notify.client_connected==True)
-		srv_spoolss_replycloseprinter(&Printer->notify.client_hnd);
-
-	Printer->notify.flags=0;
-	Printer->notify.options=0;
-	Printer->notify.localmachine[0]='\0';
-	Printer->notify.printerlocal=0;
-	free_spool_notify_option(&Printer->notify.option);
-	Printer->notify.option=NULL;
-	Printer->notify.client_connected=False;
-
-	/* Remove from the internal list. */
-	DLIST_REMOVE(printers_list, Printer);
-
-	SAFE_FREE(Printer);
-}
-
-/****************************************************************************
- Functions to duplicate a SPOOL_NOTIFY_OPTION struct stored in Printer_entry.
-****************************************************************************/
-
-SPOOL_NOTIFY_OPTION *dup_spool_notify_option(SPOOL_NOTIFY_OPTION *sp)
-{
-	SPOOL_NOTIFY_OPTION *new_sp = NULL;
-
-	if (!sp)
-		return NULL;
-
-	new_sp = (SPOOL_NOTIFY_OPTION *)malloc(sizeof(SPOOL_NOTIFY_OPTION));
-	if (!new_sp)
-		return NULL;
-
-	*new_sp = *sp;
-
-	if (sp->ctr.count) {
-		new_sp->ctr.type = (SPOOL_NOTIFY_OPTION_TYPE *)memdup(sp->ctr.type, sizeof(SPOOL_NOTIFY_OPTION_TYPE) * sp->ctr.count);
-
-		if (!new_sp->ctr.type) {
-			SAFE_FREE(new_sp);
-			return NULL;
-		}
-	}
-
-	return new_sp;
-}
-
-/****************************************************************************
-  find printer index by handle
-****************************************************************************/
-
-static Printer_entry *find_printer_index_by_hnd(pipes_struct *p, POLICY_HND *hnd)
-{
-	Printer_entry *find_printer = NULL;
-
-	if(!find_policy_by_hnd(p,hnd,(void **)&find_printer)) {
-		DEBUG(2,("find_printer_index_by_hnd: Printer handle not found: "));
-		return NULL;
-	}
-
-	return find_printer;
-}
-
-/****************************************************************************
- Close printer index by handle.
-****************************************************************************/
-
-static BOOL close_printer_handle(pipes_struct *p, POLICY_HND *hnd)
-{
-	Printer_entry *Printer = find_printer_index_by_hnd(p, hnd);
-
-	if (!Printer) {
-		DEBUG(2,("close_printer_handle: Invalid handle (%s:%u:%u)\n", OUR_HANDLE(hnd)));
-		return False;
-	}
-
-	close_policy_hnd(p, hnd);
-
-	return True;
-}	
-
-/****************************************************************************
- Delete a printer given a handle.
-****************************************************************************/
-
-static WERROR delete_printer_handle(pipes_struct *p, POLICY_HND *hnd)
-{
-	Printer_entry *Printer = find_printer_index_by_hnd(p, hnd);
-
-	if (!Printer) {
-		DEBUG(2,("delete_printer_handle: Invalid handle (%s:%u:%u)\n", OUR_HANDLE(hnd)));
-		return WERR_BADFID;
-	}
-
-	/* 
-	 * It turns out that Windows allows delete printer on a handle
-	 * opened by an admin user, then used on a pipe handle created
-	 * by an anonymous user..... but they're working on security.... riiight !
-	 * JRA.
-	 */
-
-	if (Printer->access_granted != PRINTER_ACCESS_ADMINISTER) {
-		DEBUG(3, ("delete_printer_handle: denied by handle\n"));
-		return WERR_ACCESS_DENIED;
-	}
-
-#if 0
-	/* Check calling user has permission to delete printer.  Note that
-	   since we set the snum parameter to -1 only administrators can
-	   delete the printer.  This stops people with the Full Control
-	   permission from deleting the printer. */
-
-	if (!print_access_check(NULL, -1, PRINTER_ACCESS_ADMINISTER)) {
-		DEBUG(3, ("printer delete denied by security descriptor\n"));
-		return WERR_ACCESS_DENIED;
-	}
-#endif
-
-	if (del_a_printer(Printer->dev.handlename) != 0) {
-		DEBUG(3,("Error deleting printer %s\n", Printer->dev.handlename));
-		return WERR_BADFID;
-	}
-
-	if (*lp_deleteprinter_cmd()) {
-
-		char *cmd = lp_deleteprinter_cmd();
-		pstring command;
-		int ret;
-		int i;
-
-		/* Printer->dev.handlename equals portname equals sharename */
-		slprintf(command, sizeof(command)-1, "%s \"%s\"", cmd,
-					Printer->dev.handlename);
-		dos_to_unix(command);  /* Convert printername to unix-codepage */
-
-		DEBUG(10,("Running [%s]\n", command));
-		ret = smbrun(command, NULL);
-		if (ret != 0) {
-			return WERR_BADFID; /* What to return here? */
-		}
-		DEBUGADD(10,("returned [%d]\n", ret));
-
-		/* Send SIGHUP to process group... is there a better way? */
-		kill(0, SIGHUP);
-
-		/* go ahead and re-read the services immediately */
-		reload_services( False );
-
-		if ( ( i = lp_servicenumber( Printer->dev.handlename ) ) < 0 )
-			return WERR_ACCESS_DENIED;
-	}
-
-	return WERR_OK;
-}
-
-/****************************************************************************
- Return the snum of a printer corresponding to an handle.
-****************************************************************************/
-
-static BOOL get_printer_snum(pipes_struct *p, POLICY_HND *hnd, int *number)
-{
-	Printer_entry *Printer = find_printer_index_by_hnd(p, hnd);
-		
-	if (!Printer) {
-		DEBUG(2,("get_printer_snum: Invalid handle (%s:%u:%u)\n", OUR_HANDLE(hnd)));
-		return False;
-	}
-	
-	switch (Printer->printer_type) {
-	case PRINTER_HANDLE_IS_PRINTER:		
-		DEBUG(4,("short name:%s\n", Printer->dev.handlename));			
-		*number = print_queue_snum(Printer->dev.handlename);
-		return (*number != -1);
-	case PRINTER_HANDLE_IS_PRINTSERVER:
-		return False;
-	default:
-		return False;
-	}
-}
-
-/****************************************************************************
- Set printer handle type.
- Check if it's \\server or \\server\printer
-****************************************************************************/
-
-static BOOL set_printer_hnd_printertype(Printer_entry *Printer, char *handlename)
-{
-	DEBUG(3,("Setting printer type=%s\n", handlename));
-
-	if ( strlen(handlename) < 3 ) {
-		DEBUGADD(4,("A print server must have at least 1 char ! %s\n", handlename));
-		return False;
-	}
-
-	/* it's a print server */
-	if (*handlename=='\\' && *(handlename+1)=='\\' && !strchr(handlename+2, '\\')) {
-		DEBUGADD(4,("Printer is a print server\n"));
-		Printer->printer_type = PRINTER_HANDLE_IS_PRINTSERVER;		
-	}
-	/* it's a printer */
-	else {
-		DEBUGADD(4,("Printer is a printer\n"));
-		Printer->printer_type = PRINTER_HANDLE_IS_PRINTER;
-	}
-
-	return True;
-}
-
-/****************************************************************************
- Set printer handle name.
-****************************************************************************/
-
-static BOOL set_printer_hnd_name(Printer_entry *Printer, char *handlename)
-{
-	int snum;
-	int n_services=lp_numservices();
-	char *aprinter;
-	fstring sname;
-	BOOL found=False;
-	
-	DEBUG(4,("Setting printer name=%s (len=%d)\n", handlename, strlen(handlename)));
-
-	if (Printer->printer_type==PRINTER_HANDLE_IS_PRINTSERVER) {
-		ZERO_STRUCT(Printer->dev.printerservername);
-		strncpy(Printer->dev.printerservername, handlename, strlen(handlename));
-		return True;
-	}
-
-	if (Printer->printer_type!=PRINTER_HANDLE_IS_PRINTER)
-		return False;
-	
-	if (*handlename=='\\') {
-		aprinter=strchr(handlename+2, '\\');
-		aprinter++;
-	}
-	else {
-		aprinter=handlename;
-	}
-
-	DEBUGADD(5,("searching for [%s] (len=%d)\n", aprinter, strlen(aprinter)));
-
-	/*
-	 * The original code allowed smbd to store a printer name that
-	 * was different from the share name.  This is not possible 
-	 * anymore, so I've simplified this loop greatly.  Here
-	 * we are just verifying that the printer name is a valid
-	 * printer service defined in smb.conf
-	 *                          --jerry [Fri Feb 15 11:17:46 CST 2002]
-	 */
-
-	for (snum=0; snum<n_services; snum++) {
-
-		if ( !(lp_snum_ok(snum) && lp_print_ok(snum) ) )
-			continue;
-		
-		fstrcpy(sname, lp_servicename(snum));
-
-		DEBUGADD(5,("share:%s\n",sname));
-		
-		if (! StrCaseCmp(sname, aprinter)) {
-			found = True;
-			break;
-		}
-
-	}
-
-		
-	if (!found) {
-		DEBUGADD(4,("Printer not found\n"));
-		return False;
-	}
-	
-	DEBUGADD(4,("set_printer_hnd_name: Printer found: %s -> %s\n", aprinter, sname));
-
-	ZERO_STRUCT(Printer->dev.handlename);
-	fstrcpy(Printer->dev.handlename, sname);
-
-	return True;
-}
-
-/****************************************************************************
- Find first available printer slot. creates a printer handle for you.
- ****************************************************************************/
-
-static BOOL open_printer_hnd(pipes_struct *p, POLICY_HND *hnd, char *name, uint32 access_granted)
-{
-	Printer_entry *new_printer;
-
-	DEBUG(10,("open_printer_hnd: name [%s]\n", name));
-
-	if((new_printer=(Printer_entry *)malloc(sizeof(Printer_entry))) == NULL)
-		return False;
-
-	ZERO_STRUCTP(new_printer);
-	
-	new_printer->notify.option=NULL;
-				
-	/* Add to the internal list. */
-	DLIST_ADD(printers_list, new_printer);
-
-	if (!create_policy_hnd(p, hnd, free_printer_entry, new_printer)) {
-		SAFE_FREE(new_printer);
-		return False;
-	}
-
-	if (!set_printer_hnd_printertype(new_printer, name)) {
-		close_printer_handle(p, hnd);
-		return False;
-	}
-	
-	if (!set_printer_hnd_name(new_printer, name)) {
-		close_printer_handle(p, hnd);
-		return False;
-	}
-
-	new_printer->access_granted = access_granted;
-
-	DEBUG(5, ("%d printer handles active\n", (int)p->pipe_handles->count ));
-
-	return True;
-}
-
-/****************************************************************************
- Allocate more memory for a BUFFER.
-****************************************************************************/
-
-static BOOL alloc_buffer_size(NEW_BUFFER *buffer, uint32 buffer_size)
-{
-	prs_struct *ps;
-	uint32 extra_space;
-	uint32 old_offset;
-	
-	ps= &buffer->prs;
-
-	/* damn, I'm doing the reverse operation of prs_grow() :) */
-	if (buffer_size < prs_data_size(ps))
-		extra_space=0;
-	else	
-		extra_space = buffer_size - prs_data_size(ps);
-
-	/*
-	 * save the offset and move to the end of the buffer
-	 * prs_grow() checks the extra_space against the offset
-	 */
-	old_offset=prs_offset(ps);	
-	prs_set_offset(ps, prs_data_size(ps));
-	
-	if (!prs_grow(ps, extra_space))
-		return False;
-
-	prs_set_offset(ps, old_offset);
-
-	buffer->string_at_end=prs_data_size(ps);
-
-	return True;
-}
-/***************************************************************************
- Always give preference Printer_entry.notify.option over 
- Printer_entry.notify.flags.  Return True if we should send notification 
- events using SPOOLSS_RRPCN.  False means that we should use 
- SPOOLSS_ROUTERREPLYPRINTER.
- **************************************************************************/
-static BOOL valid_notify_options(Printer_entry *printer)
-{
-	if (printer->notify.option == NULL)
-		return False;
-		
-	return True;
-}
-
-/***************************************************************************
- Simple check to see if the client motify handle is set to watch for events
- represented by 'flags'
- 
- FIXME!!!! only a stub right now     --jerry
- **************************************************************************/
- 
-static BOOL is_client_monitoring_event(Printer_entry *p, uint32 flags)
-{
-
-	return True;
-}
-
-/***************************************************************************
- Server wrapper for cli_spoolss_routerreplyprinter() since the client 
- function can only send a single change notification at a time.
- 
- FIXME!!!  only handles one change currently (PRINTER_CHANGE_SET_PRINTER_DRIVER)
- --jerry
- **************************************************************************/
- 
-static WERROR srv_spoolss_routerreplyprinter (struct cli_state *reply_cli, TALLOC_CTX *mem_ctx,
-					POLICY_HND *pol, PRINTER_MESSAGE_INFO *info,
-					NT_PRINTER_INFO_LEVEL *printer)				
-{
-	WERROR result;
-	uint32 condition = 0x0;
-	
-	if (info->flags & PRINTER_MESSAGE_DRIVER)
-		condition = PRINTER_CHANGE_SET_PRINTER_DRIVER;
-	
-	result = cli_spoolss_routerreplyprinter(reply_cli, mem_ctx, pol, condition, 
-			printer->info_2->changeid);
-
-	return result;
-}
-
-/***********************************************************************
- Wrapper around the decision of which RPC use to in the change 
- notification
- **********************************************************************/
- 
-static WERROR srv_spoolss_send_event_to_client(Printer_entry* Printer, 
-	struct cli_state *send_cli,	PRINTER_MESSAGE_INFO *msg, 
-	NT_PRINTER_INFO_LEVEL *info)
-{
-	WERROR result;
-	
-	if (valid_notify_options(Printer)) {
-		/* This is a single call that can send information about multiple changes */
-		if (Printer->printer_type == PRINTER_HANDLE_IS_PRINTSERVER)
-			msg->flags |= PRINTER_MESSAGE_ATTRIBUTES;
-
-		result = cli_spoolss_reply_rrpcn(send_cli, send_cli->mem_ctx, &Printer->notify.client_hnd, 
-				msg, info);
-	}
-	else {
-		/* This requires that the server send an individual event notification for each change */
-		result = srv_spoolss_routerreplyprinter(send_cli, send_cli->mem_ctx, &Printer->notify.client_hnd, 
-				msg, info);
-	}
-	
-	return result;
-}
-
-
-/***********************************************************************
- Send a change notication message on all handles which have a call 
- back registered
- **********************************************************************/
-
-static void send_spoolss_event_notification(PRINTER_MESSAGE_INFO *msg)
-{
-	Printer_entry *find_printer;
-	WERROR result;
-	NT_PRINTER_INFO_LEVEL *printer = NULL;
-	
-	if (!msg) {
-		ZERODEBUG(0,("send_spoolss_event_notification: NULL msg pointer!\n"));
-		return;
-	}
-	
-	for(find_printer = printers_list; find_printer; find_printer = find_printer->next) {
-
-		/*
-		 * If the entry has a connected client we send the message. There should 
-		 * only be one of these normally when dealing with the NT/2k spooler.
-		 * However, iterate over all to make sure we deal with user applications
-		 * in addition to spooler service.
-		 *
-		 * While we are only maintaining a single connection to the client, 
-		 * the FindFirstPrinterChangeNotification() call is made on a printer 
-		 * handle, so "client_connected" represents the whether or not the 
-		 * client asked for change notication on this handle.
-		 * 
-		 * --jerry
-		 */
-
-		if (find_printer->notify.client_connected==True) {
-		
-			msg->low = find_printer->notify.change;
-
-			/* does the client care about what changed? */
-
-			if (msg->flags && !is_client_monitoring_event(find_printer, msg->flags)) {
-				DEBUG(10,("send_spoolss_event_notification: Client [%s] not monitoring these events\n",
-					find_printer->client.machine)); 
-				continue;
-			}
-			
-			if (find_printer->printer_type == PRINTER_HANDLE_IS_PRINTSERVER)
-				DEBUG(10,("send_spoolss_event_notification: printserver [%s]\n", find_printer->dev.printerservername ));
-			else
-				DEBUG(10,("send_spoolss_event_notification: printer [%s]\n", find_printer->dev.handlename));
-
-			/*
-			 * if handle is a printer, only send if the printer_name matches.
-			 * ...else if handle is a printerserver, send to all
-			 */
-
-			if (*msg->printer_name && (find_printer->printer_type==PRINTER_HANDLE_IS_PRINTER) 
-				&& !strequal(msg->printer_name, find_printer->dev.handlename)) 
-			{
-				DEBUG(10,("send_spoolss_event_notification: ignoring message sent to %s [%s]\n",
-					msg->printer_name, find_printer->dev.handlename ));
-				continue;
-			}
-
-
-			/* lookup the printer if we have a name if we don't already have a 
-			   valid NT_PRINTER_INFO_LEVEL structure. And yes I'm assuming we 
-			   will always have a non-empty msg.printer_name */
-				   
-			if (!printer || !printer->info_2 || strcmp(msg->printer_name, printer->info_2->printername)) 
-			{
-			
-				if (printer) {
-					free_a_printer(&printer, 2);
-					printer = NULL;
-				}
-					
-				result = get_a_printer(&printer, 2, msg->printer_name);
-				if (!W_ERROR_IS_OK(result))
-					continue;
-			}
-
-			/* issue the client call */
-
-			result = srv_spoolss_send_event_to_client(find_printer, &cli, msg, printer);
-			
-			if (!W_ERROR_IS_OK(result)) {
-				DEBUG(5,("send_spoolss_event_notification: Event notification failed [%s]\n",
-					dos_errstr(result)));
-			}
-		}
-	}
-
-	return;
-}
-/***************************************************************************
- Receive the notify message and decode the message.  Do not send 
- notification if we sent this originally as that would result in 
- duplicates.
-****************************************************************************/
-
-static void srv_spoolss_receive_message(int msg_type, pid_t src, void *buf, size_t len)
-{
-	PRINTER_MESSAGE_INFO msg;
-	
-	if (len < sizeof(msg)) {
-		DEBUG(2,("srv_spoolss_receive_message: got incorrect message size (%u)!\n", (unsigned int)len));
-		return;
-	}
-
-	memcpy(&msg, buf, sizeof(PRINTER_MESSAGE_INFO));
-	
-	DEBUG(10,("srv_spoolss_receive_message: Got message printer change [queue = %s] low=0x%x  high=0x%x flags=0x%x\n",
-		msg.printer_name, (unsigned int)msg.low, (unsigned int)msg.high, msg.flags ));
-
-	/* Iterate the printer list */
-	
-	send_spoolss_event_notification(&msg);
-	
-}
-
-/***************************************************************************
- Send a notify event.
-****************************************************************************/
-
-static BOOL srv_spoolss_sendnotify(char* printer_name, uint32 high, uint32 low, uint32 flags)
-{
-	char msg[sizeof(PRINTER_MESSAGE_INFO)];
-	PRINTER_MESSAGE_INFO info;
-	
-	ZERO_STRUCT(info);
-
-	info.low 	= low;
-	info.high	= high;
-	info.flags	= flags;
-	fstrcpy(info.printer_name, printer_name);
-	
-	memcpy(msg, &info, sizeof(PRINTER_MESSAGE_INFO));	
-	
-	DEBUG(10,("srv_spoolss_sendnotify: printer change low=0x%x  high=0x%x [%s], flags=0x%x\n", 
-		low, high, printer_name, flags));
-		
-	message_send_all(conn_tdb_ctx(), MSG_PRINTER_NOTIFY, msg, sizeof(PRINTER_MESSAGE_INFO), 
-		False, NULL);
-	
-	return True;
-}	
-
-/********************************************************************
- Send a message to ourself about new driver being installed
- so we can upgrade the information for each printer bound to this
- driver
- ********************************************************************/
- 
-static BOOL srv_spoolss_drv_upgrade_printer(char* drivername)
-{
-	int len = strlen(drivername);
-	
-	if (!len)
-		return False;
-
-	DEBUG(10,("srv_spoolss_drv_upgrade_printer: Sending message about driver upgrade [%s]\n",
-		drivername));
-		
-	message_send_pid(sys_getpid(), MSG_PRINTER_DRVUPGRADE, drivername, len+1, False);
-
-	return True;
-}
-
-/**********************************************************************
- callback to receive a MSG_PRINTER_DRVUPGRADE message and interate
- over all printers, upgrading ones as neessary 
- **********************************************************************/
- 
-void do_drv_upgrade_printer(int msg_type, pid_t src, void *buf, size_t len)
-{
-	fstring drivername;
-	int snum;
-	int n_services = lp_numservices();
-	
-	len = MIN(len,sizeof(drivername)-1);
-	strncpy(drivername, buf, len);
-	
-	DEBUG(10,("do_drv_upgrade_printer: Got message for new driver [%s]\n", drivername ));
-
-	/* Iterate the printer list */
-	
-	for (snum=0; snum<n_services; snum++)
-	{
-		if (lp_snum_ok(snum) && lp_print_ok(snum) ) 
-		{
-			WERROR result;
-			NT_PRINTER_INFO_LEVEL *printer = NULL;
-			
-			result = get_a_printer(&printer, 2, lp_servicename(snum));
-			if (!W_ERROR_IS_OK(result))
-				continue;
-				
-			if (printer && printer->info_2 && !strcmp(drivername, printer->info_2->drivername)) 
-			{
-				DEBUG(6,("Updating printer [%s]\n", printer->info_2->printername));
-				
-				/* all we care about currently is the change_id */
-				
-				result = mod_a_printer(*printer, 2);
-				if (!W_ERROR_IS_OK(result)) {
-					DEBUG(3,("do_drv_upgrade_printer: mod_a_printer() failed with status [%s]\n", 
-						dos_errstr(result)));
-				}
-			}
-			
-			free_a_printer(&printer, 2);			
-		}
-	}
-	
-	/* all done */	
-}
-
-/********************************************************************
- Copy routines used by convert_to_openprinterex()
- *******************************************************************/
-
-static DEVICEMODE* dup_devicemode(TALLOC_CTX *ctx, DEVICEMODE *devmode)
-{
-	DEVICEMODE *d;
-	int len;
-
-	if (!devmode)
-		return NULL;
-		
-	DEBUG (8,("dup_devmode\n"));
-	
-	/* bulk copy first */
-	
-	d = talloc_memdup(ctx, devmode, sizeof(DEVICEMODE));
-	if (!d)
-		return NULL;
-		
-	/* dup the pointer members separately */
-	
-	len = unistrlen(devmode->devicename.buffer);
-	if (len != -1) {
-		d->devicename.buffer = talloc(ctx, len*2);
-		if (unistrcpy(d->devicename.buffer, devmode->devicename.buffer) != len)
-			return NULL;
-	}
-		
-
-	len = unistrlen(devmode->formname.buffer);
-	if (len != -1) {
-		d->devicename.buffer = talloc(ctx, len*2);
-		if (unistrcpy(d->formname.buffer, devmode->formname.buffer) != len)
-			return NULL;
-	}
-
-	d->private = talloc_memdup(ctx, devmode->private, devmode->driverextra);
-	
-	return d;
-}
-
-static void copy_devmode_ctr(TALLOC_CTX *ctx, DEVMODE_CTR *new_ctr, DEVMODE_CTR *ctr)
-{
-	if (!new_ctr || !ctr)
-		return;
-		
-	DEBUG(8,("copy_devmode_ctr\n"));
-	
-	new_ctr->size = ctr->size;
-	new_ctr->devmode_ptr = ctr->devmode_ptr;
-	
-	if(ctr->devmode_ptr)
-		new_ctr->devmode = dup_devicemode(ctx, ctr->devmode);
-}
-
-static void copy_printer_default(TALLOC_CTX *ctx, PRINTER_DEFAULT *new_def, PRINTER_DEFAULT *def)
-{
-	if (!new_def || !def)
-		return;
-	
-	DEBUG(8,("copy_printer_defaults\n"));
-	
-	new_def->datatype_ptr = def->datatype_ptr;
-	
-	if (def->datatype_ptr)
-		copy_unistr2(&new_def->datatype, &def->datatype);
-	
-	copy_devmode_ctr(ctx, &new_def->devmode_cont, &def->devmode_cont);
-	
-	new_def->access_required = def->access_required;
-}
-
-/********************************************************************
- * Convert a SPOOL_Q_OPEN_PRINTER structure to a 
- * SPOOL_Q_OPEN_PRINTER_EX structure
- ********************************************************************/
-
-static void convert_to_openprinterex(TALLOC_CTX *ctx, SPOOL_Q_OPEN_PRINTER_EX *q_u_ex, SPOOL_Q_OPEN_PRINTER *q_u)
-{
-	if (!q_u_ex || !q_u)
-		return;
-
-	DEBUG(8,("convert_to_openprinterex\n"));
-				
-	q_u_ex->printername_ptr = q_u->printername_ptr;
-	
-	if (q_u->printername_ptr)
-		copy_unistr2(&q_u_ex->printername, &q_u->printername);
-	
-	copy_printer_default(ctx, &q_u_ex->printer_default, &q_u->printer_default);
-}
-
-/********************************************************************
- * spoolss_open_printer
- *
- * called from the spoolss dispatcher
- ********************************************************************/
-
-WERROR _spoolss_open_printer(pipes_struct *p, SPOOL_Q_OPEN_PRINTER *q_u, SPOOL_R_OPEN_PRINTER *r_u)
-{
-	SPOOL_Q_OPEN_PRINTER_EX q_u_ex;
-	SPOOL_R_OPEN_PRINTER_EX r_u_ex;
-	
-	if (!q_u || !r_u)
-		return WERR_NOMEM;
-	
-	ZERO_STRUCT(q_u_ex);
-	ZERO_STRUCT(r_u_ex);
-	
-	/* convert the OpenPrinter() call to OpenPrinterEx() */
-	
-	convert_to_openprinterex(p->mem_ctx, &q_u_ex, q_u);
-	
-	r_u_ex.status = _spoolss_open_printer_ex(p, &q_u_ex, &r_u_ex);
-	
-	/* convert back to OpenPrinter() */
-	
-	memcpy(r_u, &r_u_ex, sizeof(*r_u));
-	
-	return r_u->status;
-}
-
-/********************************************************************
- * spoolss_open_printer
- *
- * If the openprinterex rpc call contains a devmode,
- * it's a per-user one. This per-user devmode is derivated
- * from the global devmode. Openprinterex() contains a per-user 
- * devmode for when you do EMF printing and spooling.
- * In the EMF case, the NT workstation is only doing half the job
- * of rendering the page. The other half is done by running the printer
- * driver on the server.
- * The EMF file doesn't contain the page description (paper size, orientation, ...).
- * The EMF file only contains what is to be printed on the page.
- * So in order for the server to know how to print, the NT client sends
- * a devicemode attached to the openprinterex call.
- * But this devicemode is short lived, it's only valid for the current print job.
- *
- * If Samba would have supported EMF spooling, this devicemode would
- * have been attached to the handle, to sent it to the driver to correctly
- * rasterize the EMF file.
- *
- * As Samba only supports RAW spooling, we only receive a ready-to-print file,
- * we just act as a pass-thru between windows and the printer.
- *
- * In order to know that Samba supports only RAW spooling, NT has to call
- * getprinter() at level 2 (attribute field) or NT has to call startdoc()
- * and until NT sends a RAW job, we refuse it.
- *
- * But to call getprinter() or startdoc(), you first need a valid handle,
- * and to get an handle you have to call openprintex(). Hence why you have
- * a devicemode in the openprinterex() call.
- *
- *
- * Differences between NT4 and NT 2000.
- * NT4:
- * ---
- * On NT4, you only have a global devicemode. This global devicemode can be changed
- * by the administrator (or by a user with enough privs). Everytime a user
- * wants to print, the devicemode is resetted to the default. In Word, everytime
- * you print, the printer's characteristics are always reset to the global devicemode.
- *
- * NT 2000:
- * -------
- * In W2K, there is the notion of per-user devicemode. The first time you use
- * a printer, a per-user devicemode is build from the global devicemode.
- * If you change your per-user devicemode, it is saved in the registry, under the
- * H_KEY_CURRENT_KEY sub_tree. So that everytime you print, you have your default
- * printer preferences available.
- *
- * To change the per-user devicemode: it's the "Printing Preferences ..." button
- * on the General Tab of the printer properties windows.
- *
- * To change the global devicemode: it's the "Printing Defaults..." button
- * on the Advanced Tab of the printer properties window.
- *
- * JFM.
- ********************************************************************/
-
-WERROR _spoolss_open_printer_ex( pipes_struct *p, SPOOL_Q_OPEN_PRINTER_EX *q_u, SPOOL_R_OPEN_PRINTER_EX *r_u)
-{
-	UNISTR2 *printername = NULL;
-	PRINTER_DEFAULT *printer_default = &q_u->printer_default;
-/*	uint32 user_switch = q_u->user_switch; - notused */
-/*	SPOOL_USER_CTR user_ctr = q_u->user_ctr; - notused */
-	POLICY_HND *handle = &r_u->handle;
-
-	fstring name;
-	int snum;
-	struct current_user user;
-	Printer_entry *Printer=NULL;
-
-	if (q_u->printername_ptr != 0)
-		printername = &q_u->printername;
-
-	if (printername == NULL)
-		return WERR_INVALID_PRINTER_NAME;
-
-	/* some sanity check because you can open a printer or a print server */
-	/* aka: \\server\printer or \\server */
-	unistr2_to_dos(name, printername, sizeof(name)-1);
-
-	DEBUGADD(3,("checking name: %s\n",name));
-
-	if (!open_printer_hnd(p, handle, name, 0))
-		return WERR_INVALID_PRINTER_NAME;
-	
-	Printer=find_printer_index_by_hnd(p, handle);
-	if (!Printer) {
-		ZERODEBUG(0,(" _spoolss_open_printer_ex: logic error. \
-Can't find printer handle we created for printer %s\n", name ));
-		close_printer_handle(p,handle);
-		return WERR_INVALID_PRINTER_NAME;
-	}
-
-	get_current_user(&user, p);
-
-	/*
-	 * First case: the user is opening the print server:
-	 *
-	 * Disallow MS AddPrinterWizard if parameter disables it. A Win2k
-	 * client 1st tries an OpenPrinterEx with access==0, MUST be allowed.
-	 *
-	 * Then both Win2k and WinNT clients try an OpenPrinterEx with
-	 * SERVER_ALL_ACCESS, which we allow only if the user is root (uid=0)
-	 * or if the user is listed in the smb.conf printer admin parameter.
-	 *
-	 * Then they try OpenPrinterEx with SERVER_READ which we allow. This lets the
-	 * client view printer folder, but does not show the MSAPW.
-	 *
-	 * Note: this test needs code to check access rights here too. Jeremy
-	 * could you look at this?
-	 * 
-	 * Second case: the user is opening a printer:
-	 * NT doesn't let us connect to a printer if the connecting user
-	 * doesn't have print permission.
-	 */
-
-	if (Printer->printer_type == PRINTER_HANDLE_IS_PRINTSERVER) 
-	{
-		/* Printserver handles use global struct... */
-
-		snum = -1;
-
-		/* Map standard access rights to object specific access rights */
-		
-		se_map_standard(&printer_default->access_required, 
-				&printserver_std_mapping);
-	
-		/* Deny any object specific bits that don't apply to print
-		   servers (i.e printer and job specific bits) */
-
-		printer_default->access_required &= SPECIFIC_RIGHTS_MASK;
-
-		if (printer_default->access_required &
-		    ~(SERVER_ACCESS_ADMINISTER | SERVER_ACCESS_ENUMERATE)) {
-			DEBUG(3, ("access DENIED for non-printserver bits"));
-			close_printer_handle(p, handle);
-			return WERR_ACCESS_DENIED;
-		}
-
-		/* Allow admin access */
-
-		if ( printer_default->access_required & SERVER_ACCESS_ADMINISTER ) 
-		{
-			if (!lp_ms_add_printer_wizard()) {
-				close_printer_handle(p, handle);
-				return WERR_ACCESS_DENIED;
-			}
-
-			/* if the user is not root and not a printer admin, then fail */
-			
-			if ( user.uid != 0
-			     && !user_in_list(uidtoname(user.uid), lp_printer_admin(snum)) )
-			{
-				close_printer_handle(p, handle);
-				return WERR_ACCESS_DENIED;
-			}
-			
-			printer_default->access_required = SERVER_ACCESS_ADMINISTER;
-		}
-		else
-		{
-			printer_default->access_required = SERVER_ACCESS_ENUMERATE;
-		}
-
-		DEBUG(4,("Setting print server access = %s\n", (printer_default->access_required == SERVER_ACCESS_ADMINISTER) 
-			? "SERVER_ACCESS_ADMINISTER" : "SERVER_ACCESS_ENUMERATE" ));
-			
-		/* We fall through to return WERR_OK */
-		
-	}
-	else
-	{
-		/* NT doesn't let us connect to a printer if the connecting user
-		   doesn't have print permission.  */
-
-		if (!get_printer_snum(p, handle, &snum))
-			return WERR_BADFID;
-
-		se_map_standard(&printer_default->access_required, &printer_std_mapping);
-		
-		/* map an empty access mask to the minimum access mask */
-		if (printer_default->access_required == 0x0)
-			printer_default->access_required = PRINTER_ACCESS_USE;
-
-		/*
-		 * If we are not serving the printer driver for this printer,
-		 * map PRINTER_ACCESS_ADMINISTER to PRINTER_ACCESS_USE.  This
-		 * will keep NT clients happy  --jerry	
-		 */
-		 
-		if (lp_use_client_driver(snum) 
-			&& (printer_default->access_required & PRINTER_ACCESS_ADMINISTER))
-		{
-			printer_default->access_required = PRINTER_ACCESS_USE;
-		}
-
-		/* check smb.conf parameters and the the sec_desc */
-		
-		if (!user_ok(uidtoname(user.uid), snum) || !print_access_check(&user, snum, printer_default->access_required)) {
-			DEBUG(3, ("access DENIED for printer open\n"));
-			close_printer_handle(p, handle);
-			return WERR_ACCESS_DENIED;
-		}
-
-		if ((printer_default->access_required & SPECIFIC_RIGHTS_MASK)& ~(PRINTER_ACCESS_ADMINISTER|PRINTER_ACCESS_USE)) {
-			DEBUG(3, ("access DENIED for printer open - unknown bits\n"));
-			close_printer_handle(p, handle);
-			return WERR_ACCESS_DENIED;
-		}
-
-		if (printer_default->access_required & PRINTER_ACCESS_ADMINISTER)
-			printer_default->access_required = PRINTER_ACCESS_ADMINISTER;
-		else
-			printer_default->access_required = PRINTER_ACCESS_USE;
-
-		DEBUG(4,("Setting printer access = %s\n", (printer_default->access_required == PRINTER_ACCESS_ADMINISTER) 
-			? "PRINTER_ACCESS_ADMINISTER" : "PRINTER_ACCESS_USE" ));
-	}
-	
-	Printer->access_granted = printer_default->access_required;	
-
-	return WERR_OK;
-}
-
-/****************************************************************************
-****************************************************************************/
-
-static BOOL convert_printer_info(const SPOOL_PRINTER_INFO_LEVEL *uni,
-				NT_PRINTER_INFO_LEVEL *printer, uint32 level)
-{
-	BOOL ret = True;
-
-	switch (level) {
-		case 2:
-			ret = uni_2_asc_printer_info_2(uni->info_2, &printer->info_2);
-			break;
-		default:
-			break;
-	}
-
-	return ret;
-}
-
-static BOOL convert_printer_driver_info(const SPOOL_PRINTER_DRIVER_INFO_LEVEL *uni,
-                                 	NT_PRINTER_DRIVER_INFO_LEVEL *printer, uint32 level)
-{
-	BOOL result = True;
-
-	switch (level) {
-		case 3:
-			printer->info_3=NULL;
-			if (!uni_2_asc_printer_driver_3(uni->info_3, &printer->info_3))
-				result = False;
-			break;
-		case 6:
-			printer->info_6=NULL;
-			if (!uni_2_asc_printer_driver_6(uni->info_6, &printer->info_6))
-				result = False;
-			break;
-		default:
-			break;
-	}
-
-	return result;
-}
-
-BOOL convert_devicemode(const char *printername, const DEVICEMODE *devmode,
-				NT_DEVICEMODE **pp_nt_devmode)
-{
-	NT_DEVICEMODE *nt_devmode = *pp_nt_devmode;
-
-	/*
-	 * Ensure nt_devmode is a valid pointer
-	 * as we will be overwriting it.
-	 */
-		
-	if (nt_devmode == NULL) {
-		DEBUG(5, ("convert_devicemode: allocating a generic devmode\n"));
-		if ((nt_devmode = construct_nt_devicemode(printername)) == NULL)
-			return False;
-	}
-
-	unistr_to_dos(nt_devmode->devicename, (const char *)devmode->devicename.buffer, 31);
-	unistr_to_dos(nt_devmode->formname, (const char *)devmode->formname.buffer, 31);
-
-	nt_devmode->specversion=devmode->specversion;
-	nt_devmode->driverversion=devmode->driverversion;
-	nt_devmode->size=devmode->size;
-	nt_devmode->fields=devmode->fields;
-	nt_devmode->orientation=devmode->orientation;
-	nt_devmode->papersize=devmode->papersize;
-	nt_devmode->paperlength=devmode->paperlength;
-	nt_devmode->paperwidth=devmode->paperwidth;
-	nt_devmode->scale=devmode->scale;
-	nt_devmode->copies=devmode->copies;
-	nt_devmode->defaultsource=devmode->defaultsource;
-	nt_devmode->printquality=devmode->printquality;
-	nt_devmode->color=devmode->color;
-	nt_devmode->duplex=devmode->duplex;
-	nt_devmode->yresolution=devmode->yresolution;
-	nt_devmode->ttoption=devmode->ttoption;
-	nt_devmode->collate=devmode->collate;
-
-	nt_devmode->logpixels=devmode->logpixels;
-	nt_devmode->bitsperpel=devmode->bitsperpel;
-	nt_devmode->pelswidth=devmode->pelswidth;
-	nt_devmode->pelsheight=devmode->pelsheight;
-	nt_devmode->displayflags=devmode->displayflags;
-	nt_devmode->displayfrequency=devmode->displayfrequency;
-	nt_devmode->icmmethod=devmode->icmmethod;
-	nt_devmode->icmintent=devmode->icmintent;
-	nt_devmode->mediatype=devmode->mediatype;
-	nt_devmode->dithertype=devmode->dithertype;
-	nt_devmode->reserved1=devmode->reserved1;
-	nt_devmode->reserved2=devmode->reserved2;
-	nt_devmode->panningwidth=devmode->panningwidth;
-	nt_devmode->panningheight=devmode->panningheight;
-
-	/*
-	 * Only change private and driverextra if the incoming devmode
-	 * has a new one. JRA.
-	 */
-
-	if ((devmode->driverextra != 0) && (devmode->private != NULL)) {
-		SAFE_FREE(nt_devmode->private);
-		nt_devmode->driverextra=devmode->driverextra;
-		if((nt_devmode->private=(uint8 *)malloc(nt_devmode->driverextra * sizeof(uint8))) == NULL)
-			return False;
-		memcpy(nt_devmode->private, devmode->private, nt_devmode->driverextra);
-	}
-
-	*pp_nt_devmode = nt_devmode;
-
-	return True;
-}
-
-/********************************************************************
- * _spoolss_enddocprinter_internal.
- ********************************************************************/
-
-static WERROR _spoolss_enddocprinter_internal(pipes_struct *p, POLICY_HND *handle)
-{
-	Printer_entry *Printer=find_printer_index_by_hnd(p, handle);
-	
-	if (!Printer) {
-		DEBUG(2,("_spoolss_enddocprinter_internal: Invalid handle (%s:%u:%u)\n", OUR_HANDLE(handle)));
-		return WERR_BADFID;
-	}
-	
-	Printer->document_started=False;
-	print_job_end(Printer->jobid,True);
-	/* error codes unhandled so far ... */
-
-	return WERR_OK;
-}
-
-/********************************************************************
- * api_spoolss_closeprinter
- ********************************************************************/
-
-WERROR _spoolss_closeprinter(pipes_struct *p, SPOOL_Q_CLOSEPRINTER *q_u, SPOOL_R_CLOSEPRINTER *r_u)
-{
-	POLICY_HND *handle = &q_u->handle;
-
-	Printer_entry *Printer=find_printer_index_by_hnd(p, handle);
-
-	if (Printer && Printer->document_started)
-		_spoolss_enddocprinter_internal(p, handle);          /* print job was not closed */
-
-	if (!close_printer_handle(p, handle))
-		return WERR_BADFID;	
-		
-	/* clear the returned printer handle.  Observed behavior 
-	   from Win2k server.  Don't think this really matters.
-	   Previous code just copied the value of the closed
-	   handle.    --jerry */
-
-	memset(&r_u->handle, '\0', sizeof(r_u->handle));
-
-	return WERR_OK;
-}
-
-/********************************************************************
- * api_spoolss_deleteprinter
-
- ********************************************************************/
-
-WERROR _spoolss_deleteprinter(pipes_struct *p, SPOOL_Q_DELETEPRINTER *q_u, SPOOL_R_DELETEPRINTER *r_u)
-{
-	POLICY_HND *handle = &q_u->handle;
-	Printer_entry *Printer=find_printer_index_by_hnd(p, handle);
-	WERROR result;
-
-	if (Printer && Printer->document_started)
-		_spoolss_enddocprinter_internal(p, handle);  /* print job was not closed */
-
-	memcpy(&r_u->handle, &q_u->handle, sizeof(r_u->handle));
-
-	result = delete_printer_handle(p, handle);
-
-	update_c_setprinter(False);
-
-	if (W_ERROR_IS_OK(result)) {
-		srv_spoolss_sendnotify(Printer->dev.handlename, 0, PRINTER_CHANGE_DELETE_PRINTER, 0x0);
-	}
-		
-	return result;
-}
-
-/*******************************************************************
- * static function to lookup the version id corresponding to an
- * long architecture string
- ******************************************************************/
-
-static int get_version_id (char * arch)
-{
-	int i;
-	struct table_node archi_table[]= {
- 
-	        {"Windows 4.0",          "WIN40",       0 },
-	        {"Windows NT x86",       "W32X86",      2 },
-	        {"Windows NT R4000",     "W32MIPS",     2 },	
-	        {"Windows NT Alpha_AXP", "W32ALPHA",    2 },
-	        {"Windows NT PowerPC",   "W32PPC",      2 },
-	        {NULL,                   "",            -1 }
-	};
- 
-	for (i=0; archi_table[i].long_archi != NULL; i++)
-	{
-		if (strcmp(arch, archi_table[i].long_archi) == 0)
-			return (archi_table[i].version);
-        }
-	
-	return -1;
-}
-
-/********************************************************************
- * _spoolss_deleteprinterdriver
- *
- * We currently delete the driver for the architecture only.
- * This can leave the driver for other archtectures.  However,
- * since every printer associates a "Windows NT x86" driver name
- * and we cannot delete that one while it is in use, **and** since
- * it is impossible to assign a driver to a Samba printer without
- * having the "Windows NT x86" driver installed,...
- * 
- * ....we should not get into trouble here.  
- *
- *                                                      --jerry
- ********************************************************************/
-
-WERROR _spoolss_deleteprinterdriver(pipes_struct *p, SPOOL_Q_DELETEPRINTERDRIVER *q_u, 
-				    SPOOL_R_DELETEPRINTERDRIVER *r_u)
-{
-	fstring				driver;
-	fstring				arch;
-	NT_PRINTER_DRIVER_INFO_LEVEL	info;
-	NT_PRINTER_DRIVER_INFO_LEVEL	info_win2k;
-	int				version;
-	struct current_user		user;
-	WERROR				status;
-	WERROR				status_win2k = WERR_ACCESS_DENIED;
-	 
-	unistr2_to_dos(driver, &q_u->driver, sizeof(driver)-1 );
-	unistr2_to_dos(arch,   &q_u->arch,   sizeof(arch)-1   );
-	get_current_user(&user, p);
-	 
-	unistr2_to_dos(arch,   &q_u->arch,   sizeof(arch)-1   );
-	
-	/* check that we have a valid driver name first */
-	
-	if ((version=get_version_id(arch)) == -1) 
-		return WERR_INVALID_ENVIRONMENT;
-				
-	ZERO_STRUCT(info);
-	ZERO_STRUCT(info_win2k);
-	
-	if (!W_ERROR_IS_OK(get_a_printer_driver(&info, 3, driver, arch, version))) 
-	{
-		/* try for Win2k driver if "Windows NT x86" */
-		
-		if ( version == 2 ) {
-			version = 3;
-			if (!W_ERROR_IS_OK(get_a_printer_driver(&info, 3, driver, arch, version))) {
-				status = WERR_UNKNOWN_PRINTER_DRIVER;
-				goto done;
-			}
-		}
-		/* otherwise it was a failure */
-		else {
-			status = WERR_UNKNOWN_PRINTER_DRIVER;
-			goto done;
-		}
-		
-	}
-	
-	if (printer_driver_in_use(info.info_3)) {
-		status = WERR_PRINTER_DRIVER_IN_USE;
-		goto done;
-	}
-		
-	if ( version == 2 )
-	{		
-		if (W_ERROR_IS_OK(get_a_printer_driver(&info_win2k, 3, driver, arch, 3)))
-		{
-			/* if we get to here, we now have 2 driver info structures to remove */
-			/* remove the Win2k driver first*/
-		
-			status_win2k = delete_printer_driver(info_win2k.info_3, &user, 3, False );
-			free_a_printer_driver( info_win2k, 3 );
-			
-			/* this should not have failed---if it did, report to client */
-			if ( !W_ERROR_IS_OK(status_win2k) )
-				goto done;
-		}
-	}
-	
-	status = delete_printer_driver(info.info_3, &user, version, False);
-	
-	/* if at least one of the deletes succeeded return OK */
-	
-	if ( W_ERROR_IS_OK(status) || W_ERROR_IS_OK(status_win2k) )
-		status = WERR_OK;
-	
-done:
-	free_a_printer_driver( info, 3 );
-	
-	return status;
-}
-
-/********************************************************************
- GetPrinterData on a printer server Handle.
-********************************************************************/
-
-static BOOL getprinterdata_printer_server(TALLOC_CTX *ctx, fstring value, uint32 *type, uint8 **data, uint32 *needed, uint32 in_size)
-{		
-	int i;
-	
-	DEBUG(8,("getprinterdata_printer_server:%s\n", value));
-		
-	if (!strcmp(value, "W3SvcInstalled")) {
-		*type = 0x4;
-		if((*data = (uint8 *)talloc_zero(ctx, 4*sizeof(uint8) )) == NULL)
-			return False;
-		*needed = 0x4;			
-		return True;
-	}
-
-	if (!strcmp(value, "BeepEnabled")) {
-		*type = 0x4;
-		if((*data = (uint8 *)talloc(ctx, 4*sizeof(uint8) )) == NULL)
-			return False;
-		SIVAL(*data, 0, 0x00);
-		*needed = 0x4;			
-		return True;
-	}
-
-	if (!strcmp(value, "EventLog")) {
-		*type = 0x4;
-		if((*data = (uint8 *)talloc(ctx, 4*sizeof(uint8) )) == NULL)
-			return False;
-		/* formally was 0x1b */
-		SIVAL(*data, 0, 0x0);
-		*needed = 0x4;			
-		return True;
-	}
-
-	if (!strcmp(value, "NetPopup")) {
-		*type = 0x4;
-		if((*data = (uint8 *)talloc(ctx, 4*sizeof(uint8) )) == NULL)
-			return False;
-		SIVAL(*data, 0, 0x00);
-		*needed = 0x4;
-		return True;
-	}
-
-	if (!strcmp(value, "MajorVersion")) {
-		*type = 0x4;
-		if((*data = (uint8 *)talloc(ctx, 4*sizeof(uint8) )) == NULL)
-			return False;
-#ifndef EMULATE_WIN2K_HACK /* JERRY */
-		SIVAL(*data, 0, 2);
-#else
-		SIVAL(*data, 0, 3);
-#endif
-		*needed = 0x4;
-		return True;
-	}
-
-   	if (!strcmp(value, "DefaultSpoolDirectory")) {
-		fstring string;
-
-		fstrcpy(string, string_truncate(lp_serverstring(), MAX_SERVER_STRING_LENGTH));
-		*type = 0x1;			
-		*needed = 2*(strlen(string)+1);		
-		if((*data  = (uint8 *)talloc(ctx, ((*needed > in_size) ? *needed:in_size) *sizeof(uint8))) == NULL)
-			return False;
-		memset(*data, 0, (*needed > in_size) ? *needed:in_size);
-		
-		/* it's done by hand ready to go on the wire */
-		for (i=0; i<strlen(string); i++) {
-			(*data)[2*i]=string[i];
-			(*data)[2*i+1]='\0';
-		}			
-		return True;
-	}
-
-	if (!strcmp(value, "Architecture")) {			
-		pstring string="Windows NT x86";
-		*type = 0x1;			
-		*needed = 2*(strlen(string)+1);	
-		if((*data  = (uint8 *)talloc(ctx, ((*needed > in_size) ? *needed:in_size) *sizeof(uint8))) == NULL)
-			return False;
-		memset(*data, 0, (*needed > in_size) ? *needed:in_size);
-		for (i=0; i<strlen(string); i++) {
-			(*data)[2*i]=string[i];
-			(*data)[2*i+1]='\0';
-		}			
-		return True;
-	}
-	
-	return False;
-}
-
-/********************************************************************
- GetPrinterData on a printer Handle.
-********************************************************************/
-
-static BOOL getprinterdata_printer(pipes_struct *p, TALLOC_CTX *ctx, POLICY_HND *handle,
-				fstring value, uint32 *type,
-                        	uint8 **data, uint32 *needed, uint32 in_size )
-{
-	NT_PRINTER_INFO_LEVEL *printer = NULL;
-	int snum=0;
-	uint8 *idata=NULL;
-	uint32 len;
-	Printer_entry *Printer = find_printer_index_by_hnd(p, handle);
-	
-	DEBUG(5,("getprinterdata_printer\n"));
-
-	if (!Printer) {
-		DEBUG(2,("getprinterdata_printer: Invalid handle (%s:%u:%u).\n", OUR_HANDLE(handle)));
-		return False;
-	}
-
-	if(!get_printer_snum(p, handle, &snum))
-		return False;
-
-	if (!W_ERROR_IS_OK(get_a_printer(&printer, 2, lp_servicename(snum))))
-		return False;
-
-	if (!get_specific_param(*printer, 2, value, &idata, type, &len)) {
-		free_a_printer(&printer, 2);
-		return False;
-	}
-
-	free_a_printer(&printer, 2);
-
-	DEBUG(5,("getprinterdata_printer:allocating %d\n", in_size));
-
-	if (in_size) {
-		if((*data  = (uint8 *)talloc(ctx, in_size *sizeof(uint8) )) == NULL) {
-			return False;
-		}
-
-		memset(*data, 0, in_size *sizeof(uint8));
-		/* copy the min(in_size, len) */
-		memcpy(*data, idata, (len>in_size)?in_size:len *sizeof(uint8));
-	} else {
-		*data = NULL;
-	}
-
-	*needed = len;
-	
-	DEBUG(5,("getprinterdata_printer:copy done\n"));
-			
-	SAFE_FREE(idata);
-	
-	return True;
-}	
-
-/********************************************************************
- * spoolss_getprinterdata
- ********************************************************************/
-
-WERROR _spoolss_getprinterdata(pipes_struct *p, SPOOL_Q_GETPRINTERDATA *q_u, SPOOL_R_GETPRINTERDATA *r_u)
-{
-	POLICY_HND *handle = &q_u->handle;
-	UNISTR2 *valuename = &q_u->valuename;
-	uint32 in_size = q_u->size;
-	uint32 *type = &r_u->type;
-	uint32 *out_size = &r_u->size;
-	uint8 **data = &r_u->data;
-	uint32 *needed = &r_u->needed;
-
-	fstring value;
-	BOOL found=False;
-	Printer_entry *Printer = find_printer_index_by_hnd(p, handle);
-	
-	/*
-	 * Reminder: when it's a string, the length is in BYTES
-	 * even if UNICODE is negociated.
-	 *
-	 * JFM, 4/19/1999
-	 */
-
-	*out_size=in_size;
-
-	/* in case of problem, return some default values */
-	*needed=0;
-	*type=0;
-	
-	DEBUG(4,("_spoolss_getprinterdata\n"));
-	
-	if (!Printer) {
-		if((*data=(uint8 *)talloc_zero(p->mem_ctx, 4*sizeof(uint8))) == NULL)
-			return WERR_NOMEM;
-		DEBUG(2,("_spoolss_getprinterdata: Invalid handle (%s:%u:%u).\n", OUR_HANDLE(handle)));
-		return WERR_BADFID;
-	}
-	
-	unistr2_to_dos(value, valuename, sizeof(value)-1);
-	
-	if (Printer->printer_type == PRINTER_HANDLE_IS_PRINTSERVER)
-		found=getprinterdata_printer_server(p->mem_ctx, value, type, data, needed, *out_size);
-	else
-		found= getprinterdata_printer(p, p->mem_ctx, handle, value, type, data, needed, *out_size);
-
-	if (found==False) {
-		DEBUG(5, ("value not found, allocating %d\n", *out_size));
-		/* reply this param doesn't exist */
-		if (*out_size) {
-			if((*data=(uint8 *)talloc_zero(p->mem_ctx, *out_size*sizeof(uint8))) == NULL)
-				return WERR_NOMEM;
-		} else {
-			*data = NULL;
-		}
-
-		/* error depends on handle type */
-
-		if (Printer->printer_type == PRINTER_HANDLE_IS_PRINTSERVER)
-			return WERR_INVALID_PARAM;
-		else 
-			return WERR_BADFILE;
-	}
-	
-	if (*needed > *out_size)
-		return WERR_MORE_DATA;
-	else 
-		return WERR_OK;
-}
-
-/***************************************************************************
- Connect to the client.
-****************************************************************************/
-
-static BOOL srv_spoolss_replyopenprinter(char *printer, uint32 localprinter, uint32 type, POLICY_HND *handle)
-{
-	WERROR result;
-
-	/*
-	 * If it's the first connection, contact the client
-	 * and connect to the IPC$ share anonumously
-	 */
-	if (smb_connections==0) {
-		fstring unix_printer;
-
-		fstrcpy(unix_printer, printer+2); /* the +2 is to strip the leading 2 backslashs */
-		dos_to_unix(unix_printer);
-
-		if(!spoolss_connect_to_client(&cli, unix_printer))
-			return False;
-			
-		message_register(MSG_PRINTER_NOTIFY, srv_spoolss_receive_message);
-
-	}
-
-	smb_connections++;
-
-	result = cli_spoolss_reply_open_printer(&cli, cli.mem_ctx, printer, localprinter, 
-			type, handle);
-			
-	if (!W_ERROR_IS_OK(result))
-		DEBUG(5,("srv_spoolss_reply_open_printer: Client RPC returned [%s]\n",
-			dos_errstr(result)));
-
-	return (W_ERROR_IS_OK(result));	
-}
-
-/********************************************************************
- * _spoolss_rffpcnex
- * ReplyFindFirstPrinterChangeNotifyEx
- *
- * before replying OK: status=0 a rpc call is made to the workstation
- * asking ReplyOpenPrinter 
- *
- * in fact ReplyOpenPrinter is the changenotify equivalent on the spoolss pipe
- * called from api_spoolss_rffpcnex
- ********************************************************************/
-
-WERROR _spoolss_rffpcnex(pipes_struct *p, SPOOL_Q_RFFPCNEX *q_u, SPOOL_R_RFFPCNEX *r_u)
-{
-	POLICY_HND *handle = &q_u->handle;
-	uint32 flags = q_u->flags;
-	uint32 options = q_u->options;
-	UNISTR2 *localmachine = &q_u->localmachine;
-	uint32 printerlocal = q_u->printerlocal;
-	SPOOL_NOTIFY_OPTION *option = q_u->option;
-
-	/* store the notify value in the printer struct */
-
-	Printer_entry *Printer=find_printer_index_by_hnd(p, handle);
-
-	if (!Printer) {
-		DEBUG(2,("_spoolss_rffpcnex: Invalid handle (%s:%u:%u).\n", OUR_HANDLE(handle)));
-		return WERR_BADFID;
-	}
-
-	Printer->notify.flags=flags;
-	Printer->notify.options=options;
-	Printer->notify.printerlocal=printerlocal;
-
-	if (Printer->notify.option)
-		free_spool_notify_option(&Printer->notify.option);
-
-	Printer->notify.option=dup_spool_notify_option(option);
-
-	unistr2_to_dos(Printer->notify.localmachine, localmachine, sizeof(Printer->notify.localmachine)-1);
-
-	/* connect to the client machine and send a ReplyOpenPrinter */
-	if(srv_spoolss_replyopenprinter(Printer->notify.localmachine,
-					Printer->notify.printerlocal, 1,
-					&Printer->notify.client_hnd)) 
-	{
-		Printer->notify.client_connected=True;
-	}
-
-	return WERR_OK;
-}
-
-/*******************************************************************
- * fill a notify_info_data with the servername
- ********************************************************************/
-
-void spoolss_notify_server_name(int snum, 
-				       SPOOL_NOTIFY_INFO_DATA *data, 
-				       print_queue_struct *queue,
-				       NT_PRINTER_INFO_LEVEL *printer,
-				       TALLOC_CTX *mem_ctx) 
-{
-	pstring temp_name, temp;
-	uint32 len;
-
-	slprintf(temp_name, sizeof(temp_name)-1, "\\\\%s", get_called_name());
-
-	len = (uint32)dos_PutUniCode(temp, temp_name, sizeof(temp) - 2, True);
-
-	data->notify_data.data.length = len / 2 - 1;
-	data->notify_data.data.string = (uint16 *)talloc(mem_ctx, len);
-
-	if (!data->notify_data.data.string) {
-		data->notify_data.data.length = 0;
-		return;
-	}
-	
-	memcpy(data->notify_data.data.string, temp, len);
-}
-
-/*******************************************************************
- * fill a notify_info_data with the printername (not including the servername).
- ********************************************************************/
-
-void spoolss_notify_printer_name(int snum, 
-					SPOOL_NOTIFY_INFO_DATA *data, 
-					print_queue_struct *queue,
-					NT_PRINTER_INFO_LEVEL *printer,
-					TALLOC_CTX *mem_ctx)
-{
-	pstring temp;
-	uint32 len;
-		
-	/* the notify name should not contain the \\server\ part */
-	char *p = strrchr(printer->info_2->printername, '\\');
-
-	if (!p) {
-		p = printer->info_2->printername;
-	} else {
-		p++;
-	}
-
-	len = (uint32)dos_PutUniCode(temp, p, sizeof(temp) - 2, True);
-
-	data->notify_data.data.length = len / 2 - 1;
-	data->notify_data.data.string = (uint16 *)talloc(mem_ctx, len);
-	
-	if (!data->notify_data.data.string) {
-		data->notify_data.data.length = 0;
-		return;
-	}
-	
-	memcpy(data->notify_data.data.string, temp, len);
-}
-
-/*******************************************************************
- * fill a notify_info_data with the servicename
- ********************************************************************/
-
-void spoolss_notify_share_name(int snum, 
-				      SPOOL_NOTIFY_INFO_DATA *data, 
-				      print_queue_struct *queue,
-				      NT_PRINTER_INFO_LEVEL *printer,
-				      TALLOC_CTX *mem_ctx)
-{
-	pstring temp;
-	uint32 len;
-
-	len = (uint32)dos_PutUniCode(temp, lp_servicename(snum), 
-				     sizeof(temp) - 2, True);
-
-	data->notify_data.data.length = len / 2 - 1;
-	data->notify_data.data.string = (uint16 *)talloc(mem_ctx, len);
-	
-	if (!data->notify_data.data.string) {
-		data->notify_data.data.length = 0;
-		return;
-	}
-	
-	memcpy(data->notify_data.data.string, temp, len);
-}
-
-/*******************************************************************
- * fill a notify_info_data with the port name
- ********************************************************************/
-
-void spoolss_notify_port_name(int snum, 
-				     SPOOL_NOTIFY_INFO_DATA *data, 
-				     print_queue_struct *queue,
-				     NT_PRINTER_INFO_LEVEL *printer,
-				     TALLOC_CTX *mem_ctx)
-{
-	pstring temp;
-	uint32 len;
-
-	/* even if it's strange, that's consistant in all the code */
-
-	len = (uint32)dos_PutUniCode(temp, printer->info_2->portname, 
-				     sizeof(temp) - 2, True);
-
-	data->notify_data.data.length = len / 2 - 1;
-	data->notify_data.data.string = (uint16 *)talloc(mem_ctx, len);
-	
-	if (!data->notify_data.data.string) {
-		data->notify_data.data.length = 0;
-		return;
-	}
-	
-	memcpy(data->notify_data.data.string, temp, len);
-}
-
-/*******************************************************************
- * fill a notify_info_data with the printername
- * but it doesn't exist, have to see what to do
- ********************************************************************/
-
-void spoolss_notify_driver_name(int snum, 
-				       SPOOL_NOTIFY_INFO_DATA *data,
-				       print_queue_struct *queue,
-				       NT_PRINTER_INFO_LEVEL *printer,
-				       TALLOC_CTX *mem_ctx)
-{
-	pstring temp;
-	uint32 len;
-
-	len = (uint32)dos_PutUniCode(temp, printer->info_2->drivername, 
-				     sizeof(temp) - 2, True);
-
-	data->notify_data.data.length = len / 2 - 1;
-	data->notify_data.data.string = (uint16 *)talloc(mem_ctx, len);
-	
-	if (!data->notify_data.data.string) {
-		data->notify_data.data.length = 0;
-		return;
-	}
-	
-	memcpy(data->notify_data.data.string, temp, len);
-}
-
-/*******************************************************************
- * fill a notify_info_data with the comment
- ********************************************************************/
-
-void spoolss_notify_comment(int snum, 
-				   SPOOL_NOTIFY_INFO_DATA *data,
-				   print_queue_struct *queue,
-				   NT_PRINTER_INFO_LEVEL *printer,
-				   TALLOC_CTX *mem_ctx)
-{
-	pstring temp;
-	uint32 len;
-
-	if (*printer->info_2->comment == '\0')
-		len = (uint32)dos_PutUniCode(temp, lp_comment(snum), 
-					     sizeof(temp) - 2, True);
-	else
-		len = (uint32)dos_PutUniCode(temp, printer->info_2->comment, 
-					     sizeof(temp) - 2, True);
-
-	data->notify_data.data.length = len / 2 - 1;
-	data->notify_data.data.string = (uint16 *)talloc(mem_ctx, len);
-	
-	if (!data->notify_data.data.string) {
-		data->notify_data.data.length = 0;
-		return;
-	}
-	
-	memcpy(data->notify_data.data.string, temp, len);
-}
-
-/*******************************************************************
- * fill a notify_info_data with the comment
- * location = "Room 1, floor 2, building 3"
- ********************************************************************/
-
-void spoolss_notify_location(int snum, 
-				    SPOOL_NOTIFY_INFO_DATA *data,
-				    print_queue_struct *queue,
-				    NT_PRINTER_INFO_LEVEL *printer,
-				    TALLOC_CTX *mem_ctx)
-{
-	pstring temp;
-	uint32 len;
-
-	len = (uint32)dos_PutUniCode(temp, printer->info_2->location, 
-				     sizeof(temp) - 2, True);
-
-	data->notify_data.data.length = len / 2 - 1;
-	data->notify_data.data.string = (uint16 *)talloc(mem_ctx, len);
-	
-	if (!data->notify_data.data.string) {
-		data->notify_data.data.length = 0;
-		return;
-	}
-	
-	memcpy(data->notify_data.data.string, temp, len);
-}
-
-/*******************************************************************
- * fill a notify_info_data with the device mode
- * jfm:xxxx don't to it for know but that's a real problem !!!
- ********************************************************************/
-
-static void spoolss_notify_devmode(int snum, 
-				   SPOOL_NOTIFY_INFO_DATA *data,
-				   print_queue_struct *queue,
-				   NT_PRINTER_INFO_LEVEL *printer,
-				   TALLOC_CTX *mem_ctx)
-{
-}
-
-/*******************************************************************
- * fill a notify_info_data with the separator file name
- ********************************************************************/
-
-void spoolss_notify_sepfile(int snum, 
-				   SPOOL_NOTIFY_INFO_DATA *data, 
-				   print_queue_struct *queue,
-				   NT_PRINTER_INFO_LEVEL *printer,
-				   TALLOC_CTX *mem_ctx)
-{
-	pstring temp;
-	uint32 len;
-
-	len = (uint32)dos_PutUniCode(temp, printer->info_2->sepfile, 
-				     sizeof(temp) - 2, True);
-
-	data->notify_data.data.length = len / 2 - 1;
-	data->notify_data.data.string = (uint16 *)talloc(mem_ctx, len);
-	
-	if (!data->notify_data.data.string) {
-		data->notify_data.data.length = 0;
-		return;
-	}
-	
-	memcpy(data->notify_data.data.string, temp, len);
-}
-
-/*******************************************************************
- * fill a notify_info_data with the print processor
- * jfm:xxxx return always winprint to indicate we don't do anything to it
- ********************************************************************/
-
-void spoolss_notify_print_processor(int snum, 
-					   SPOOL_NOTIFY_INFO_DATA *data,
-					   print_queue_struct *queue,
-					   NT_PRINTER_INFO_LEVEL *printer,
-					   TALLOC_CTX *mem_ctx)
-{
-	pstring temp;
-	uint32 len;
-
-	len = (uint32)dos_PutUniCode(temp, printer->info_2->printprocessor, 
-				     sizeof(temp) - 2, True);
-
-	data->notify_data.data.length = len / 2 - 1;
-	data->notify_data.data.string = (uint16 *)talloc(mem_ctx, len);
-	
-	if (!data->notify_data.data.string) {
-		data->notify_data.data.length = 0;
-		return;
-	}
-	
-	memcpy(data->notify_data.data.string, temp, len);
-}
-
-/*******************************************************************
- * fill a notify_info_data with the print processor options
- * jfm:xxxx send an empty string
- ********************************************************************/
-
-void spoolss_notify_parameters(int snum, 
-				      SPOOL_NOTIFY_INFO_DATA *data,
-				      print_queue_struct *queue,
-				      NT_PRINTER_INFO_LEVEL *printer,
-				      TALLOC_CTX *mem_ctx)
-{
-	pstring temp;
-	uint32 len;
-
-	len = (uint32)dos_PutUniCode(temp, printer->info_2->parameters, 
-				     sizeof(temp) - 2, True);
-
-	data->notify_data.data.length = len / 2 - 1;
-	data->notify_data.data.string = (uint16 *)talloc(mem_ctx, len);
-	
-	if (!data->notify_data.data.string) {
-		data->notify_data.data.length = 0;
-		return;
-	}
-	
-	memcpy(data->notify_data.data.string, temp, len);
-}
-
-/*******************************************************************
- * fill a notify_info_data with the data type
- * jfm:xxxx always send RAW as data type
- ********************************************************************/
-
-void spoolss_notify_datatype(int snum, 
-				    SPOOL_NOTIFY_INFO_DATA *data,
-				    print_queue_struct *queue,
-				    NT_PRINTER_INFO_LEVEL *printer,
-				    TALLOC_CTX *mem_ctx)
-{
-	pstring temp;
-	uint32 len;
-
-	len = (uint32)dos_PutUniCode(temp, printer->info_2->datatype, 
-				     sizeof(pstring) - 2, True);
-
-	data->notify_data.data.length = len / 2 - 1;
-	data->notify_data.data.string = (uint16 *)talloc(mem_ctx, len);
-	
-	if (!data->notify_data.data.string) {
-		data->notify_data.data.length = 0;
-		return;
-	}
-	
-	memcpy(data->notify_data.data.string, temp, len);
-}
-
-/*******************************************************************
- * fill a notify_info_data with the security descriptor
- * jfm:xxxx send an null pointer to say no security desc
- * have to implement security before !
- ********************************************************************/
-
-static void spoolss_notify_security_desc(int snum, 
-					 SPOOL_NOTIFY_INFO_DATA *data,
-					 print_queue_struct *queue,
-					 NT_PRINTER_INFO_LEVEL *printer,
-					 TALLOC_CTX *mem_ctx)
-{
-	data->notify_data.data.length=0;
-	data->notify_data.data.string = NULL;
-}
-
-/*******************************************************************
- * fill a notify_info_data with the attributes
- * jfm:xxxx a samba printer is always shared
- ********************************************************************/
-
-void spoolss_notify_attributes(int snum, 
-				      SPOOL_NOTIFY_INFO_DATA *data,
-				      print_queue_struct *queue,
-				      NT_PRINTER_INFO_LEVEL *printer,
-				      TALLOC_CTX *mem_ctx)
-{
-	data->notify_data.value[0] = printer->info_2->attributes;
-	data->notify_data.value[1] = 0;
-}
-
-/*******************************************************************
- * fill a notify_info_data with the priority
- ********************************************************************/
-
-static void spoolss_notify_priority(int snum, 
-				    SPOOL_NOTIFY_INFO_DATA *data,
-				    print_queue_struct *queue,
-				    NT_PRINTER_INFO_LEVEL *printer,
-				    TALLOC_CTX *mem_ctx)
-{
-	data->notify_data.value[0] = printer->info_2->priority;
-	data->notify_data.value[1] = 0;
-}
-
-/*******************************************************************
- * fill a notify_info_data with the default priority
- ********************************************************************/
-
-static void spoolss_notify_default_priority(int snum, 
-					    SPOOL_NOTIFY_INFO_DATA *data,
-					    print_queue_struct *queue,
-					    NT_PRINTER_INFO_LEVEL *printer,
-					    TALLOC_CTX *mem_ctx)
-{
-	data->notify_data.value[0] = printer->info_2->default_priority;
-	data->notify_data.value[1] = 0;
-}
-
-/*******************************************************************
- * fill a notify_info_data with the start time
- ********************************************************************/
-
-static void spoolss_notify_start_time(int snum, 
-				      SPOOL_NOTIFY_INFO_DATA *data,
-				      print_queue_struct *queue,
-				      NT_PRINTER_INFO_LEVEL *printer,
-				      TALLOC_CTX *mem_ctx)
-{
-	data->notify_data.value[0] = printer->info_2->starttime;
-	data->notify_data.value[1] = 0;
-}
-
-/*******************************************************************
- * fill a notify_info_data with the until time
- ********************************************************************/
-
-static void spoolss_notify_until_time(int snum, 
-				      SPOOL_NOTIFY_INFO_DATA *data,
-				      print_queue_struct *queue,
-				      NT_PRINTER_INFO_LEVEL *printer,
-				      TALLOC_CTX *mem_ctx)
-{
-	data->notify_data.value[0] = printer->info_2->untiltime;
-	data->notify_data.value[1] = 0;
-}
-
-/*******************************************************************
- * fill a notify_info_data with the status
- ********************************************************************/
-
-static void spoolss_notify_status(int snum, 
-				  SPOOL_NOTIFY_INFO_DATA *data,
-				  print_queue_struct *queue,
-				  NT_PRINTER_INFO_LEVEL *printer,
-				  TALLOC_CTX *mem_ctx)
-{
-	print_status_struct status;
-
-	print_queue_length(snum, &status);
-	data->notify_data.value[0]=(uint32) status.status;
-	data->notify_data.value[1] = 0;
-}
-
-/*******************************************************************
- * fill a notify_info_data with the number of jobs queued
- ********************************************************************/
-
-void spoolss_notify_cjobs(int snum, 
-				 SPOOL_NOTIFY_INFO_DATA *data,
-				 print_queue_struct *queue,
-				 NT_PRINTER_INFO_LEVEL *printer, 
-				 TALLOC_CTX *mem_ctx)
-{
-	data->notify_data.value[0] = print_queue_length(snum, NULL);
-	data->notify_data.value[1] = 0;
-}
-
-/*******************************************************************
- * fill a notify_info_data with the average ppm
- ********************************************************************/
-
-static void spoolss_notify_average_ppm(int snum, 
-				       SPOOL_NOTIFY_INFO_DATA *data,
-				       print_queue_struct *queue,
-				       NT_PRINTER_INFO_LEVEL *printer,
-				       TALLOC_CTX *mem_ctx)
-{
-	/* always respond 8 pages per minutes */
-	/* a little hard ! */
-	data->notify_data.value[0] = printer->info_2->averageppm;
-	data->notify_data.value[1] = 0;
-}
-
-/*******************************************************************
- * fill a notify_info_data with username
- ********************************************************************/
-
-static void spoolss_notify_username(int snum, 
-				    SPOOL_NOTIFY_INFO_DATA *data,
-				    print_queue_struct *queue,
-				    NT_PRINTER_INFO_LEVEL *printer,
-				    TALLOC_CTX *mem_ctx)
-{
-	pstring temp;
-	uint32 len;
-
-	len = (uint32)dos_PutUniCode(temp, queue->fs_user, 
-				     sizeof(temp) - 2, True);
-
-	data->notify_data.data.length = len / 2 - 1;
-	data->notify_data.data.string = (uint16 *)talloc(mem_ctx, len);
-	
-	if (!data->notify_data.data.string) {
-		data->notify_data.data.length = 0;
-		return;
-	}
-	
-	memcpy(data->notify_data.data.string, temp, len);
-}
-
-/*******************************************************************
- * fill a notify_info_data with job status
- ********************************************************************/
-
-static void spoolss_notify_job_status(int snum, 
-				      SPOOL_NOTIFY_INFO_DATA *data,
-				      print_queue_struct *queue,
-				      NT_PRINTER_INFO_LEVEL *printer,
-				      TALLOC_CTX *mem_ctx)
-{
-	data->notify_data.value[0]=nt_printj_status(queue->status);
-	data->notify_data.value[1] = 0;
-}
-
-/*******************************************************************
- * fill a notify_info_data with job name
- ********************************************************************/
-
-static void spoolss_notify_job_name(int snum, 
-				    SPOOL_NOTIFY_INFO_DATA *data,
-				    print_queue_struct *queue,
-				    NT_PRINTER_INFO_LEVEL *printer,
-				    TALLOC_CTX *mem_ctx)
-{
-	pstring temp;
-	uint32 len;
-
-	len = (uint32)dos_PutUniCode(temp, queue->fs_file, sizeof(temp) - 2, 
-				     True);
-
-	data->notify_data.data.length = len / 2 - 1;
-	data->notify_data.data.string = (uint16 *)talloc(mem_ctx, len);
-	
-	if (!data->notify_data.data.string) {
-		data->notify_data.data.length = 0;
-		return;
-	}
-	
-	memcpy(data->notify_data.data.string, temp, len);
-}
-
-/*******************************************************************
- * fill a notify_info_data with job status
- ********************************************************************/
-
-static void spoolss_notify_job_status_string(int snum, 
-					     SPOOL_NOTIFY_INFO_DATA *data,
-					     print_queue_struct *queue,
-					     NT_PRINTER_INFO_LEVEL *printer, 
-					     TALLOC_CTX *mem_ctx)
-{
-	/*
-	 * Now we're returning job status codes we just return a "" here. JRA.
-	 */
-
-	const char *p = "";
-	pstring temp;
-	uint32 len;
-
-#if 0 /* NO LONGER NEEDED - JRA. 02/22/2001 */
-	p = "unknown";
-
-	switch (queue->status) {
-	case LPQ_QUEUED:
-		p = "Queued";
-		break;
-	case LPQ_PAUSED:
-		p = "";    /* NT provides the paused string */
-		break;
-	case LPQ_SPOOLING:
-		p = "Spooling";
-		break;
-	case LPQ_PRINTING:
-		p = "Printing";
-		break;
-	}
-#endif /* NO LONGER NEEDED. */
-
-	len = (uint32)dos_PutUniCode(temp, p, sizeof(temp) - 2, True);
-
-	data->notify_data.data.length = len / 2 - 1;
-	data->notify_data.data.string = (uint16 *)talloc(mem_ctx, len);
-	
-	if (!data->notify_data.data.string) {
-		data->notify_data.data.length = 0;
-		return;
-	}
-	
-	memcpy(data->notify_data.data.string, temp, len);
-}
-
-/*******************************************************************
- * fill a notify_info_data with job time
- ********************************************************************/
-
-static void spoolss_notify_job_time(int snum, 
-				    SPOOL_NOTIFY_INFO_DATA *data,
-				    print_queue_struct *queue,
-				    NT_PRINTER_INFO_LEVEL *printer,
-				    TALLOC_CTX *mem_ctx)
-{
-	data->notify_data.value[0]=0x0;
-	data->notify_data.value[1]=0;
-}
-
-/*******************************************************************
- * fill a notify_info_data with job size
- ********************************************************************/
-
-static void spoolss_notify_job_size(int snum, 
-				    SPOOL_NOTIFY_INFO_DATA *data,
-				    print_queue_struct *queue,
-				    NT_PRINTER_INFO_LEVEL *printer,
-				    TALLOC_CTX *mem_ctx)
-{
-	data->notify_data.value[0]=queue->size;
-	data->notify_data.value[1]=0;
-}
-
-/*******************************************************************
- * fill a notify_info_data with page info
- ********************************************************************/
-static void spoolss_notify_total_pages(int snum,
-				SPOOL_NOTIFY_INFO_DATA *data,
-				print_queue_struct *queue,
-				NT_PRINTER_INFO_LEVEL *printer,
-				TALLOC_CTX *mem_ctx)
-{
-	data->notify_data.value[0]=queue->page_count;
-	data->notify_data.value[1]=0;
-}
-
-/*******************************************************************
- * fill a notify_info_data with pages printed info.
- ********************************************************************/
-static void spoolss_notify_pages_printed(int snum,
-				SPOOL_NOTIFY_INFO_DATA *data,
-				print_queue_struct *queue,
-				NT_PRINTER_INFO_LEVEL *printer,
-				TALLOC_CTX *mem_ctx)
-{
-	data->notify_data.value[0]=0;  /* Add code when back-end tracks this */
-	data->notify_data.value[1]=0;
-}
-
-/*******************************************************************
- Fill a notify_info_data with job position.
- ********************************************************************/
-
-static void spoolss_notify_job_position(int snum, 
-					SPOOL_NOTIFY_INFO_DATA *data,
-					print_queue_struct *queue,
-					NT_PRINTER_INFO_LEVEL *printer,
-					TALLOC_CTX *mem_ctx)
-{
-	data->notify_data.value[0]=queue->job;
-	data->notify_data.value[1]=0;
-}
-
-/*******************************************************************
- Fill a notify_info_data with submitted time.
- ********************************************************************/
-
-static void spoolss_notify_submitted_time(int snum, 
-					  SPOOL_NOTIFY_INFO_DATA *data,
-					  print_queue_struct *queue,
-					  NT_PRINTER_INFO_LEVEL *printer,
-					  TALLOC_CTX *mem_ctx)
-{
-	struct tm *t;
-	uint32 len;
-	SYSTEMTIME st;
-	char *p;
-
-	t=gmtime(&queue->time);
-
-	len = sizeof(SYSTEMTIME);
-
-	data->notify_data.data.length = len;
-	data->notify_data.data.string = (uint16 *)talloc(mem_ctx, len);
-
-	if (!data->notify_data.data.string) {
-		data->notify_data.data.length = 0;
-		return;
-	}
-	
-	make_systemtime(&st, t);
-
-	/*
-	 * Systemtime must be linearized as a set of UINT16's. 
-	 * Fix from Benjamin (Bj) Kuit bj@it.uts.edu.au
-	 */
-
-	p = (char *)data->notify_data.data.string;
-	SSVAL(p, 0, st.year);
-	SSVAL(p, 2, st.month);
-	SSVAL(p, 4, st.dayofweek);
-	SSVAL(p, 6, st.day);
-	SSVAL(p, 8, st.hour);
-        SSVAL(p, 10, st.minute);
-	SSVAL(p, 12, st.second);
-	SSVAL(p, 14, st.milliseconds);
-}
-
-#define END 65535
-
-struct s_notify_info_data_table
-{
-	uint16 type;
-	uint16 field;
-	const char *name;
-	uint32 size;
-	void (*fn) (int snum, SPOOL_NOTIFY_INFO_DATA *data,
-		    print_queue_struct *queue,
-		    NT_PRINTER_INFO_LEVEL *printer, TALLOC_CTX *mem_ctx);
-};
-
-/* A table describing the various print notification constants and
-   whether the notification data is a pointer to a variable sized
-   buffer, a one value uint32 or a two value uint32. */
-
-struct s_notify_info_data_table notify_info_data_table[] =
-{
-{ PRINTER_NOTIFY_TYPE, PRINTER_NOTIFY_SERVER_NAME,         "PRINTER_NOTIFY_SERVER_NAME",         POINTER,   spoolss_notify_server_name },
-{ PRINTER_NOTIFY_TYPE, PRINTER_NOTIFY_PRINTER_NAME,        "PRINTER_NOTIFY_PRINTER_NAME",        POINTER,   spoolss_notify_printer_name },
-{ PRINTER_NOTIFY_TYPE, PRINTER_NOTIFY_SHARE_NAME,          "PRINTER_NOTIFY_SHARE_NAME",          POINTER,   spoolss_notify_share_name },
-{ PRINTER_NOTIFY_TYPE, PRINTER_NOTIFY_PORT_NAME,           "PRINTER_NOTIFY_PORT_NAME",           POINTER,   spoolss_notify_port_name },
-{ PRINTER_NOTIFY_TYPE, PRINTER_NOTIFY_DRIVER_NAME,         "PRINTER_NOTIFY_DRIVER_NAME",         POINTER,   spoolss_notify_driver_name },
-{ PRINTER_NOTIFY_TYPE, PRINTER_NOTIFY_COMMENT,             "PRINTER_NOTIFY_COMMENT",             POINTER,   spoolss_notify_comment },
-{ PRINTER_NOTIFY_TYPE, PRINTER_NOTIFY_LOCATION,            "PRINTER_NOTIFY_LOCATION",            POINTER,   spoolss_notify_location },
-{ PRINTER_NOTIFY_TYPE, PRINTER_NOTIFY_DEVMODE,             "PRINTER_NOTIFY_DEVMODE",             POINTER,   spoolss_notify_devmode },
-{ PRINTER_NOTIFY_TYPE, PRINTER_NOTIFY_SEPFILE,             "PRINTER_NOTIFY_SEPFILE",             POINTER,   spoolss_notify_sepfile },
-{ PRINTER_NOTIFY_TYPE, PRINTER_NOTIFY_PRINT_PROCESSOR,     "PRINTER_NOTIFY_PRINT_PROCESSOR",     POINTER,   spoolss_notify_print_processor },
-{ PRINTER_NOTIFY_TYPE, PRINTER_NOTIFY_PARAMETERS,          "PRINTER_NOTIFY_PARAMETERS",          POINTER,   spoolss_notify_parameters },
-{ PRINTER_NOTIFY_TYPE, PRINTER_NOTIFY_DATATYPE,            "PRINTER_NOTIFY_DATATYPE",            POINTER,   spoolss_notify_datatype },
-{ PRINTER_NOTIFY_TYPE, PRINTER_NOTIFY_SECURITY_DESCRIPTOR, "PRINTER_NOTIFY_SECURITY_DESCRIPTOR", POINTER,   spoolss_notify_security_desc },
-{ PRINTER_NOTIFY_TYPE, PRINTER_NOTIFY_ATTRIBUTES,          "PRINTER_NOTIFY_ATTRIBUTES",          ONE_VALUE, spoolss_notify_attributes },
-{ PRINTER_NOTIFY_TYPE, PRINTER_NOTIFY_PRIORITY,            "PRINTER_NOTIFY_PRIORITY",            ONE_VALUE, spoolss_notify_priority },
-{ PRINTER_NOTIFY_TYPE, PRINTER_NOTIFY_DEFAULT_PRIORITY,    "PRINTER_NOTIFY_DEFAULT_PRIORITY",    ONE_VALUE, spoolss_notify_default_priority },
-{ PRINTER_NOTIFY_TYPE, PRINTER_NOTIFY_START_TIME,          "PRINTER_NOTIFY_START_TIME",          ONE_VALUE, spoolss_notify_start_time },
-{ PRINTER_NOTIFY_TYPE, PRINTER_NOTIFY_UNTIL_TIME,          "PRINTER_NOTIFY_UNTIL_TIME",          ONE_VALUE, spoolss_notify_until_time },
-{ PRINTER_NOTIFY_TYPE, PRINTER_NOTIFY_STATUS,              "PRINTER_NOTIFY_STATUS",              ONE_VALUE, spoolss_notify_status },
-{ PRINTER_NOTIFY_TYPE, PRINTER_NOTIFY_STATUS_STRING,       "PRINTER_NOTIFY_STATUS_STRING",       POINTER,   NULL },
-{ PRINTER_NOTIFY_TYPE, PRINTER_NOTIFY_CJOBS,               "PRINTER_NOTIFY_CJOBS",               ONE_VALUE, spoolss_notify_cjobs },
-{ PRINTER_NOTIFY_TYPE, PRINTER_NOTIFY_AVERAGE_PPM,         "PRINTER_NOTIFY_AVERAGE_PPM",         ONE_VALUE, spoolss_notify_average_ppm },
-{ PRINTER_NOTIFY_TYPE, PRINTER_NOTIFY_TOTAL_PAGES,         "PRINTER_NOTIFY_TOTAL_PAGES",         POINTER,   NULL },
-{ PRINTER_NOTIFY_TYPE, PRINTER_NOTIFY_PAGES_PRINTED,       "PRINTER_NOTIFY_PAGES_PRINTED",       POINTER,   NULL },
-{ PRINTER_NOTIFY_TYPE, PRINTER_NOTIFY_TOTAL_BYTES,         "PRINTER_NOTIFY_TOTAL_BYTES",         POINTER,   NULL },
-{ PRINTER_NOTIFY_TYPE, PRINTER_NOTIFY_BYTES_PRINTED,       "PRINTER_NOTIFY_BYTES_PRINTED",       POINTER,   NULL },
-{ JOB_NOTIFY_TYPE,     JOB_NOTIFY_PRINTER_NAME,            "JOB_NOTIFY_PRINTER_NAME",            POINTER,   spoolss_notify_printer_name },
-{ JOB_NOTIFY_TYPE,     JOB_NOTIFY_MACHINE_NAME,            "JOB_NOTIFY_MACHINE_NAME",            POINTER,   spoolss_notify_server_name },
-{ JOB_NOTIFY_TYPE,     JOB_NOTIFY_PORT_NAME,               "JOB_NOTIFY_PORT_NAME",               POINTER,   spoolss_notify_port_name },
-{ JOB_NOTIFY_TYPE,     JOB_NOTIFY_USER_NAME,               "JOB_NOTIFY_USER_NAME",               POINTER,   spoolss_notify_username },
-{ JOB_NOTIFY_TYPE,     JOB_NOTIFY_NOTIFY_NAME,             "JOB_NOTIFY_NOTIFY_NAME",             POINTER,   spoolss_notify_username },
-{ JOB_NOTIFY_TYPE,     JOB_NOTIFY_DATATYPE,                "JOB_NOTIFY_DATATYPE",                POINTER,   spoolss_notify_datatype },
-{ JOB_NOTIFY_TYPE,     JOB_NOTIFY_PRINT_PROCESSOR,         "JOB_NOTIFY_PRINT_PROCESSOR",         POINTER,   spoolss_notify_print_processor },
-{ JOB_NOTIFY_TYPE,     JOB_NOTIFY_PARAMETERS,              "JOB_NOTIFY_PARAMETERS",              POINTER,   spoolss_notify_parameters },
-{ JOB_NOTIFY_TYPE,     JOB_NOTIFY_DRIVER_NAME,             "JOB_NOTIFY_DRIVER_NAME",             POINTER,   spoolss_notify_driver_name },
-{ JOB_NOTIFY_TYPE,     JOB_NOTIFY_DEVMODE,                 "JOB_NOTIFY_DEVMODE",                 POINTER,   spoolss_notify_devmode },
-{ JOB_NOTIFY_TYPE,     JOB_NOTIFY_STATUS,                  "JOB_NOTIFY_STATUS",                  ONE_VALUE, spoolss_notify_job_status },
-{ JOB_NOTIFY_TYPE,     JOB_NOTIFY_STATUS_STRING,           "JOB_NOTIFY_STATUS_STRING",           POINTER,   spoolss_notify_job_status_string },
-{ JOB_NOTIFY_TYPE,     JOB_NOTIFY_SECURITY_DESCRIPTOR,     "JOB_NOTIFY_SECURITY_DESCRIPTOR",     POINTER,   NULL },
-{ JOB_NOTIFY_TYPE,     JOB_NOTIFY_DOCUMENT,                "JOB_NOTIFY_DOCUMENT",                POINTER,   spoolss_notify_job_name },
-{ JOB_NOTIFY_TYPE,     JOB_NOTIFY_PRIORITY,                "JOB_NOTIFY_PRIORITY",                ONE_VALUE, spoolss_notify_priority },
-{ JOB_NOTIFY_TYPE,     JOB_NOTIFY_POSITION,                "JOB_NOTIFY_POSITION",                ONE_VALUE, spoolss_notify_job_position },
-{ JOB_NOTIFY_TYPE,     JOB_NOTIFY_SUBMITTED,               "JOB_NOTIFY_SUBMITTED",               POINTER,   spoolss_notify_submitted_time },
-{ JOB_NOTIFY_TYPE,     JOB_NOTIFY_START_TIME,              "JOB_NOTIFY_START_TIME",              ONE_VALUE, spoolss_notify_start_time },
-{ JOB_NOTIFY_TYPE,     JOB_NOTIFY_UNTIL_TIME,              "JOB_NOTIFY_UNTIL_TIME",              ONE_VALUE, spoolss_notify_until_time },
-{ JOB_NOTIFY_TYPE,     JOB_NOTIFY_TIME,                    "JOB_NOTIFY_TIME",                    ONE_VALUE, spoolss_notify_job_time },
-{ JOB_NOTIFY_TYPE,     JOB_NOTIFY_TOTAL_PAGES,             "JOB_NOTIFY_TOTAL_PAGES",             ONE_VALUE, spoolss_notify_total_pages },
-{ JOB_NOTIFY_TYPE,     JOB_NOTIFY_PAGES_PRINTED,           "JOB_NOTIFY_PAGES_PRINTED",           ONE_VALUE, spoolss_notify_pages_printed },
-{ JOB_NOTIFY_TYPE,     JOB_NOTIFY_TOTAL_BYTES,             "JOB_NOTIFY_TOTAL_BYTES",             ONE_VALUE, spoolss_notify_job_size },
-{ JOB_NOTIFY_TYPE,     JOB_NOTIFY_BYTES_PRINTED,           "JOB_NOTIFY_BYTES_PRINTED",           ONE_VALUE, NULL },
-{ END,                 END,                                "",                                   END,       NULL }
-};
-
-/*******************************************************************
- Return the size of info_data structure.
-********************************************************************/
-
-static uint32 size_of_notify_info_data(uint16 type, uint16 field)
-{
-	int i=0;
-
-	while (notify_info_data_table[i].type != END)
-	{
-		if ( (notify_info_data_table[i].type == type ) &&
-		     (notify_info_data_table[i].field == field ) )
-		{
-			return (notify_info_data_table[i].size);
-		}
-		i++;
-	}
-	return (65535);
-}
-
-/*******************************************************************
- Return the type of notify_info_data.
-********************************************************************/
-
-static BOOL type_of_notify_info_data(uint16 type, uint16 field)
-{
-	int i=0;
-
-	while (notify_info_data_table[i].type != END)
-	{
-		if ( (notify_info_data_table[i].type == type ) &&
-		     (notify_info_data_table[i].field == field ) )
-		{
-			if (notify_info_data_table[i].size == POINTER)
-			{
-				return (False);
-			}
-			else
-			{
-				return (True);
-			}
-		}
-		i++;
-	}
-	return (False);
-}
-
-/****************************************************************************
-****************************************************************************/
-
-static int search_notify(uint16 type, uint16 field, int *value)
-{	
-	int j;
-	BOOL found;
-
-	for (j=0, found=False; found==False && notify_info_data_table[j].type != END ; j++)
-	{
-		if ( (notify_info_data_table[j].type  == type  ) &&
-		     (notify_info_data_table[j].field == field ) )
-			found=True;
-	}
-	*value=--j;
-
-	if ( found && (notify_info_data_table[j].fn != NULL) )
-		return True;
-	else
-		return False;	
-}
-
-/****************************************************************************
-****************************************************************************/
-
-void construct_info_data(SPOOL_NOTIFY_INFO_DATA *info_data, uint16 type, uint16 field, int id)
-{
-	info_data->type     = type;
-	info_data->field    = field;
-	info_data->reserved = 0;
-	info_data->id       = id;
-	info_data->size     = size_of_notify_info_data(type, field);
-	info_data->enc_type = type_of_notify_info_data(type, field);
-}
-
-
-/*******************************************************************
- *
- * fill a notify_info struct with info asked
- *
- ********************************************************************/
-
-static BOOL construct_notify_printer_info(SPOOL_NOTIFY_INFO *info, int
-					  snum, SPOOL_NOTIFY_OPTION_TYPE
-					  *option_type, uint32 id,
-					  TALLOC_CTX *mem_ctx) 
-{
-	int field_num,j;
-	uint16 type;
-	uint16 field;
-
-	SPOOL_NOTIFY_INFO_DATA *current_data, *tid;
-	NT_PRINTER_INFO_LEVEL *printer = NULL;
-	print_queue_struct *queue=NULL;
-
-	type=option_type->type;
-
-	DEBUG(4,("construct_notify_printer_info: Notify type: [%s], number of notify info: [%d] on printer: [%s]\n",
-		(option_type->type==PRINTER_NOTIFY_TYPE?"PRINTER_NOTIFY_TYPE":"JOB_NOTIFY_TYPE"),
-		option_type->count, lp_servicename(snum)));
-	
-	if (!W_ERROR_IS_OK(get_a_printer(&printer, 2, lp_servicename(snum))))
-		return False;
-
-	for(field_num=0; field_num<option_type->count; field_num++) {
-		field = option_type->fields[field_num];
-		DEBUG(4,("construct_notify_printer_info: notify [%d]: type [%x], field [%x]\n", field_num, type, field));
-
-		if (!search_notify(type, field, &j) )
-			continue;
-
-		if((tid=(SPOOL_NOTIFY_INFO_DATA *)Realloc(info->data, (info->count+1)*sizeof(SPOOL_NOTIFY_INFO_DATA))) == NULL) {
-			DEBUG(2,("construct_notify_printer_info: failed to enlarge buffer info->data!\n"));
-			return False;
-		}
-		else info->data = tid;
-
-		current_data=&info->data[info->count];
-
-		construct_info_data(current_data, type, field, id);
-
-		DEBUG(10,("construct_notify_printer_info: calling [%s]  snum=%d  printername=[%s])\n",
-				notify_info_data_table[j].name, snum, printer->info_2->printername ));
-
-		notify_info_data_table[j].fn(snum, current_data, queue,
-					     printer, mem_ctx);
-
-		info->count++;
-	}
-
-	free_a_printer(&printer, 2);
-	return True;
-}
-
-/*******************************************************************
- *
- * fill a notify_info struct with info asked
- *
- ********************************************************************/
-
-static BOOL construct_notify_jobs_info(print_queue_struct *queue,
-				       SPOOL_NOTIFY_INFO *info,
-				       NT_PRINTER_INFO_LEVEL *printer,
-				       int snum, SPOOL_NOTIFY_OPTION_TYPE
-				       *option_type, uint32 id,
-				       TALLOC_CTX *mem_ctx) 
-{
-	int field_num,j;
-	uint16 type;
-	uint16 field;
-
-	SPOOL_NOTIFY_INFO_DATA *current_data, *tid;
-	
-	DEBUG(4,("construct_notify_jobs_info\n"));
-	
-	type = option_type->type;
-
-	DEBUGADD(4,("Notify type: [%s], number of notify info: [%d]\n",
-		(option_type->type==PRINTER_NOTIFY_TYPE?"PRINTER_NOTIFY_TYPE":"JOB_NOTIFY_TYPE"),
-		option_type->count));
-
-	for(field_num=0; field_num<option_type->count; field_num++) {
-		field = option_type->fields[field_num];
-
-		if (!search_notify(type, field, &j) )
-			continue;
-
-		if((tid=Realloc(info->data, (info->count+1)*sizeof(SPOOL_NOTIFY_INFO_DATA))) == NULL) {
-			DEBUG(2,("construct_notify_jobs_info: failed to enlarg buffer info->data!\n"));
-			return False;
-		}
-		else info->data = tid;
-
-		current_data=&(info->data[info->count]);
-
-		construct_info_data(current_data, type, field, id);
-		notify_info_data_table[j].fn(snum, current_data, queue,
-					     printer, mem_ctx);
-		info->count++;
-	}
-
-	return True;
-}
-
-/*
- * JFM: The enumeration is not that simple, it's even non obvious.
- *
- * let's take an example: I want to monitor the PRINTER SERVER for
- * the printer's name and the number of jobs currently queued.
- * So in the NOTIFY_OPTION, I have one NOTIFY_OPTION_TYPE structure.
- * Its type is PRINTER_NOTIFY_TYPE and it has 2 fields NAME and CJOBS.
- *
- * I have 3 printers on the back of my server.
- *
- * Now the response is a NOTIFY_INFO structure, with 6 NOTIFY_INFO_DATA
- * structures.
- *   Number	Data			Id
- *	1	printer 1 name		1
- *	2	printer 1 cjob		1
- *	3	printer 2 name		2
- *	4	printer 2 cjob		2
- *	5	printer 3 name		3
- *	6	printer 3 name		3
- *
- * that's the print server case, the printer case is even worse.
- */
-
-/*******************************************************************
- *
- * enumerate all printers on the printserver
- * fill a notify_info struct with info asked
- *
- ********************************************************************/
-
-static WERROR printserver_notify_info(pipes_struct *p, POLICY_HND *hnd, 
-				      SPOOL_NOTIFY_INFO *info,
-				      TALLOC_CTX *mem_ctx)
-{
-	int snum;
-	Printer_entry *Printer=find_printer_index_by_hnd(p, hnd);
-	int n_services=lp_numservices();
-	int i;
-	uint32 id;
-	SPOOL_NOTIFY_OPTION *option;
-	SPOOL_NOTIFY_OPTION_TYPE *option_type;
-
-	DEBUG(4,("printserver_notify_info\n"));
-	
-	if (!Printer)
-		return WERR_BADFID;
-
-	option=Printer->notify.option;
-	id=1;
-	info->version=2;
-	info->data=NULL;
-	info->count=0;
-
-	/* a bug in xp sp2 rc2 causes it to send a fnpcn request without 
-	   sending a ffpcn() request first */
-
-	if ( !option )
-		return WERR_BADFID;
-
-	for (i=0; i<option->count; i++) {
-		option_type=&(option->ctr.type[i]);
-		
-		if (option_type->type!=PRINTER_NOTIFY_TYPE)
-			continue;
-		
-		for (snum=0; snum<n_services; snum++)
-			if ( lp_browseable(snum) && lp_snum_ok(snum) && lp_print_ok(snum) )
-				if (construct_notify_printer_info
-				    (info, snum, option_type, id, mem_ctx))
-					id++;
-	}
-			
-	/*
-	 * Debugging information, don't delete.
-	 */
-	/*
-	DEBUG(1,("dumping the NOTIFY_INFO\n"));
-	DEBUGADD(1,("info->version:[%d], info->flags:[%d], info->count:[%d]\n", info->version, info->flags, info->count));
-	DEBUGADD(1,("num\ttype\tfield\tres\tid\tsize\tenc_type\n"));
-	
-	for (i=0; i<info->count; i++) {
-		DEBUGADD(1,("[%d]\t[%d]\t[%d]\t[%d]\t[%d]\t[%d]\t[%d]\n",
-		i, info->data[i].type, info->data[i].field, info->data[i].reserved,
-		info->data[i].id, info->data[i].size, info->data[i].enc_type));
-	}
-	*/
-	
-	return WERR_OK;
-}
-
-/*******************************************************************
- *
- * fill a notify_info struct with info asked
- *
- ********************************************************************/
-
-static WERROR printer_notify_info(pipes_struct *p, POLICY_HND *hnd, SPOOL_NOTIFY_INFO *info,
-				  TALLOC_CTX *mem_ctx)
-{
-	int snum;
-	Printer_entry *Printer=find_printer_index_by_hnd(p, hnd);
-	int i;
-	uint32 id;
-	SPOOL_NOTIFY_OPTION *option;
-	SPOOL_NOTIFY_OPTION_TYPE *option_type;
-	int count,j;
-	print_queue_struct *queue=NULL;
-	print_status_struct status;
-	
-	DEBUG(4,("printer_notify_info\n"));
-
-	if (!Printer)
-		return WERR_BADFID;
-
-	option=Printer->notify.option;
-	id = 0x0;
-	info->version=2;
-	info->data=NULL;
-	info->count=0;
-
-	/* a bug in xp sp2 rc2 causes it to send a fnpcn request without 
-	   sending a ffpcn() request first */
-
-	if ( !option )
-		return WERR_BADFID;
-
-	get_printer_snum(p, hnd, &snum);
-
-	for (i=0; i<option->count; i++) {
-		option_type=&option->ctr.type[i];
-		
-		switch ( option_type->type ) {
-		case PRINTER_NOTIFY_TYPE:
-			if(construct_notify_printer_info(info, snum, 
-							 option_type, id,
-							 mem_ctx))  
-				id--;
-			break;
-			
-		case JOB_NOTIFY_TYPE: {
-			NT_PRINTER_INFO_LEVEL *printer = NULL;
-
-			count = print_queue_status(snum, &queue, &status);
-
-			if (!W_ERROR_IS_OK(get_a_printer(&printer, 2, 
-							 lp_servicename(snum))))
-				goto done;
-
-			for (j=0; j<count; j++) {
-				construct_notify_jobs_info(&queue[j], info,
-							   printer, snum,
-							   option_type,
-							   queue[j].job,
-							   mem_ctx); 
-			}
-
-			free_a_printer(&printer, 2);
-			
-		done:
-			SAFE_FREE(queue);
-			break;
-		}
-		}
-	}
-	
-	/*
-	 * Debugging information, don't delete.
-	 */
-	/*
-	DEBUG(1,("dumping the NOTIFY_INFO\n"));
-	DEBUGADD(1,("info->version:[%d], info->flags:[%d], info->count:[%d]\n", info->version, info->flags, info->count));
-	DEBUGADD(1,("num\ttype\tfield\tres\tid\tsize\tenc_type\n"));
-	
-	for (i=0; i<info->count; i++) {
-		DEBUGADD(1,("[%d]\t[%d]\t[%d]\t[%d]\t[%d]\t[%d]\t[%d]\n",
-		i, info->data[i].type, info->data[i].field, info->data[i].reserved,
-		info->data[i].id, info->data[i].size, info->data[i].enc_type));
-	}
-	*/
-	return WERR_OK;
-}
-
-/********************************************************************
- * spoolss_rfnpcnex
- ********************************************************************/
-
-WERROR _spoolss_rfnpcnex( pipes_struct *p, SPOOL_Q_RFNPCNEX *q_u, SPOOL_R_RFNPCNEX *r_u)
-{
-	POLICY_HND *handle = &q_u->handle;
-/*	SPOOL_NOTIFY_OPTION *option = q_u->option; - notused. */
-	SPOOL_NOTIFY_INFO *info = &r_u->info;
-
-	Printer_entry *Printer=find_printer_index_by_hnd(p, handle);
-	WERROR result = WERR_BADFID;
-
-	/* we always have a NOTIFY_INFO struct */
-	r_u->info_ptr=0x1;
-
-	if (!Printer) {
-		DEBUG(2,("_spoolss_rfnpcnex: Invalid handle (%s:%u:%u).\n",
-			 OUR_HANDLE(handle)));
-		goto done;
-	}
-
-	DEBUG(4,("Printer type %x\n",Printer->printer_type));
-
-	/*
-	 *	same thing for option->flags
-	 *	I should check for PRINTER_NOTIFY_OPTIONS_REFRESH but as
-	 *	I don't have a global notification system, I'm sending back all the
-	 *	informations even when _NOTHING_ has changed.
-	 */
-
-	if (Printer->notify.client_connected)
-		Printer->notify.change = q_u->change;
-
-	/* just ignore the SPOOL_NOTIFY_OPTION */
-	
-	switch (Printer->printer_type) {
-		case PRINTER_HANDLE_IS_PRINTSERVER:
-			result = printserver_notify_info(p, handle, info, p->mem_ctx);
-			break;
-			
-		case PRINTER_HANDLE_IS_PRINTER:
-			result = printer_notify_info(p, handle, info, p->mem_ctx);
-			break;
-	}
-	
- done:
-	return result;
-}
-
-/********************************************************************
- * construct_printer_info_0
- * fill a printer_info_0 struct
- ********************************************************************/
-
-static BOOL construct_printer_info_0(PRINTER_INFO_0 *printer, int snum)
-{
-	pstring chaine;
-	int count;
-	NT_PRINTER_INFO_LEVEL *ntprinter = NULL;
-	counter_printer_0 *session_counter;
-	uint32 global_counter;
-	struct tm *t;
-	time_t setuptime;
-	print_status_struct status;
-	
-	if (!W_ERROR_IS_OK(get_a_printer(&ntprinter, 2, lp_servicename(snum))))
-		return False;
-
-	count = print_queue_length(snum, &status);
-
-	/* check if we already have a counter for this printer */	
-	session_counter = (counter_printer_0 *)ubi_dlFirst(&counter_list);
-
-	for(; session_counter; session_counter = (counter_printer_0 *)ubi_dlNext(session_counter)) {
-		if (session_counter->snum == snum)
-			break;
-	}
-
-	/* it's the first time, add it to the list */
-	if (session_counter==NULL) {
-		if((session_counter=(counter_printer_0 *)malloc(sizeof(counter_printer_0))) == NULL) {
-			free_a_printer(&ntprinter, 2);
-			return False;
-		}
-		ZERO_STRUCTP(session_counter);
-		session_counter->snum=snum;
-		session_counter->counter=0;
-		ubi_dlAddHead( &counter_list, (ubi_dlNode *)session_counter);
-	}
-	
-	/* increment it */
-	session_counter->counter++;
-	
-	/* JFM:
-	 * the global_counter should be stored in a TDB as it's common to all the clients
-	 * and should be zeroed on samba startup
-	 */
-	global_counter=session_counter->counter;
-	
-	pstrcpy(chaine,ntprinter->info_2->printername);
-
-	init_unistr(&printer->printername, chaine);
-	
-	slprintf(chaine,sizeof(chaine)-1,"\\\\%s", get_called_name());
-	init_unistr(&printer->servername, chaine);
-	
-	printer->cjobs = count;
-	printer->total_jobs = 0;
-	printer->total_bytes = 0;
-
-	setuptime = (time_t)ntprinter->info_2->setuptime;
-	t=gmtime(&setuptime);
-
-	printer->year = t->tm_year+1900;
-	printer->month = t->tm_mon+1;
-	printer->dayofweek = t->tm_wday;
-	printer->day = t->tm_mday;
-	printer->hour = t->tm_hour;
-	printer->minute = t->tm_min;
-	printer->second = t->tm_sec;
-	printer->milliseconds = 0;
-
-	printer->global_counter = global_counter;
-	printer->total_pages = 0;
-#ifndef EMULATE_WIN2K_HACK	/* JERRY */
-	printer->major_version = 0x0004; 	/* NT 4 */
-	printer->build_version = 0x0565; 	/* build 1381 */
-#else
-	printer->major_version = 0x0005; 	/* NT 5 */
-	printer->build_version = 0x0893; 	/* build 2195 */
-#endif
-	printer->unknown7 = 0x1;
-	printer->unknown8 = 0x0;
-	printer->unknown9 = 0x0;
-	printer->session_counter = session_counter->counter;
-	printer->unknown11 = 0x0;
-	printer->printer_errors = 0x0;		/* number of print failure */
-	printer->unknown13 = 0x0;
-	printer->unknown14 = 0x1;
-	printer->unknown15 = 0x024a;		/* 586 Pentium ? */
-	printer->unknown16 =  0x0;
-	printer->change_id = ntprinter->info_2->changeid; /* ChangeID in milliseconds*/
-	printer->unknown18 =  0x0;
-	printer->status = nt_printq_status(status.status);
-	printer->unknown20 =  0x0;
-	printer->c_setprinter = get_c_setprinter(); /* monotonically increasing sum of delta printer counts */
-	printer->unknown22 = 0x0;
-	printer->unknown23 = 0x6; 		/* 6  ???*/
-	printer->unknown24 = 0; 		/* unknown 24 to 26 are always 0 */
-	printer->unknown25 = 0;
-	printer->unknown26 = 0;
-	printer->unknown27 = 0;
-	printer->unknown28 = 0;
-	printer->unknown29 = 0;
-	
-	free_a_printer(&ntprinter,2);
-	return (True);	
-}
-
-/********************************************************************
- * construct_printer_info_1
- * fill a printer_info_1 struct
- ********************************************************************/
-static BOOL construct_printer_info_1(uint32 flags, PRINTER_INFO_1 *printer, int snum)
-{
-	pstring chaine;
-	pstring chaine2;
-	NT_PRINTER_INFO_LEVEL *ntprinter = NULL;
-
-	if (!W_ERROR_IS_OK(get_a_printer(&ntprinter, 2, lp_servicename(snum))))
-		return False;
-
-	printer->flags=flags;
-
-	if (*ntprinter->info_2->comment == '\0') {
-		init_unistr(&printer->comment, lp_comment(snum));
-		slprintf(chaine,sizeof(chaine)-1,"%s,%s,%s", ntprinter->info_2->printername,
-			ntprinter->info_2->drivername, lp_comment(snum));
-	}
-	else {
-		init_unistr(&printer->comment, ntprinter->info_2->comment); /* saved comment. */
-		slprintf(chaine,sizeof(chaine)-1,"%s,%s,%s", ntprinter->info_2->printername,
-			ntprinter->info_2->drivername, ntprinter->info_2->comment);
-	}
-		
-	slprintf(chaine2,sizeof(chaine)-1,"%s", ntprinter->info_2->printername);
-
-	init_unistr(&printer->description, chaine);
-	init_unistr(&printer->name, chaine2);	
-	
-	free_a_printer(&ntprinter,2);
-
-	return True;
-}
-
-/****************************************************************************
- Free a DEVMODE struct.
-****************************************************************************/
-
-static void free_dev_mode(DEVICEMODE *dev)
-{
-	if (dev == NULL)
-		return;
-
-		SAFE_FREE(dev->private);
-	SAFE_FREE(dev);	
-}
-
-/****************************************************************************
- Create a DEVMODE struct. Returns malloced memory.
-****************************************************************************/
-
-static DEVICEMODE *construct_dev_mode(int snum)
-{
-	char adevice[32];
-	char aform[32];
-	NT_PRINTER_INFO_LEVEL *printer = NULL;
-	NT_DEVICEMODE *ntdevmode = NULL;
-	DEVICEMODE *devmode = NULL;
-
-	DEBUG(7,("construct_dev_mode\n"));
-	
-	DEBUGADD(8,("getting printer characteristics\n"));
-
-	if ((devmode = (DEVICEMODE *)malloc(sizeof(DEVICEMODE))) == NULL) {
-		DEBUG(2,("construct_dev_mode: malloc fail.\n"));
-		return NULL;
-	}
-
-	ZERO_STRUCTP(devmode);	
-
-	if (!W_ERROR_IS_OK(get_a_printer(&printer, 2, lp_servicename(snum))))
-		goto fail;
-
-	if (printer->info_2->devmode)
-		ntdevmode = dup_nt_devicemode(printer->info_2->devmode);
-
-	if (ntdevmode == NULL)
-		goto fail;
-
-	DEBUGADD(8,("loading DEVICEMODE\n"));
-
-	slprintf(adevice, sizeof(adevice)-1, printer->info_2->printername);
-	init_unistr(&devmode->devicename, adevice);
-
-	slprintf(aform, sizeof(aform)-1, ntdevmode->formname);
-	init_unistr(&devmode->formname, aform);
-
-	devmode->specversion      = ntdevmode->specversion;
-	devmode->driverversion    = ntdevmode->driverversion;
-	devmode->size             = ntdevmode->size;
-	devmode->driverextra      = ntdevmode->driverextra;
-	devmode->fields           = ntdevmode->fields;
-				
-	devmode->orientation      = ntdevmode->orientation;	
-	devmode->papersize        = ntdevmode->papersize;
-	devmode->paperlength      = ntdevmode->paperlength;
-	devmode->paperwidth       = ntdevmode->paperwidth;
-	devmode->scale            = ntdevmode->scale;
-	devmode->copies           = ntdevmode->copies;
-	devmode->defaultsource    = ntdevmode->defaultsource;
-	devmode->printquality     = ntdevmode->printquality;
-	devmode->color            = ntdevmode->color;
-	devmode->duplex           = ntdevmode->duplex;
-	devmode->yresolution      = ntdevmode->yresolution;
-	devmode->ttoption         = ntdevmode->ttoption;
-	devmode->collate          = ntdevmode->collate;
-	devmode->icmmethod        = ntdevmode->icmmethod;
-	devmode->icmintent        = ntdevmode->icmintent;
-	devmode->mediatype        = ntdevmode->mediatype;
-	devmode->dithertype       = ntdevmode->dithertype;
-
-	if (ntdevmode->private != NULL) {
-		if ((devmode->private=(uint8 *)memdup(ntdevmode->private, ntdevmode->driverextra)) == NULL)
-			goto fail;
-	}
-
-	free_nt_devicemode(&ntdevmode);
-	free_a_printer(&printer,2);
-
-	return devmode;
-
-  fail:
-
-	if (ntdevmode)
-		free_nt_devicemode(&ntdevmode);
-	if (printer)
-		free_a_printer(&printer,2);
-	free_dev_mode(devmode);
-
-	return NULL;
-}
-
-/********************************************************************
- * construct_printer_info_2
- * fill a printer_info_2 struct
- ********************************************************************/
-
-static BOOL construct_printer_info_2(PRINTER_INFO_2 *printer, int snum)
-{
-	int count;
-	NT_PRINTER_INFO_LEVEL *ntprinter = NULL;
-
-	print_status_struct status;
-
-	if (!W_ERROR_IS_OK(get_a_printer(&ntprinter, 2, lp_servicename(snum))))
-		return False;
-		
-	count = print_queue_length(snum, &status);
-
-	init_unistr(&printer->servername, ntprinter->info_2->servername); /* servername*/
-	init_unistr(&printer->printername, ntprinter->info_2->printername);				/* printername*/
-	init_unistr(&printer->sharename, lp_servicename(snum));			/* sharename */
-	init_unistr(&printer->portname, ntprinter->info_2->portname);			/* port */	
-	init_unistr(&printer->drivername, ntprinter->info_2->drivername);	/* drivername */
-
-	if (*ntprinter->info_2->comment == '\0')
-		init_unistr(&printer->comment, lp_comment(snum));			/* comment */	
-	else
-		init_unistr(&printer->comment, ntprinter->info_2->comment); /* saved comment. */
-
-	init_unistr(&printer->location, ntprinter->info_2->location);		/* location */	
-	init_unistr(&printer->sepfile, ntprinter->info_2->sepfile);		/* separator file */
-	init_unistr(&printer->printprocessor, ntprinter->info_2->printprocessor);/* print processor */
-	init_unistr(&printer->datatype, ntprinter->info_2->datatype);		/* datatype */	
-	init_unistr(&printer->parameters, ntprinter->info_2->parameters);	/* parameters (of print processor) */	
-
-	printer->attributes = ntprinter->info_2->attributes;
-
-	printer->priority = ntprinter->info_2->priority;				/* priority */	
-	printer->defaultpriority = ntprinter->info_2->default_priority;		/* default priority */
-	printer->starttime = ntprinter->info_2->starttime;			/* starttime */
-	printer->untiltime = ntprinter->info_2->untiltime;			/* untiltime */
-	printer->status = nt_printq_status(status.status);			/* status */
-	printer->cjobs = count;							/* jobs */
-	printer->averageppm = ntprinter->info_2->averageppm;			/* average pages per minute */
-			
-	if((printer->devmode = construct_dev_mode(snum)) == NULL) {
-		DEBUG(8, ("Returning NULL Devicemode!\n"));
-	}
-
-	if (ntprinter->info_2->secdesc_buf && ntprinter->info_2->secdesc_buf->len != 0) {
-		/* steal the printer info sec_desc structure.  [badly done]. */
-		printer->secdesc = ntprinter->info_2->secdesc_buf->sec;
-		ntprinter->info_2->secdesc_buf->sec = NULL; /* Stolen memory. */
-		ntprinter->info_2->secdesc_buf->len = 0; /* Stolen memory. */
-		ntprinter->info_2->secdesc_buf->max_len = 0; /* Stolen memory. */
-	}
-	else {
-		printer->secdesc = NULL;
-	}
-
-	free_a_printer(&ntprinter, 2);
-	return True;
-}
-
-/********************************************************************
- * construct_printer_info_3
- * fill a printer_info_3 struct
- ********************************************************************/
-
-static BOOL construct_printer_info_3(PRINTER_INFO_3 **pp_printer, int snum)
-{
-	NT_PRINTER_INFO_LEVEL *ntprinter = NULL;
-	PRINTER_INFO_3 *printer = NULL;
-
-	if (!W_ERROR_IS_OK(get_a_printer(&ntprinter, 2, lp_servicename(snum))))
-		return False;
-
-	*pp_printer = NULL;
-	if ((printer = (PRINTER_INFO_3 *)malloc(sizeof(PRINTER_INFO_3))) == NULL) {
-		DEBUG(2,("construct_printer_info_3: malloc fail.\n"));
-		return False;
-	}
-
-	ZERO_STRUCTP(printer);
-	
-	printer->flags = 4; /* These are the components of the SD we are returning. */
-	if (ntprinter->info_2->secdesc_buf && ntprinter->info_2->secdesc_buf->len != 0) {
-		/* steal the printer info sec_desc structure.  [badly done]. */
-		printer->secdesc = ntprinter->info_2->secdesc_buf->sec;
-
-#if 0
-		/*
-		 * Set the flags for the components we are returning.
-		 */
-
-		if (printer->secdesc->owner_sid)
-			printer->flags |= OWNER_SECURITY_INFORMATION;
-
-		if (printer->secdesc->grp_sid)
-			printer->flags |= GROUP_SECURITY_INFORMATION;
-
-		if (printer->secdesc->dacl)
-			printer->flags |= DACL_SECURITY_INFORMATION;
-
-		if (printer->secdesc->sacl)
-			printer->flags |= SACL_SECURITY_INFORMATION;
-#endif
-
-		ntprinter->info_2->secdesc_buf->sec = NULL; /* Stolen the malloced memory. */
-		ntprinter->info_2->secdesc_buf->len = 0; /* Stolen the malloced memory. */
-		ntprinter->info_2->secdesc_buf->max_len = 0; /* Stolen the malloced memory. */
-	}
-
-	free_a_printer(&ntprinter, 2);
-
-	*pp_printer = printer;
-	return True;
-}
-
-/********************************************************************
- * construct_printer_info_4
- * fill a printer_info_4 struct
- ********************************************************************/
-
-static BOOL construct_printer_info_4(PRINTER_INFO_4 *printer, int snum)
-{
-	NT_PRINTER_INFO_LEVEL *ntprinter = NULL;
-
-	if (!W_ERROR_IS_OK(get_a_printer(&ntprinter, 2, lp_servicename(snum))))
-		return False;
-		
-	init_unistr(&printer->printername, ntprinter->info_2->printername);				/* printername*/
-	init_unistr(&printer->servername, ntprinter->info_2->servername); /* servername*/
-	printer->attributes = ntprinter->info_2->attributes;
-
-	free_a_printer(&ntprinter, 2);
-	return True;
-}
-
-/********************************************************************
- * construct_printer_info_5
- * fill a printer_info_5 struct
- ********************************************************************/
-
-static BOOL construct_printer_info_5(PRINTER_INFO_5 *printer, int snum)
-{
-	NT_PRINTER_INFO_LEVEL *ntprinter = NULL;
-
-	if (!W_ERROR_IS_OK(get_a_printer(&ntprinter, 2, lp_servicename(snum))))
-		return False;
-		
-	init_unistr(&printer->printername, ntprinter->info_2->printername);				/* printername*/
-	init_unistr(&printer->portname, ntprinter->info_2->portname); /* portname */
-	printer->attributes = ntprinter->info_2->attributes;
-	printer->device_not_selected_timeout = 0x3a98;
-	printer->transmission_retry_timeout = 0xafc8;
-
-	free_a_printer(&ntprinter, 2);
-	return True;
-}
-
-/********************************************************************
- Spoolss_enumprinters.
-********************************************************************/
-
-static WERROR enum_all_printers_info_1(uint32 flags, NEW_BUFFER *buffer, uint32 offered, uint32 *needed, uint32 *returned)
-{
-	int snum;
-	int i;
-	int n_services=lp_numservices();
-	PRINTER_INFO_1 *tp, *printers=NULL;
-	PRINTER_INFO_1 current_prt;
-	
-	DEBUG(4,("enum_all_printers_info_1\n"));	
-
-	for (snum=0; snum<n_services; snum++) {
-		if (lp_browseable(snum) && lp_snum_ok(snum) && lp_print_ok(snum) ) {
-			DEBUG(4,("Found a printer in smb.conf: %s[%x]\n", lp_servicename(snum), snum));
-
-			if (construct_printer_info_1(flags, &current_prt, snum)) {
-				if((tp=Realloc(printers, (*returned +1)*sizeof(PRINTER_INFO_1))) == NULL) {
-					DEBUG(2,("enum_all_printers_info_1: failed to enlarge printers buffer!\n"));
-					SAFE_FREE(printers);
-					*returned=0;
-					return WERR_NOMEM;
-				}
-				else printers = tp;
-				DEBUG(4,("ReAlloced memory for [%d] PRINTER_INFO_1\n", *returned));		
-
-				memcpy(&printers[*returned], &current_prt, sizeof(PRINTER_INFO_1));
-				(*returned)++;
-			}
-		}
-	}
-		
-	/* check the required size. */	
-	for (i=0; i<*returned; i++)
-		(*needed) += spoolss_size_printer_info_1(&printers[i]);
-
-	if (!alloc_buffer_size(buffer, *needed))
-		return WERR_INSUFFICIENT_BUFFER;
-
-	/* fill the buffer with the structures */
-	for (i=0; i<*returned; i++)
-		smb_io_printer_info_1("", buffer, &printers[i], 0);	
-
-	/* clear memory */
-	SAFE_FREE(printers);
-
-	if (*needed > offered) {
-		*returned=0;
-		return WERR_INSUFFICIENT_BUFFER;
-	}
-	else
-		return WERR_OK;
-}
-
-/********************************************************************
- enum_all_printers_info_1_local.
-*********************************************************************/
-
-static WERROR enum_all_printers_info_1_local(NEW_BUFFER *buffer, uint32 offered, uint32 *needed, uint32 *returned)
-{
-	DEBUG(4,("enum_all_printers_info_1_local\n"));	
-	
-	return enum_all_printers_info_1(PRINTER_ENUM_ICON8, buffer, offered, needed, returned);
-}
-
-/********************************************************************
- enum_all_printers_info_1_name.
-*********************************************************************/
-
-static WERROR enum_all_printers_info_1_name(fstring name, NEW_BUFFER *buffer, uint32 offered, uint32 *needed, uint32 *returned)
-{
-	char *s = name;
-	
-	DEBUG(4,("enum_all_printers_info_1_name\n"));	
-	
-	if ((name[0] == '\\') && (name[1] == '\\'))
-		s = name + 2;
-		
-	if (is_myname_or_ipaddr(s)) {
-		return enum_all_printers_info_1(PRINTER_ENUM_ICON8, buffer, offered, needed, returned);
-	}
-	else
-		return WERR_INVALID_NAME;
-}
-
-/********************************************************************
- enum_all_printers_info_1_remote.
-*********************************************************************/
-
-static WERROR enum_all_printers_info_1_remote(fstring name, NEW_BUFFER *buffer, uint32 offered, uint32 *needed, uint32 *returned)
-{
-	PRINTER_INFO_1 *printer;
-	fstring printername;
-	fstring desc;
-	fstring comment;
-	DEBUG(4,("enum_all_printers_info_1_remote\n"));	
-
-	/* JFM: currently it's more a place holder than anything else.
-	 * In the spooler world there is a notion of server registration.
-	 * the print servers are registring (sp ?) on the PDC (in the same domain)
-	 *
-	 * We should have a TDB here. The registration is done thru an undocumented RPC call.
-	 */
-	
-	if((printer=(PRINTER_INFO_1 *)malloc(sizeof(PRINTER_INFO_1))) == NULL)
-		return WERR_NOMEM;
-
-	*returned=1;
-	
-	slprintf(printername, sizeof(printername)-1,"Windows NT Remote Printers!!\\\\%s", get_called_name());		
-	slprintf(desc, sizeof(desc)-1,"%s", get_called_name());
-	slprintf(comment, sizeof(comment)-1, "Logged on Domain");
-
-	init_unistr(&printer->description, desc);
-	init_unistr(&printer->name, printername);	
-	init_unistr(&printer->comment, comment);
-	printer->flags=PRINTER_ENUM_ICON3|PRINTER_ENUM_CONTAINER;
-		
-	/* check the required size. */	
-	*needed += spoolss_size_printer_info_1(printer);
-
-	if (!alloc_buffer_size(buffer, *needed)) {
-		SAFE_FREE(printer);
-		return WERR_INSUFFICIENT_BUFFER;
-	}
-
-	/* fill the buffer with the structures */
-	smb_io_printer_info_1("", buffer, printer, 0);	
-
-	/* clear memory */
-	SAFE_FREE(printer);
-
-	if (*needed > offered) {
-		*returned=0;
-		return WERR_INSUFFICIENT_BUFFER;
-	}
-	else
-		return WERR_OK;
-}
-
-/********************************************************************
- enum_all_printers_info_1_network.
-*********************************************************************/
-
-static WERROR enum_all_printers_info_1_network(fstring name, NEW_BUFFER *buffer, uint32 offered, uint32 *needed, uint32 *returned)
-{
-	char *s = name;
-
-	DEBUG(4,("enum_all_printers_info_1_network\n"));	
-	
-	/* If we respond to a enum_printers level 1 on our name with flags
-	   set to PRINTER_ENUM_REMOTE with a list of printers then these
-	   printers incorrectly appear in the APW browse list.
-	   Specifically the printers for the server appear at the workgroup
-	   level where all the other servers in the domain are
-	   listed. Windows responds to this call with a
-	   WERR_CAN_NOT_COMPLETE so we should do the same. */ 
-
-	if (name[0] == '\\' && name[1] == '\\')
-		 s = name + 2;
-
-	if (is_myname_or_ipaddr(s))
-		 return WERR_CAN_NOT_COMPLETE;
-
-	return enum_all_printers_info_1(PRINTER_ENUM_UNKNOWN_8, buffer, offered, needed, returned);
-}
-
-/********************************************************************
- * api_spoolss_enumprinters
- *
- * called from api_spoolss_enumprinters (see this to understand)
- ********************************************************************/
-
-static WERROR enum_all_printers_info_2(NEW_BUFFER *buffer, uint32 offered, uint32 *needed, uint32 *returned)
-{
-	int snum;
-	int i;
-	int n_services=lp_numservices();
-	PRINTER_INFO_2 *tp, *printers=NULL;
-	PRINTER_INFO_2 current_prt;
-
-	for (snum=0; snum<n_services; snum++) {
-		if (lp_browseable(snum) && lp_snum_ok(snum) && lp_print_ok(snum) ) {
-			DEBUG(4,("Found a printer in smb.conf: %s[%x]\n", lp_servicename(snum), snum));
-				
-			if (construct_printer_info_2(&current_prt, snum)) {
-				if((tp=Realloc(printers, (*returned +1)*sizeof(PRINTER_INFO_2))) == NULL) {
-					DEBUG(2,("enum_all_printers_info_2: failed to enlarge printers buffer!\n"));
-					SAFE_FREE(printers);
-					*returned = 0;
-					return WERR_NOMEM;
-				}
-				else printers = tp;
-				DEBUG(4,("ReAlloced memory for [%d] PRINTER_INFO_2\n", *returned));		
-				memcpy(&printers[*returned], &current_prt, sizeof(PRINTER_INFO_2));
-				(*returned)++;
-			}
-		}
-	}
-	
-	/* check the required size. */	
-	for (i=0; i<*returned; i++) 
-		(*needed) += spoolss_size_printer_info_2(&printers[i]);
-	
-	if (!alloc_buffer_size(buffer, *needed)) {
-		for (i=0; i<*returned; i++) {
-			free_devmode(printers[i].devmode);
-		}
-		SAFE_FREE(printers);
-		return WERR_INSUFFICIENT_BUFFER;
-	}
-
-	/* fill the buffer with the structures */
-	for (i=0; i<*returned; i++)
-		smb_io_printer_info_2("", buffer, &(printers[i]), 0);	
-	
-	/* clear memory */
-	for (i=0; i<*returned; i++) {
-		free_devmode(printers[i].devmode);
-	}
-	SAFE_FREE(printers);
-
-	if (*needed > offered) {
-		*returned=0;
-		return WERR_INSUFFICIENT_BUFFER;
-	}
-	else
-		return WERR_OK;
-}
-
-/********************************************************************
- * handle enumeration of printers at level 1
- ********************************************************************/
-
-static WERROR enumprinters_level1( uint32 flags, fstring name,
-			         NEW_BUFFER *buffer, uint32 offered,
-			         uint32 *needed, uint32 *returned)
-{
-	/* Not all the flags are equals */
-
-	if (flags & PRINTER_ENUM_LOCAL)
-		return enum_all_printers_info_1_local(buffer, offered, needed, returned);
-
-	if (flags & PRINTER_ENUM_NAME)
-		return enum_all_printers_info_1_name(name, buffer, offered, needed, returned);
-
-	if (flags & PRINTER_ENUM_REMOTE)
-		return enum_all_printers_info_1_remote(name, buffer, offered, needed, returned);
-
-	if (flags & PRINTER_ENUM_NETWORK)
-		return enum_all_printers_info_1_network(name, buffer, offered, needed, returned);
-
-	return WERR_OK; /* NT4sp5 does that */
-}
-
-/********************************************************************
- * handle enumeration of printers at level 2
- ********************************************************************/
-
-static WERROR enumprinters_level2( uint32 flags, fstring servername,
-			         NEW_BUFFER *buffer, uint32 offered,
-			         uint32 *needed, uint32 *returned)
-{
-	char *s = servername;
-
-	if (flags & PRINTER_ENUM_LOCAL) {
-			return enum_all_printers_info_2(buffer, offered, needed, returned);
-	}
-
-	if (flags & PRINTER_ENUM_NAME) {
-		if ((servername[0] == '\\') && (servername[1] == '\\'))
-			s = servername + 2;
-		if (is_myname_or_ipaddr(s))
-			return enum_all_printers_info_2(buffer, offered, needed, returned);
-		else
-			return WERR_INVALID_NAME;
-	}
-
-	if (flags & PRINTER_ENUM_REMOTE)
-		return WERR_UNKNOWN_LEVEL;
-
-	return WERR_OK;
-}
-
-/********************************************************************
- * handle enumeration of printers at level 5
- ********************************************************************/
-
-static WERROR enumprinters_level5( uint32 flags, fstring servername,
-			         NEW_BUFFER *buffer, uint32 offered,
-			         uint32 *needed, uint32 *returned)
-{
-/*	return enum_all_printers_info_5(buffer, offered, needed, returned);*/
-	return WERR_OK;
-}
-
-/********************************************************************
- * api_spoolss_enumprinters
- *
- * called from api_spoolss_enumprinters (see this to understand)
- ********************************************************************/
-
-WERROR _spoolss_enumprinters( pipes_struct *p, SPOOL_Q_ENUMPRINTERS *q_u, SPOOL_R_ENUMPRINTERS *r_u)
-{
-	uint32 flags = q_u->flags;
-	UNISTR2 *servername = &q_u->servername;
-	uint32 level = q_u->level;
-	NEW_BUFFER *buffer = NULL;
-	uint32 offered = q_u->offered;
-	uint32 *needed = &r_u->needed;
-	uint32 *returned = &r_u->returned;
-
-	fstring name;
-	
-	/* that's an [in out] buffer */
-	spoolss_move_buffer(q_u->buffer, &r_u->buffer);
-	buffer = r_u->buffer;
-
-	DEBUG(4,("_spoolss_enumprinters\n"));
-
-	*needed=0;
-	*returned=0;
-	
-	/*
-	 * Level 1:
-	 *	    flags==PRINTER_ENUM_NAME
-	 *	     if name=="" then enumerates all printers
-	 *	     if name!="" then enumerate the printer
-	 *	    flags==PRINTER_ENUM_REMOTE
-	 *	    name is NULL, enumerate printers
-	 * Level 2: name!="" enumerates printers, name can't be NULL
-	 * Level 3: doesn't exist
-	 * Level 4: does a local registry lookup
-	 * Level 5: same as Level 2
-	 */
-
-	unistr2_to_dos(name, servername, sizeof(name)-1);
-	strupper(name);
-
-	switch (level) {
-	case 1:
-		return enumprinters_level1(flags, name, buffer, offered, needed, returned);
-	case 2:
-		return enumprinters_level2(flags, name, buffer, offered, needed, returned);
-	case 5:
-		return enumprinters_level5(flags, name, buffer, offered, needed, returned);
-	case 3:
-	case 4:
-		break;
-	}
-	return WERR_UNKNOWN_LEVEL;
-}
-
-/****************************************************************************
-****************************************************************************/
-
-static WERROR getprinter_level_0(int snum, NEW_BUFFER *buffer, uint32 offered, uint32 *needed)
-{
-	PRINTER_INFO_0 *printer=NULL;
-
-	if((printer=(PRINTER_INFO_0*)malloc(sizeof(PRINTER_INFO_0))) == NULL)
-		return WERR_NOMEM;
-
-	construct_printer_info_0(printer, snum);
-	
-	/* check the required size. */	
-	*needed += spoolss_size_printer_info_0(printer);
-
-	if (!alloc_buffer_size(buffer, *needed)) {
-		SAFE_FREE(printer);
-		return WERR_INSUFFICIENT_BUFFER;
-	}
-
-	/* fill the buffer with the structures */
-	smb_io_printer_info_0("", buffer, printer, 0);	
-	
-	/* clear memory */
-	SAFE_FREE(printer);
-
-	if (*needed > offered) {
-		return WERR_INSUFFICIENT_BUFFER;
-	}
-
-	return WERR_OK;
-}
-
-/****************************************************************************
-****************************************************************************/
-
-static WERROR getprinter_level_1(int snum, NEW_BUFFER *buffer, uint32 offered, uint32 *needed)
-{
-	PRINTER_INFO_1 *printer=NULL;
-
-	if((printer=(PRINTER_INFO_1*)malloc(sizeof(PRINTER_INFO_1))) == NULL)
-		return WERR_NOMEM;
-
-	construct_printer_info_1(PRINTER_ENUM_ICON8, printer, snum);
-	
-	/* check the required size. */	
-	*needed += spoolss_size_printer_info_1(printer);
-
-	if (!alloc_buffer_size(buffer, *needed)) {
-		SAFE_FREE(printer);
-		return WERR_INSUFFICIENT_BUFFER;
-	}
-
-	/* fill the buffer with the structures */
-	smb_io_printer_info_1("", buffer, printer, 0);	
-	
-	/* clear memory */
-	SAFE_FREE(printer);
-
-	if (*needed > offered) {
-		return WERR_INSUFFICIENT_BUFFER;
-	}
-
-	return WERR_OK;	
-}
-
-/****************************************************************************
-****************************************************************************/
-
-static WERROR getprinter_level_2(int snum, NEW_BUFFER *buffer, uint32 offered, uint32 *needed)
-{
-	PRINTER_INFO_2 *printer=NULL;
-
-	if((printer=(PRINTER_INFO_2*)malloc(sizeof(PRINTER_INFO_2)))==NULL)
-		return WERR_NOMEM;
-	
-	construct_printer_info_2(printer, snum);
-	
-	/* check the required size. */	
-	*needed += spoolss_size_printer_info_2(printer);
-	
-	if (!alloc_buffer_size(buffer, *needed)) {
-		free_printer_info_2(printer);
-		return WERR_INSUFFICIENT_BUFFER;
-	}
-
-	/* fill the buffer with the structures */
-	if (!smb_io_printer_info_2("", buffer, printer, 0)) {
-		free_printer_info_2(printer);
-		return WERR_NOMEM;
-	}
-	
-	/* clear memory */
-	free_printer_info_2(printer);
-
-	if (*needed > offered) {
-		return WERR_INSUFFICIENT_BUFFER;
-	}
-
-	return WERR_OK;	
-}
-
-/****************************************************************************
-****************************************************************************/
-
-static WERROR getprinter_level_3(int snum, NEW_BUFFER *buffer, uint32 offered, uint32 *needed)
-{
-	PRINTER_INFO_3 *printer=NULL;
-
-	if (!construct_printer_info_3(&printer, snum))
-		return WERR_NOMEM;
-	
-	/* check the required size. */	
-	*needed += spoolss_size_printer_info_3(printer);
-
-	if (!alloc_buffer_size(buffer, *needed)) {
-		free_printer_info_3(printer);
-		return WERR_INSUFFICIENT_BUFFER;
-	}
-
-	/* fill the buffer with the structures */
-	smb_io_printer_info_3("", buffer, printer, 0);	
-	
-	/* clear memory */
-	free_printer_info_3(printer);
-	
-	if (*needed > offered) {
-		return WERR_INSUFFICIENT_BUFFER;
-	}
-
-	return WERR_OK;	
-}
-
-/****************************************************************************
-****************************************************************************/
-
-static WERROR getprinter_level_4(int snum, NEW_BUFFER *buffer, uint32 offered, uint32 *needed)
-{
-	PRINTER_INFO_4 *printer=NULL;
-
-	if((printer=(PRINTER_INFO_4*)malloc(sizeof(PRINTER_INFO_4)))==NULL)
-		return WERR_NOMEM;
-
-	if (!construct_printer_info_4(printer, snum))
-		return WERR_NOMEM;
-	
-	/* check the required size. */	
-	*needed += spoolss_size_printer_info_4(printer);
-
-	if (!alloc_buffer_size(buffer, *needed)) {
-		free_printer_info_4(printer);
-		return WERR_INSUFFICIENT_BUFFER;
-	}
-
-	/* fill the buffer with the structures */
-	smb_io_printer_info_4("", buffer, printer, 0);	
-	
-	/* clear memory */
-	free_printer_info_4(printer);
-	
-	if (*needed > offered) {
-		return WERR_INSUFFICIENT_BUFFER;
-	}
-
-	return WERR_OK;	
-}
-
-/****************************************************************************
-****************************************************************************/
-
-static WERROR getprinter_level_5(int snum, NEW_BUFFER *buffer, uint32 offered, uint32 *needed)
-{
-	PRINTER_INFO_5 *printer=NULL;
-
-	if((printer=(PRINTER_INFO_5*)malloc(sizeof(PRINTER_INFO_5)))==NULL)
-		return WERR_NOMEM;
-
-	if (!construct_printer_info_5(printer, snum))
-		return WERR_NOMEM;
-	
-	/* check the required size. */	
-	*needed += spoolss_size_printer_info_5(printer);
-
-	if (!alloc_buffer_size(buffer, *needed)) {
-		free_printer_info_5(printer);
-		return WERR_INSUFFICIENT_BUFFER;
-	}
-
-	/* fill the buffer with the structures */
-	smb_io_printer_info_5("", buffer, printer, 0);	
-	
-	/* clear memory */
-	free_printer_info_5(printer);
-	
-	if (*needed > offered) {
-		return WERR_INSUFFICIENT_BUFFER;
-	}
-
-	return WERR_OK;	
-}
-
-/****************************************************************************
-****************************************************************************/
-
-WERROR _spoolss_getprinter(pipes_struct *p, SPOOL_Q_GETPRINTER *q_u, SPOOL_R_GETPRINTER *r_u)
-{
-	POLICY_HND *handle = &q_u->handle;
-	uint32 level = q_u->level;
-	NEW_BUFFER *buffer = NULL;
-	uint32 offered = q_u->offered;
-	uint32 *needed = &r_u->needed;
-
-	int snum;
-
-	/* that's an [in out] buffer */
-	spoolss_move_buffer(q_u->buffer, &r_u->buffer);
-	buffer = r_u->buffer;
-
-	*needed=0;
-
-	if (!get_printer_snum(p, handle, &snum))
-		return WERR_BADFID;
-
-	switch (level) {
-	case 0:
-		return getprinter_level_0(snum, buffer, offered, needed);
-	case 1:
-		return getprinter_level_1(snum, buffer, offered, needed);
-	case 2:		
-		return getprinter_level_2(snum, buffer, offered, needed);
-	case 3:		
-		return getprinter_level_3(snum, buffer, offered, needed);
-	case 4:		
-		return getprinter_level_4(snum, buffer, offered, needed);
-	case 5:		
-		return getprinter_level_5(snum, buffer, offered, needed);
-	}
-	return WERR_UNKNOWN_LEVEL;
-}	
-		
-/********************************************************************
- * fill a DRIVER_INFO_1 struct
- ********************************************************************/
-
-static void fill_printer_driver_info_1(DRIVER_INFO_1 *info, NT_PRINTER_DRIVER_INFO_LEVEL driver, fstring servername, fstring architecture)
-{
-	init_unistr( &info->name, driver.info_3->name);
-}
-
-/********************************************************************
- * construct_printer_driver_info_1
- ********************************************************************/
-
-static WERROR construct_printer_driver_info_1(DRIVER_INFO_1 *info, int snum, fstring servername, fstring architecture, uint32 version)
-{	
-	NT_PRINTER_INFO_LEVEL *printer = NULL;
-	NT_PRINTER_DRIVER_INFO_LEVEL driver;
-
-	ZERO_STRUCT(driver);
-
-	if (!W_ERROR_IS_OK(get_a_printer(&printer, 2, lp_servicename(snum))))
-		return WERR_INVALID_PRINTER_NAME;
-
-	if (!W_ERROR_IS_OK(get_a_printer_driver(&driver, 3, printer->info_2->drivername, architecture, version)))
-		return WERR_UNKNOWN_PRINTER_DRIVER;
-
-	fill_printer_driver_info_1(info, driver, servername, architecture);
-
-	free_a_printer(&printer,2);
-
-	return WERR_OK;
-}
-
-/********************************************************************
- * construct_printer_driver_info_2
- * fill a printer_info_2 struct
- ********************************************************************/
-
-static void fill_printer_driver_info_2(DRIVER_INFO_2 *info, NT_PRINTER_DRIVER_INFO_LEVEL driver, fstring servername)
-{
-	pstring temp;
-
-	info->version=driver.info_3->cversion;
-
-	init_unistr( &info->name, driver.info_3->name );
-	init_unistr( &info->architecture, driver.info_3->environment );
-
-
-    if (strlen(driver.info_3->driverpath)) {
-		slprintf(temp, sizeof(temp)-1, "\\\\%s%s", servername, driver.info_3->driverpath);
-		init_unistr( &info->driverpath, temp );
-    } else
-        init_unistr( &info->driverpath, "" );
-
-	if (strlen(driver.info_3->datafile)) {
-		slprintf(temp, sizeof(temp)-1, "\\\\%s%s", servername, driver.info_3->datafile);
-		init_unistr( &info->datafile, temp );
-	} else
-		init_unistr( &info->datafile, "" );
-	
-	if (strlen(driver.info_3->configfile)) {
-		slprintf(temp, sizeof(temp)-1, "\\\\%s%s", servername, driver.info_3->configfile);
-		init_unistr( &info->configfile, temp );	
-	} else
-		init_unistr( &info->configfile, "" );
-}
-
-/********************************************************************
- * construct_printer_driver_info_2
- * fill a printer_info_2 struct
- ********************************************************************/
-
-static WERROR construct_printer_driver_info_2(DRIVER_INFO_2 *info, int snum, fstring servername, fstring architecture, uint32 version)
-{
-	NT_PRINTER_INFO_LEVEL *printer = NULL;
-	NT_PRINTER_DRIVER_INFO_LEVEL driver;
-
-	ZERO_STRUCT(printer);
-	ZERO_STRUCT(driver);
-
-	if (!W_ERROR_IS_OK(get_a_printer(&printer, 2, lp_servicename(snum))))
-		return WERR_INVALID_PRINTER_NAME;
-
-	if (!W_ERROR_IS_OK(get_a_printer_driver(&driver, 3, printer->info_2->drivername, architecture, version)))
-		return WERR_UNKNOWN_PRINTER_DRIVER;
-
-	fill_printer_driver_info_2(info, driver, servername);
-
-	free_a_printer(&printer,2);
-
-	return WERR_OK;
-}
-
-/********************************************************************
- * copy a strings array and convert to UNICODE
- *
- * convert an array of ascii string to a UNICODE string
- ********************************************************************/
-
-static void init_unistr_array(uint16 **uni_array, fstring *char_array, char *servername)
-{
-	int i=0;
-	int j=0;
-	const char *v;
-	pstring line;
-	uint16 *tuary;
-
-	DEBUG(6,("init_unistr_array\n"));
-	*uni_array=NULL;
-
-	while (1) {
-		if (char_array == NULL)
-			v = "";
-		else {
-			v = char_array[i];
-			if (!v) v = ""; /* hack to handle null lists */
-		}
-		if (strlen(v) == 0) break;
-		slprintf(line, sizeof(line)-1, "\\\\%s%s", servername, v);
-		DEBUGADD(6,("%d:%s:%d\n", i, line, strlen(line)));
-		if((tuary=Realloc(*uni_array, (j+strlen(line)+2)*sizeof(uint16))) == NULL) {
-			DEBUG(2,("init_unistr_array: Realloc error\n" ));
-			return;
-		} else
-			*uni_array = tuary;
-		j += (dos_PutUniCode((char *)(*uni_array+j), line , sizeof(uint16)*strlen(line), True) / sizeof(uint16) );
-		i++;
-	}
-	
-	if (*uni_array) {
-		(*uni_array)[j]=0x0000;
-	}
-	
-	DEBUGADD(6,("last one:done\n"));
-}
-
-/********************************************************************
- * construct_printer_info_3
- * fill a printer_info_3 struct
- ********************************************************************/
-
-static void fill_printer_driver_info_3(DRIVER_INFO_3 *info, NT_PRINTER_DRIVER_INFO_LEVEL driver, fstring servername)
-{
-	pstring temp;
-
-	ZERO_STRUCTP(info);
-
-	info->version=driver.info_3->cversion;
-
-	init_unistr( &info->name, driver.info_3->name );	
-	init_unistr( &info->architecture, driver.info_3->environment );
-
-    if (strlen(driver.info_3->driverpath)) {
-        slprintf(temp, sizeof(temp)-1, "\\\\%s%s", servername, driver.info_3->driverpath);		
-        init_unistr( &info->driverpath, temp );
-    } else
-        init_unistr( &info->driverpath, "" );
-    
-    if (strlen(driver.info_3->datafile)) {
-        slprintf(temp, sizeof(temp)-1, "\\\\%s%s", servername, driver.info_3->datafile);
-        init_unistr( &info->datafile, temp );
-    } else
-        init_unistr( &info->datafile, "" );
-
-    if (strlen(driver.info_3->configfile)) {
-        slprintf(temp, sizeof(temp)-1, "\\\\%s%s", servername, driver.info_3->configfile);
-        init_unistr( &info->configfile, temp );	
-    } else
-        init_unistr( &info->configfile, "" );
-
-    if (strlen(driver.info_3->helpfile)) {
-        slprintf(temp, sizeof(temp)-1, "\\\\%s%s", servername, driver.info_3->helpfile);
-        init_unistr( &info->helpfile, temp );
-    } else
-        init_unistr( &info->helpfile, "" );
-
-	init_unistr( &info->monitorname, driver.info_3->monitorname );
-	init_unistr( &info->defaultdatatype, driver.info_3->defaultdatatype );
-
-	info->dependentfiles=NULL;
-	init_unistr_array(&info->dependentfiles, driver.info_3->dependentfiles, servername);
-}
-
-/********************************************************************
- * construct_printer_info_3
- * fill a printer_info_3 struct
- ********************************************************************/
-
-static WERROR construct_printer_driver_info_3(DRIVER_INFO_3 *info, int snum, fstring servername, fstring architecture, uint32 version)
-{	
-	NT_PRINTER_INFO_LEVEL *printer = NULL;
-	NT_PRINTER_DRIVER_INFO_LEVEL driver;
-	WERROR status;
-	ZERO_STRUCT(driver);
-
-	status=get_a_printer(&printer, 2, lp_servicename(snum) );
-	DEBUG(8,("construct_printer_driver_info_3: status: %s\n", dos_errstr(status)));
-	if (!W_ERROR_IS_OK(status))
-		return WERR_INVALID_PRINTER_NAME;
-
-	status=get_a_printer_driver(&driver, 3, printer->info_2->drivername, architecture, version);	
-	DEBUG(8,("construct_printer_driver_info_3: status: %s\n", dos_errstr(status)));
-
-#if 0	/* JERRY */
-
-	/* 
-	 * I put this code in during testing.  Helpful when commenting out the 
-	 * support for DRIVER_INFO_6 in regards to win2k.  Not needed in general
-	 * as win2k always queries the driver using an infor level of 6.
-	 * I've left it in (but ifdef'd out) because I'll probably
-	 * use it in experimentation again in the future.   --jerry 22/01/2002
-	 */
-
-	if (!W_ERROR_IS_OK(status)) {
-		/*
-		 * Is this a W2k client ?
-		 */
-		if (version == 3) {
-			/* Yes - try again with a WinNT driver. */
-			version = 2;
-			status=get_a_printer_driver(&driver, 3, printer->info_2->drivername, architecture, version);	
-			DEBUG(8,("construct_printer_driver_info_3: status: %s\n", dos_errstr(status)));
-		}
-#endif
-
-		if (!W_ERROR_IS_OK(status)) {
-			free_a_printer(&printer,2);
-			return WERR_UNKNOWN_PRINTER_DRIVER;
-		}
-		
-#if 0	/* JERRY */
-	}
-#endif
-	
-
-	fill_printer_driver_info_3(info, driver, servername);
-
-	free_a_printer(&printer,2);
-
-	return WERR_OK;
-}
-
-/********************************************************************
- * construct_printer_info_6
- * fill a printer_info_6 struct - we know that driver is really level 3. This sucks. JRA.
- ********************************************************************/
-
-static void fill_printer_driver_info_6(DRIVER_INFO_6 *info, NT_PRINTER_DRIVER_INFO_LEVEL driver, fstring servername)
-{
-	pstring temp;
-	fstring nullstr;
-
-	ZERO_STRUCTP(info);
-	memset(&nullstr, '\0', sizeof(fstring));
-
-	info->version=driver.info_3->cversion;
-
-	init_unistr( &info->name, driver.info_3->name );	
-	init_unistr( &info->architecture, driver.info_3->environment );
-
-	if (strlen(driver.info_3->driverpath)) {
-		slprintf(temp, sizeof(temp)-1, "\\\\%s%s", servername, driver.info_3->driverpath);		
-		init_unistr( &info->driverpath, temp );
-	} else
-		init_unistr( &info->driverpath, "" );
-
-	if (strlen(driver.info_3->datafile)) {
-		slprintf(temp, sizeof(temp)-1, "\\\\%s%s", servername, driver.info_3->datafile);
-		init_unistr( &info->datafile, temp );
-	} else
-		init_unistr( &info->datafile, "" );
-
-	if (strlen(driver.info_3->configfile)) {
-		slprintf(temp, sizeof(temp)-1, "\\\\%s%s", servername, driver.info_3->configfile);
-		init_unistr( &info->configfile, temp );	
-	} else
-		init_unistr( &info->configfile, "" );
-
-	if (strlen(driver.info_3->helpfile)) {
-		slprintf(temp, sizeof(temp)-1, "\\\\%s%s", servername, driver.info_3->helpfile);
-		init_unistr( &info->helpfile, temp );
-	} else
-		init_unistr( &info->helpfile, "" );
-	
-	init_unistr( &info->monitorname, driver.info_3->monitorname );
-	init_unistr( &info->defaultdatatype, driver.info_3->defaultdatatype );
-
-	info->dependentfiles=NULL;
-	init_unistr_array(&info->dependentfiles, driver.info_3->dependentfiles, servername);
-
-	info->previousdrivernames=NULL;
-	init_unistr_array(&info->previousdrivernames, &nullstr, servername);
-
-	info->driver_date.low=0;
-	info->driver_date.high=0;
-
-	info->padding=0;
-	info->driver_version_low=0;
-	info->driver_version_high=0;
-
-	init_unistr( &info->mfgname, "");
-	init_unistr( &info->oem_url, "");
-	init_unistr( &info->hardware_id, "");
-	init_unistr( &info->provider, "");
-}
-
-/********************************************************************
- * construct_printer_info_6
- * fill a printer_info_6 struct
- ********************************************************************/
-
-static WERROR construct_printer_driver_info_6(DRIVER_INFO_6 *info, int snum, fstring servername, fstring architecture, uint32 version)
-{	
-	NT_PRINTER_INFO_LEVEL *printer = NULL;
-	NT_PRINTER_DRIVER_INFO_LEVEL driver;
-	WERROR status;
-	ZERO_STRUCT(driver);
-
-	status=get_a_printer(&printer, 2, lp_servicename(snum) );
-	DEBUG(8,("construct_printer_driver_info_6: status: %s\n", dos_errstr(status)));
-	if (!W_ERROR_IS_OK(status))
-		return WERR_INVALID_PRINTER_NAME;
-
-	status=get_a_printer_driver(&driver, 3, printer->info_2->drivername, architecture, version);	
-	DEBUG(8,("construct_printer_driver_info_6: status: %s\n", dos_errstr(status)));
-	if (!W_ERROR_IS_OK(status)) {
-		/*
-		 * Is this a W2k client ?
-		 */
-
-		if (version < 3) {
-			free_a_printer(&printer,2);
-			return WERR_UNKNOWN_PRINTER_DRIVER;
-		}
-
-		/* Yes - try again with a WinNT driver. */
-		version = 2;
-		status=get_a_printer_driver(&driver, 3, printer->info_2->drivername, architecture, version);	
-		DEBUG(8,("construct_printer_driver_info_6: status: %s\n", dos_errstr(status)));
-		if (!W_ERROR_IS_OK(status)) {
-			free_a_printer(&printer,2);
-			return WERR_UNKNOWN_PRINTER_DRIVER;
-		}
-	}
-
-	fill_printer_driver_info_6(info, driver, servername);
-
-	free_a_printer(&printer,2);
-
-	return WERR_OK;
-}
-
-/****************************************************************************
-****************************************************************************/
-
-static void free_printer_driver_info_3(DRIVER_INFO_3 *info)
-{
-	SAFE_FREE(info->dependentfiles);
-}
-
-/****************************************************************************
-****************************************************************************/
-
-static void free_printer_driver_info_6(DRIVER_INFO_6 *info)
-{
-	SAFE_FREE(info->dependentfiles);
-	
-}
-
-/****************************************************************************
-****************************************************************************/
-
-static WERROR getprinterdriver2_level1(fstring servername, fstring architecture, uint32 version, int snum, NEW_BUFFER *buffer, uint32 offered, uint32 *needed)
-{
-	DRIVER_INFO_1 *info=NULL;
-	WERROR status;
-	
-	if((info=(DRIVER_INFO_1 *)malloc(sizeof(DRIVER_INFO_1))) == NULL)
-		return WERR_NOMEM;
-	
-	status=construct_printer_driver_info_1(info, snum, servername, architecture, version);
-	if (!W_ERROR_IS_OK(status)) {
-		SAFE_FREE(info);
-		return status;
-	}
-
-	/* check the required size. */	
-	*needed += spoolss_size_printer_driver_info_1(info);
-
-	if (!alloc_buffer_size(buffer, *needed)) {
-		SAFE_FREE(info);
-		return WERR_INSUFFICIENT_BUFFER;
-	}
-
-	/* fill the buffer with the structures */
-	smb_io_printer_driver_info_1("", buffer, info, 0);	
-
-	/* clear memory */
-	SAFE_FREE(info);
-
-	if (*needed > offered)
-		return WERR_INSUFFICIENT_BUFFER;
-
-	return WERR_OK;
-}
-
-/****************************************************************************
-****************************************************************************/
-
-static WERROR getprinterdriver2_level2(fstring servername, fstring architecture, uint32 version, int snum, NEW_BUFFER *buffer, uint32 offered, uint32 *needed)
-{
-	DRIVER_INFO_2 *info=NULL;
-	WERROR status;
-	
-	if((info=(DRIVER_INFO_2 *)malloc(sizeof(DRIVER_INFO_2))) == NULL)
-		return WERR_NOMEM;
-	
-	status=construct_printer_driver_info_2(info, snum, servername, architecture, version);
-	if (!W_ERROR_IS_OK(status)) {
-		SAFE_FREE(info);
-		return status;
-	}
-
-	/* check the required size. */	
-	*needed += spoolss_size_printer_driver_info_2(info);
-
-	if (!alloc_buffer_size(buffer, *needed)) {
-		SAFE_FREE(info);
-		return WERR_INSUFFICIENT_BUFFER;
-	}
-
-	/* fill the buffer with the structures */
-	smb_io_printer_driver_info_2("", buffer, info, 0);	
-
-	/* clear memory */
-	SAFE_FREE(info);
-
-	if (*needed > offered)
-		return WERR_INSUFFICIENT_BUFFER;
-	
-	return WERR_OK;
-}
-
-/****************************************************************************
-****************************************************************************/
-
-static WERROR getprinterdriver2_level3(fstring servername, fstring architecture, uint32 version, int snum, NEW_BUFFER *buffer, uint32 offered, uint32 *needed)
-{
-	DRIVER_INFO_3 info;
-	WERROR status;
-
-	ZERO_STRUCT(info);
-
-	status=construct_printer_driver_info_3(&info, snum, servername, architecture, version);
-	if (!W_ERROR_IS_OK(status)) {
-		return status;
-	}
-
-	/* check the required size. */	
-	*needed += spoolss_size_printer_driver_info_3(&info);
-
-	if (!alloc_buffer_size(buffer, *needed)) {
-		free_printer_driver_info_3(&info);
-		return WERR_INSUFFICIENT_BUFFER;
-	}
-
-	/* fill the buffer with the structures */
-	smb_io_printer_driver_info_3("", buffer, &info, 0);
-
-	free_printer_driver_info_3(&info);
-
-	if (*needed > offered)
-		return WERR_INSUFFICIENT_BUFFER;
-
-	return WERR_OK;
-}
-
-/****************************************************************************
-****************************************************************************/
-
-static WERROR getprinterdriver2_level6(fstring servername, fstring architecture, uint32 version, int snum, NEW_BUFFER *buffer, uint32 offered, uint32 *needed)
-{
-	DRIVER_INFO_6 info;
-	WERROR status;
-
-	ZERO_STRUCT(info);
-
-	status=construct_printer_driver_info_6(&info, snum, servername, architecture, version);
-	if (!W_ERROR_IS_OK(status)) {
-		return status;
-	}
-
-	/* check the required size. */	
-	*needed += spoolss_size_printer_driver_info_6(&info);
-
-	if (!alloc_buffer_size(buffer, *needed)) {
-		free_printer_driver_info_6(&info);
-		return WERR_INSUFFICIENT_BUFFER;
-	}
-
-	/* fill the buffer with the structures */
-	smb_io_printer_driver_info_6("", buffer, &info, 0);
-
-	free_printer_driver_info_6(&info);
-
-	if (*needed > offered)
-		return WERR_INSUFFICIENT_BUFFER;
-	
-	return WERR_OK;
-}
-
-/****************************************************************************
-****************************************************************************/
-
-WERROR _spoolss_getprinterdriver2(pipes_struct *p, SPOOL_Q_GETPRINTERDRIVER2 *q_u, SPOOL_R_GETPRINTERDRIVER2 *r_u)
-{
-	POLICY_HND *handle = &q_u->handle;
-	UNISTR2 *uni_arch = &q_u->architecture;
-	uint32 level = q_u->level;
-	uint32 clientmajorversion = q_u->clientmajorversion;
-/*	uint32 clientminorversion = q_u->clientminorversion; - notused. */
-	NEW_BUFFER *buffer = NULL;
-	uint32 offered = q_u->offered;
-	uint32 *needed = &r_u->needed;
-	uint32 *servermajorversion = &r_u->servermajorversion;
-	uint32 *serverminorversion = &r_u->serverminorversion;
-
-	fstring servername;
-	fstring architecture;
-	int snum;
-
-	/* that's an [in out] buffer */
-	spoolss_move_buffer(q_u->buffer, &r_u->buffer);
-	buffer = r_u->buffer;
-
-	DEBUG(4,("_spoolss_getprinterdriver2\n"));
-
-	*needed=0;
-	*servermajorversion=0;
-	*serverminorversion=0;
-
-	pstrcpy(servername, get_called_name());
-	unistr2_to_dos(architecture, uni_arch, sizeof(architecture)-1);
-
-	if (!get_printer_snum(p, handle, &snum))
-		return WERR_BADFID;
-
-	switch (level) {
-	case 1:
-		return getprinterdriver2_level1(servername, architecture, clientmajorversion, snum, buffer, offered, needed);
-	case 2:
-		return getprinterdriver2_level2(servername, architecture, clientmajorversion, snum, buffer, offered, needed);
-	case 3:
-		return getprinterdriver2_level3(servername, architecture, clientmajorversion, snum, buffer, offered, needed);
-	case 6:
-		return getprinterdriver2_level6(servername, architecture, clientmajorversion, snum, buffer, offered, needed);
-	}
-
-	return WERR_UNKNOWN_LEVEL;
-}
-
-/****************************************************************************
-****************************************************************************/
-
-WERROR _spoolss_startpageprinter(pipes_struct *p, SPOOL_Q_STARTPAGEPRINTER *q_u, SPOOL_R_STARTPAGEPRINTER *r_u)
-{
-	POLICY_HND *handle = &q_u->handle;
-
-	Printer_entry *Printer = find_printer_index_by_hnd(p, handle);
-
-	if (!Printer) {
-		DEBUG(3,("Error in startpageprinter printer handle\n"));
-		return WERR_BADFID;
-	}
-
-	Printer->page_started=True;
-	return WERR_OK;
-}
-
-/****************************************************************************
-****************************************************************************/
-
-WERROR _spoolss_endpageprinter(pipes_struct *p, SPOOL_Q_ENDPAGEPRINTER *q_u, SPOOL_R_ENDPAGEPRINTER *r_u)
-{
-	POLICY_HND *handle = &q_u->handle;
-
-	Printer_entry *Printer = find_printer_index_by_hnd(p, handle);
-
-	if (!Printer) {
-		DEBUG(2,("_spoolss_endpageprinter: Invalid handle (%s:%u:%u).\n",OUR_HANDLE(handle)));
-		return WERR_BADFID;
-	}
-	
-	Printer->page_started=False;
-	print_job_endpage(Printer->jobid);
-
-	return WERR_OK;
-}
-
-/********************************************************************
- * api_spoolss_getprinter
- * called from the spoolss dispatcher
- *
- ********************************************************************/
-
-WERROR _spoolss_startdocprinter(pipes_struct *p, SPOOL_Q_STARTDOCPRINTER *q_u, SPOOL_R_STARTDOCPRINTER *r_u)
-{
-	POLICY_HND *handle = &q_u->handle;
-/* 	uint32 level = q_u->doc_info_container.level; - notused. */
-	DOC_INFO *docinfo = &q_u->doc_info_container.docinfo;
-	uint32 *jobid = &r_u->jobid;
-
-	DOC_INFO_1 *info_1 = &docinfo->doc_info_1;
-	int snum;
-	pstring jobname;
-	fstring datatype;
-	Printer_entry *Printer = find_printer_index_by_hnd(p, handle);
-	struct current_user user;
-
-	if (!Printer) {
-		DEBUG(2,("_spoolss_startdocprinter: Invalid handle (%s:%u:%u)\n", OUR_HANDLE(handle)));
-		return WERR_BADFID;
-	}
-
-	get_current_user(&user, p);
-
-	/*
-	 * a nice thing with NT is it doesn't listen to what you tell it.
-	 * when asked to send _only_ RAW datas, it tries to send datas
-	 * in EMF format.
-	 *
-	 * So I add checks like in NT Server ...
-	 *
-	 * lkclXXXX jean-francois, i love this kind of thing.  oh, well,
-	 * there's a bug in NT client-side code, so we'll fix it in the
-	 * server-side code. *nnnnnggggh!*
-	 */
-	
-	if (info_1->p_datatype != 0) {
-		unistr2_to_dos(datatype, &info_1->datatype, sizeof(datatype));
-		if (strcmp(datatype, "RAW") != 0) {
-			(*jobid)=0;
-			return WERR_INVALID_DATATYPE;
-		}		
-	}		
-	
-	/* get the share number of the printer */
-	if (!get_printer_snum(p, handle, &snum)) {
-		return WERR_BADFID;
-	}
-
-	unistr2_to_dos(jobname, &info_1->docname, sizeof(jobname));
-	
-	Printer->jobid = print_job_start(&user, snum, jobname);
-
-	/* An error occured in print_job_start() so return an appropriate
-	   NT error code. */
-
-	if (Printer->jobid == -1) {
-		return map_werror_from_unix(errno);
-	}
-	
-	Printer->document_started=True;
-	(*jobid) = Printer->jobid;
-
-	return WERR_OK;
-}
-
-/********************************************************************
- * api_spoolss_getprinter
- * called from the spoolss dispatcher
- *
- ********************************************************************/
-
-WERROR _spoolss_enddocprinter(pipes_struct *p, SPOOL_Q_ENDDOCPRINTER *q_u, SPOOL_R_ENDDOCPRINTER *r_u)
-{
-	POLICY_HND *handle = &q_u->handle;
-
-	return _spoolss_enddocprinter_internal(p, handle);
-}
-
-/****************************************************************************
-****************************************************************************/
-
-WERROR _spoolss_writeprinter(pipes_struct *p, SPOOL_Q_WRITEPRINTER *q_u, SPOOL_R_WRITEPRINTER *r_u)
-{
-	POLICY_HND *handle = &q_u->handle;
-	uint32 buffer_size = q_u->buffer_size;
-	uint8 *buffer = q_u->buffer;
-	uint32 *buffer_written = &q_u->buffer_size2;
-
-	Printer_entry *Printer = find_printer_index_by_hnd(p, handle);
-	
-	if (!Printer) {
-		DEBUG(2,("_spoolss_writeprinter: Invalid handle (%s:%u:%u)\n",OUR_HANDLE(handle)));
-		r_u->buffer_written = q_u->buffer_size2;
-		return WERR_BADFID;
-	}
-
-	(*buffer_written) = print_job_write(Printer->jobid, (char *)buffer, buffer_size);
-
-
-	r_u->buffer_written = q_u->buffer_size2;
-
-	return WERR_OK;
-}
-
-/********************************************************************
- * api_spoolss_getprinter
- * called from the spoolss dispatcher
- *
- ********************************************************************/
-
-static WERROR control_printer(POLICY_HND *handle, uint32 command,
-			      pipes_struct *p)
-{
-	struct current_user user;
-	int snum;
-	WERROR errcode = WERR_BADFUNC;
-	Printer_entry *Printer = find_printer_index_by_hnd(p, handle);
-
-	get_current_user(&user, p);
-
-	if (!Printer) {
-		DEBUG(2,("control_printer: Invalid handle (%s:%u:%u)\n", OUR_HANDLE(handle)));
-		return WERR_BADFID;
-	}
-
-	if (!get_printer_snum(p, handle, &snum))
-		return WERR_BADFID;
-
-	switch (command) {
-	case PRINTER_CONTROL_PAUSE:
-		if (print_queue_pause(&user, snum, &errcode)) {
-			errcode = WERR_OK;
-		}
-		break;
-	case PRINTER_CONTROL_RESUME:
-	case PRINTER_CONTROL_UNPAUSE:
-		if (print_queue_resume(&user, snum, &errcode)) {
-			errcode = WERR_OK;
-		}
-		break;
-	case PRINTER_CONTROL_PURGE:
-		if (print_queue_purge(&user, snum, &errcode)) {
-			errcode = WERR_OK;
-		}
-		break;
-	default:
-		return WERR_UNKNOWN_LEVEL;
-	}
-
-	return errcode;
-}
-
-/********************************************************************
- * api_spoolss_abortprinter
- ********************************************************************/
-
-WERROR _spoolss_abortprinter(pipes_struct *p, SPOOL_Q_ABORTPRINTER *q_u, SPOOL_R_ABORTPRINTER *r_u)
-{
-	POLICY_HND *handle = &q_u->handle;
-
-	return control_printer(handle, PRINTER_CONTROL_PURGE, p);
-}
-
-/********************************************************************
- * called by spoolss_api_setprinter
- * when updating a printer description
- ********************************************************************/
-
-static WERROR update_printer_sec(POLICY_HND *handle, uint32 level,
-				 const SPOOL_PRINTER_INFO_LEVEL *info,
-				 pipes_struct *p, SEC_DESC_BUF *secdesc_ctr)
-{
-	SEC_DESC_BUF *new_secdesc_ctr = NULL, *old_secdesc_ctr = NULL;
-	struct current_user user;
-	WERROR result;
-	int snum;
-
-	Printer_entry *Printer = find_printer_index_by_hnd(p, handle);
-
-	if (!Printer || !get_printer_snum(p, handle, &snum)) {
-		DEBUG(2,("update_printer_sec: Invalid handle (%s:%u:%u)\n",
-			 OUR_HANDLE(handle)));
-
-		result = WERR_BADFID;
-		goto done;
-	}
-
-	/* NT seems to like setting the security descriptor even though
-	   nothing may have actually changed.  This causes annoying
-	   dialog boxes when the user doesn't have permission to change
-	   the security descriptor. */
-
-	nt_printing_getsec(p->mem_ctx, Printer->dev.handlename, &old_secdesc_ctr);
-
-	if (DEBUGLEVEL >= 10) {
-		SEC_ACL *the_acl;
-		int i;
-
-		the_acl = old_secdesc_ctr->sec->dacl;
-		DEBUG(10, ("old_secdesc_ctr for %s has %d aces:\n", 
-			   PRINTERNAME(snum), the_acl->num_aces));
-
-		for (i = 0; i < the_acl->num_aces; i++) {
-			fstring sid_str;
-
-			sid_to_string(sid_str, &the_acl->ace[i].trustee);
-
-			DEBUG(10, ("%s 0x%08x\n", sid_str, 
-				  the_acl->ace[i].info.mask));
-		}
-
-		the_acl = secdesc_ctr->sec->dacl;
-
-		if (the_acl) {
-			DEBUG(10, ("secdesc_ctr for %s has %d aces:\n", 
-				   PRINTERNAME(snum), the_acl->num_aces));
-
-			for (i = 0; i < the_acl->num_aces; i++) {
-				fstring sid_str;
-				
-				sid_to_string(sid_str, &the_acl->ace[i].trustee);
-				
-				DEBUG(10, ("%s 0x%08x\n", sid_str, 
-					   the_acl->ace[i].info.mask));
-			}
-		} else {
-			DEBUG(10, ("dacl for secdesc_ctr is NULL\n"));
-		}
-	}
-
-	new_secdesc_ctr = sec_desc_merge(p->mem_ctx, secdesc_ctr, old_secdesc_ctr);
-
-	if (sec_desc_equal(new_secdesc_ctr->sec, old_secdesc_ctr->sec)) {
-		result = WERR_OK;
-		goto done;
-	}
-
-	/* Work out which user is performing the operation */
-
-	get_current_user(&user, p);
-
-	/* Check the user has permissions to change the security
-	   descriptor.  By experimentation with two NT machines, the user
-	   requires Full Access to the printer to change security
-	   information. */
-
-	if (!print_access_check(&user, snum, PRINTER_ACCESS_ADMINISTER)) {
-		result = WERR_ACCESS_DENIED;
-		goto done;
-	}
-
-	result = nt_printing_setsec(Printer->dev.handlename, new_secdesc_ctr);
-
- done:
-
-	return result;
-}
-
-/********************************************************************
- Do Samba sanity checks on a printer info struct.
- this has changed purpose: it now "canonicalises" printer
- info from a client rather than just checking it is correct
- ********************************************************************/
-
-static BOOL check_printer_ok(NT_PRINTER_INFO_LEVEL_2 *info, int snum)
-{
-	DEBUG(5,("check_printer_ok: servername=%s printername=%s sharename=%s portname=%s drivername=%s comment=%s location=%s\n",
-		 info->servername, info->printername, info->sharename, info->portname, info->drivername, info->comment, info->location));
-
-	/* we force some elements to "correct" values */
-	slprintf(info->servername, sizeof(info->servername)-1, "\\\\%s", get_called_name());
-	fstrcpy(info->sharename, lp_servicename(snum));
-	slprintf(info->printername, sizeof(info->printername)-1, "\\\\%s\\%s",
-		 get_called_name(), info->sharename);
-	info->attributes = PRINTER_ATTRIBUTE_SHARED | PRINTER_ATTRIBUTE_NETWORK;
-	
-	return True;
-}
-
-/****************************************************************************
-****************************************************************************/
-
-static BOOL add_printer_hook(NT_PRINTER_INFO_LEVEL *printer)
-{
-	char *cmd = lp_addprinter_cmd();
-	char **qlines;
-	pstring command;
-	pstring driverlocation;
-	int numlines;
-	int ret;
-	int fd;
-	fstring remote_machine = "%m";
-
-	/* build driver path... only 9X architecture is needed for legacy reasons */
-	slprintf(driverlocation, sizeof(driverlocation)-1, "\\\\%s\\print$\\WIN40\\0",
-			get_called_name());
-	/* change \ to \\ for the shell */
-	all_string_sub(driverlocation,"\\","\\\\",sizeof(pstring));
-	standard_sub_basic(remote_machine,sizeof(remote_machine));
-	
-	slprintf(command, sizeof(command)-1, "%s \"%s\" \"%s\" \"%s\" \"%s\" \"%s\" \"%s\" \"%s\"",
-			cmd, printer->info_2->printername, printer->info_2->sharename,
-			printer->info_2->portname, printer->info_2->drivername,
-			printer->info_2->location, driverlocation, remote_machine);
-
-	/* Convert script args to unix-codepage */
-	dos_to_unix(command);
-	DEBUG(10,("Running [%s]\n", command));
-	ret = smbrun(command, &fd);
-	DEBUGADD(10,("returned [%d]\n", ret));
-
-	if ( ret != 0 ) {
-		if (fd != -1)
-			close(fd);
-		return False;
-	}
-
-	numlines = 0;
-	/* Get lines and convert them back to dos-codepage */
-	qlines = fd_lines_load(fd, &numlines, True);
-	DEBUGADD(10,("Lines returned = [%d]\n", numlines));
-	close(fd);
-
-	if(numlines) {
-		/* Set the portname to what the script says the portname should be. */
-		strncpy(printer->info_2->portname, qlines[0], sizeof(printer->info_2->portname));
-		DEBUGADD(6,("Line[0] = [%s]\n", qlines[0]));
-
-		/* Send SIGHUP to process group... is there a better way? */
-		kill(0, SIGHUP);
-		
-		/* reload our services immediately */
-		reload_services( False );
-	}
-
-	file_lines_free(qlines);
-	return True;
-}
-
-#if 0	/* JERRY */
-
-/* Return true if two devicemodes are equal */
-
-#define DEVMODE_CHECK_INT(field) \
-    if (d1->field != d2->field) { \
-        DEBUG(10, ("nt_devicemode_equal(): " #field " not equal (%d != %d)\n", \
-            d1->field, d2->field)); \
-        return False; \
-    }
-
-/************************************************************************
- Handy, but currently unused functions
- ***********************************************************************/
-
-static BOOL nt_devicemode_equal(NT_DEVICEMODE *d1, NT_DEVICEMODE *d2)
-{
-	if (!d1 && !d2) goto equal;  /* if both are NULL they are equal */
-
-	if (!d1 ^ !d2) {
-		DEBUG(10, ("nt_devicemode_equal(): pointers not equal\n"));
-		return False; /* if either is exclusively NULL are not equal */
-	}
-
-	if (!strequal(d1->devicename, d2->devicename)) {
-		DEBUG(10, ("nt_devicemode_equal(): device not equal (%s != %s)\n", d1->devicename, d2->devicename));
-		return False;
-	}
-
-	if (!strequal(d1->formname, d2->formname)) {
-		DEBUG(10, ("nt_devicemode_equal(): formname not equal (%s != %s)\n", d1->formname, d2->formname));
-		return False;
-	}
-
-	DEVMODE_CHECK_INT(specversion);
-	DEVMODE_CHECK_INT(driverversion);
-	DEVMODE_CHECK_INT(driverextra);
-	DEVMODE_CHECK_INT(orientation);
-	DEVMODE_CHECK_INT(papersize);
-	DEVMODE_CHECK_INT(paperlength);
-	DEVMODE_CHECK_INT(paperwidth);
-	DEVMODE_CHECK_INT(scale);
-	DEVMODE_CHECK_INT(copies);
-	DEVMODE_CHECK_INT(defaultsource);
-	DEVMODE_CHECK_INT(printquality);
-	DEVMODE_CHECK_INT(color);
-	DEVMODE_CHECK_INT(duplex);
-	DEVMODE_CHECK_INT(yresolution);
-	DEVMODE_CHECK_INT(ttoption);
-	DEVMODE_CHECK_INT(collate);
-	DEVMODE_CHECK_INT(logpixels);
-
-	DEVMODE_CHECK_INT(fields);
-	DEVMODE_CHECK_INT(bitsperpel);
-	DEVMODE_CHECK_INT(pelswidth);
-	DEVMODE_CHECK_INT(pelsheight);
-	DEVMODE_CHECK_INT(displayflags);
-	DEVMODE_CHECK_INT(displayfrequency);
-	DEVMODE_CHECK_INT(icmmethod);
-	DEVMODE_CHECK_INT(icmintent);
-	DEVMODE_CHECK_INT(mediatype);
-	DEVMODE_CHECK_INT(dithertype);
-	DEVMODE_CHECK_INT(reserved1);
-	DEVMODE_CHECK_INT(reserved2);
-	DEVMODE_CHECK_INT(panningwidth);
-	DEVMODE_CHECK_INT(panningheight);
-
-	/* compare the private data if it exists */
-	if (!d1->driverextra && !d2->driverextra) goto equal;
-
-
-	DEVMODE_CHECK_INT(driverextra);
-
-	if (memcmp(d1->private, d2->private, d1->driverextra)) {
-		DEBUG(10, ("nt_devicemode_equal(): private data not equal\n"));
-		return False;
-	}
-
- equal:
-	DEBUG(10, ("nt_devicemode_equal(): devicemodes identical\n"));
-	return True;
-}
-
-/* Return true if two NT_PRINTER_PARAM structures are equal */
-
-static BOOL nt_printer_param_equal(NT_PRINTER_PARAM *p1,
-				   NT_PRINTER_PARAM *p2)
-{
-	if (!p1 && !p2) goto equal;
-
-	if ((!p1 && p2) || (p1 && !p2)) {
-		DEBUG(10, ("nt_printer_param_equal(): pointers differ\n"));
-		return False;
-	}
-
-	/* Compare lists of printer parameters */
-
-	while (p1) {
-		BOOL found = False;
-		NT_PRINTER_PARAM *q = p1;
-
-		/* Find the parameter in the second structure */
-
-		while(q) {
-
-			if (strequal(p1->value, q->value)) {
-
-				if (p1->type != q->type) {
-					DEBUG(10, ("nt_printer_param_equal():"
-						   "types for %s differ (%d != %d)\n",
-						   p1->value, p1->type,
-						   q->type));
-					break;
-				}
-
-				if (p1->data_len != q->data_len) {
-					DEBUG(10, ("nt_printer_param_equal():"
-						   "len for %s differs (%d != %d)\n",
-						   p1->value, p1->data_len,
-						   q->data_len));
-					break;
-				}
-
-				if (memcmp(p1->data, q->data, p1->data_len) == 0) {
-					found = True;
-				} else {
-					DEBUG(10, ("nt_printer_param_equal():"
-						   "data for %s differs\n", p1->value));
-				}
-
-				break;
-			}
-
-			q = q->next;
-		}
-
-		if (!found) {
-			DEBUG(10, ("nt_printer_param_equal(): param %s "
-				   "does not exist\n", p1->value));
-			return False;
-		}
-
-		p1 = p1->next;
-	}
-
-	equal:
-
-	DEBUG(10, ("nt_printer_param_equal(): printer params identical\n"));
-	return True;
-}
-
-/********************************************************************
- * Called by update_printer when trying to work out whether to
- * actually update printer info.
- ********************************************************************/
-
-#define PI_CHECK_INT(field) \
-    if (pi1->field != pi2->field) { \
-        DEBUG(10, ("nt_printer_info_level_equal(): " #field " not equal (%d != %d)\n", \
-            pi1->field, pi2->field)); \
-        return False; \
-    }
-
-#define PI_CHECK_STR(field) \
-    if (!strequal(pi1->field, pi2->field)) { \
-        DEBUG(10, ("nt_printer_info_level_equal(): " #field " not equal (%s != %s)\n", \
-            pi1->field, pi2->field)); \
-        return False; \
-    }
-
-static BOOL nt_printer_info_level_equal(NT_PRINTER_INFO_LEVEL *p1,
-					NT_PRINTER_INFO_LEVEL *p2)
-{
-	NT_PRINTER_INFO_LEVEL_2 *pi1, *pi2;
-
-	/* Trivial conditions */
-
-	if ((!p1 && !p2) || (!p1->info_2 && !p2->info_2)) {
-		goto equal;
-	}
-
-	if ((!p1 && p2) || (p1 && !p2) ||
-	    (!p1->info_2 && p2->info_2) ||
-	    (p1->info_2 && !p2->info_2)) {
-		DEBUG(10, ("nt_printer_info_level_equal(): info levels "
-			   "differ\n"));
-		return False;
-	}
-
-	/* Compare two nt_printer_info_level structures.  Don't compare
-	   status or cjobs as they seem to have something to do with the
-	   printer queue. */
-
-	pi1 = p1->info_2;
-	pi2 = p2->info_2;
-
-	/* Don't check the attributes as we stomp on the value in
-	   check_printer_ok() anyway. */
-
-#if 0
-	PI_CHECK_INT(attributes);
-#endif
-
-	PI_CHECK_INT(priority);
-	PI_CHECK_INT(default_priority);
-	PI_CHECK_INT(starttime);
-	PI_CHECK_INT(untiltime);
-	PI_CHECK_INT(averageppm);
-
-	/* Yuck - don't check the printername or servername as the
-	   mod_a_printer() code plays games with them.  You can't
-	   change the printername or the sharename through this interface
-	   in Samba. */
-
-	PI_CHECK_STR(sharename);
-	PI_CHECK_STR(portname);
-	PI_CHECK_STR(drivername);
-	PI_CHECK_STR(comment);
-	PI_CHECK_STR(location);
-
-	if (!nt_devicemode_equal(pi1->devmode, pi2->devmode)) {
-		return False;
-	}
-
-	PI_CHECK_STR(sepfile);
-	PI_CHECK_STR(printprocessor);
-	PI_CHECK_STR(datatype);
-	PI_CHECK_STR(parameters);
-
-	if (!nt_printer_param_equal(pi1->specific, pi2->specific)) {
-		return False;
-	}
-
-	if (!sec_desc_equal(pi1->secdesc_buf->sec, pi2->secdesc_buf->sec)) {
-		return False;
-	}
-
-	PI_CHECK_INT(changeid);
-	PI_CHECK_INT(c_setprinter);
-	PI_CHECK_INT(setuptime);
-
- equal:
-	DEBUG(10, ("nt_printer_info_level_equal(): infos are identical\n"));
-	return True;
-}
-
-#endif
-
-/********************************************************************
- * Called by spoolss_api_setprinter
- * when updating a printer description.
- ********************************************************************/
-
-static WERROR update_printer(pipes_struct *p, POLICY_HND *handle, uint32 level,
-                           const SPOOL_PRINTER_INFO_LEVEL *info,
-                           DEVICEMODE *devmode)
-{
-	int snum;
-	NT_PRINTER_INFO_LEVEL *printer = NULL, *old_printer = NULL;
-	Printer_entry *Printer = find_printer_index_by_hnd(p, handle);
-	PRINTER_MESSAGE_INFO msg;
-	WERROR result;
-
-	DEBUG(8,("update_printer\n"));
-
-	ZERO_STRUCT(msg);
-	
-	result = WERR_OK;
-
-	if (level!=2) {
-		ZERODEBUG(0,("update_printer: Send a mail to samba@samba.org\n"));
-		DEBUGADD(0,("with the following message: update_printer: level!=2\n"));
-		result = WERR_UNKNOWN_LEVEL;
-		goto done;
-	}
-
-	if (!Printer) {
-		result = WERR_BADFID;
-		goto done;
-	}
-
-	if (!get_printer_snum(p, handle, &snum)) {
-		result = WERR_BADFID;
-		goto done;
-	}
-
-	if (!W_ERROR_IS_OK(get_a_printer(&printer, 2, lp_servicename(snum))) ||
-	    (!W_ERROR_IS_OK(get_a_printer(&old_printer, 2, lp_servicename(snum))))) {
-		result = WERR_BADFID;
-		goto done;
-	}
-
-	DEBUGADD(8,("Converting info_2 struct\n"));
-
-	/*
-	 * convert_printer_info converts the incoming
-	 * info from the client and overwrites the info
-	 * just read from the tdb in the pointer 'printer'.
-	 */
-
-	if (!convert_printer_info(info, printer, level)) {
-		result =  WERR_NOMEM;
-		goto done;
-	}
-
-	if (devmode) {
-		/* we have a valid devmode
-		   convert it and link it*/
-
-		DEBUGADD(8,("update_printer: Converting the devicemode struct\n"));
-		if (!convert_devicemode(printer->info_2->printername, devmode,
-				&printer->info_2->devmode)) {
-			result =  WERR_NOMEM;
-			goto done;
-		}
-
-		/* 
-		 * make sure we actually reload the services after 
-		 * this as smb.conf could have a new section in it 
-		 * .... shouldn't .... but could
-		 */
-		reload_services(False);	
-	}
-
-	/* Do sanity check on the requested changes for Samba */
-
-	if (!check_printer_ok(printer->info_2, snum)) {
-		result = WERR_INVALID_PARAM;
-		goto done;
-	}
-
-#if 0	/* JERRY */
-	
-	/*
-	 * Another one of those historical misunderstandings...
-	 * This is reminisent of a similar call we had in _spoolss_setprinterdata()
-	 * I'm leaving it here as a reminder.  --jerry
-	 */
-
-	if (nt_printer_info_level_equal(printer, old_printer)) {
-		DEBUG(3, ("update_printer: printer info has not changed\n"));
-		result = WERR_OK;
-		goto done;
-	}
-
-#endif
-
-	/* Check calling user has permission to update printer description */
-
-	if (Printer->access_granted != PRINTER_ACCESS_ADMINISTER) {
-		DEBUG(3, ("update_printer: printer property change denied by handle\n"));
-		result = WERR_ACCESS_DENIED;
-		goto done;
-	}
-
-	/* Call addprinter hook */
-
-	if (*lp_addprinter_cmd()) {
-		if ( !add_printer_hook(printer) ) {
-			result = WERR_ACCESS_DENIED;
-			goto done;
-		}
-	}
-	
-	/*
-	 * Set the DRIVER_INIT info in the tdb; trigger on magic value for the
-	 * DEVMODE.displayfrequency, which is not used for printer drivers. This
-	 * requires Win32 client code (see other notes elsewhere in the code).
-	 */
-	if (printer->info_2->devmode &&
-		printer->info_2->devmode->displayfrequency == MAGIC_DISPLAY_FREQUENCY) {
- 
-		DEBUG(10,("update_printer: Save printer driver init data\n"));
-		printer->info_2->devmode->displayfrequency = 0;
- 
-		if (update_driver_init(*printer, 2)!=0) {
-			DEBUG(10,("update_printer: error updating printer driver init DEVMODE\n"));
-			result = WERR_ACCESS_DENIED;
-			goto done;
-		}
-	} else {
-		/*
-		 * When a *new* driver is bound to a printer, the drivername is used to
-		 * lookup previously saved driver initialization info, which is then
-		 * bound to the printer, simulating what happens in the Windows arch.
-		 */
-		if (!strequal(printer->info_2->drivername, old_printer->info_2->drivername)){
-			if (!set_driver_init(printer, 2)) {
-				DEBUG(5,("update_printer: Error restoring driver initialization data for driver [%s]!\n",
-					printer->info_2->drivername));
-			}
-			msg.flags |= PRINTER_MESSAGE_DRIVER;
-		}
-	}
-
-	/* Update printer info */
-	result = mod_a_printer(*printer, 2);
-
-	/* flag which changes actually occured.  This is a small subset of
-	   all the possible changes                                         */
-
-	if (!strequal(printer->info_2->comment, old_printer->info_2->comment))
-		msg.flags |= PRINTER_MESSAGE_COMMENT;
-
-	if (!strequal(printer->info_2->sharename, old_printer->info_2->sharename))
-		msg.flags |= PRINTER_MESSAGE_SHARENAME;
-
-	if (!strequal(printer->info_2->portname, old_printer->info_2->portname))
-		msg.flags |= PRINTER_MESSAGE_PORT;
-
-	if (!strequal(printer->info_2->location, old_printer->info_2->location))
-		msg.flags |= PRINTER_MESSAGE_LOCATION;
-
-	msg.low = PRINTER_CHANGE_ADD_PRINTER;
-	fstrcpy(msg.printer_name, printer->info_2->printername);
-
-	/* only send a notify if something changed */
-	if (msg.flags) {
-		srv_spoolss_sendnotify(msg.printer_name, 0, PRINTER_CHANGE_ADD_PRINTER, msg.flags);
-	}
-
-done:
-	free_a_printer(&printer, 2);
-	free_a_printer(&old_printer, 2);
-
-
-	return result;
-}
-
-/****************************************************************************
-****************************************************************************/
-
-WERROR _spoolss_setprinter(pipes_struct *p, SPOOL_Q_SETPRINTER *q_u, SPOOL_R_SETPRINTER *r_u)
-{
-	POLICY_HND *handle = &q_u->handle;
-	uint32 level = q_u->level;
-	SPOOL_PRINTER_INFO_LEVEL *info = &q_u->info;
-	DEVMODE_CTR devmode_ctr = q_u->devmode_ctr;
-	SEC_DESC_BUF *secdesc_ctr = q_u->secdesc_ctr;
-	uint32 command = q_u->command;
-
-	Printer_entry *Printer = find_printer_index_by_hnd(p, handle);
-	
-	if (!Printer) {
-		DEBUG(2,("_spoolss_setprinter: Invalid handle (%s:%u:%u)\n", OUR_HANDLE(handle)));
-		return WERR_BADFID;
-	}
-
-	/* check the level */	
-	switch (level) {
-		case 0:
-			return control_printer(handle, command, p);
-		case 2:
-			return update_printer(p, handle, level, info, devmode_ctr.devmode);
-		case 3:
-			return update_printer_sec(handle, level, info, p,
-						  secdesc_ctr);
-		default:
-			return WERR_UNKNOWN_LEVEL;
-	}
-}
-
-/****************************************************************************
-****************************************************************************/
-
-WERROR _spoolss_fcpn(pipes_struct *p, SPOOL_Q_FCPN *q_u, SPOOL_R_FCPN *r_u)
-{
-	POLICY_HND *handle = &q_u->handle;
-
-	Printer_entry *Printer= find_printer_index_by_hnd(p, handle);
-	
-	if (!Printer) {
-		DEBUG(2,("_spoolss_fcpn: Invalid handle (%s:%u:%u)\n", OUR_HANDLE(handle)));
-		return WERR_BADFID;
-	}
-
-	if (Printer->notify.client_connected==True)
-		srv_spoolss_replycloseprinter(&Printer->notify.client_hnd);
-
-	Printer->notify.flags=0;
-	Printer->notify.options=0;
-	Printer->notify.localmachine[0]='\0';
-	Printer->notify.printerlocal=0;
-	if (Printer->notify.option)
-		free_spool_notify_option(&Printer->notify.option);
-	Printer->notify.client_connected=False;
-
-	return WERR_OK;
-}
-
-/****************************************************************************
-****************************************************************************/
-
-WERROR _spoolss_addjob(pipes_struct *p, SPOOL_Q_ADDJOB *q_u, SPOOL_R_ADDJOB *r_u)
-{
-	/* that's an [in out] buffer (despite appearences to the contrary) */
-	spoolss_move_buffer(q_u->buffer, &r_u->buffer);
-
-	r_u->needed = 0;
-	return WERR_INVALID_PARAM; /* this is what a NT server
-                                           returns for AddJob. AddJob
-                                           must fail on non-local
-                                           printers */
-}
-
-/****************************************************************************
-****************************************************************************/
-
-static void fill_job_info_1(JOB_INFO_1 *job_info, print_queue_struct *queue,
-                            int position, int snum)
-{
-	pstring temp_name;
-	
-	struct tm *t;
-	
-	t=gmtime(&queue->time);
-	slprintf(temp_name, sizeof(temp_name)-1, "\\\\%s", get_called_name());
-
-	job_info->jobid=queue->job;	
-	init_unistr(&job_info->printername, lp_servicename(snum));
-	init_unistr(&job_info->machinename, temp_name);
-	init_unistr(&job_info->username, queue->fs_user);
-	init_unistr(&job_info->document, queue->fs_file);
-	init_unistr(&job_info->datatype, "RAW");
-	init_unistr(&job_info->text_status, "");
-	job_info->status=nt_printj_status(queue->status);
-	job_info->priority=queue->priority;
-	job_info->position=position;
-	job_info->totalpages=queue->page_count;
-	job_info->pagesprinted=0;
-
-	make_systemtime(&job_info->submitted, t);
-}
-
-/****************************************************************************
-****************************************************************************/
-
-static BOOL fill_job_info_2(JOB_INFO_2 *job_info, print_queue_struct *queue,
-                            int position, int snum, 
-			    NT_PRINTER_INFO_LEVEL *ntprinter,
-			    DEVICEMODE *devmode)
-{
-	pstring temp_name;
-	struct tm *t;
-
-	t=gmtime(&queue->time);
-	slprintf(temp_name, sizeof(temp_name)-1, "\\\\%s", get_called_name());
-
-	job_info->jobid=queue->job;
-	
-	init_unistr(&job_info->printername, ntprinter->info_2->printername);
-	
-	init_unistr(&job_info->machinename, temp_name);
-	init_unistr(&job_info->username, queue->fs_user);
-	init_unistr(&job_info->document, queue->fs_file);
-	init_unistr(&job_info->notifyname, queue->fs_user);
-	init_unistr(&job_info->datatype, "RAW");
-	init_unistr(&job_info->printprocessor, "winprint");
-	init_unistr(&job_info->parameters, "");
-	init_unistr(&job_info->drivername, ntprinter->info_2->drivername);
-	init_unistr(&job_info->text_status, "");
-	
-/* and here the security descriptor */
-
-	job_info->status=nt_printj_status(queue->status);
-	job_info->priority=queue->priority;
-	job_info->position=position;
-	job_info->starttime=0;
-	job_info->untiltime=0;
-	job_info->totalpages=queue->page_count;
-	job_info->size=queue->size;
-	make_systemtime(&(job_info->submitted), t);
-	job_info->timeelapsed=0;
-	job_info->pagesprinted=0;
-
-	job_info->devmode = devmode;
-
-	return (True);
-}
-
-/****************************************************************************
- Enumjobs at level 1.
-****************************************************************************/
-
-static WERROR enumjobs_level1(print_queue_struct *queue, int snum,
-			      NEW_BUFFER *buffer, uint32 offered,
-			      uint32 *needed, uint32 *returned)
-{
-	JOB_INFO_1 *info;
-	int i;
-	
-	info=(JOB_INFO_1 *)malloc(*returned*sizeof(JOB_INFO_1));
-	if (info==NULL) {
-		SAFE_FREE(queue);
-		*returned=0;
-		return WERR_NOMEM;
-	}
-	
-	for (i=0; i<*returned; i++)
-		fill_job_info_1(&info[i], &queue[i], i, snum);
-
-	SAFE_FREE(queue);
-
-	/* check the required size. */	
-	for (i=0; i<*returned; i++)
-		(*needed) += spoolss_size_job_info_1(&info[i]);
-
-	if (!alloc_buffer_size(buffer, *needed)) {
-		SAFE_FREE(info);
-		return WERR_INSUFFICIENT_BUFFER;
-	}
-
-	/* fill the buffer with the structures */
-	for (i=0; i<*returned; i++)
-		smb_io_job_info_1("", buffer, &info[i], 0);	
-
-	/* clear memory */
-	SAFE_FREE(info);
-
-	if (*needed > offered) {
-		*returned=0;
-		return WERR_INSUFFICIENT_BUFFER;
-	}
-
-	return WERR_OK;
-}
-
-/****************************************************************************
- Enumjobs at level 2.
-****************************************************************************/
-
-static WERROR enumjobs_level2(print_queue_struct *queue, int snum,
-			      NEW_BUFFER *buffer, uint32 offered,
-			      uint32 *needed, uint32 *returned)
-{
-	NT_PRINTER_INFO_LEVEL *ntprinter = NULL;
-	JOB_INFO_2 *info = NULL;
-	int i;
-	WERROR result;
-	DEVICEMODE *devmode = NULL;
-	
-	info=(JOB_INFO_2 *)malloc(*returned*sizeof(JOB_INFO_2));
-	if (info==NULL) {
-		*returned=0;
-		result = WERR_NOMEM;
-		goto done;
-	}
-
-	result = get_a_printer(&ntprinter, 2, lp_servicename(snum));
-	if (!W_ERROR_IS_OK(result)) {
-		*returned = 0;
-		goto done;
-	}
-		
-	/* this should not be a failure condition if the devmode is NULL */
-	
-	devmode = construct_dev_mode(snum);
-
-	for (i=0; i<*returned; i++)
-		fill_job_info_2(&(info[i]), &queue[i], i, snum, ntprinter,
-				devmode);
-
-	free_a_printer(&ntprinter, 2);
-	SAFE_FREE(queue);
-
-	/* check the required size. */	
-	for (i=0; i<*returned; i++)
-		(*needed) += spoolss_size_job_info_2(&info[i]);
-
-	if (*needed > offered) {
-		*returned=0;
-		result = WERR_INSUFFICIENT_BUFFER;
-		goto done;
-	}
-
-	if (!alloc_buffer_size(buffer, *needed)) {
-		SAFE_FREE(info);
-		result = WERR_INSUFFICIENT_BUFFER;
-		goto done;
-	}
-
-	/* fill the buffer with the structures */
-	for (i=0; i<*returned; i++)
-		smb_io_job_info_2("", buffer, &info[i], 0);	
-
-	result = WERR_OK;
-
- done:
-	free_a_printer(&ntprinter, 2);
-	free_devmode(devmode);
-	SAFE_FREE(queue);
-	SAFE_FREE(info);
-
-	return result;
-
-}
-
-/****************************************************************************
- Enumjobs.
-****************************************************************************/
-
-WERROR _spoolss_enumjobs( pipes_struct *p, SPOOL_Q_ENUMJOBS *q_u, SPOOL_R_ENUMJOBS *r_u)
-{	
-	POLICY_HND *handle = &q_u->handle;
-/*	uint32 firstjob = q_u->firstjob; - notused. */
-/*	uint32 numofjobs = q_u->numofjobs; - notused. */
-	uint32 level = q_u->level;
-	NEW_BUFFER *buffer = NULL;
-	uint32 offered = q_u->offered;
-	uint32 *needed = &r_u->needed;
-	uint32 *returned = &r_u->returned;
-
-	int snum;
-	print_status_struct prt_status;
-	print_queue_struct *queue=NULL;
-
-	/* that's an [in out] buffer */
-	spoolss_move_buffer(q_u->buffer, &r_u->buffer);
-	buffer = r_u->buffer;
-
-	DEBUG(4,("_spoolss_enumjobs\n"));
-
-	*needed=0;
-	*returned=0;
-
-	if (!get_printer_snum(p, handle, &snum))
-		return WERR_BADFID;
-
-	*returned = print_queue_status(snum, &queue, &prt_status);
-	DEBUGADD(4,("count:[%d], status:[%d], [%s]\n", *returned, prt_status.status, prt_status.message));
-
-	if (*returned == 0) {
-		SAFE_FREE(queue);
-		return WERR_OK;
-	}
-
-	switch (level) {
-	case 1:
-		return enumjobs_level1(queue, snum, buffer, offered, needed, returned);
-	case 2:
-		return enumjobs_level2(queue, snum, buffer, offered, needed, returned);
-	default:
-		SAFE_FREE(queue);
-		*returned=0;
-		return WERR_UNKNOWN_LEVEL;
-	}
-}
-
-/****************************************************************************
-****************************************************************************/
-
-WERROR _spoolss_schedulejob( pipes_struct *p, SPOOL_Q_SCHEDULEJOB *q_u, SPOOL_R_SCHEDULEJOB *r_u)
-{
-	return WERR_OK;
-}
-
-/****************************************************************************
-****************************************************************************/
-
-WERROR _spoolss_setjob(pipes_struct *p, SPOOL_Q_SETJOB *q_u, SPOOL_R_SETJOB *r_u)
-{
-	POLICY_HND *handle = &q_u->handle;
-	uint32 jobid = q_u->jobid;
-/*	uint32 level = q_u->level; - notused. */
-/*	JOB_INFO *ctr = &q_u->ctr; - notused. */
-	uint32 command = q_u->command;
-
-	struct current_user user;
-	int snum;
-	WERROR errcode = WERR_BADFUNC;
-		
-	if (!get_printer_snum(p, handle, &snum)) {
-		return WERR_BADFID;
-	}
-
-	if (!print_job_exists(jobid)) {
-		return WERR_INVALID_PRINTER_NAME;
-	}
-
-	get_current_user(&user, p);	
-
-	switch (command) {
-	case JOB_CONTROL_CANCEL:
-	case JOB_CONTROL_DELETE:
-		if (print_job_delete(&user, jobid, &errcode)) {
-			errcode = WERR_OK;
-		}
-		break;
-	case JOB_CONTROL_PAUSE:
-		if (print_job_pause(&user, jobid, &errcode)) {
-			errcode = WERR_OK;
-		}		
-		break;
-	case JOB_CONTROL_RESTART:
-	case JOB_CONTROL_RESUME:
-		if (print_job_resume(&user, jobid, &errcode)) {
-			errcode = WERR_OK;
-		}
-		break;
-	default:
-		return WERR_UNKNOWN_LEVEL;
-	}
-
-	return errcode;
-}
-
-/****************************************************************************
- Enumerates all printer drivers at level 1.
-****************************************************************************/
-
-static WERROR enumprinterdrivers_level1(fstring servername, fstring architecture, NEW_BUFFER *buffer, uint32 offered, uint32 *needed, uint32 *returned)
-{
-	int i;
-	int ndrivers;
-	uint32 version;
-	fstring *list = NULL;
-
-	NT_PRINTER_DRIVER_INFO_LEVEL driver;
-	DRIVER_INFO_1 *tdi1, *driver_info_1=NULL;
-
-	*returned=0;
-
-#define MAX_VERSION 4
-
-	for (version=0; version<MAX_VERSION; version++) {
-		list=NULL;
-		ndrivers=get_ntdrivers(&list, architecture, version);
-		DEBUGADD(4,("we have:[%d] drivers in environment [%s] and version [%d]\n", ndrivers, architecture, version));
-
-		if(ndrivers == -1)
-			return WERR_NOMEM;
-
-		if(ndrivers != 0) {
-			if((tdi1=(DRIVER_INFO_1 *)Realloc(driver_info_1, (*returned+ndrivers) * sizeof(DRIVER_INFO_1))) == NULL) {
-				ZERODEBUG(0,("enumprinterdrivers_level1: failed to enlarge driver info buffer!\n"));
-				SAFE_FREE(driver_info_1);
-				SAFE_FREE(list);
-				return WERR_NOMEM;
-			}
-			else driver_info_1 = tdi1;
-		}
-
-		for (i=0; i<ndrivers; i++) {
-			WERROR status;
-			DEBUGADD(5,("\tdriver: [%s]\n", list[i]));
-			ZERO_STRUCT(driver);
-			status = get_a_printer_driver(&driver, 3, list[i], 
-						      architecture, version);
-			if (!W_ERROR_IS_OK(status)) {
-				SAFE_FREE(list);
-				return status;
-			}
-			fill_printer_driver_info_1(&driver_info_1[*returned+i], driver, servername, architecture );		
-			free_a_printer_driver(driver, 3);
-		}	
-
-		*returned+=ndrivers;
-		SAFE_FREE(list);
-	}
-	
-	/* check the required size. */
-	for (i=0; i<*returned; i++) {
-		DEBUGADD(6,("adding driver [%d]'s size\n",i));
-		*needed += spoolss_size_printer_driver_info_1(&driver_info_1[i]);
-	}
-
-	if (!alloc_buffer_size(buffer, *needed)) {
-		SAFE_FREE(driver_info_1);
-		return WERR_INSUFFICIENT_BUFFER;
-	}
-
-	/* fill the buffer with the driver structures */
-	for (i=0; i<*returned; i++) {
-		DEBUGADD(6,("adding driver [%d] to buffer\n",i));
-		smb_io_printer_driver_info_1("", buffer, &driver_info_1[i], 0);
-	}
-
-	SAFE_FREE(driver_info_1);
-
-	if (*needed > offered) {
-		*returned=0;
-		return WERR_INSUFFICIENT_BUFFER;
-	}
-
-	return WERR_OK;
-}
-
-/****************************************************************************
- Enumerates all printer drivers at level 2.
-****************************************************************************/
-
-static WERROR enumprinterdrivers_level2(fstring servername, fstring architecture, NEW_BUFFER *buffer, uint32 offered, uint32 *needed, uint32 *returned)
-{
-	int i;
-	int ndrivers;
-	uint32 version;
-	fstring *list = NULL;
-
-	NT_PRINTER_DRIVER_INFO_LEVEL driver;
-	DRIVER_INFO_2 *tdi2, *driver_info_2=NULL;
-
-	*returned=0;
-
-#define MAX_VERSION 4
-
-	for (version=0; version<MAX_VERSION; version++) {
-		list=NULL;
-		ndrivers=get_ntdrivers(&list, architecture, version);
-		DEBUGADD(4,("we have:[%d] drivers in environment [%s] and version [%d]\n", ndrivers, architecture, version));
-
-		if(ndrivers == -1)
-			return WERR_NOMEM;
-
-		if(ndrivers != 0) {
-			if((tdi2=(DRIVER_INFO_2 *)Realloc(driver_info_2, (*returned+ndrivers) * sizeof(DRIVER_INFO_2))) == NULL) {
-				ZERODEBUG(0,("enumprinterdrivers_level2: failed to enlarge driver info buffer!\n"));
-				SAFE_FREE(driver_info_2);
-				SAFE_FREE(list);
-				return WERR_NOMEM;
-			}
-			else driver_info_2 = tdi2;
-		}
-		
-		for (i=0; i<ndrivers; i++) {
-			WERROR status;
-
-			DEBUGADD(5,("\tdriver: [%s]\n", list[i]));
-			ZERO_STRUCT(driver);
-			status = get_a_printer_driver(&driver, 3, list[i], 
-						      architecture, version);
-			if (!W_ERROR_IS_OK(status)) {
-				SAFE_FREE(list);
-				return status;
-			}
-			fill_printer_driver_info_2(&driver_info_2[*returned+i], driver, servername);		
-			free_a_printer_driver(driver, 3);
-		}	
-
-		*returned+=ndrivers;
-		SAFE_FREE(list);
-	}
-	
-	/* check the required size. */
-	for (i=0; i<*returned; i++) {
-		DEBUGADD(6,("adding driver [%d]'s size\n",i));
-		*needed += spoolss_size_printer_driver_info_2(&(driver_info_2[i]));
-	}
-
-	if (!alloc_buffer_size(buffer, *needed)) {
-		SAFE_FREE(driver_info_2);
-		return WERR_INSUFFICIENT_BUFFER;
-	}
-
-	/* fill the buffer with the form structures */
-	for (i=0; i<*returned; i++) {
-		DEBUGADD(6,("adding driver [%d] to buffer\n",i));
-		smb_io_printer_driver_info_2("", buffer, &(driver_info_2[i]), 0);
-	}
-
-	SAFE_FREE(driver_info_2);
-
-	if (*needed > offered) {
-		*returned=0;
-		return WERR_INSUFFICIENT_BUFFER;
-	}
-
-	return WERR_OK;
-}
-
-/****************************************************************************
- Enumerates all printer drivers at level 3.
-****************************************************************************/
-
-static WERROR enumprinterdrivers_level3(fstring servername, fstring architecture, NEW_BUFFER *buffer, uint32 offered, uint32 *needed, uint32 *returned)
-{
-	int i;
-	int ndrivers;
-	uint32 version;
-	fstring *list = NULL;
-
-	NT_PRINTER_DRIVER_INFO_LEVEL driver;
-	DRIVER_INFO_3 *tdi3, *driver_info_3=NULL;
-
-	*returned=0;
-
-#define MAX_VERSION 4
-
-	for (version=0; version<MAX_VERSION; version++) {
-		list=NULL;
-		ndrivers=get_ntdrivers(&list, architecture, version);
-		DEBUGADD(4,("we have:[%d] drivers in environment [%s] and version [%d]\n", ndrivers, architecture, version));
-
-		if(ndrivers == -1)
-			return WERR_NOMEM;
-
-		if(ndrivers != 0) {
-			if((tdi3=(DRIVER_INFO_3 *)Realloc(driver_info_3, (*returned+ndrivers) * sizeof(DRIVER_INFO_3))) == NULL) {
-				ZERODEBUG(0,("enumprinterdrivers_level3: failed to enlarge driver info buffer!\n"));
-				SAFE_FREE(driver_info_3);
-				SAFE_FREE(list);
-				return WERR_NOMEM;
-			}
-			else driver_info_3 = tdi3;
-		}
-
-		for (i=0; i<ndrivers; i++) {
-			WERROR status;
-
-			DEBUGADD(5,("\tdriver: [%s]\n", list[i]));
-			ZERO_STRUCT(driver);
-			status = get_a_printer_driver(&driver, 3, list[i], 
-						      architecture, version);
-			if (!W_ERROR_IS_OK(status)) {
-				SAFE_FREE(list);
-				return status;
-			}
-			fill_printer_driver_info_3(&driver_info_3[*returned+i], driver, servername);		
-			free_a_printer_driver(driver, 3);
-		}	
-
-		*returned+=ndrivers;
-		SAFE_FREE(list);
-	}
-
-	/* check the required size. */
-	for (i=0; i<*returned; i++) {
-		DEBUGADD(6,("adding driver [%d]'s size\n",i));
-		*needed += spoolss_size_printer_driver_info_3(&driver_info_3[i]);
-	}
-
-	if (!alloc_buffer_size(buffer, *needed)) {
-		SAFE_FREE(driver_info_3);
-		return WERR_INSUFFICIENT_BUFFER;
-	}
-	
-	/* fill the buffer with the driver structures */
-	for (i=0; i<*returned; i++) {
-		DEBUGADD(6,("adding driver [%d] to buffer\n",i));
-		smb_io_printer_driver_info_3("", buffer, &driver_info_3[i], 0);
-	}
-
-	for (i=0; i<*returned; i++)
-		SAFE_FREE(driver_info_3[i].dependentfiles);
-	
-	SAFE_FREE(driver_info_3);
-	
-	if (*needed > offered) {
-		*returned=0;
-		return WERR_INSUFFICIENT_BUFFER;
-	}
-
-	return WERR_OK;
-}
-
-/****************************************************************************
- Enumerates all printer drivers.
-****************************************************************************/
-
-WERROR _spoolss_enumprinterdrivers( pipes_struct *p, SPOOL_Q_ENUMPRINTERDRIVERS *q_u, SPOOL_R_ENUMPRINTERDRIVERS *r_u)
-{
-/*	UNISTR2 *name = &q_u->name; - notused. */
-	UNISTR2 *environment = &q_u->environment;
-	uint32 level = q_u->level;
-	NEW_BUFFER *buffer = NULL;
-	uint32 offered = q_u->offered;
-	uint32 *needed = &r_u->needed;
-	uint32 *returned = &r_u->returned;
-
-	fstring *list = NULL;
-	fstring servername;
-	fstring architecture;
-
-	/* that's an [in out] buffer */
-	spoolss_move_buffer(q_u->buffer, &r_u->buffer);
-	buffer = r_u->buffer;
-
-	DEBUG(4,("_spoolss_enumprinterdrivers\n"));
-	fstrcpy(servername, get_called_name());
-	*needed=0;
-	*returned=0;
-
-	unistr2_to_dos(architecture, environment, sizeof(architecture)-1);
-
-	switch (level) {
-	case 1:
-		return enumprinterdrivers_level1(servername, architecture, buffer, offered, needed, returned);
-	case 2:
-		return enumprinterdrivers_level2(servername, architecture, buffer, offered, needed, returned);
-	case 3:
-		return enumprinterdrivers_level3(servername, architecture, buffer, offered, needed, returned);
-	default:
-		*returned=0;
-		SAFE_FREE(list);
-		return WERR_UNKNOWN_LEVEL;
-	}
-}
-
-/****************************************************************************
-****************************************************************************/
-
-static void fill_form_1(FORM_1 *form, nt_forms_struct *list)
-{
-	form->flag=list->flag;
-	init_unistr(&form->name, list->name);
-	form->width=list->width;
-	form->length=list->length;
-	form->left=list->left;
-	form->top=list->top;
-	form->right=list->right;
-	form->bottom=list->bottom;	
-}
-	
-/****************************************************************************
-****************************************************************************/
-
-WERROR _spoolss_enumforms(pipes_struct *p, SPOOL_Q_ENUMFORMS *q_u, SPOOL_R_ENUMFORMS *r_u)
-{
-/*	POLICY_HND *handle = &q_u->handle; - notused. */
-	uint32 level = q_u->level;
-	NEW_BUFFER *buffer = NULL;
-	uint32 offered = q_u->offered;
-	uint32 *needed = &r_u->needed;
-	uint32 *numofforms = &r_u->numofforms;
-	uint32 numbuiltinforms;
-
-	nt_forms_struct *list=NULL;
-	nt_forms_struct *builtinlist=NULL;
-	FORM_1 *forms_1;
-	int buffer_size=0;
-	int i;
-
-	/* that's an [in out] buffer */
-	spoolss_move_buffer(q_u->buffer, &r_u->buffer);
-	buffer = r_u->buffer;
-
-	DEBUG(4,("_spoolss_enumforms\n"));
-	DEBUGADD(5,("Offered buffer size [%d]\n", offered));
-	DEBUGADD(5,("Info level [%d]\n",          level));
-
-	numbuiltinforms = get_builtin_ntforms(&builtinlist);
-	DEBUGADD(5,("Number of builtin forms [%d]\n",     numbuiltinforms));
-	*numofforms = get_ntforms(&list);
-	DEBUGADD(5,("Number of user forms [%d]\n",     *numofforms));
-	*numofforms += numbuiltinforms;
-
-	if (*numofforms == 0) return WERR_NO_MORE_ITEMS;
-
-	switch (level) {
-	case 1:
-		if ((forms_1=(FORM_1 *)malloc(*numofforms * sizeof(FORM_1))) == NULL) {
-			*numofforms=0;
-			return WERR_NOMEM;
-		}
-
-		/* construct the list of form structures */
-		for (i=0; i<numbuiltinforms; i++) {
-			DEBUGADD(6,("Filling form number [%d]\n",i));
-			fill_form_1(&forms_1[i], &builtinlist[i]);
-		}
-		
-		SAFE_FREE(builtinlist);
-
-		for (; i<*numofforms; i++) {
-			DEBUGADD(6,("Filling form number [%d]\n",i));
-			fill_form_1(&forms_1[i], &list[i-numbuiltinforms]);
-		}
-		
-		SAFE_FREE(list);
-
-		/* check the required size. */
-		for (i=0; i<numbuiltinforms; i++) {
-			DEBUGADD(6,("adding form [%d]'s size\n",i));
-			buffer_size += spoolss_size_form_1(&forms_1[i]);
-		}
-		for (; i<*numofforms; i++) {
-			DEBUGADD(6,("adding form [%d]'s size\n",i));
-			buffer_size += spoolss_size_form_1(&forms_1[i]);
-		}
-
-		*needed=buffer_size;		
-		
-		if (!alloc_buffer_size(buffer, buffer_size)){
-			SAFE_FREE(forms_1);
-			return WERR_INSUFFICIENT_BUFFER;
-		}
-
-		/* fill the buffer with the form structures */
-		for (i=0; i<numbuiltinforms; i++) {
-			DEBUGADD(6,("adding form [%d] to buffer\n",i));
-			smb_io_form_1("", buffer, &forms_1[i], 0);
-		}
-		for (; i<*numofforms; i++) {
-			DEBUGADD(6,("adding form [%d] to buffer\n",i));
-			smb_io_form_1("", buffer, &forms_1[i], 0);
-		}
-
-		SAFE_FREE(forms_1);
-
-		if (*needed > offered) {
-			*numofforms=0;
-			return WERR_INSUFFICIENT_BUFFER;
-		}
-		else
-			return WERR_OK;
-			
-	default:
-		SAFE_FREE(list);
-		SAFE_FREE(builtinlist);
-		return WERR_UNKNOWN_LEVEL;
-	}
-
-}
-
-/****************************************************************************
-****************************************************************************/
-
-WERROR _spoolss_getform(pipes_struct *p, SPOOL_Q_GETFORM *q_u, SPOOL_R_GETFORM *r_u)
-{
-/*	POLICY_HND *handle = &q_u->handle; - notused. */
-	uint32 level = q_u->level;
-	UNISTR2 *uni_formname = &q_u->formname;
-	NEW_BUFFER *buffer = NULL;
-	uint32 offered = q_u->offered;
-	uint32 *needed = &r_u->needed;
-
-	nt_forms_struct *list=NULL;
-	nt_forms_struct builtin_form;
-	BOOL foundBuiltin;
-	FORM_1 form_1;
-	fstring form_name;
-	int buffer_size=0;
-	int numofforms=0, i=0;
-
-	/* that's an [in out] buffer */
-	spoolss_move_buffer(q_u->buffer, &r_u->buffer);
-	buffer = r_u->buffer;
-
-	unistr2_to_dos(form_name, uni_formname, sizeof(form_name)-1);
-
-	DEBUG(4,("_spoolss_getform\n"));
-	DEBUGADD(5,("Offered buffer size [%d]\n", offered));
-	DEBUGADD(5,("Info level [%d]\n",          level));
-
-	foundBuiltin = get_a_builtin_ntform(uni_formname,&builtin_form);
-	if (!foundBuiltin) {
-		numofforms = get_ntforms(&list);
-		DEBUGADD(5,("Number of forms [%d]\n",     numofforms));
-
-		if (numofforms == 0)
-			return WERR_BADFID;
-	}
-
-	switch (level) {
-	case 1:
-		if (foundBuiltin) {
-			fill_form_1(&form_1, &builtin_form);
-		} else {
-
-			/* Check if the requested name is in the list of form structures */
-			for (i=0; i<numofforms; i++) {
-
-				DEBUG(4,("_spoolss_getform: checking form %s (want %s)\n", list[i].name, form_name));
-
-				if (strequal(form_name, list[i].name)) {
-					DEBUGADD(6,("Found form %s number [%d]\n", form_name, i));
-					fill_form_1(&form_1, &list[i]);
-					break;
-				}
-			}
-			
-			SAFE_FREE(list);
-			if (i == numofforms) {
-				return WERR_BADFID;
-			}
-		}
-		/* check the required size. */
-
-		*needed=spoolss_size_form_1(&form_1);
-		
-		if (!alloc_buffer_size(buffer, buffer_size)){
-			return WERR_INSUFFICIENT_BUFFER;
-		}
-
-		if (*needed > offered) {
-			return WERR_INSUFFICIENT_BUFFER;
-		}
-
-		/* fill the buffer with the form structures */
-		DEBUGADD(6,("adding form %s [%d] to buffer\n", form_name, i));
-		smb_io_form_1("", buffer, &form_1, 0);
-
-		return WERR_OK;
-			
-	default:
-		SAFE_FREE(list);
-		return WERR_UNKNOWN_LEVEL;
-	}
-}
-
-/****************************************************************************
-****************************************************************************/
-
-static void fill_port_1(PORT_INFO_1 *port, const char *name)
-{
-	init_unistr(&port->port_name, name);
-}
-
-/****************************************************************************
-****************************************************************************/
-
-static void fill_port_2(PORT_INFO_2 *port, const char *name)
-{
-	init_unistr(&port->port_name, name);
-	init_unistr(&port->monitor_name, "Local Monitor");
-	init_unistr(&port->description, "Local Port");
-#define PORT_TYPE_WRITE 1
-	port->port_type=PORT_TYPE_WRITE;
-	port->reserved=0x0;	
-}
-
-/****************************************************************************
- enumports level 1.
-****************************************************************************/
-
-static WERROR enumports_level_1(NEW_BUFFER *buffer, uint32 offered, uint32 *needed, uint32 *returned)
-{
-	PORT_INFO_1 *ports=NULL;
-	int i=0;
-
-	if (*lp_enumports_cmd()) {
-		char *cmd = lp_enumports_cmd();
-		char **qlines;
-		pstring command;
-		int numlines;
-		int ret;
-		int fd;
-
-		slprintf(command, sizeof(command)-1, "%s \"%d\"", cmd, 1);
-
-		DEBUG(10,("Running [%s]\n", command));
-		ret = smbrun(command, &fd);
-		DEBUG(10,("Returned [%d]\n", ret));
-		if (ret != 0) {
-			if (fd != -1)
-				close(fd);
-			/* Is this the best error to return here? */
-			return WERR_ACCESS_DENIED;
-		}
-
-		numlines = 0;
-		qlines = fd_lines_load(fd, &numlines,True);
-		DEBUGADD(10,("Lines returned = [%d]\n", numlines));
-		close(fd);
-
-		if(numlines) {
-			if((ports=(PORT_INFO_1 *)malloc( numlines * sizeof(PORT_INFO_1) )) == NULL) {
-				DEBUG(10,("Returning WERR_NOMEM [%s]\n", 
-					  dos_errstr(WERR_NOMEM)));
-				file_lines_free(qlines);
-				return WERR_NOMEM;
-			}
-
-			for (i=0; i<numlines; i++) {
-				DEBUG(6,("Filling port number [%d] with port [%s]\n", i, qlines[i]));
-				fill_port_1(&ports[i], qlines[i]);
-			}
-
-			file_lines_free(qlines);
-		}
-
-		*returned = numlines;
-
-	} else {
-		*returned = 1; /* Sole Samba port returned. */
-
-		if((ports=(PORT_INFO_1 *)malloc( sizeof(PORT_INFO_1) )) == NULL)
-			return WERR_NOMEM;
-	
-		DEBUG(10,("enumports_level_1: port name %s\n", SAMBA_PRINTER_PORT_NAME));
-
-		fill_port_1(&ports[0], SAMBA_PRINTER_PORT_NAME);
-	}
-
-	/* check the required size. */
-	for (i=0; i<*returned; i++) {
-		DEBUGADD(6,("adding port [%d]'s size\n", i));
-		*needed += spoolss_size_port_info_1(&ports[i]);
-	}
-		
-	if (!alloc_buffer_size(buffer, *needed)) {
-		SAFE_FREE(ports);
-		return WERR_INSUFFICIENT_BUFFER;
-	}
-
-	/* fill the buffer with the ports structures */
-	for (i=0; i<*returned; i++) {
-		DEBUGADD(6,("adding port [%d] to buffer\n", i));
-		smb_io_port_1("", buffer, &ports[i], 0);
-	}
-
-	SAFE_FREE(ports);
-
-	if (*needed > offered) {
-		*returned=0;
-		return WERR_INSUFFICIENT_BUFFER;
-	}
-
-	return WERR_OK;
-}
-
-/****************************************************************************
- enumports level 2.
-****************************************************************************/
-
-static WERROR enumports_level_2(NEW_BUFFER *buffer, uint32 offered, uint32 *needed, uint32 *returned)
-{
-	PORT_INFO_2 *ports=NULL;
-	int i=0;
-
-	if (*lp_enumports_cmd()) {
-		char *cmd = lp_enumports_cmd();
-		char *path;
-		char **qlines;
-		pstring tmp_file;
-		pstring command;
-		int numlines;
-		int ret;
-		int fd;
-
-		if (*lp_pathname(lp_servicenumber(PRINTERS_NAME)))
-			path = lp_pathname(lp_servicenumber(PRINTERS_NAME));
-		else
-			path = lp_lockdir();
-
-		slprintf(tmp_file, sizeof(tmp_file)-1, "%s/smbcmd.%u.", path, (unsigned int)sys_getpid());
-		slprintf(command, sizeof(command)-1, "%s \"%d\"", cmd, 2);
-
-		unlink(tmp_file);
-		DEBUG(10,("Running [%s > %s]\n", command,tmp_file));
-		ret = smbrun(command, &fd);
-		DEBUGADD(10,("returned [%d]\n", ret));
-		if (ret != 0) {
-			if (fd != -1)
-				close(fd);
-			/* Is this the best error to return here? */
-			return WERR_ACCESS_DENIED;
-		}
-
-		numlines = 0;
-		qlines = fd_lines_load(fd, &numlines,True);
-		DEBUGADD(10,("Lines returned = [%d]\n", numlines));
-		close(fd);
-
-		if(numlines) {
-			if((ports=(PORT_INFO_2 *)malloc( numlines * sizeof(PORT_INFO_2) )) == NULL) {
-				file_lines_free(qlines);
-				return WERR_NOMEM;
-			}
-
-			for (i=0; i<numlines; i++) {
-				DEBUG(6,("Filling port number [%d] with port [%s]\n", i, qlines[i]));
-				fill_port_2(&(ports[i]), qlines[i]);
-			}
-
-			file_lines_free(qlines);
-		}
-
-		*returned = numlines;
-
-	} else {
-
-		*returned = 1;
-
-		if((ports=(PORT_INFO_2 *)malloc( sizeof(PORT_INFO_2) )) == NULL)
-			return WERR_NOMEM;
-	
-		DEBUG(10,("enumports_level_2: port name %s\n", SAMBA_PRINTER_PORT_NAME));
-
-		fill_port_2(&ports[0], SAMBA_PRINTER_PORT_NAME);
-	}
-
-	/* check the required size. */
-	for (i=0; i<*returned; i++) {
-		DEBUGADD(6,("adding port [%d]'s size\n", i));
-		*needed += spoolss_size_port_info_2(&ports[i]);
-	}
-		
-	if (!alloc_buffer_size(buffer, *needed)) {
-		SAFE_FREE(ports);
-		return WERR_INSUFFICIENT_BUFFER;
-	}
-
-	/* fill the buffer with the ports structures */
-	for (i=0; i<*returned; i++) {
-		DEBUGADD(6,("adding port [%d] to buffer\n", i));
-		smb_io_port_2("", buffer, &ports[i], 0);
-	}
-
-	SAFE_FREE(ports);
-
-	if (*needed > offered) {
-		*returned=0;
-		return WERR_INSUFFICIENT_BUFFER;
-	}
-
-	return WERR_OK;
-}
-
-/****************************************************************************
- enumports.
-****************************************************************************/
-
-WERROR _spoolss_enumports( pipes_struct *p, SPOOL_Q_ENUMPORTS *q_u, SPOOL_R_ENUMPORTS *r_u)
-{
-/*	UNISTR2 *name = &q_u->name; - notused. */
-	uint32 level = q_u->level;
-	NEW_BUFFER *buffer = NULL;
-	uint32 offered = q_u->offered;
-	uint32 *needed = &r_u->needed;
-	uint32 *returned = &r_u->returned;
-
-	/* that's an [in out] buffer */
-	spoolss_move_buffer(q_u->buffer, &r_u->buffer);
-	buffer = r_u->buffer;
-
-	DEBUG(4,("_spoolss_enumports\n"));
-	
-	*returned=0;
-	*needed=0;
-	
-	switch (level) {
-	case 1:
-		return enumports_level_1(buffer, offered, needed, returned);
-	case 2:
-		return enumports_level_2(buffer, offered, needed, returned);
-	default:
-		return WERR_UNKNOWN_LEVEL;
-	}
-}
-
-/****************************************************************************
-****************************************************************************/
-
-static WERROR spoolss_addprinterex_level_2( pipes_struct *p, const UNISTR2 *uni_srv_name,
-				const SPOOL_PRINTER_INFO_LEVEL *info,
-				DEVICEMODE *devmode, SEC_DESC_BUF *sec_desc_buf,
-				uint32 user_switch, const SPOOL_USER_CTR *user,
-				POLICY_HND *handle)
-{
-	NT_PRINTER_INFO_LEVEL *printer = NULL;
-	fstring	name;
-	int	snum;
-	WERROR err = WERR_OK;
-
-	if ((printer = (NT_PRINTER_INFO_LEVEL *)malloc(sizeof(NT_PRINTER_INFO_LEVEL))) == NULL) {
-		ZERODEBUG(0,("spoolss_addprinterex_level_2: malloc fail.\n"));
-		return WERR_NOMEM;
-	}
-
-	ZERO_STRUCTP(printer);
-
-	/* convert from UNICODE to ASCII - this allocates the info_2 struct inside *printer.*/
-	if (!convert_printer_info(info, printer, 2)) {
-		free_a_printer(&printer, 2);
-		return WERR_NOMEM;
-	}
-
-	/* check to see if the printer already exists */
-
-	if ((snum = print_queue_snum(printer->info_2->sharename)) != -1) {
-		DEBUG(5, ("_spoolss_addprinterex: Attempted to add a printer named [%s] when one already existed!\n", 
-			printer->info_2->sharename));
-		free_a_printer(&printer, 2);
-		return WERR_PRINTER_ALREADY_EXISTS;
-	}
-
-	if (*lp_addprinter_cmd() ) {
-		if ( !add_printer_hook(printer) ) {
-			free_a_printer(&printer,2);
-			return WERR_ACCESS_DENIED;
-	}
-	}
-
-	slprintf(name, sizeof(name)-1, "\\\\%s\\%s", get_called_name(),
-             printer->info_2->sharename);
-
-	
-	if ((snum = print_queue_snum(printer->info_2->sharename)) == -1) {
-		free_a_printer(&printer,2);
-		return WERR_ACCESS_DENIED;
-	}
-
-	/* you must be a printer admin to add a new printer */
-	if (!print_access_check(NULL, snum, PRINTER_ACCESS_ADMINISTER)) {
-		free_a_printer(&printer,2);
-		return WERR_ACCESS_DENIED;		
-	}
-	
-	/*
-	 * Do sanity check on the requested changes for Samba.
-	 */
-
-	if (!check_printer_ok(printer->info_2, snum)) {
-		free_a_printer(&printer,2);
-		return WERR_INVALID_PARAM;
-	}
-
-	/*
-	 * When a printer is created, the drivername bound to the printer is used
-	 * to lookup previously saved driver initialization info, which is then 
-	 * bound to the new printer, simulating what happens in the Windows arch.
-	 */
-
-	if (!devmode)
-		set_driver_init(printer, 2);
-	else {
-		/* A valid devmode was included, convert and link it
-		*/
-		DEBUGADD(10, ("spoolss_addprinterex_level_2: devmode included, converting\n"));
-
-		if (!convert_devicemode(printer->info_2->printername, devmode,
-				&printer->info_2->devmode))
-			return  WERR_NOMEM;
-	}
-
-	set_driver_init(printer, 2);
-	
-	/* write the ASCII on disk */
-	err = mod_a_printer(*printer, 2);
-	if (!W_ERROR_IS_OK(err)) {
-		free_a_printer(&printer,2);
-		return err;
-	}
-
-	if (!open_printer_hnd(p, handle, name, PRINTER_ACCESS_ADMINISTER)) {
-		/* Handle open failed - remove addition. */
-		del_a_printer(printer->info_2->sharename);
-		free_a_printer(&printer,2);
-		return WERR_ACCESS_DENIED;
-	}
-
-	update_c_setprinter(False);
-
-	srv_spoolss_sendnotify(printer->info_2->printername, 0, PRINTER_CHANGE_ADD_PRINTER, 0x0);
-
-	free_a_printer(&printer,2);
-
-	return WERR_OK;
-}
-
-/****************************************************************************
-****************************************************************************/
-
-WERROR _spoolss_addprinterex( pipes_struct *p, SPOOL_Q_ADDPRINTEREX *q_u, SPOOL_R_ADDPRINTEREX *r_u)
-{
-	UNISTR2 *uni_srv_name = &q_u->server_name;
-	uint32 level = q_u->level;
-	SPOOL_PRINTER_INFO_LEVEL *info = &q_u->info;
-	DEVICEMODE *devmode = q_u->devmode_ctr.devmode;
-	SEC_DESC_BUF *sdb = q_u->secdesc_ctr;
-	uint32 user_switch = q_u->user_switch;
-	SPOOL_USER_CTR *user = &q_u->user_ctr;
-	POLICY_HND *handle = &r_u->handle;
-
-	switch (level) {
-		case 1:
-			/* we don't handle yet */
-			/* but I know what to do ... */
-			return WERR_UNKNOWN_LEVEL;
-		case 2:
-			return spoolss_addprinterex_level_2(p, uni_srv_name, info,
-							    devmode, sdb,
-							    user_switch, user, handle);
-		default:
-			return WERR_UNKNOWN_LEVEL;
-	}
-}
-
-/****************************************************************************
-****************************************************************************/
-
-WERROR _spoolss_addprinterdriver(pipes_struct *p, SPOOL_Q_ADDPRINTERDRIVER *q_u, SPOOL_R_ADDPRINTERDRIVER *r_u)
-{
-/*	UNISTR2 *server_name = &q_u->server_name; - notused. */
-	uint32 level = q_u->level;
-	SPOOL_PRINTER_DRIVER_INFO_LEVEL *info = &q_u->info;
-	WERROR err = WERR_OK;
-	NT_PRINTER_DRIVER_INFO_LEVEL driver;
-	struct current_user user;
-	fstring driver_name;
-	uint32 version;
-
-	ZERO_STRUCT(driver);
-
-	get_current_user(&user, p);	
-	
-	if (!convert_printer_driver_info(info, &driver, level)) {
-		err = WERR_NOMEM;
-		goto done;
-	}
-
-	DEBUG(5,("Cleaning driver's information\n"));
-	err = clean_up_driver_struct(driver, level, &user);
-	if (!W_ERROR_IS_OK(err))
-		goto done;
-
-	DEBUG(5,("Moving driver to final destination\n"));
-	if(!move_driver_to_download_area(driver, level, &user, &err)) {
-		if (W_ERROR_IS_OK(err))
-			err = WERR_ACCESS_DENIED;
-		goto done;
-	}
-
-	if (add_a_printer_driver(driver, level)!=0) {
-		err = WERR_ACCESS_DENIED;
-		goto done;
-	}
-
-	/* BEGIN_ADMIN_LOG */
-        switch(level) {
-	    case 3:
-		sys_adminlog(LOG_INFO,"Added printer driver. Print driver name: %s. Print driver OS: %s. Administrator name: %s.",
-			driver.info_3->name,drv_ver_to_os[driver.info_3->cversion],uidtoname(user.uid));
-		fstrcpy(driver_name, driver.info_3->name);
-		break;
-	    case 6:   
-		sys_adminlog(LOG_INFO,"Added printer driver. Print driver name: %s. Print driver OS: %s. Administrator name: %s.",
-			driver.info_6->name,drv_ver_to_os[driver.info_6->version],uidtoname(user.uid));
-		fstrcpy(driver_name, driver.info_6->name);
-		break;
-        }
-	/* END_ADMIN_LOG */
-
-	/* 
-	 * I think this is where he DrvUpgradePrinter() hook would be
-	 * be called in a driver's interface DLL on a Windows NT 4.0/2k
-	 * server.  Right now, we just need to send ourselves a message
-	 * to update each printer bound to this driver.   --jerry	
-	 */
-	 
-	if (!srv_spoolss_drv_upgrade_printer(driver_name)) {
-		ZERODEBUG(0,("_spoolss_addprinterdriver: Failed to send message about upgrading driver [%s]!\n",
-			driver_name));
-	}
-
-	/*
-	 * Based on the version (e.g. driver destination dir: 0=9x,2=Nt/2k,3=2k/Xp),
-	 * decide if the driver init data should be deleted. The rules are:
-	 *  1) never delete init data if it is a 9x driver, they don't use it anyway
-	 *  2) delete init data only if there is no 2k/Xp driver
-	 *  3) always delete init data
-	 * The generalized rule is always use init data from the highest order driver.
-	 * It is necessary to follow the driver install by an initialization step to
-	 * finish off this process.
-	*/
-	if (level == 3)
-		version = driver.info_3->cversion;
-	else if (level == 6)
-		version = driver.info_6->version;
-	else
-		version = -1;
-	switch (version) {
-		/*
-		 * 9x printer driver - never delete init data
-		*/
-		case 0: 
-			DEBUG(10,("_spoolss_addprinterdriver: init data not deleted for 9x driver [%s]\n",
-					driver_name));
-			break;
-		
-		/*
-		 * Nt or 2k (compatiblity mode) printer driver - only delete init data if
-		 * there is no 2k/Xp driver init data for this driver name.
-		*/
-		case 2:
-		{
-			NT_PRINTER_DRIVER_INFO_LEVEL driver1;
-
-			if (!W_ERROR_IS_OK(get_a_printer_driver(&driver1, 3, driver_name, "Windows NT x86", 3))) {
-				/*
-				 * No 2k/Xp driver found, delete init data (if any) for the new Nt driver.
-				*/
-				if (!del_driver_init(driver_name))
-					DEBUG(6,("_spoolss_addprinterdriver: del_driver_init(%s) Nt failed!\n", driver_name));
-			} else {
-				/*
-				 * a 2k/Xp driver was found, don't delete init data because Nt driver will use it.
-				*/
-				free_a_printer_driver(driver1,3);
-				DEBUG(10,("_spoolss_addprinterdriver: init data not deleted for Nt driver [%s]\n", 
-						driver_name));
-			}
-		}
-		break;
-
-		/*
-		 * 2k or Xp printer driver - always delete init data
-		*/
-		case 3:	
-			if (!del_driver_init(driver_name))
-				DEBUG(6,("_spoolss_addprinterdriver: del_driver_init(%s) 2k/Xp failed!\n", driver_name));
-			break;
-
-		default:
-			ZERODEBUG(0,("_spoolss_addprinterdriver: invalid level=%d\n", level));
-			break;
- 	}
-
-	
-done:
-	free_a_printer_driver(driver, level);
-	return err;
-}
-
-/****************************************************************************
-****************************************************************************/
-
-static void fill_driverdir_1(DRIVER_DIRECTORY_1 *info, char *name)
-{
-	init_unistr(&info->name, name);
-}
-
-/****************************************************************************
-****************************************************************************/
-
-static WERROR getprinterdriverdir_level_1(UNISTR2 *name, UNISTR2 *uni_environment, NEW_BUFFER *buffer, uint32 offered, uint32 *needed)
-{
-	pstring path;
-	pstring long_archi;
-	pstring short_archi;
-	DRIVER_DIRECTORY_1 *info=NULL;
-
-	unistr2_to_dos(long_archi, uni_environment, sizeof(long_archi)-1);
-
-	if (get_short_archi(short_archi, long_archi)==False)
-		return WERR_INVALID_ENVIRONMENT;
-
-	if((info=(DRIVER_DIRECTORY_1 *)malloc(sizeof(DRIVER_DIRECTORY_1))) == NULL)
-		return WERR_NOMEM;
-
-	slprintf(path, sizeof(path)-1, "\\\\%s\\print$\\%s", get_called_name(), short_archi);
-
-	DEBUG(4,("printer driver directory: [%s]\n", path));
-
-	fill_driverdir_1(info, path);
-	
-	*needed += spoolss_size_driverdir_info_1(info);
-
-	if (!alloc_buffer_size(buffer, *needed)) {
-		SAFE_FREE(info);
-		return WERR_INSUFFICIENT_BUFFER;
-	}
-
-	smb_io_driverdir_1("", buffer, info, 0);
-
-	SAFE_FREE(info);
-	
-	if (*needed > offered)
-		return WERR_INSUFFICIENT_BUFFER;
-
-	return WERR_OK;
-}
-
-/****************************************************************************
-****************************************************************************/
-
-WERROR _spoolss_getprinterdriverdirectory(pipes_struct *p, SPOOL_Q_GETPRINTERDRIVERDIR *q_u, SPOOL_R_GETPRINTERDRIVERDIR *r_u)
-{
-	UNISTR2 *name = &q_u->name;
-	UNISTR2 *uni_environment = &q_u->environment;
-	uint32 level = q_u->level;
-	NEW_BUFFER *buffer = NULL;
-	uint32 offered = q_u->offered;
-	uint32 *needed = &r_u->needed;
-
-	/* that's an [in out] buffer */
-	spoolss_move_buffer(q_u->buffer, &r_u->buffer);
-	buffer = r_u->buffer;
-
-	DEBUG(4,("_spoolss_getprinterdriverdirectory\n"));
-
-	*needed=0;
-
-	switch(level) {
-	case 1:
-		return getprinterdriverdir_level_1(name, uni_environment, buffer, offered, needed);
-	default:
-		return WERR_UNKNOWN_LEVEL;
-	}
-}
-	
-/****************************************************************************
-****************************************************************************/
-
-WERROR _spoolss_enumprinterdata(pipes_struct *p, SPOOL_Q_ENUMPRINTERDATA *q_u, SPOOL_R_ENUMPRINTERDATA *r_u)
-{
-	POLICY_HND *handle = &q_u->handle;
-	uint32 idx = q_u->index;
-	uint32 in_value_len = q_u->valuesize;
-	uint32 in_data_len = q_u->datasize;
-	uint32 *out_max_value_len = &r_u->valuesize;
-	uint16 **out_value = &r_u->value;
-	uint32 *out_value_len = &r_u->realvaluesize;
-	uint32 *out_type = &r_u->type;
-	uint32 *out_max_data_len = &r_u->datasize;
-	uint8  **data_out = &r_u->data;
-	uint32 *out_data_len = &r_u->realdatasize;
-
-	NT_PRINTER_INFO_LEVEL *printer = NULL;
-	
-	fstring value;
-	
-	uint32 param_index;
-	uint32 biggest_valuesize;
-	uint32 biggest_datasize;
-	uint32 data_len;
-	Printer_entry *Printer = find_printer_index_by_hnd(p, handle);
-	int snum;
-	uint8 *data=NULL;
-	uint32 type;
-	WERROR result;
-
-	ZERO_STRUCT(printer);
-	
-	*out_type=0;
-
-	*out_max_data_len=0;
-	*data_out=NULL;
-	*out_data_len=0;
-
-	DEBUG(5,("spoolss_enumprinterdata\n"));
-
-	if (!Printer) {
-		DEBUG(2,("_spoolss_enumprinterdata: Invalid handle (%s:%u:%u).\n", OUR_HANDLE(handle)));
-		return WERR_BADFID;
-	}
-
-	if (!get_printer_snum(p,handle, &snum))
-		return WERR_BADFID;
-	
-	result = get_a_printer(&printer, 2, lp_servicename(snum));
-	if (!W_ERROR_IS_OK(result))
-		return result;
-
-	/*
-	 * The NT machine wants to know the biggest size of value and data
-	 *
-	 * cf: MSDN EnumPrinterData remark section
-	 */
-	if ( (in_value_len==0) && (in_data_len==0) ) {
-		DEBUGADD(6,("Activating NT mega-hack to find sizes\n"));
-
-		SAFE_FREE(data);
-
-		param_index=0;
-		biggest_valuesize=0;
-		biggest_datasize=0;
-		
-		while (get_specific_param_by_index(*printer, 2, param_index, value, &data, &type, &data_len)) {
-			if (strlen(value) > biggest_valuesize) biggest_valuesize=strlen(value);
-			if (data_len > biggest_datasize) biggest_datasize=data_len;
-
-			DEBUG(6,("current values: [%d], [%d]\n", biggest_valuesize, biggest_datasize));
-
-			SAFE_FREE(data);
-			param_index++;
-		}
-
-		/* the value is an UNICODE string but realvaluesize is the length in bytes including the leading 0 */
-		*out_value_len=2*(1+biggest_valuesize);
-		*out_data_len=biggest_datasize;
-
-		DEBUG(6,("final values: [%d], [%d]\n", *out_value_len, *out_data_len));
-
-		free_a_printer(&printer, 2);
-		return WERR_OK;
-	}
-	
-	/*
-	 * the value len is wrong in NT sp3
-	 * that's the number of bytes not the number of unicode chars
-	 */
-
-	if (!get_specific_param_by_index(*printer, 2, idx, value, &data, &type, &data_len)) {
-
-		SAFE_FREE(data);
-		free_a_printer(&printer, 2);
-
-		/* out_value should default to "" or else NT4 has
-		   problems unmarshalling the response */
-
-		*out_max_value_len=(in_value_len/sizeof(uint16));
-		if((*out_value=(uint16 *)talloc_zero(p->mem_ctx, in_value_len*sizeof(uint8))) == NULL)
-			return WERR_NOMEM;
-
-		*out_value_len = (uint32)dos_PutUniCode((char *)*out_value, "", in_value_len, True);
-
-		/* the data is counted in bytes */
-		*out_max_data_len = in_data_len;
-		*out_data_len = in_data_len;
-		if((*data_out=(uint8 *)talloc_zero(p->mem_ctx, in_data_len*sizeof(uint8))) == NULL)
-			return WERR_NOMEM;
-
-		return WERR_NO_MORE_ITEMS;
-	}
-
-	free_a_printer(&printer, 2);
-
-	/*
-	 * the value is:
-	 * - counted in bytes in the request
-	 * - counted in UNICODE chars in the max reply
-	 * - counted in bytes in the real size
-	 *
-	 * take a pause *before* coding not *during* coding
-	 */
-	
-	*out_max_value_len=(in_value_len/sizeof(uint16));
-	if((*out_value=(uint16 *)talloc_zero(p->mem_ctx,in_value_len*sizeof(uint8))) == NULL) {
-		SAFE_FREE(data);
-		return WERR_NOMEM;
-	}
-	
-	*out_value_len = (uint32)dos_PutUniCode((char *)*out_value, value, in_value_len, True);
-
-	*out_type=type;
-
-	/* the data is counted in bytes */
-	*out_max_data_len=in_data_len;
-	if((*data_out=(uint8 *)talloc_zero(p->mem_ctx, in_data_len*sizeof(uint8))) == NULL) {
-		SAFE_FREE(data);
-		return WERR_NOMEM;
-	}
-	
-	memcpy(*data_out, data, (size_t)data_len);
-	*out_data_len=data_len;
-
-	SAFE_FREE(data);
-	
-	return WERR_OK;
-}
-
-/****************************************************************************
-****************************************************************************/
-
-WERROR _spoolss_setprinterdata( pipes_struct *p, SPOOL_Q_SETPRINTERDATA *q_u, SPOOL_R_SETPRINTERDATA *r_u)
-{
-	POLICY_HND *handle = &q_u->handle;
-	UNISTR2 *value = &q_u->value;
-	uint32 type = q_u->type;
-/*	uint32 max_len = q_u->max_len; - notused. */
-	uint8 *data = q_u->data;
-	uint32 real_len = q_u->real_len;
-/*	uint32 numeric_data = q_u->numeric_data; - notused. */
-
-	NT_PRINTER_INFO_LEVEL *printer = NULL;
-	NT_PRINTER_PARAM *param = NULL, old_param;
-	int snum=0;
-	WERROR status = WERR_OK;
-	Printer_entry *Printer=find_printer_index_by_hnd(p, handle);
-	
-	DEBUG(5,("spoolss_setprinterdata\n"));
-
-	if (!Printer) {
-		DEBUG(2,("_spoolss_setprinterdata: Invalid handle (%s:%u:%u).\n", OUR_HANDLE(handle)));
-		return WERR_BADFID;
-	}
-
-	if (!get_printer_snum(p,handle, &snum))
-		return WERR_BADFID;
-
-	ZERO_STRUCT(old_param);
-
-	/* 
-	 * Access check : NT returns "access denied" if you make a 
-	 * SetPrinterData call without the necessary privildge.
-	 * we were originally returning OK if nothing changed
-	 * which made Win2k issue **a lot** of SetPrinterData
-	 * when connecting to a printer  --jerry
-	 */
-
-	if (Printer->access_granted != PRINTER_ACCESS_ADMINISTER) {
-		DEBUG(3, ("_spoolss_setprinterdata: change denied by handle access permissions\n"));
-		status = WERR_ACCESS_DENIED;
-		goto done;
-	}
-
-	/* Check if we are making any changes or not.  Return true if
-	   nothing is actually changing.  This is not needed anymore but
-	   has been left in as an optimization to keep from from
-	   writing to disk as often  --jerry  */
-
-	status = get_a_printer(&printer, 2, lp_servicename(snum));
-	if (!W_ERROR_IS_OK(status))
-		return status;
-
-	convert_specific_param(&param, value , type, data, real_len);
-
-	unlink_specific_param_if_exist(printer->info_2, param);
-	
-	/*
-	 * When client side code sets a magic printer data key, detect it and save
-	 * the current printer data and the magic key's data (its the DEVMODE) for
-	 * future printer/driver initializations.
-	 */
-	if (param->type==3 && !strcmp( param->value, PHANTOM_DEVMODE_KEY)) {
-		/*
-		 * Set devmode and printer initialization info
-		 */
-		status = save_driver_init(printer, 2, param);
-	}
-	else {
-		add_a_specific_param(printer->info_2, &param);
-		status = mod_a_printer(*printer, 2);
-	}
-
- done:
-	free_a_printer(&printer, 2);
-	if (param)
-		free_nt_printer_param(&param);
-	SAFE_FREE(old_param.data);
-
-	return status;
-}
-
-/****************************************************************************
-****************************************************************************/
-
-WERROR _spoolss_resetprinter(pipes_struct *p, SPOOL_Q_RESETPRINTER *q_u, SPOOL_R_RESETPRINTER *r_u)
-{
-	POLICY_HND *handle = &q_u->handle;
-	Printer_entry *Printer=find_printer_index_by_hnd(p, handle);
-	int snum;
-	
-	DEBUG(5,("_spoolss_resetprinter\n"));
-
-	/*
-	 * All we do is to check to see if the handle and queue is valid.
-	 * This call really doesn't mean anything to us because we only
-	 * support RAW printing.   --jerry
-	 */
-	 
-	if (!Printer) {
-		DEBUG(2,("_spoolss_resetprinter: Invalid handle (%s:%u:%u).\n", OUR_HANDLE(handle)));
-		return WERR_BADFID;
-	}
-
-	if (!get_printer_snum(p,handle, &snum))
-		return WERR_BADFID;
-
-
-	/* blindly return success */	
-	return WERR_OK;
-}
-
-
-WERROR _spoolss_deleteprinterdata(pipes_struct *p, SPOOL_Q_DELETEPRINTERDATA *q_u, SPOOL_R_DELETEPRINTERDATA *r_u)
-{
-	POLICY_HND *handle = &q_u->handle;
-	UNISTR2 *value = &q_u->valuename;
-
-	NT_PRINTER_INFO_LEVEL *printer = NULL;
-	NT_PRINTER_PARAM param;
-	int snum=0;
-	WERROR status = WERR_OK;
-	Printer_entry *Printer=find_printer_index_by_hnd(p, handle);
-	
-	DEBUG(5,("spoolss_deleteprinterdata\n"));
-	
-	if (!Printer) {
-		DEBUG(2,("_spoolss_deleteprinterdata: Invalid handle (%s:%u:%u).\n", OUR_HANDLE(handle)));
-		return WERR_BADFID;
-	}
-
-	if (!get_printer_snum(p, handle, &snum))
-		return WERR_BADFID;
-
-	if (Printer->access_granted != PRINTER_ACCESS_ADMINISTER) {
-		DEBUG(3, ("_spoolss_deleteprinterdata: printer properties change denied by handle\n"));
-		return WERR_ACCESS_DENIED;
-	}
-
-	status = get_a_printer(&printer, 2, lp_servicename(snum));
-	if (!W_ERROR_IS_OK(status))
-		return status;
-
-	ZERO_STRUCTP(&param);
-	unistr2_to_dos(param.value, value, sizeof(param.value)-1);
-
-	if(!unlink_specific_param_if_exist(printer->info_2, &param))
-		status = WERR_INVALID_PARAM;
-	else
-		status = mod_a_printer(*printer, 2);
-
-	free_a_printer(&printer, 2);
-	return status;
-}
-
-/****************************************************************************
-****************************************************************************/
-
-WERROR _spoolss_addform( pipes_struct *p, SPOOL_Q_ADDFORM *q_u, SPOOL_R_ADDFORM *r_u)
-{
-	POLICY_HND *handle = &q_u->handle;
-/*	uint32 level = q_u->level; - notused. */
-	FORM *form = &q_u->form;
-	nt_forms_struct tmpForm;
-	int snum;
-	WERROR status = WERR_OK;
-	NT_PRINTER_INFO_LEVEL *printer = NULL;
-
-	int count=0;
-	nt_forms_struct *list=NULL;
-	Printer_entry *Printer = find_printer_index_by_hnd(p, handle);
-
-	DEBUG(5,("spoolss_addform\n"));
-
-	if (!Printer) {
-		DEBUG(2,("_spoolss_addform: Invalid handle (%s:%u:%u).\n", OUR_HANDLE(handle)));
-		return WERR_BADFID;
-	}
-	
-	
-	/* forms can be added on printer of on the print server handle */
-	
-	if ( Printer->printer_type == PRINTER_HANDLE_IS_PRINTER )
-	{
-		if (!get_printer_snum(p,handle, &snum))
-	                return WERR_BADFID;
-	 
-		status = get_a_printer(&printer, 2, lp_servicename(snum));
-        	if (!W_ERROR_IS_OK(status))
-			goto done;
-	}
-
-	if ( !(Printer->access_granted & (PRINTER_ACCESS_ADMINISTER|SERVER_ACCESS_ADMINISTER)) ) {
-		DEBUG(2,("_spoolss_addform: denied by handle permissions.\n"));
-		status = WERR_ACCESS_DENIED;
-		goto done;
-	}
-	
-	/* can't add if builtin */
-	
-	if (get_a_builtin_ntform(&form->name,&tmpForm)) {
-		status = WERR_ALREADY_EXISTS;
-		goto done;
-	}
-
-	count = get_ntforms(&list);
-	
-	if(!add_a_form(&list, form, &count)) {
-		status =  WERR_NOMEM;
-		goto done;
-	}
-	
-	write_ntforms(&list, count);
-	
-	/*
-	 * ChangeID must always be set if this is a printer
-	 */
-	 
-	if ( Printer->printer_type == PRINTER_HANDLE_IS_PRINTER )
-		status = mod_a_printer(*printer, 2);
-	
-done:
-	if ( printer )
-		free_a_printer(&printer, 2);
-	SAFE_FREE(list);
-
-	return status;
-}
-
-/****************************************************************************
-****************************************************************************/
-
-WERROR _spoolss_deleteform( pipes_struct *p, SPOOL_Q_DELETEFORM *q_u, SPOOL_R_DELETEFORM *r_u)
-{
-	POLICY_HND *handle = &q_u->handle;
-	UNISTR2 *form_name = &q_u->name;
-	nt_forms_struct tmpForm;
-	int count=0;
-	nt_forms_struct *list=NULL;
-	Printer_entry *Printer = find_printer_index_by_hnd(p, handle);
-	int snum;
-	WERROR status = WERR_OK;
-	NT_PRINTER_INFO_LEVEL *printer = NULL;
-
-	DEBUG(5,("spoolss_deleteform\n"));
-
-	if (!Printer) {
-		DEBUG(2,("_spoolss_deleteform: Invalid handle (%s:%u:%u).\n", OUR_HANDLE(handle)));
-		return WERR_BADFID;
-	}
-
-	/* forms can be deleted on printer of on the print server handle */
-	
-	if ( Printer->printer_type == PRINTER_HANDLE_IS_PRINTER )
-	{
-		if (!get_printer_snum(p,handle, &snum))
-	                return WERR_BADFID;
-	 
-		status = get_a_printer(&printer, 2, lp_servicename(snum));
-        	if (!W_ERROR_IS_OK(status))
-			goto done;
-	}
-
-	if ( !(Printer->access_granted & (PRINTER_ACCESS_ADMINISTER|SERVER_ACCESS_ADMINISTER)) ) {
-		DEBUG(2,("_spoolss_deleteform: denied by handle permissions.\n"));
-		status = WERR_ACCESS_DENIED;
-		goto done;
-	}
-
-	/* can't delete if builtin */
-	
-	if (get_a_builtin_ntform(form_name,&tmpForm)) {
-		status = WERR_INVALID_PARAM;
-		goto done;
-	}
-
-	count = get_ntforms(&list);
-	
-	if ( !delete_a_form(&list, form_name, &count, &status ))
-		goto done;
-
-	/*
-	 * ChangeID must always be set if this is a printer
-	 */
-	 
-	if ( Printer->printer_type == PRINTER_HANDLE_IS_PRINTER )
-		status = mod_a_printer(*printer, 2);
-	
-done:
-	if ( printer )
-		free_a_printer(&printer, 2);
-	SAFE_FREE(list);
-
-	return status;
-}
-
-/****************************************************************************
-****************************************************************************/
-
-WERROR _spoolss_setform(pipes_struct *p, SPOOL_Q_SETFORM *q_u, SPOOL_R_SETFORM *r_u)
-{
-	POLICY_HND *handle = &q_u->handle;
-/*	UNISTR2 *uni_name = &q_u->name; - notused. */
-/*	uint32 level = q_u->level; - notused. */
-	FORM *form = &q_u->form;
-	nt_forms_struct tmpForm;
-	int snum;
-	WERROR status = WERR_OK;
-	NT_PRINTER_INFO_LEVEL *printer = NULL;
-
-	int count=0;
-	nt_forms_struct *list=NULL;
-	Printer_entry *Printer = find_printer_index_by_hnd(p, handle);
-
- 	DEBUG(5,("spoolss_setform\n"));
-
-	if (!Printer) {
-		DEBUG(2,("_spoolss_setform: Invalid handle (%s:%u:%u).\n", OUR_HANDLE(handle)));
-		return WERR_BADFID;
-	}
-
-	/* forms can be modified on printer of on the print server handle */
-	
-	if ( Printer->printer_type == PRINTER_HANDLE_IS_PRINTER )
-	{
-		if (!get_printer_snum(p,handle, &snum))
-	                return WERR_BADFID;
-	 
-		status = get_a_printer(&printer, 2, lp_servicename(snum));
-        	if (!W_ERROR_IS_OK(status))
-			goto done;
-	}
-
-	if ( !(Printer->access_granted & (PRINTER_ACCESS_ADMINISTER|SERVER_ACCESS_ADMINISTER)) ) {
-		DEBUG(2,("_spoolss_setform: denied by handle permissions\n"));
-		status = WERR_ACCESS_DENIED;
-		goto done;
-	}
-
-	/* can't set if builtin */
-	if (get_a_builtin_ntform(&form->name,&tmpForm)) {
-		status = WERR_INVALID_PARAM;
-		goto done;
-	}
-
-	count = get_ntforms(&list);
-	update_a_form(&list, form, count);
-	write_ntforms(&list, count);
-
-	/*
-	 * ChangeID must always be set if this is a printer
-	 */
-	 
-	if ( Printer->printer_type == PRINTER_HANDLE_IS_PRINTER )
-		status = mod_a_printer(*printer, 2);
-	
-	
-done:
-	if ( printer )
-		free_a_printer(&printer, 2);
-	SAFE_FREE(list);
-
-	return status;
-}
-
-/****************************************************************************
- enumprintprocessors level 1.
-****************************************************************************/
-
-static WERROR enumprintprocessors_level_1(NEW_BUFFER *buffer, uint32 offered, uint32 *needed, uint32 *returned)
-{
-	PRINTPROCESSOR_1 *info_1=NULL;
-	
-	if((info_1 = (PRINTPROCESSOR_1 *)malloc(sizeof(PRINTPROCESSOR_1))) == NULL)
-		return WERR_NOMEM;
-
-	(*returned) = 0x1;
-	
-	init_unistr(&info_1->name, "winprint");
-
-	*needed += spoolss_size_printprocessor_info_1(info_1);
-
-	if (!alloc_buffer_size(buffer, *needed))
-		return WERR_INSUFFICIENT_BUFFER;
-
-	smb_io_printprocessor_info_1("", buffer, info_1, 0);
-
-	SAFE_FREE(info_1);
-
-	if (*needed > offered) {
-		*returned=0;
-		return WERR_INSUFFICIENT_BUFFER;
-	}
-
-	return WERR_OK;
-}
-
-/****************************************************************************
-****************************************************************************/
-
-WERROR _spoolss_enumprintprocessors(pipes_struct *p, SPOOL_Q_ENUMPRINTPROCESSORS *q_u, SPOOL_R_ENUMPRINTPROCESSORS *r_u)
-{
-/*	UNISTR2 *name = &q_u->name; - notused. */
-/*	UNISTR2 *environment = &q_u->environment; - notused. */
-	uint32 level = q_u->level;
-    NEW_BUFFER *buffer = NULL;
-	uint32 offered = q_u->offered;
-    uint32 *needed = &r_u->needed;
-	uint32 *returned = &r_u->returned;
-
-	/* that's an [in out] buffer */
-	spoolss_move_buffer(q_u->buffer, &r_u->buffer);
-	buffer = r_u->buffer;
-
- 	DEBUG(5,("spoolss_enumprintprocessors\n"));
-
-	/*
-	 * Enumerate the print processors ...
-	 *
-	 * Just reply with "winprint", to keep NT happy
-	 * and I can use my nice printer checker.
-	 */
-	
-	*returned=0;
-	*needed=0;
-	
-	switch (level) {
-	case 1:
-		return enumprintprocessors_level_1(buffer, offered, needed, returned);
-	default:
-		return WERR_UNKNOWN_LEVEL;
-	}
-}
-
-/****************************************************************************
- enumprintprocdatatypes level 1.
-****************************************************************************/
-
-static WERROR enumprintprocdatatypes_level_1(NEW_BUFFER *buffer, uint32 offered, uint32 *needed, uint32 *returned)
-{
-	PRINTPROCDATATYPE_1 *info_1=NULL;
-	
-	if((info_1 = (PRINTPROCDATATYPE_1 *)malloc(sizeof(PRINTPROCDATATYPE_1))) == NULL)
-		return WERR_NOMEM;
-
-	(*returned) = 0x1;
-	
-	init_unistr(&info_1->name, "RAW");
-
-	*needed += spoolss_size_printprocdatatype_info_1(info_1);
-
-	if (!alloc_buffer_size(buffer, *needed))
-		return WERR_INSUFFICIENT_BUFFER;
-
-	smb_io_printprocdatatype_info_1("", buffer, info_1, 0);
-
-	SAFE_FREE(info_1);
-
-	if (*needed > offered) {
-		*returned=0;
-		return WERR_INSUFFICIENT_BUFFER;
-	}
-
-	return WERR_OK;
-}
-
-/****************************************************************************
-****************************************************************************/
-
-WERROR _spoolss_enumprintprocdatatypes(pipes_struct *p, SPOOL_Q_ENUMPRINTPROCDATATYPES *q_u, SPOOL_R_ENUMPRINTPROCDATATYPES *r_u)
-{
-/*	UNISTR2 *name = &q_u->name; - notused. */
-/*	UNISTR2 *processor = &q_u->processor; - notused. */
-	uint32 level = q_u->level;
-	NEW_BUFFER *buffer = NULL;
-	uint32 offered = q_u->offered;
-	uint32 *needed = &r_u->needed;
-	uint32 *returned = &r_u->returned;
-
-	/* that's an [in out] buffer */
-	spoolss_move_buffer(q_u->buffer, &r_u->buffer);
-	buffer = r_u->buffer;
-
- 	DEBUG(5,("_spoolss_enumprintprocdatatypes\n"));
-	
-	*returned=0;
-	*needed=0;
-	
-	switch (level) {
-	case 1:
-		return enumprintprocdatatypes_level_1(buffer, offered, needed, returned);
-	default:
-		return WERR_UNKNOWN_LEVEL;
-	}
-}
-
-/****************************************************************************
- enumprintmonitors level 1.
-****************************************************************************/
-
-static WERROR enumprintmonitors_level_1(NEW_BUFFER *buffer, uint32 offered, uint32 *needed, uint32 *returned)
-{
-	PRINTMONITOR_1 *info_1=NULL;
-	
-	if((info_1 = (PRINTMONITOR_1 *)malloc(sizeof(PRINTMONITOR_1))) == NULL)
-		return WERR_NOMEM;
-
-	(*returned) = 0x1;
-	
-	init_unistr(&info_1->name, "Local Port");
-
-	*needed += spoolss_size_printmonitor_info_1(info_1);
-
-	if (!alloc_buffer_size(buffer, *needed))
-		return WERR_INSUFFICIENT_BUFFER;
-
-	smb_io_printmonitor_info_1("", buffer, info_1, 0);
-
-	SAFE_FREE(info_1);
-
-	if (*needed > offered) {
-		*returned=0;
-		return WERR_INSUFFICIENT_BUFFER;
-	}
-
-	return WERR_OK;
-}
-
-/****************************************************************************
- enumprintmonitors level 2.
-****************************************************************************/
-
-static WERROR enumprintmonitors_level_2(NEW_BUFFER *buffer, uint32 offered, uint32 *needed, uint32 *returned)
-{
-	PRINTMONITOR_2 *info_2=NULL;
-	
-	if((info_2 = (PRINTMONITOR_2 *)malloc(sizeof(PRINTMONITOR_2))) == NULL)
-		return WERR_NOMEM;
-
-	(*returned) = 0x1;
-	
-	init_unistr(&info_2->name, "Local Port");
-	init_unistr(&info_2->environment, "Windows NT X86");
-	init_unistr(&info_2->dll_name, "localmon.dll");
-
-	*needed += spoolss_size_printmonitor_info_2(info_2);
-
-	if (!alloc_buffer_size(buffer, *needed))
-		return WERR_INSUFFICIENT_BUFFER;
-
-	smb_io_printmonitor_info_2("", buffer, info_2, 0);
-
-	SAFE_FREE(info_2);
-
-	if (*needed > offered) {
-		*returned=0;
-		return WERR_INSUFFICIENT_BUFFER;
-	}
-
-	return WERR_OK;
-}
-
-/****************************************************************************
-****************************************************************************/
-
-WERROR _spoolss_enumprintmonitors(pipes_struct *p, SPOOL_Q_ENUMPRINTMONITORS *q_u, SPOOL_R_ENUMPRINTMONITORS *r_u)
-{
-/*	UNISTR2 *name = &q_u->name; - notused. */
-	uint32 level = q_u->level;
-    NEW_BUFFER *buffer = NULL;
-	uint32 offered = q_u->offered;
-    uint32 *needed = &r_u->needed;
-	uint32 *returned = &r_u->returned;
-
-	/* that's an [in out] buffer */
-	spoolss_move_buffer(q_u->buffer, &r_u->buffer);
-	buffer = r_u->buffer;
-
- 	DEBUG(5,("spoolss_enumprintmonitors\n"));
-
-	/*
-	 * Enumerate the print monitors ...
-	 *
-	 * Just reply with "Local Port", to keep NT happy
-	 * and I can use my nice printer checker.
-	 */
-	
-	*returned=0;
-	*needed=0;
-	
-	switch (level) {
-	case 1:
-		return enumprintmonitors_level_1(buffer, offered, needed, returned);
-	case 2:
-		return enumprintmonitors_level_2(buffer, offered, needed, returned);
-	default:
-		return WERR_UNKNOWN_LEVEL;
-	}
-}
-
-/****************************************************************************
-****************************************************************************/
-
-static WERROR getjob_level_1(print_queue_struct *queue, int count, int snum, uint32 jobid, NEW_BUFFER *buffer, uint32 offered, uint32 *needed)
-{
-	int i=0;
-	BOOL found=False;
-	JOB_INFO_1 *info_1=NULL;
-
-	info_1=(JOB_INFO_1 *)malloc(sizeof(JOB_INFO_1));
-
-	if (info_1 == NULL) {
-		SAFE_FREE(queue);
-		return WERR_NOMEM;
-	}
-		
-	for (i=0; i<count && found==False; i++) {
-		if (queue[i].job==(int)jobid)
-			found=True;
-	}
-	
-	if (found==False) {
-		SAFE_FREE(queue);
-		SAFE_FREE(info_1);
-		/* NT treats not found as bad param... yet another bad choice */
-		return WERR_INVALID_PARAM;
-	}
-	
-	fill_job_info_1(info_1, &(queue[i-1]), i, snum);
-	
-	SAFE_FREE(queue);
-	
-	*needed += spoolss_size_job_info_1(info_1);
-
-	if (!alloc_buffer_size(buffer, *needed)) {
-		SAFE_FREE(info_1);
-		return WERR_INSUFFICIENT_BUFFER;
-	}
-
-	smb_io_job_info_1("", buffer, info_1, 0);
-
-	SAFE_FREE(info_1);
-
-	if (*needed > offered)
-		return WERR_INSUFFICIENT_BUFFER;
-
-	return WERR_OK;
-}
-
-/****************************************************************************
-****************************************************************************/
-
-static WERROR getjob_level_2(print_queue_struct *queue, int count, int snum, uint32 jobid, NEW_BUFFER *buffer, uint32 offered, uint32 *needed)
-{
-	int i=0;
-	BOOL found=False;
-	JOB_INFO_2 *info_2;
-	NT_PRINTER_INFO_LEVEL *ntprinter = NULL;
-	WERROR ret;
-	DEVICEMODE *devmode = NULL;
-
-	info_2=(JOB_INFO_2 *)malloc(sizeof(JOB_INFO_2));
-
-	ZERO_STRUCTP(info_2);
-
-	if (info_2 == NULL) {
-		ret = WERR_NOMEM;
-		goto done;
-	}
-
-	for (i=0; i<count && found==False; i++) {
-		if (queue[i].job==(int)jobid)
-			found=True;
-	}
-	
-	if (found==False) {
-		/* NT treats not found as bad param... yet another bad
-		   choice */
-		ret = WERR_INVALID_PARAM;
-		goto done;
-	}
-	
-	ret = get_a_printer(&ntprinter, 2, lp_servicename(snum));
-	if (!W_ERROR_IS_OK(ret))
-		goto done;
-		
-	/* not a failure condition if devmode == NULL */
-	
-	construct_dev_mode(snum);
-
-	fill_job_info_2(info_2, &(queue[i-1]), i, snum, ntprinter, devmode);
-	
-	*needed += spoolss_size_job_info_2(info_2);
-
-	if (!alloc_buffer_size(buffer, *needed)) {
-		ret = WERR_INSUFFICIENT_BUFFER;
-		goto done;
-	}
-
-	smb_io_job_info_2("", buffer, info_2, 0);
-
-	if (*needed > offered) {
-		ret = WERR_INSUFFICIENT_BUFFER;
-		goto done;
-	}
-
-	ret = WERR_OK;
-	
- done:
-	/* Cleanup allocated memory */
-
-	SAFE_FREE(queue);
-	free_job_info_2(info_2);	/* Also frees devmode */
-	SAFE_FREE(info_2);
-	free_a_printer(&ntprinter, 2);
-
-	return ret;
-}
-
-/****************************************************************************
-****************************************************************************/
-
-WERROR _spoolss_getjob( pipes_struct *p, SPOOL_Q_GETJOB *q_u, SPOOL_R_GETJOB *r_u)
-{
-	POLICY_HND *handle = &q_u->handle;
-	uint32 jobid = q_u->jobid;
-	uint32 level = q_u->level;
-	NEW_BUFFER *buffer = NULL;
-	uint32 offered = q_u->offered;
-	uint32 *needed = &r_u->needed;
-
-	int snum;
-	int count;
-	print_queue_struct *queue=NULL;
-	print_status_struct prt_status;
-
-	/* that's an [in out] buffer */
-	spoolss_move_buffer(q_u->buffer, &r_u->buffer);
-	buffer = r_u->buffer;
-
-	DEBUG(5,("spoolss_getjob\n"));
-	
-	*needed=0;
-	
-	if (!get_printer_snum(p, handle, &snum))
-		return WERR_BADFID;
-	
-	count = print_queue_status(snum, &queue, &prt_status);
-	
-	DEBUGADD(4,("count:[%d], prt_status:[%d], [%s]\n",
-	             count, prt_status.status, prt_status.message));
-		
-	switch (level) {
-	case 1:
-		return getjob_level_1(queue, count, snum, jobid, buffer, offered, needed);
-	case 2:
-		return getjob_level_2(queue, count, snum, jobid, buffer, offered, needed);
-	default:
-		SAFE_FREE(queue);
-		return WERR_UNKNOWN_LEVEL;
-	}
-}
-
-/********************************************************************
- * spoolss_getprinterdataex
- ********************************************************************/
-
-WERROR _spoolss_getprinterdataex(pipes_struct *p, SPOOL_Q_GETPRINTERDATAEX *q_u, SPOOL_R_GETPRINTERDATAEX *r_u)
-{
-	POLICY_HND	*handle = &q_u->handle;
-	uint32 		in_size = q_u->size;
-	uint32 		*type = &r_u->type;
-	uint32 		*out_size = &r_u->size;
-	uint8 		**data = &r_u->data;
-	uint32 		*needed = &r_u->needed;
-
-	fstring 	key, value;
-	Printer_entry 	*Printer = find_printer_index_by_hnd(p, handle);
-	BOOL 		found = False;
-
-	DEBUG(4,("_spoolss_getprinterdataex\n"));
-
-        unistr2_to_dos(key, &q_u->keyname, sizeof(key) - 1);
-        unistr2_to_dos(value, &q_u->valuename, sizeof(value) - 1);
-
-	/* in case of problem, return some default values */
-	*needed=0;
-	*type=0;
-	*out_size=0;
-
-		
-	if (!Printer) {
-		if((*data=(uint8 *)talloc_zero(p->mem_ctx, 4*sizeof(uint8))) == NULL)
-			return WERR_NOMEM;
-		DEBUG(2,("_spoolss_getprinterdata: Invalid handle (%s:%u:%u).\n", OUR_HANDLE(handle)));
-		return WERR_BADFID;
-	}
-
-		
-	/* Is the handle to a printer or to the server? */
-
-	if (Printer->printer_type == PRINTER_HANDLE_IS_PRINTSERVER)
-	{
-		DEBUG(10,("_spoolss_getprinterdatex: Not implemented for server handles yet\n"));
-		return WERR_INVALID_PARAM;
-	}
-	else
-	{
-	        /* 
-		 * From MSDN documentation of GetPrinterDataEx: pass request
-		 * to GetPrinterData if key is "PrinterDriverData". This is 
-		 * the only key we really support. Other keys to implement:
-		 * (a) DsDriver
-		 * (b) DsSpooler
-		 * (c) PnPData
-		 */
-	   
-		if (strcmp(key, "PrinterDriverData") != 0)
-			return WERR_BADFILE;
-
-		DEBUG(10, ("_spoolss_getprinterdataex: pass me to getprinterdata\n"));
-		found = getprinterdata_printer(p, p->mem_ctx, handle, value, 
-			type, data, needed, in_size);
-		
-	}
-	 
-	if (!found) {
-		DEBUG(5, ("value not found, allocating %d\n", *out_size));
-		
-		/* reply this param doesn't exist */
-		if (*out_size) {
-			if((*data=(uint8 *)talloc_zero(p->mem_ctx, *out_size*sizeof(uint8))) == NULL)
-				return WERR_NOMEM;
-		} else {
-			*data = NULL;
-		}
-
-		return WERR_INVALID_PARAM;
-	}
-	
-	if (*needed > *out_size)
-		return WERR_MORE_DATA;
-	else
-		return WERR_OK;
-}
-
-/********************************************************************
- * spoolss_setprinterdata
- ********************************************************************/
-
-WERROR _spoolss_setprinterdataex(pipes_struct *p, SPOOL_Q_SETPRINTERDATAEX *q_u, SPOOL_R_SETPRINTERDATAEX *r_u)
-{
-	SPOOL_Q_SETPRINTERDATA q_u_local;
-	SPOOL_R_SETPRINTERDATA r_u_local;
-        fstring key;
-
-	DEBUG(4,("_spoolss_setprinterdataex\n"));
-
-        /* From MSDN documentation of SetPrinterDataEx: pass request to
-           SetPrinterData if key is "PrinterDriverData" */
-
-        unistr2_to_dos(key, &q_u->key, sizeof(key) - 1);
-
-        if (strcmp(key, "PrinterDriverData") != 0)
-	        return WERR_INVALID_PARAM;
-		
-	ZERO_STRUCT(q_u_local);	
-	ZERO_STRUCT(r_u_local);	
-	
-	/* make a copy to call _spoolss_setprinterdata() */
-
-	memcpy(&q_u_local.handle, &q_u->handle, sizeof(POLICY_HND));
-	copy_unistr2(&q_u_local.value, &q_u->value);
-	q_u_local.type = q_u->type;
-	q_u_local.max_len = q_u->max_len;
-	q_u_local.data = q_u->data;
-	q_u_local.real_len = q_u->real_len;
-	q_u_local.numeric_data = q_u->numeric_data;
-		
-	return _spoolss_setprinterdata(p, &q_u_local, &r_u_local);
-}
-
-/********************************************************************
- * spoolss_enumprinterkey
- ********************************************************************/
-
-/* constants for EnumPrinterKey() */
-#define ENUMERATED_KEY_SIZE	19
-
-WERROR _spoolss_enumprinterkey(pipes_struct *p, SPOOL_Q_ENUMPRINTERKEY *q_u, SPOOL_R_ENUMPRINTERKEY *r_u)
-{
-	fstring key;
-	uint16  enumkeys[ENUMERATED_KEY_SIZE+1];
-	fstring	PrinterKey;
-	UNISTR2	uni_keys;
-	int	enum_key_len;
-
-	DEBUG(4,("_spoolss_enumprinterkey\n"));
-
-	unistr2_to_dos(key, &q_u->key, sizeof(key) - 1);
-
-	ZERO_STRUCTP(PrinterKey);
-	fstrcpy( PrinterKey, "PrinterDriverData" );
-
-	/* add space for 2 terminating NULLs */
-
-	enum_key_len = strlen( PrinterKey ) + 2;
-
-
-	/* 
-	 * we only support enumating all keys (key == "")
-	 * Of course, the only key we support is the "PrinterDriverData" 
-	 * key
-	 */	
-	if (strlen(key) == 0)
-	{
-		r_u->needed = enum_key_len*2;
-		if (q_u->size < r_u->needed)
-			return WERR_MORE_DATA;
-	
-		init_unistr2( &uni_keys, PrinterKey, enum_key_len );
-
-		if ( !make_spoolss_buffer5(p->mem_ctx, &r_u->keys, enum_key_len, uni_keys.buffer) )
-			return WERR_BADFILE;
-			
-		return WERR_OK;
-	}
-	
-	/* The "PrinterDriverData" key should have no subkeys */
-	if (strcmp(key, PrinterKey) == 0)
-	{
-		r_u-> needed = 2;
-		if (q_u->size < r_u->needed)
-			return WERR_MORE_DATA;
-		enumkeys[0] = 0x0;
-		if (!make_spoolss_buffer5(p->mem_ctx, &r_u->keys, 1, enumkeys))
-			return WERR_BADFILE;
-			
-		return WERR_OK;
-	}
-	
-
-	/* The return value for an unknown key is documented in MSDN
-	   EnumPrinterKey description */
-        return WERR_BADFILE;
-}
-
-/********************************************************************
- * spoolss_enumprinterdataex
- ********************************************************************/
-
-WERROR _spoolss_enumprinterdataex(pipes_struct *p, SPOOL_Q_ENUMPRINTERDATAEX *q_u, SPOOL_R_ENUMPRINTERDATAEX *r_u)
-{
-	POLICY_HND	*handle = &q_u->handle; 
-	uint32 		in_size = q_u->size;
-	uint32 		num_entries, 
-			needed;
-	NT_PRINTER_INFO_LEVEL 	*printer = NULL;
-	PRINTER_ENUM_VALUES	*enum_values = NULL;
-	fstring 	key, value;
-	Printer_entry 	*Printer = find_printer_index_by_hnd(p, handle);
-	int 		snum;
-	uint32 		param_index, 
-			data_len,
-			type;
-	WERROR 		result;
-	uint8 		*data=NULL;
-	
-
-	DEBUG(4,("_spoolss_enumprinterdataex\n"));
-
-	if (!Printer) {
-		DEBUG(2,("_spoolss_enumprinterdata: Invalid handle (%s:%u:%u1<).\n", OUR_HANDLE(handle)));
-		return WERR_BADFID;
-	}
-
-		
-        /* 
-	 * The only key we support is "PrinterDriverData". This should return 
-	 > an array of all the key/value pairs returned by EnumPrinterDataSee 
-	 * _spoolss_getprinterdataex() for details    --jerry
-	 */
-   
-	unistr2_to_dos(key, &q_u->key, sizeof(key) - 1);
-	if (strcmp(key, "PrinterDriverData") != 0)
-	{
-		DEBUG(10,("_spoolss_enumprinterdataex: Unknown keyname [%s]\n", key));
-		return WERR_INVALID_PARAM;
-	}
-
-
-	if (!get_printer_snum(p,handle, &snum))
-		return WERR_BADFID;
-	
-	ZERO_STRUCT(printer);
-	result = get_a_printer(&printer, 2, lp_servicename(snum));
-	if (!W_ERROR_IS_OK(result))
-		return result;
-
-	
-	/* 
-	 * loop through all params and build the array to pass 
-	 * back to the  client 
-	 */
-	result = WERR_OK;
-	param_index		= 0;
-	needed 			= 0;
-	num_entries		= 0;
-	
-	while (get_specific_param_by_index(*printer, 2, param_index, value, &data, &type, &data_len)) 
-	{
-		PRINTER_ENUM_VALUES	*ptr;
-
-		DEBUG(10,("retrieved value number [%d] [%s]\n", num_entries, value));
-
-		if ((ptr=talloc_realloc(p->mem_ctx, enum_values, (num_entries+1) * sizeof(PRINTER_ENUM_VALUES))) == NULL)
-		{
-			ZERODEBUG(0,("talloc_realloc failed to allocate more memory!\n"));
-			result = WERR_NOMEM;
-			goto done;
-		}
-		enum_values = ptr;
-		
-		ZERO_STRUCTP( &enum_values[num_entries] );
-
-		/* copy the data */
-		
-		init_unistr(&enum_values[num_entries].valuename, value);
-		enum_values[num_entries].value_len = (strlen(value)+1) * 2;
-		enum_values[num_entries].type      = type;
-		
-		if ( data_len )
-		{
-			if ( !(enum_values[num_entries].data = talloc_zero(p->mem_ctx, data_len)) ) {
-				ZERODEBUG(0,("talloc_realloc failed to allocate more memory [data_len=%d] for data!\n", data_len ));
-				result = WERR_NOMEM;
-				goto done;
-			}
-			memcpy(enum_values[num_entries].data, data, data_len);
-		}
-
-		enum_values[num_entries].data_len = data_len;
-
-		/* keep track of the size of the array in bytes */
-		
-		needed += spoolss_size_printer_enum_values(&enum_values[num_entries]);
-		
-		num_entries++;
-		param_index++;
-	}
-	
-	r_u->needed 		= needed;
-	r_u->returned 		= num_entries;
-
-	if (needed > in_size) {
-		result = WERR_MORE_DATA;
-		goto done;
-	}
-		
-	/* copy data into the reply */
-	
-	r_u->ctr.size        	= r_u->needed;
-	r_u->ctr.size_of_array 	= r_u->returned;
-	r_u->ctr.values 	= enum_values;
-	
-	
-		
-done:	
-	free_a_printer(&printer, 2);
-
-	return result;
-}
-
-/****************************************************************************
-****************************************************************************/
-
-static void fill_printprocessordirectory_1(PRINTPROCESSOR_DIRECTORY_1 *info, char *name)
-{
-	init_unistr(&info->name, name);
-}
-
-static WERROR getprintprocessordirectory_level_1(UNISTR2 *name, 
-						 UNISTR2 *environment, 
-						 NEW_BUFFER *buffer, 
-						 uint32 offered, 
-						 uint32 *needed)
-{
-	pstring path;
-	pstring long_archi;
-	pstring short_archi;
-	PRINTPROCESSOR_DIRECTORY_1 *info=NULL;
-
-	unistr2_to_dos(long_archi, environment, sizeof(long_archi)-1);
-
-	if (get_short_archi(short_archi, long_archi)==False)
-		return WERR_INVALID_ENVIRONMENT;
-
-	if((info=(PRINTPROCESSOR_DIRECTORY_1 *)malloc(sizeof(PRINTPROCESSOR_DIRECTORY_1))) == NULL)
-		return WERR_NOMEM;
-
-	pstrcpy(path, "C:\\WINNT\\System32\\spool\\PRTPROCS\\W32X86");
-
-	fill_printprocessordirectory_1(info, path);
-	
-	*needed += spoolss_size_printprocessordirectory_info_1(info);
-
-	if (!alloc_buffer_size(buffer, *needed)) {
-		safe_free(info);
-		return WERR_INSUFFICIENT_BUFFER;
-	}
-
-	smb_io_printprocessordirectory_1("", buffer, info, 0);
-
-	safe_free(info);
-	
-	if (*needed > offered)
-		return WERR_INSUFFICIENT_BUFFER;
-	else
-		return WERR_OK;
-}
-
-WERROR _spoolss_getprintprocessordirectory(pipes_struct *p, SPOOL_Q_GETPRINTPROCESSORDIRECTORY *q_u, SPOOL_R_GETPRINTPROCESSORDIRECTORY *r_u)
-{
-	uint32 level = q_u->level;
-	NEW_BUFFER *buffer = NULL;
-	uint32 offered = q_u->offered;
-	uint32 *needed = &r_u->needed;
-	WERROR result;
-
-	/* that's an [in out] buffer */
-	spoolss_move_buffer(q_u->buffer, &r_u->buffer);
-	buffer = r_u->buffer;
-
- 	DEBUG(5,("_spoolss_getprintprocessordirectory\n"));
-	
-	*needed=0;
-
-	switch(level) {
-	case 1:
-		result = getprintprocessordirectory_level_1
-		  (&q_u->name, &q_u->environment, buffer, offered, needed);
-		break;
-	default:
-		result = WERR_UNKNOWN_LEVEL;
-	}
-
-	return result;
-}
-
diff -Naur samba-2.2.12-orig/source/smbd/close.c samba-2.2.12/source/smbd/close.c
--- samba-2.2.12-orig/source/smbd/close.c	2011-03-04 13:51:45.000000000 +0100
+++ samba-2.2.12/source/smbd/close.c	2011-03-04 13:15:06.000000000 +0100
@@ -135,7 +135,6 @@
 		err1 = -1;
 
 	if (fsp->print_file) {
-		print_fsp_end(fsp, normal_close);
 		file_free(fsp);
 		return 0;
 	}
diff -Naur samba-2.2.12-orig/source/smbd/fileio.c samba-2.2.12/source/smbd/fileio.c
--- samba-2.2.12-orig/source/smbd/fileio.c	2011-03-04 13:51:45.000000000 +0100
+++ samba-2.2.12/source/smbd/fileio.c	2011-03-04 12:52:57.000000000 +0100
@@ -163,7 +163,7 @@
 	int write_path = -1; 
 
 	if (fsp->print_file)
-		return print_job_write(fsp->print_jobid, data, n);
+		return (0);
 
 	if (!fsp->can_write) {
 		errno = EPERM;
diff -Naur samba-2.2.12-orig/source/smbd/lanman.c samba-2.2.12/source/smbd/lanman.c
--- samba-2.2.12-orig/source/smbd/lanman.c	2011-03-04 13:51:45.000000000 +0100
+++ samba-2.2.12/source/smbd/lanman.c	2011-03-04 12:58:15.000000000 +0100
@@ -357,715 +357,9 @@
 }
 
 
-/****************************************************************************
-  get a print queue
-  ****************************************************************************/
-static void PackDriverData(struct pack_desc* desc)
-{
-  char drivdata[4+4+32];
-  SIVAL(drivdata,0,sizeof drivdata); /* cb */
-  SIVAL(drivdata,4,1000);	/* lVersion */
-  memset(drivdata+8,0,32);	/* szDeviceName */
-  pstrcpy(drivdata+8,"NULL");
-  PACKl(desc,"l",drivdata,sizeof drivdata); /* pDriverData */
-}
-
-static int check_printq_info(struct pack_desc* desc,
- 			     int uLevel, char *id1, char *id2)
-{
-  desc->subformat = NULL;
-  switch( uLevel ) {
-  case 0:
-    desc->format = "B13";
-    break;
-  case 1:
-    desc->format = "B13BWWWzzzzzWW";
-    break;
-  case 2:
-    desc->format = "B13BWWWzzzzzWN";
-    desc->subformat = "WB21BB16B10zWWzDDz";
-    break;
-  case 3:
-    desc->format = "zWWWWzzzzWWzzl";
-    break;
-  case 4:
-    desc->format = "zWWWWzzzzWNzzl";
-    desc->subformat = "WWzWWDDzz";
-    break;
-  case 5:
-    desc->format = "z";
-    break;
-  case 51:
-    desc->format = "K";
-    break;
-  case 52:
-    desc->format = "WzzzzzzzzN";
-    desc->subformat = "z";
-    break;
-  default: return False;
-  }
-  if (strcmp(desc->format,id1) != 0) return False;
-  if (desc->subformat && strcmp(desc->subformat,id2) != 0) return False;
-  return True;
-}
-
-
-#define RAP_JOB_STATUS_QUEUED 0
-#define RAP_JOB_STATUS_PAUSED 1
-#define RAP_JOB_STATUS_SPOOLING 2
-#define RAP_JOB_STATUS_PRINTING 3
-#define RAP_JOB_STATUS_PRINTED 4
-
-#define RAP_QUEUE_STATUS_PAUSED 1
-#define RAP_QUEUE_STATUS_ERROR 2
-
-/* turn a print job status into a on the wire status 
-*/
-static int printj_status(int v)
-{
-	switch (v) {
-	case LPQ_QUEUED:
-		return RAP_JOB_STATUS_QUEUED;
-	case LPQ_PAUSED:
-		return RAP_JOB_STATUS_PAUSED;
-	case LPQ_SPOOLING:
-		return RAP_JOB_STATUS_SPOOLING;
-	case LPQ_PRINTING:
-		return RAP_JOB_STATUS_PRINTING;
-	}
-	return 0;
-}
-
-/* turn a print queue status into a on the wire status 
-*/
-static int printq_status(int v)
-{
-	switch (v) {
-	case LPQ_QUEUED:
-		return 0;
-	case LPQ_PAUSED:
-		return RAP_QUEUE_STATUS_PAUSED;
-	}
-	return RAP_QUEUE_STATUS_ERROR;
-}
-
-static void fill_printjob_info(connection_struct *conn, int snum, int uLevel,
-			       struct pack_desc* desc,
-			       print_queue_struct* queue, int n)
-{
-  time_t t = queue->time;
-
-  /* the client expects localtime */
-  t -= TimeDiff(t);
-
-  PACKI(desc,"W",queue->job); /* uJobId */
-  if (uLevel == 1) {
-    PACKS(desc,"B21",dos_to_unix_static(queue->fs_user)); /* szUserName */
-    PACKS(desc,"B","");		/* pad */
-    PACKS(desc,"B16","");	/* szNotifyName */
-    PACKS(desc,"B10","PM_Q_RAW"); /* szDataType */
-    PACKS(desc,"z","");		/* pszParms */
-    PACKI(desc,"W",n+1);		/* uPosition */
-    PACKI(desc,"W",printj_status(queue->status)); /* fsStatus */
-    PACKS(desc,"z","");		/* pszStatus */
-    PACKI(desc,"D",t); /* ulSubmitted */
-    PACKI(desc,"D",queue->size); /* ulSize */
-    PACKS(desc,"z",dos_to_unix_static(queue->fs_file)); /* pszComment */
-  }
-  if (uLevel == 2 || uLevel == 3 || uLevel == 4) {
-    PACKI(desc,"W",queue->priority);		/* uPriority */
-    PACKS(desc,"z",dos_to_unix_static(queue->fs_user)); /* pszUserName */
-    PACKI(desc,"W",n+1);		/* uPosition */
-    PACKI(desc,"W",printj_status(queue->status)); /* fsStatus */
-    PACKI(desc,"D",t); /* ulSubmitted */
-    PACKI(desc,"D",queue->size); /* ulSize */
-    PACKS(desc,"z","Samba");	/* pszComment */
-    PACKS(desc,"z",dos_to_unix_static(queue->fs_file)); /* pszDocument */
-    if (uLevel == 3) {
-      PACKS(desc,"z","");	/* pszNotifyName */
-      PACKS(desc,"z","PM_Q_RAW"); /* pszDataType */
-      PACKS(desc,"z","");	/* pszParms */
-      PACKS(desc,"z","");	/* pszStatus */
-      PACKS(desc,"z",SERVICE(snum)); /* pszQueue */
-      PACKS(desc,"z","lpd");	/* pszQProcName */
-      PACKS(desc,"z","");	/* pszQProcParms */
-      PACKS(desc,"z","NULL"); /* pszDriverName */
-      PackDriverData(desc);	/* pDriverData */
-      PACKS(desc,"z","");	/* pszPrinterName */
-    } else if (uLevel == 4) {   /* OS2 */
-      PACKS(desc,"z","");       /* pszSpoolFileName  */
-       PACKS(desc,"z","");       /* pszPortName       */
-       PACKS(desc,"z","");       /* pszStatus         */
-       PACKI(desc,"D",0);        /* ulPagesSpooled    */
-       PACKI(desc,"D",0);        /* ulPagesSent       */
-       PACKI(desc,"D",0);        /* ulPagesPrinted    */
-       PACKI(desc,"D",0);        /* ulTimePrinted     */
-       PACKI(desc,"D",0);        /* ulExtendJobStatus */
-       PACKI(desc,"D",0);        /* ulStartPage       */
-       PACKI(desc,"D",0);        /* ulEndPage         */
-    }
-  }
-}
-
-/********************************************************************
- Return a driver name given an snum.
- Looks in a tdb first. Returns True if from tdb, False otherwise.
- ********************************************************************/
-
-static BOOL get_driver_name(int snum, pstring drivername)
-{
-	NT_PRINTER_INFO_LEVEL *info = NULL;
-	BOOL in_tdb = False;
-
-	get_a_printer (&info, 2, lp_servicename(snum));
-	if (info != NULL) {
-		pstrcpy( drivername, info->info_2->drivername);
-		in_tdb = True;
-		free_a_printer(&info, 2);
-	} else {
-		pstrcpy( drivername, lp_printerdriver(snum));
-	}
-
-	return in_tdb;
-}
-
-/********************************************************************
- Respond to the DosPrintQInfo command with a level of 52
- This is used to get printer driver information for Win9x clients
- ********************************************************************/
-static void fill_printq_info_52(connection_struct *conn, int snum, int uLevel,
-				struct pack_desc* desc,
-				int count, print_queue_struct* queue,
-				print_status_struct* status)
-{
-	int i;
-	BOOL ok = False;
-	pstring tok,driver,datafile,langmon,helpfile,datatype;
-	const char *p;
-	char **lines = NULL;
-	pstring gen_line;
-	BOOL in_tdb = False;
-	fstring location;
-	pstring drivername;
-
-	/*
-	 * Check in the tdb *first* before checking the legacy
-	 * files. This allows an NT upload to take precedence over
-	 * the existing fileset. JRA.
-	 * 
-	 * we need to lookup the driver name prior to making the call
-	 * to get_a_printer_driver_9x_compatible() and not rely on the
-	 * 'print driver' parameter --jerry
-	 */
-
-
-	if ((get_driver_name(snum,drivername)) && 
-	    ((ok = get_a_printer_driver_9x_compatible(gen_line, drivername)) == True))
-	{
-		in_tdb = True;
-		p = gen_line;
-		DEBUG(10,("9x compatable driver line for [%s]: [%s]\n", drivername, gen_line));
-	} 
-	else 
-	{
-		/* didn't find driver in tdb */
-
-		DEBUG(10,("snum: %d\nprinterdriver: [%s]\nlp_driverfile: [%s]\n",
-			   snum, drivername, lp_driverfile(snum)));
-
-		lines = file_lines_load(lp_driverfile(snum),NULL, False);
-		if (!lines) 
-		{
-			DEBUG(3,("Can't open %s - %s\n", lp_driverfile(snum),
-				  strerror(errno)));
-			desc->errcode=NERR_notsupported;
-			goto done;
-		} 
-
-		/* lookup the long printer driver name in the file description */
-		for (i=0;lines[i] && !ok;i++) 
-		{
-			p = lines[i];
-			if (next_token(&p,tok,":",sizeof(tok)) &&
-		    	   (strlen(drivername) == strlen(tok)) &&
-		    	   (!strncmp(tok,drivername,strlen(drivername))))
-			{
-				ok = True;
-			}
-		}
-	}
-
-	if (ok)
-	{
-		/* driver file name */
-		if (!next_token(&p,driver,":",sizeof(driver)))
-			goto err;
-
-		/* data file name */
-		if (!next_token(&p,datafile,":",sizeof(datafile)))
-			goto err;
-
-		/*
-		 * for the next tokens - which may be empty - I have
-		 * to check for empty tokens first because the
-		 * next_token function will skip all empty token
-		 * fields */
-
-		/* help file */
-		if (*p == ':') 
-		{
-			*helpfile = '\0';
-			p++;
-		} 
-		else if (!next_token(&p,helpfile,":",sizeof(helpfile)))
-			goto err;
-	
-		/* language monitor */
-		if (*p == ':') 
-		{
-			*langmon = '\0';
-			p++;
-		} 
-		else if (!next_token(&p,langmon,":",sizeof(langmon)))
-			goto err;
-	
-		/* default data type */
-		if (!next_token(&p,datatype,":",sizeof(datatype))) 
-			goto err;
-	
-		PACKI(desc,"W",0x0400);               /* don't know */
-		PACKS(desc,"z",drivername);    /* long printer name */
-		PACKS(desc,"z",driver);                    /* Driverfile Name */
-		PACKS(desc,"z",datafile);                  /* Datafile name */
-		PACKS(desc,"z",langmon);			 /* language monitor */
-		if (in_tdb)
-		{
-			fstrcpy(location, "\\\\");
-			fstrcat(location, global_myname);
-			fstrcat(location, "\\print$\\WIN40\\0");
-			PACKS(desc,"z",location);   /* share to retrieve files */
-		}
-		else
-		{
-			PACKS(desc,"z",lp_driverlocation(snum));   /* share to retrieve files */
-		}
-		PACKS(desc,"z",datatype);			 /* default data type */
-		PACKS(desc,"z",helpfile);                  /* helpfile name */
-		PACKS(desc,"z",driver);                    /* driver name */
-
-		DEBUG(3,("printerdriver:%s:\n",drivername));
-		DEBUG(3,("Driver:%s:\n",driver));
-		DEBUG(3,("Data File:%s:\n",datafile));
-		DEBUG(3,("Language Monitor:%s:\n",langmon));
-		if (in_tdb)
-			DEBUG(3,("lp_driverlocation:%s:\n",location));
-		else
-			DEBUG(3,("lp_driverlocation:%s:\n",lp_driverlocation(snum)));
-		DEBUG(3,("Data Type:%s:\n",datatype));
-		DEBUG(3,("Help File:%s:\n",helpfile));
-		PACKI(desc,"N",count);                     /* number of files to copy */
-
-		for (i=0;i<count;i++) 
-		{
-			/* no need to check return value here
-			 * - it was already tested in
-			 * get_printerdrivernumber */
-			next_token(&p,tok,",",sizeof(tok));
-			PACKS(desc,"z",tok);         /* driver files to copy */
-			DEBUG(3,("file:%s:\n",tok));
-		}
-		
-		DEBUG(3,("fill_printq_info on <%s> gave %d entries\n",
-		  	  SERVICE(snum),count));
-
-	        desc->errcode=NERR_Success;
-		goto done;
-	}
-
-  err:
-
-	DEBUG(3,("fill_printq_info: Can't supply driver files\n"));
-	desc->errcode=NERR_notsupported;
-
- done:
-	file_lines_free(lines);	
-}
-
-
-static void fill_printq_info(connection_struct *conn, int snum, int uLevel,
- 			     struct pack_desc* desc,
- 			     int count, print_queue_struct* queue,
- 			     print_status_struct* status)
-{
-	switch (uLevel) {
-	case 1:
-	case 2:
-		PACKS(desc,"B13",SERVICE(snum));
-		break;
-	case 3:
-	case 4:
-	case 5:
-		PACKS(desc,"z",Expand(conn,snum,SERVICE(snum)));
-		break;
-	case 51:
-		PACKI(desc,"K",printq_status(status->status));
-		break;
-	}
-
-	if (uLevel == 1 || uLevel == 2) {
-		PACKS(desc,"B","");		/* alignment */
-		PACKI(desc,"W",5);		/* priority */
-		PACKI(desc,"W",0);		/* start time */
-		PACKI(desc,"W",0);		/* until time */
-		PACKS(desc,"z","");		/* pSepFile */
-		PACKS(desc,"z","lpd");	/* pPrProc */
-		PACKS(desc,"z",SERVICE(snum)); /* pDestinations */
-		PACKS(desc,"z","");		/* pParms */
-		if (snum < 0) {
-			PACKS(desc,"z","UNKNOWN PRINTER");
-			PACKI(desc,"W",LPSTAT_ERROR);
-		}
-		else if (!status || !status->message[0]) {
-			PACKS(desc,"z",Expand(conn,snum,lp_comment(snum)));
-			PACKI(desc,"W",LPSTAT_OK); /* status */
-		} else {
-			PACKS(desc,"z",status->message);
-			PACKI(desc,"W",printq_status(status->status)); /* status */
-		}
-		PACKI(desc,(uLevel == 1 ? "W" : "N"),count);
-	}
-
-	if (uLevel == 3 || uLevel == 4) {
-		pstring drivername;
-
-		PACKI(desc,"W",5);		/* uPriority */
-		PACKI(desc,"W",0);		/* uStarttime */
-		PACKI(desc,"W",0);		/* uUntiltime */
-		PACKI(desc,"W",5);		/* pad1 */
-		PACKS(desc,"z","");		/* pszSepFile */
-		PACKS(desc,"z","WinPrint");	/* pszPrProc */
-		PACKS(desc,"z",NULL);		/* pszParms */
-		PACKS(desc,"z",NULL);		/* pszComment - don't ask.... JRA */
-		/* "don't ask" that it's done this way to fix corrupted 
-		   Win9X/ME printer comments. */
-		if (!status) {
-			PACKI(desc,"W",LPSTAT_OK); /* fsStatus */
-		} else {
-			PACKI(desc,"W",printq_status(status->status)); /* fsStatus */
-		}
-		PACKI(desc,(uLevel == 3 ? "W" : "N"),count);	/* cJobs */
-		PACKS(desc,"z",SERVICE(snum)); /* pszPrinters */
-		get_driver_name(snum,drivername);
-		PACKS(desc,"z",drivername);		/* pszDriverName */
-		PackDriverData(desc);	/* pDriverData */
-	}
-
-	if (uLevel == 2 || uLevel == 4) {
-		int i;
-		for (i=0;i<count;i++)
-			fill_printjob_info(conn,snum,uLevel == 2 ? 1 : 2,desc,&queue[i],i);
-	}
-
-	if (uLevel==52) {
-		fill_printq_info_52(conn, snum, uLevel, desc, count, queue, status);
-	}
-}
-
-/* This function returns the number of files for a given driver */
-static int get_printerdrivernumber(int snum)
-{
-	int i, result = 0;
-	BOOL ok = False;
-	pstring tok;
-	const char *p;
-	char **lines = NULL;
-	pstring gen_line;
-	pstring drivername;
-
-	/*
-	 * Check in the tdb *first* before checking the legacy
-	 * files. This allows an NT upload to take precedence over
-	 * the existing fileset. JRA.
-	 *
-	 * we need to lookup the driver name prior to making the call
-	 * to get_a_printer_driver_9x_compatible() and not rely on the
-	 * 'print driver' parameter --jerry
-	 */
-	
-	if ((get_driver_name(snum,drivername)) && 
-	    (ok = get_a_printer_driver_9x_compatible(gen_line, drivername) == True)) 
-	{
-		p = gen_line;
-		DEBUG(10,("9x compatable driver line for [%s]: [%s]\n", drivername, gen_line));
-	} 
-	else 
-	{
-		/* didn't find driver in tdb */
-	
-		DEBUG(10,("snum: %d\nprinterdriver: [%s]\nlp_driverfile: [%s]\n",
-			  snum, drivername, lp_driverfile(snum)));
-		
-		lines = file_lines_load(lp_driverfile(snum), NULL, False);
-		if (!lines) 
-		{
-			DEBUG(3,("Can't open %s - %s\n", lp_driverfile(snum),strerror(errno)));
-			goto done;
-		} 
-
-		/* lookup the long printer driver name in the file description */
-		for (i=0;lines[i] && !ok;i++) 
-		{
-			p = lines[i];
-			if (next_token(&p,tok,":",sizeof(tok)) &&
-			   (strlen(drivername) == strlen(tok)) &&
-			   (!strncmp(tok,drivername,strlen(drivername)))) 
-			{
-				ok = True;
-			}
-		}
-	}
-	
-	if( ok ) 
-	{
-		/* skip 5 fields */
-		i = 5;
-		while (*p && i) {
-			if (*p++ == ':') i--;
-		}
-		if (!*p || i) {
-			DEBUG(3,("Can't determine number of printer driver files\n"));
-			goto done;
-		}
-		
-		/* count the number of files */
-		while (next_token(&p,tok,",",sizeof(tok)))
-			i++;
-	
-		result = i;
-	}
-
- done:
-
-	file_lines_free(lines);
-
-	return result;
-}
-
-static BOOL api_DosPrintQGetInfo(connection_struct *conn,
-				 uint16 vuid, char *param,char *data,
-				 int mdrcnt,int mprcnt,
-				 char **rdata,char **rparam,
-				 int *rdata_len,int *rparam_len)
-{
-	char *str1 = param+2;
-	char *str2 = skip_string(str1,1);
-	char *p = skip_string(str2,1);
-	char *QueueName = p;
-	int uLevel;
-	int count=0;
-	int snum;
-	char* str3;
-	struct pack_desc desc;
-	print_queue_struct *queue=NULL;
-	print_status_struct status;
-	char* tmpdata=NULL;
-
-	memset((char *)&status,'\0',sizeof(status));
-	memset((char *)&desc,'\0',sizeof(desc));
- 
-	p = skip_string(p,1);
-	uLevel = SVAL(p,0);
-	str3 = p + 4;
- 
-	/* remove any trailing username */
-	if ((p = strchr(QueueName,'%')))
-		*p = 0;
- 
-	DEBUG(3,("api_DosPrintQGetInfo: uLevel=%d name=%s\n",uLevel,QueueName));
- 
-	/* check it's a supported varient */
-	if (!prefix_ok(str1,"zWrLh"))
-		return False;
-	if (!check_printq_info(&desc,uLevel,str2,str3)) {
-		/*
-		 * Patch from Scott Moomaw <scott@bridgewater.edu>
-		 * to return the 'invalid info level' error if an
-		 * unknown level was requested.
-		 */
-		*rdata_len = 0;
-		*rparam_len = 6;
-		*rparam = REALLOC(*rparam,*rparam_len);
-		SSVALS(*rparam,0,ERRunknownlevel);
-		SSVAL(*rparam,2,0);
-		SSVAL(*rparam,4,0);
-		return(True);
-	}
- 
-	snum = lp_servicenumber(QueueName);
-	if (snum < 0 && pcap_printername_ok(QueueName,NULL)) {
-		int pnum = lp_servicenumber(PRINTERS_NAME);
-		if (pnum >= 0) {
-			lp_add_printer(QueueName,pnum);
-			snum = lp_servicenumber(QueueName);
-		}
-	}
-  
-	if (snum < 0 || !VALID_SNUM(snum))
-		return(False);
-
-	if (uLevel==52) {
-		count = get_printerdrivernumber(snum);
-		DEBUG(3,("api_DosPrintQGetInfo: Driver files count: %d\n",count));
-	} else {
-		count = print_queue_status(snum, &queue,&status);
-	}
-
-	if (mdrcnt > 0) {
-		*rdata = REALLOC(*rdata,mdrcnt);
-		desc.base = *rdata;
-		desc.buflen = mdrcnt;
-	} else {
-		/*
-		 * Don't return data but need to get correct length
-		 * init_package will return wrong size if buflen=0
-		 */
-		desc.buflen = getlen(desc.format);
-		desc.base = tmpdata = (char *) malloc (desc.buflen);
-	}
-
-	if (init_package(&desc,1,count)) {
-		desc.subcount = count;
-		fill_printq_info(conn,snum,uLevel,&desc,count,queue,&status);
-	} 
-  
-	/*
-	 * We must set the return code to ERRbuftoosmall
-	 * in order to support lanman style printing with Win NT/2k
-	 * clients       --jerry
-	 */
-	if (!mdrcnt && lp_disable_spoolss())
-		desc.errcode = ERRbuftoosmall;
-	
-	*rdata_len = desc.usedlen;
-  
-	*rparam_len = 6;
-	*rparam = REALLOC(*rparam,*rparam_len);
-	SSVALS(*rparam,0,desc.errcode);
-	SSVAL(*rparam,2,0);
-	SSVAL(*rparam,4,desc.neededlen);
-
-	DEBUG(4,("printqgetinfo: errorcode %d\n",desc.errcode));
-
-	SAFE_FREE(queue);
-	SAFE_FREE(tmpdata);
-
-	return(True);
-}
-
-/****************************************************************************
- View list of all print jobs on all queues.
-****************************************************************************/
-
-static BOOL api_DosPrintQEnum(connection_struct *conn, uint16 vuid, char* param, char* data,
- 			      int mdrcnt, int mprcnt,
- 			      char **rdata, char** rparam,
- 			      int *rdata_len, int *rparam_len)
-{
-  char *param_format = param+2;
-  char *output_format1 = skip_string(param_format,1);
-  char *p = skip_string(output_format1,1);
-  int uLevel = SVAL(p,0);
-  char *output_format2 = p + 4;
-  int services = lp_numservices();
-  int i, n;
-  struct pack_desc desc;
-  print_queue_struct **queue = NULL;
-  print_status_struct *status = NULL;
-  int* subcntarr = NULL;
-  int queuecnt, subcnt=0, succnt=0;
- 
-  memset((char *)&desc,'\0',sizeof(desc));
-
-  DEBUG(3,("DosPrintQEnum uLevel=%d\n",uLevel));
- 
-  if (!prefix_ok(param_format,"WrLeh")) return False;
-  if (!check_printq_info(&desc,uLevel,output_format1,output_format2)) {
-    /*
-     * Patch from Scott Moomaw <scott@bridgewater.edu>
-     * to return the 'invalid info level' error if an
-     * unknown level was requested.
-     */
-    *rdata_len = 0;
-    *rparam_len = 6;
-    *rparam = REALLOC(*rparam,*rparam_len);
-    SSVALS(*rparam,0,ERRunknownlevel);
-    SSVAL(*rparam,2,0);
-    SSVAL(*rparam,4,0);
-    return(True);
-  }
-
-  queuecnt = 0;
-  for (i = 0; i < services; i++)
-    if (lp_snum_ok(i) && lp_print_ok(i) && lp_browseable(i))
-      queuecnt++;
-  if (uLevel > 0) {
-    if((queue = (print_queue_struct**)malloc(queuecnt*sizeof(print_queue_struct*))) == NULL) {
-      ZERODEBUG(0,("api_DosPrintQEnum: malloc fail !\n"));
-      return False;
-    }
-    memset(queue,0,queuecnt*sizeof(print_queue_struct*));
-    if((status = (print_status_struct*)malloc(queuecnt*sizeof(print_status_struct))) == NULL) {
-      ZERODEBUG(0,("api_DosPrintQEnum: malloc fail !\n"));
-      return False;
-    }
-    memset(status,0,queuecnt*sizeof(print_status_struct));
-    if((subcntarr = (int*)malloc(queuecnt*sizeof(int))) == NULL) {
-      ZERODEBUG(0,("api_DosPrintQEnum: malloc fail !\n"));
-      return False;
-    }
-    subcnt = 0;
-    n = 0;
-    for (i = 0; i < services; i++)
-      if (lp_snum_ok(i) && lp_print_ok(i) && lp_browseable(i)) {
- 	subcntarr[n] = print_queue_status(i, &queue[n],&status[n]);
- 	subcnt += subcntarr[n];
- 	n++;
-      }
-  }
-  if (mdrcnt > 0) *rdata = REALLOC(*rdata,mdrcnt);
-  desc.base = *rdata;
-  desc.buflen = mdrcnt;
 
-  if (init_package(&desc,queuecnt,subcnt)) {
-    n = 0;
-    succnt = 0;
-    for (i = 0; i < services; i++)
-      if (lp_snum_ok(i) && lp_print_ok(i) && lp_browseable(i)) {
-	fill_printq_info(conn,i,uLevel,&desc,subcntarr[n],queue[n],&status[n]);
-	n++;
-	if (desc.errcode == NERR_Success) succnt = n;
-      }
-  }
 
-  SAFE_FREE(subcntarr);
- 
-  *rdata_len = desc.usedlen;
-  *rparam_len = 8;
-  *rparam = REALLOC(*rparam,*rparam_len);
-  SSVALS(*rparam,0,desc.errcode);
-  SSVAL(*rparam,2,0);
-  SSVAL(*rparam,4,succnt);
-  SSVAL(*rparam,6,queuecnt);
-  
-  for (i = 0; i < queuecnt; i++) {
-    if (queue) SAFE_FREE(queue[i]);
-  }
 
-  SAFE_FREE(queue);
-  SAFE_FREE(status);
-  
-  return True;
-}
 
 /****************************************************************************
   get info level for a server list query
@@ -1898,200 +1192,7 @@
   return(True);
 }
 
-/****************************************************************************
-  delete a print job
-  Form: <W> <> 
-  ****************************************************************************/
-static BOOL api_RDosPrintJobDel(connection_struct *conn,uint16 vuid, char *param,char *data,
-				int mdrcnt,int mprcnt,
-				char **rdata,char **rparam,
-				int *rdata_len,int *rparam_len)
-{
-	int function = SVAL(param,0);
-	char *str1 = param+2;
-	char *str2 = skip_string(str1,1);
-	char *p = skip_string(str2,1);
-	int jobid, errcode;
-	extern struct current_user current_user;
-	WERROR werr = WERR_OK;
-
-	jobid = SVAL(p,0);
-
-	/* check it's a supported varient */
-	if (!(strcsequal(str1,"W") && strcsequal(str2,"")))
-		return(False);
-
-	*rparam_len = 4;
-	*rparam = REALLOC(*rparam,*rparam_len);	
-	*rdata_len = 0;
-
-	if (!print_job_exists(jobid)) {
-		errcode = NERR_JobNotFound;
-		goto out;
-	}
 
-	errcode = NERR_notsupported;
-	
-	switch (function) {
-	case 81:		/* delete */ 
-		if (print_job_delete(&current_user, jobid, &werr)) 
-			errcode = NERR_Success;
-		break;
-	case 82:		/* pause */
-		if (print_job_pause(&current_user, jobid, &werr)) 
-			errcode = NERR_Success;
-		break;
-	case 83:		/* resume */
-		if (print_job_resume(&current_user, jobid, &werr)) 
-			errcode = NERR_Success;
-		break;
-	}
-	
-	if (!W_ERROR_IS_OK(werr))
-		errcode = W_ERROR_V(werr);
-	
- out:
-	SSVAL(*rparam,0,errcode);	
-	SSVAL(*rparam,2,0);		/* converter word */
-
-	return(True);
-}
-
-/****************************************************************************
-  Purge a print queue - or pause or resume it.
-  ****************************************************************************/
-static BOOL api_WPrintQueueCtrl(connection_struct *conn,uint16 vuid, char *param,char *data,
-				 int mdrcnt,int mprcnt,
-				 char **rdata,char **rparam,
-				 int *rdata_len,int *rparam_len)
-{
-	int function = SVAL(param,0);
-	char *str1 = param+2;
-	char *str2 = skip_string(str1,1);
-	char *QueueName = skip_string(str2,1);
-	int errcode = NERR_notsupported;
-	int snum;
-	WERROR werr = WERR_OK;
-	extern struct current_user current_user;
-
-	/* check it's a supported varient */
-	if (!(strcsequal(str1,"z") && strcsequal(str2,"")))
-		return(False);
-
-	*rparam_len = 4;
-	*rparam = REALLOC(*rparam,*rparam_len);
-	*rdata_len = 0;
-
-	snum = print_queue_snum(QueueName);
-
-	if (snum == -1) {
-		errcode = NERR_JobNotFound;
-		goto out;
-	}
-
-	switch (function) {
-	case 74: /* Pause queue */
-		if (print_queue_pause(&current_user, snum, &werr)) errcode = NERR_Success;
-		break;
-	case 75: /* Resume queue */
-		if (print_queue_resume(&current_user, snum, &werr)) errcode = NERR_Success;
-		break;
-	case 103: /* Purge */
-		if (print_queue_purge(&current_user, snum, &werr)) errcode = NERR_Success;
-		break;
-	}
-
-	if (!W_ERROR_IS_OK(werr)) errcode = W_ERROR_V(werr);
- out:
-	SSVAL(*rparam,0,errcode);
-	SSVAL(*rparam,2,0);		/* converter word */
-
-	return(True);
-}
-
-
-/****************************************************************************
-  set the property of a print job (undocumented?)
-  ? function = 0xb -> set name of print job
-  ? function = 0x6 -> move print job up/down
-  Form: <WWsTP> <WWzWWDDzzzzzzzzzzlz> 
-  or   <WWsTP> <WB21BB16B10zWWzDDz> 
-****************************************************************************/
-static int check_printjob_info(struct pack_desc* desc,
-			       int uLevel, char* id)
-{
-	desc->subformat = NULL;
-	switch( uLevel ) {
-	case 0: desc->format = "W"; break;
-	case 1: desc->format = "WB21BB16B10zWWzDDz"; break;
-	case 2: desc->format = "WWzWWDDzz"; break;
-	case 3: desc->format = "WWzWWDDzzzzzzzzzzlz"; break;
-	case 4: desc->format = "WWzWWDDzzzzzDDDDDDD"; break;
-	default: return False;
-	}
-	if (strcmp(desc->format,id) != 0) return False;
-	return True;
-}
-
-static BOOL api_PrintJobInfo(connection_struct *conn,uint16 vuid,char *param,char *data,
-  			     int mdrcnt,int mprcnt,
-  			     char **rdata,char **rparam,
-  			     int *rdata_len,int *rparam_len)
-{
-	struct pack_desc desc;
-	char *str1 = param+2;
-	char *str2 = skip_string(str1,1);
-	char *p = skip_string(str2,1);
-	int jobid;
-	int uLevel = SVAL(p,2);
-	int function = SVAL(p,4);
-	int place, errcode;
-
-	jobid = SVAL(p,0);
-	*rparam_len = 4;
-	*rparam = REALLOC(*rparam,*rparam_len);
-  
-	*rdata_len = 0;
-	
-	/* check it's a supported varient */
-	if ((strcmp(str1,"WWsTP")) || 
-	    (!check_printjob_info(&desc,uLevel,str2)))
-		return(False);
-
-	if (!print_job_exists(jobid)) {
-		errcode=NERR_JobNotFound;
-		goto out;
-	}
-
-	errcode = NERR_notsupported;
-
-	switch (function) {
-	case 0x6:
-		/* change job place in the queue, 
-		   data gives the new place */
-		place = SVAL(data,0);
-		if (print_job_set_place(jobid, place)) {
-			errcode=NERR_Success;
-		}
-		break;
-
-	case 0xb:   
-		/* change print job name, data gives the name */
-		if (print_job_set_name(jobid, data)) {
-			errcode=NERR_Success;
-		}
-		break;
-
-	default:
-		return False;
-	}
-
- out:
-	SSVALS(*rparam,0,errcode);
-	SSVAL(*rparam,2,0);		/* converter word */
-	
-	return(True);
-}
 
 
 /****************************************************************************
@@ -2764,462 +1865,6 @@
   return(True);
 }
 
-/****************************************************************************
-  api_WPrintJobEnumerate
-  ****************************************************************************/
-static BOOL api_WPrintJobGetInfo(connection_struct *conn,uint16 vuid, char *param,char *data,
-				 int mdrcnt,int mprcnt,
-				 char **rdata,char **rparam,
-				 int *rdata_len,int *rparam_len)
-{
-  char *str1 = param+2;
-  char *str2 = skip_string(str1,1);
-  char *p = skip_string(str2,1);
-  int uLevel;
-  int count;
-  int i;
-  int snum;
-  int job;
-  struct pack_desc desc;
-  print_queue_struct *queue=NULL;
-  print_status_struct status;
-  char *tmpdata=NULL;
-
-  uLevel = SVAL(p,2);
-
-  memset((char *)&desc,'\0',sizeof(desc));
-  memset((char *)&status,'\0',sizeof(status));
-
-  DEBUG(3,("WPrintJobGetInfo uLevel=%d uJobId=0x%X\n",uLevel,SVAL(p,0)));
-
-  /* check it's a supported varient */
-  if (strcmp(str1,"WWrLh") != 0) return False;
-  if (!check_printjob_info(&desc,uLevel,str2)) return False;
-
-  job = SVAL(p,0);
-  snum = print_job_snum(job);
-
-  if (snum < 0 || !VALID_SNUM(snum)) return(False);
-
-  count = print_queue_status(snum,&queue,&status);
-  for (i = 0; i < count; i++) {
-    if (queue[i].job == job) break;
-  }
-
-  if (mdrcnt > 0) {
-    *rdata = REALLOC(*rdata,mdrcnt);
-    desc.base = *rdata;
-    desc.buflen = mdrcnt;
-  } else {
-    /*
-     * Don't return data but need to get correct length
-     *  init_package will return wrong size if buflen=0
-     */
-    desc.buflen = getlen(desc.format);
-    desc.base = tmpdata = (char *)malloc ( desc.buflen );
-  }
-
-  if (init_package(&desc,1,0)) {
-    if (i < count) {
-      fill_printjob_info(conn,snum,uLevel,&desc,&queue[i],i);
-      *rdata_len = desc.usedlen;
-    }
-    else {
-      desc.errcode = NERR_JobNotFound;
-      *rdata_len = 0;
-    }
-  }
-
-  *rparam_len = 6;
-  *rparam = REALLOC(*rparam,*rparam_len);
-  SSVALS(*rparam,0,desc.errcode);
-  SSVAL(*rparam,2,0);
-  SSVAL(*rparam,4,desc.neededlen);
-
-  SAFE_FREE(queue);
-  SAFE_FREE(tmpdata);
-
-  DEBUG(4,("WPrintJobGetInfo: errorcode %d\n",desc.errcode));
-  return(True);
-}
-
-static BOOL api_WPrintJobEnumerate(connection_struct *conn,uint16 vuid, char *param,char *data,
-				   int mdrcnt,int mprcnt,
-				   char **rdata,char **rparam,
-				   int *rdata_len,int *rparam_len)
-{
-  char *str1 = param+2;
-  char *str2 = skip_string(str1,1);
-  char *p = skip_string(str2,1);
-  char* name = p;
-  int uLevel;
-  int count;
-  int i, succnt=0;
-  int snum;
-  struct pack_desc desc;
-  print_queue_struct *queue=NULL;
-  print_status_struct status;
-
-  memset((char *)&desc,'\0',sizeof(desc));
-  memset((char *)&status,'\0',sizeof(status));
-
-  p = skip_string(p,1);
-  uLevel = SVAL(p,0);
-
-  DEBUG(3,("WPrintJobEnumerate uLevel=%d name=%s\n",uLevel,name));
-
-  /* check it's a supported varient */
-  if (strcmp(str1,"zWrLeh") != 0) return False;
-  if (uLevel > 2) return False;	/* defined only for uLevel 0,1,2 */
-  if (!check_printjob_info(&desc,uLevel,str2)) return False;
-
-  snum = lp_servicenumber(name);
-  if (snum < 0 && pcap_printername_ok(name,NULL)) {
-    int pnum = lp_servicenumber(PRINTERS_NAME);
-    if (pnum >= 0) {
-      lp_add_printer(name,pnum);
-      snum = lp_servicenumber(name);
-    }
-  }
-
-  if (snum < 0 || !VALID_SNUM(snum)) return(False);
-
-  count = print_queue_status(snum,&queue,&status);
-  if (mdrcnt > 0) *rdata = REALLOC(*rdata,mdrcnt);
-  desc.base = *rdata;
-  desc.buflen = mdrcnt;
-
-  if (init_package(&desc,count,0)) {
-    succnt = 0;
-    for (i = 0; i < count; i++) {
-      fill_printjob_info(conn,snum,uLevel,&desc,&queue[i],i);
-      if (desc.errcode == NERR_Success) succnt = i+1;
-    }
-  }
-
-  *rdata_len = desc.usedlen;
-
-  *rparam_len = 8;
-  *rparam = REALLOC(*rparam,*rparam_len);
-  SSVALS(*rparam,0,desc.errcode);
-  SSVAL(*rparam,2,0);
-  SSVAL(*rparam,4,succnt);
-  SSVAL(*rparam,6,count);
-
-  SAFE_FREE(queue);
-
-  DEBUG(4,("WPrintJobEnumerate: errorcode %d\n",desc.errcode));
-  return(True);
-}
-
-static int check_printdest_info(struct pack_desc* desc,
-				int uLevel, char* id)
-{
-  desc->subformat = NULL;
-  switch( uLevel ) {
-  case 0: desc->format = "B9"; break;
-  case 1: desc->format = "B9B21WWzW"; break;
-  case 2: desc->format = "z"; break;
-  case 3: desc->format = "zzzWWzzzWW"; break;
-  default: return False;
-  }
-  if (strcmp(desc->format,id) != 0) return False;
-  return True;
-}
-
-static void fill_printdest_info(connection_struct *conn, int snum, int uLevel,
-				struct pack_desc* desc)
-{
-  char buf[100];
-  strncpy(buf,SERVICE(snum),sizeof(buf)-1);
-  buf[sizeof(buf)-1] = 0;
-  strupper(buf);
-  if (uLevel <= 1) {
-    PACKS(desc,"B9",buf);	/* szName */
-    if (uLevel == 1) {
-      PACKS(desc,"B21","");	/* szUserName */
-      PACKI(desc,"W",0);		/* uJobId */
-      PACKI(desc,"W",0);		/* fsStatus */
-      PACKS(desc,"z","");	/* pszStatus */
-      PACKI(desc,"W",0);		/* time */
-    }
-  }
-  if (uLevel == 2 || uLevel == 3) {
-    PACKS(desc,"z",buf);		/* pszPrinterName */
-    if (uLevel == 3) {
-      PACKS(desc,"z","");	/* pszUserName */
-      PACKS(desc,"z","");	/* pszLogAddr */
-      PACKI(desc,"W",0);		/* uJobId */
-      PACKI(desc,"W",0);		/* fsStatus */
-      PACKS(desc,"z","");	/* pszStatus */
-      PACKS(desc,"z","");	/* pszComment */
-      PACKS(desc,"z","NULL"); /* pszDrivers */
-      PACKI(desc,"W",0);		/* time */
-      PACKI(desc,"W",0);		/* pad1 */
-    }
-  }
-}
-
-static BOOL api_WPrintDestGetInfo(connection_struct *conn,uint16 vuid, char *param,char *data,
-				  int mdrcnt,int mprcnt,
-				  char **rdata,char **rparam,
-				  int *rdata_len,int *rparam_len)
-{
-  char *str1 = param+2;
-  char *str2 = skip_string(str1,1);
-  char *p = skip_string(str2,1);
-  char* PrinterName = p;
-  int uLevel;
-  struct pack_desc desc;
-  int snum;
-  char *tmpdata=NULL;
-
-  memset((char *)&desc,'\0',sizeof(desc));
-
-  p = skip_string(p,1);
-  uLevel = SVAL(p,0);
-
-  DEBUG(3,("WPrintDestGetInfo uLevel=%d PrinterName=%s\n",uLevel,PrinterName));
-
-  /* check it's a supported varient */
-  if (strcmp(str1,"zWrLh") != 0) return False;
-  if (!check_printdest_info(&desc,uLevel,str2)) return False;
-
-  snum = lp_servicenumber(PrinterName);
-  if (snum < 0 && pcap_printername_ok(PrinterName,NULL)) {
-    int pnum = lp_servicenumber(PRINTERS_NAME);
-    if (pnum >= 0) {
-      lp_add_printer(PrinterName,pnum);
-      snum = lp_servicenumber(PrinterName);
-    }
-  }
-
-  if (snum < 0) {
-    *rdata_len = 0;
-    desc.errcode = NERR_DestNotFound;
-    desc.neededlen = 0;
-  }
-  else {
-    if (mdrcnt > 0) {
-      *rdata = REALLOC(*rdata,mdrcnt);
-      desc.base = *rdata;
-      desc.buflen = mdrcnt;
-    } else {
-      /*
-       * Don't return data but need to get correct length
-       *  init_package will return wrong size if buflen=0
-       */
-      desc.buflen = getlen(desc.format);
-      desc.base = tmpdata = (char *)malloc ( desc.buflen );
-    }
-    if (init_package(&desc,1,0)) {
-      fill_printdest_info(conn,snum,uLevel,&desc);
-    }
-    *rdata_len = desc.usedlen;
-  }
-
-  *rparam_len = 6;
-  *rparam = REALLOC(*rparam,*rparam_len);
-  SSVALS(*rparam,0,desc.errcode);
-  SSVAL(*rparam,2,0);
-  SSVAL(*rparam,4,desc.neededlen);
-
-  DEBUG(4,("WPrintDestGetInfo: errorcode %d\n",desc.errcode));
-  SAFE_FREE(tmpdata);
-  return(True);
-}
-
-static BOOL api_WPrintDestEnum(connection_struct *conn,uint16 vuid, char *param,char *data,
-			       int mdrcnt,int mprcnt,
-			       char **rdata,char **rparam,
-			       int *rdata_len,int *rparam_len)
-{
-  char *str1 = param+2;
-  char *str2 = skip_string(str1,1);
-  char *p = skip_string(str2,1);
-  int uLevel;
-  int queuecnt;
-  int i, n, succnt=0;
-  struct pack_desc desc;
-  int services = lp_numservices();
-
-  memset((char *)&desc,'\0',sizeof(desc));
-
-  uLevel = SVAL(p,0);
-
-  DEBUG(3,("WPrintDestEnum uLevel=%d\n",uLevel));
-
-  /* check it's a supported varient */
-  if (strcmp(str1,"WrLeh") != 0) return False;
-  if (!check_printdest_info(&desc,uLevel,str2)) return False;
-
-  queuecnt = 0;
-  for (i = 0; i < services; i++)
-    if (lp_snum_ok(i) && lp_print_ok(i) && lp_browseable(i))
-      queuecnt++;
-
-  if (mdrcnt > 0) *rdata = REALLOC(*rdata,mdrcnt);
-  desc.base = *rdata;
-  desc.buflen = mdrcnt;
-  if (init_package(&desc,queuecnt,0)) {    
-    succnt = 0;
-    n = 0;
-    for (i = 0; i < services; i++) {
-      if (lp_snum_ok(i) && lp_print_ok(i) && lp_browseable(i)) {
-	fill_printdest_info(conn,i,uLevel,&desc);
-	n++;
-	if (desc.errcode == NERR_Success) succnt = n;
-      }
-    }
-  }
-
-  *rdata_len = desc.usedlen;
-
-  *rparam_len = 8;
-  *rparam = REALLOC(*rparam,*rparam_len);
-  SSVALS(*rparam,0,desc.errcode);
-  SSVAL(*rparam,2,0);
-  SSVAL(*rparam,4,succnt);
-  SSVAL(*rparam,6,queuecnt);
-
-  DEBUG(4,("WPrintDestEnumerate: errorcode %d\n",desc.errcode));
-  return(True);
-}
-
-static BOOL api_WPrintDriverEnum(connection_struct *conn,uint16 vuid, char *param,char *data,
-				 int mdrcnt,int mprcnt,
-				 char **rdata,char **rparam,
-				 int *rdata_len,int *rparam_len)
-{
-  char *str1 = param+2;
-  char *str2 = skip_string(str1,1);
-  char *p = skip_string(str2,1);
-  int uLevel;
-  int succnt;
-  struct pack_desc desc;
-
-  memset((char *)&desc,'\0',sizeof(desc));
-
-  uLevel = SVAL(p,0);
-
-  DEBUG(3,("WPrintDriverEnum uLevel=%d\n",uLevel));
-
-  /* check it's a supported varient */
-  if (strcmp(str1,"WrLeh") != 0) return False;
-  if (uLevel != 0 || strcmp(str2,"B41") != 0) return False;
-
-  if (mdrcnt > 0) *rdata = REALLOC(*rdata,mdrcnt);
-  desc.base = *rdata;
-  desc.buflen = mdrcnt;
-  if (init_package(&desc,1,0)) {
-    PACKS(&desc,"B41","NULL");
-  }
-
-  succnt = (desc.errcode == NERR_Success ? 1 : 0);
-
-  *rdata_len = desc.usedlen;
-
-  *rparam_len = 8;
-  *rparam = REALLOC(*rparam,*rparam_len);
-  SSVALS(*rparam,0,desc.errcode);
-  SSVAL(*rparam,2,0);
-  SSVAL(*rparam,4,succnt);
-  SSVAL(*rparam,6,1);
-
-  DEBUG(4,("WPrintDriverEnum: errorcode %d\n",desc.errcode));
-  return(True);
-}
-
-static BOOL api_WPrintQProcEnum(connection_struct *conn,uint16 vuid, char *param,char *data,
-				int mdrcnt,int mprcnt,
-				char **rdata,char **rparam,
-				int *rdata_len,int *rparam_len)
-{
-  char *str1 = param+2;
-  char *str2 = skip_string(str1,1);
-  char *p = skip_string(str2,1);
-  int uLevel;
-  int succnt;
-  struct pack_desc desc;
-
-  memset((char *)&desc,'\0',sizeof(desc));
-
-  uLevel = SVAL(p,0);
-
-  DEBUG(3,("WPrintQProcEnum uLevel=%d\n",uLevel));
-
-  /* check it's a supported varient */
-  if (strcmp(str1,"WrLeh") != 0) return False;
-  if (uLevel != 0 || strcmp(str2,"B13") != 0) return False;
-
-  if (mdrcnt > 0) *rdata = REALLOC(*rdata,mdrcnt);
-  desc.base = *rdata;
-  desc.buflen = mdrcnt;
-  desc.format = str2;
-  if (init_package(&desc,1,0)) {
-    PACKS(&desc,"B13","lpd");
-  }
-
-  succnt = (desc.errcode == NERR_Success ? 1 : 0);
-
-  *rdata_len = desc.usedlen;
-
-  *rparam_len = 8;
-  *rparam = REALLOC(*rparam,*rparam_len);
-  SSVALS(*rparam,0,desc.errcode);
-  SSVAL(*rparam,2,0);
-  SSVAL(*rparam,4,succnt);
-  SSVAL(*rparam,6,1);
-
-  DEBUG(4,("WPrintQProcEnum: errorcode %d\n",desc.errcode));
-  return(True);
-}
-
-static BOOL api_WPrintPortEnum(connection_struct *conn,uint16 vuid, char *param,char *data,
-			       int mdrcnt,int mprcnt,
-			       char **rdata,char **rparam,
-			       int *rdata_len,int *rparam_len)
-{
-  char *str1 = param+2;
-  char *str2 = skip_string(str1,1);
-  char *p = skip_string(str2,1);
-  int uLevel;
-  int succnt;
-  struct pack_desc desc;
-
-  memset((char *)&desc,'\0',sizeof(desc));
-
-  uLevel = SVAL(p,0);
-
-  DEBUG(3,("WPrintPortEnum uLevel=%d\n",uLevel));
-
-  /* check it's a supported varient */
-  if (strcmp(str1,"WrLeh") != 0) return False;
-  if (uLevel != 0 || strcmp(str2,"B9") != 0) return False;
-
-  if (mdrcnt > 0) *rdata = REALLOC(*rdata,mdrcnt);
-  memset((char *)&desc,'\0',sizeof(desc));
-  desc.base = *rdata;
-  desc.buflen = mdrcnt;
-  desc.format = str2;
-  if (init_package(&desc,1,0)) {
-    PACKS(&desc,"B13","lp0");
-  }
-
-  succnt = (desc.errcode == NERR_Success ? 1 : 0);
-
-  *rdata_len = desc.usedlen;
-
-  *rparam_len = 8;
-  *rparam = REALLOC(*rparam,*rparam_len);
-  SSVALS(*rparam,0,desc.errcode);
-  SSVAL(*rparam,2,0);
-  SSVAL(*rparam,4,succnt);
-  SSVAL(*rparam,6,1);
-
-  DEBUG(4,("WPrintPortEnum: errorcode %d\n",desc.errcode));
-  return(True);
-}
 
 /****************************************************************************
  The buffer was too small
@@ -3292,27 +1937,12 @@
   {"RNetUserGetInfo",	RAP_WUserGetInfo,	api_RNetUserGetInfo,0},
   {"NetUserGetGroups",	RAP_WUserGetGroups,	api_NetUserGetGroups,0},
   {"NetWkstaGetInfo",	RAP_WWkstaGetInfo,	api_NetWkstaGetInfo,0},
-  {"DosPrintQEnum",	RAP_WPrintQEnum,	api_DosPrintQEnum,0},
-  {"DosPrintQGetInfo",	RAP_WPrintQGetInfo,	api_DosPrintQGetInfo,0},
-  {"WPrintQueuePause",  RAP_WPrintQPause,	api_WPrintQueueCtrl,0},
-  {"WPrintQueueResume", RAP_WPrintQContinue,	api_WPrintQueueCtrl,0},
-  {"WPrintJobEnumerate",RAP_WPrintJobEnum,	api_WPrintJobEnumerate,0},
-  {"WPrintJobGetInfo",	RAP_WPrintJobGetInfo,	api_WPrintJobGetInfo,0},
-  {"RDosPrintJobDel",	RAP_WPrintJobDel,	api_RDosPrintJobDel,0},
-  {"RDosPrintJobPause",	RAP_WPrintJobPause,	api_RDosPrintJobDel,0},
-  {"RDosPrintJobResume",RAP_WPrintJobContinue,	api_RDosPrintJobDel,0},
-  {"WPrintDestEnum",	RAP_WPrintDestEnum,	api_WPrintDestEnum,0},
-  {"WPrintDestGetInfo",	RAP_WPrintDestGetInfo,	api_WPrintDestGetInfo,0},
   {"NetRemoteTOD",	RAP_NetRemoteTOD,	api_NetRemoteTOD,0},
-  {"WPrintQueuePurge",	RAP_WPrintQPurge,	api_WPrintQueueCtrl,0},
   {"NetServerEnum",	RAP_NetServerEnum2,	api_RNetServerEnum,0},
   {"WAccessGetUserPerms",RAP_WAccessGetUserPerms,api_WAccessGetUserPerms,0},
   {"SetUserPassword",	RAP_WUserPasswordSet2,	api_SetUserPassword,0},
   {"WWkstaUserLogon",	RAP_WWkstaUserLogon,	api_WWkstaUserLogon,0},
-  {"PrintJobInfo",	RAP_WPrintJobSetInfo,	api_PrintJobInfo,0},
-  {"WPrintDriverEnum",	RAP_WPrintDriverEnum,	api_WPrintDriverEnum,0},
-  {"WPrintQProcEnum",	RAP_WPrintQProcessorEnum,api_WPrintQProcEnum,0},
-  {"WPrintPortEnum",	RAP_WPrintPortEnum,	api_WPrintPortEnum,0},
+
   {"SamOEMChangePassword",RAP_SamOEMChgPasswordUser2_P,api_SamOEMChangePassword,0},
   {NULL,		-1,	api_Unsupported,0}};
 
diff -Naur samba-2.2.12-orig/source/smbd/open.c samba-2.2.12/source/smbd/open.c
--- samba-2.2.12-orig/source/smbd/open.c	2011-03-04 13:51:45.000000000 +0100
+++ samba-2.2.12/source/smbd/open.c	2011-03-04 12:41:32.000000000 +0100
@@ -790,13 +790,7 @@
 	mode_t new_mode = (mode_t)0;
 
 	if (conn->printer) {
-		/* printers are handled completely differently. Most
-			of the passed parameters are ignored */
-		if (Access)
-			*Access = DOS_OPEN_WRONLY;
-		if (action)
-			*action = FILE_WAS_CREATED;
-		return print_fsp_open(conn, fname);
+		return NULL;
 	}
 
 	fsp = file_new(conn);
diff -Naur samba-2.2.12-orig/source/smbd/reply.c samba-2.2.12/source/smbd/reply.c
--- samba-2.2.12-orig/source/smbd/reply.c	2011-03-04 13:51:45.000000000 +0100
+++ samba-2.2.12/source/smbd/reply.c	2011-03-04 13:14:28.000000000 +0100
@@ -3425,31 +3425,7 @@
 int reply_printopen(connection_struct *conn, 
 		    char *inbuf,char *outbuf, int dum_size, int dum_buffsize)
 {
-	int outsize = 0;
-	files_struct *fsp;
-	START_PROFILE(SMBsplopen);
-	
-	if (!CAN_PRINT(conn)) {
-		END_PROFILE(SMBsplopen);
 		return ERROR_DOS(ERRDOS,ERRnoaccess);
-	}
-
-	/* Open for exclusive use, write only. */
-	fsp = print_fsp_open(conn, NULL);
-
-	if (!fsp) {
-		END_PROFILE(SMBsplopen);
-		return(UNIXERROR(ERRDOS,ERRnoaccess));
-	}
-
-	outsize = set_message(outbuf,1,0,True);
-	SSVAL(outbuf,smb_vwv0,fsp->fnum);
-  
-	DEBUG(3,("openprint fd=%d fnum=%d\n",
-		 fsp->fd, fsp->fnum));
-
-	END_PROFILE(SMBsplopen);
-	return(outsize);
 }
 
 /****************************************************************************
@@ -3459,31 +3435,7 @@
 int reply_printclose(connection_struct *conn,
 		     char *inbuf,char *outbuf, int dum_size, int dum_buffsize)
 {
-	int outsize = set_message(outbuf,0,0,True);
-	files_struct *fsp = file_fsp(inbuf,smb_vwv0);
-	int close_err = 0;
-	START_PROFILE(SMBsplclose);
-
-	CHECK_FSP(fsp,conn);
-
-	if (!CAN_PRINT(conn)) {
-		END_PROFILE(SMBsplclose);
 		return ERROR_DOS(ERRDOS,ERRnoaccess);
-	}
-  
-	DEBUG(3,("printclose fd=%d fnum=%d\n",
-		 fsp->fd,fsp->fnum));
-  
-	close_err = close_file(fsp,True);
-
-	if(close_err != 0) {
-		errno = close_err;
-		END_PROFILE(SMBsplclose);
-		return(UNIXERROR(ERRHRD,ERRgeneral));
-	}
-
-	END_PROFILE(SMBsplclose);
-	return(outsize);
 }
 
 /****************************************************************************
@@ -3493,71 +3445,7 @@
 int reply_printqueue(connection_struct *conn,
 		     char *inbuf,char *outbuf, int dum_size, int dum_buffsize)
 {
-	int outsize = set_message(outbuf,2,3,True);
-	int max_count = SVAL(inbuf,smb_vwv0);
-	int start_index = SVAL(inbuf,smb_vwv1);
-	START_PROFILE(SMBsplretq);
-
-	/* we used to allow the client to get the cnum wrong, but that
-	   is really quite gross and only worked when there was only
-	   one printer - I think we should now only accept it if they
-	   get it right (tridge) */
-	if (!CAN_PRINT(conn)) {
-		END_PROFILE(SMBsplretq);
 		return ERROR_DOS(ERRDOS,ERRnoaccess);
-	}
-
-	SSVAL(outbuf,smb_vwv0,0);
-	SSVAL(outbuf,smb_vwv1,0);
-	SCVAL(smb_buf(outbuf),0,1);
-	SSVAL(smb_buf(outbuf),1,0);
-  
-	DEBUG(3,("printqueue start_index=%d max_count=%d\n",
-		 start_index, max_count));
-
-	{
-		print_queue_struct *queue = NULL;
-		print_status_struct status;
-		char *p = smb_buf(outbuf) + 3;
-		int count = print_queue_status(SNUM(conn), &queue, &status);
-		int num_to_get = ABS(max_count);
-		int first = (max_count>0?start_index:start_index+max_count+1);
-		int i;
-
-		if (first >= count)
-			num_to_get = 0;
-		else
-			num_to_get = MIN(num_to_get,count-first);
-    
-
-		for (i=first;i<first+num_to_get;i++) {
-			/* check to make sure we have room in the buffer */
-			if ( (PTR_DIFF(p, outbuf)+28) > BUFFER_SIZE )
-				break;
-			put_dos_date2(p,0,queue[i].time);
-			SCVAL(p,4,(queue[i].status==LPQ_PRINTING?2:3));
-			SSVAL(p,5, queue[i].job);
-			SIVAL(p,7,queue[i].size);
-			SCVAL(p,11,0);
-			StrnCpy(p+12,queue[i].fs_user,16);
-			p += 28;
-		}
-
-		if (count > 0) {
-			outsize = set_message(outbuf,2,28*count+3,False); 
-			SSVAL(outbuf,smb_vwv0,count);
-			SSVAL(outbuf,smb_vwv1,(max_count>0?first+count:first-1));
-			SCVAL(smb_buf(outbuf),0,1);
-			SSVAL(smb_buf(outbuf),1,28*count);
-		}
-
-		SAFE_FREE(queue);
-	  
-		DEBUG(3,("%d entries returned in queue\n",count));
-	}
-  
-	END_PROFILE(SMBsplretq);
-	return(outsize);
 }
 
 /****************************************************************************
@@ -3566,32 +3454,7 @@
 
 int reply_printwrite(connection_struct *conn, char *inbuf,char *outbuf, int dum_size, int dum_buffsize)
 {
-  int numtowrite;
-  int outsize = set_message(outbuf,0,0,True);
-  char *data;
-  files_struct *fsp = file_fsp(inbuf,smb_vwv0);
-  START_PROFILE(SMBsplwr);
-  
-  if (!CAN_PRINT(conn)) {
-    END_PROFILE(SMBsplwr);
     return ERROR_DOS(ERRDOS,ERRnoaccess);
-  }
-
-  CHECK_FSP(fsp,conn);
-  CHECK_WRITE(fsp);
-
-  numtowrite = SVAL(smb_buf(inbuf),1);
-  data = smb_buf(inbuf) + 3;
-  
-  if (write_file(fsp,data,-1,numtowrite) != numtowrite) {
-    END_PROFILE(SMBsplwr);
-    return(UNIXERROR(ERRHRD,ERRdiskfull));
-  }
-
-  DEBUG( 3, ( "printwrite fnum=%d num=%d\n", fsp->fnum, numtowrite ) );
-  
-  END_PROFILE(SMBsplwr);
-  return(outsize);
 }
 
 /****************************************************************************
diff -Naur samba-2.2.12-orig/source/smbd/server.c samba-2.2.12/source/smbd/server.c
--- samba-2.2.12-orig/source/smbd/server.c	2011-03-04 13:51:45.000000000 +0100
+++ samba-2.2.12/source/smbd/server.c	2011-03-04 13:12:23.000000000 +0100
@@ -399,8 +399,6 @@
 	
 	ret = lp_load(servicesf,False,False,True);
 
-	load_printers();
-
 	/* perhaps the config filename is now set */
 	if (!test)
 		reload_services(True);
@@ -887,9 +885,6 @@
 	if (!locking_init(0))
 		exit(1);
 
-	if (!print_backend_init())
-		exit(1);
-
 	if (!share_info_db_init())
 		exit(1);
 
diff -Naur samba-2.2.12-orig/source/smbd/service.c samba-2.2.12/source/smbd/service.c
--- samba-2.2.12-orig/source/smbd/service.c	2011-03-04 13:51:45.000000000 +0100
+++ samba-2.2.12/source/smbd/service.c	2011-03-04 12:41:32.000000000 +0100
@@ -143,32 +143,7 @@
       iService = add_home_service(service,phome_dir);
    }
 
-   /* If we still don't have a service, attempt to add it as a printer. */
-   if (iService < 0)
-   {
-      int iPrinterService;
-
-      if ((iPrinterService = lp_servicenumber(PRINTERS_NAME)) >= 0)
-      {
-         char *pszTemp;
-
-         DEBUG(3,("checking whether %s is a valid printer name...\n", service));
-         pszTemp = PRINTCAP;
-         if ((pszTemp != NULL) && pcap_printername_ok(service, pszTemp))
-         {
-            DEBUG(3,("%s is a valid printer name\n", service));
-            DEBUG(3,("adding %s as a printer service\n", service));
-            lp_add_printer(service,iPrinterService);
-            iService = lp_servicenumber(service);
-            if (iService < 0)
-               ZERODEBUG(0,("failed to add %s as a printer service!\n", service));
-         }
-         else
-            DEBUG(3,("%s is not a valid printer name\n", service));
-      }
-   }
-
    /* Check for default vfs service?  Unsure whether to implement this */
    if (iService < 0)
    {
    }
diff -Naur samba-2.2.12-orig/source/smbwrapper/smbw.c samba-2.2.12/source/smbwrapper/smbw.c
--- samba-2.2.12-orig/source/smbwrapper/smbw.c	2011-03-04 13:51:45.000000000 +0100
+++ samba-2.2.12/source/smbwrapper/smbw.c	2011-03-04 12:58:15.000000000 +0100
@@ -985,13 +985,7 @@
 	}
 
 	if (strncmp(srv->cli.dev, "LPT", 3) == 0) {
-		int job = smbw_stat_printjob(srv, path, NULL, NULL);
-		if (job == -1) {
-			goto failed;
-		}
-		if (cli_printjob_del(&srv->cli, job) != 0) {
-			goto failed;
-		}
+		goto failed;
 	} else if (!cli_unlink(&srv->cli, path)) {
 		errno = smbw_errno(&srv->cli);
 		goto failed;
diff -Naur samba-2.2.12-orig/source/smbwrapper/smbw_dir.c samba-2.2.12/source/smbwrapper/smbw_dir.c
--- samba-2.2.12-orig/source/smbwrapper/smbw_dir.c	2011-03-04 13:51:45.000000000 +0100
+++ samba-2.2.12/source/smbwrapper/smbw_dir.c	2011-03-04 12:56:56.000000000 +0100
@@ -130,27 +130,6 @@
 }
 
 
-/***************************************************** 
-add a entry to a directory listing
-*******************************************************/
-static void smbw_printjob_add(struct print_job_info *job)
-{
-	struct file_info finfo;
-
-	ZERO_STRUCT(finfo);
-
-	pstrcpy(finfo.name, job->name);
-	finfo.mode = aRONLY | aDIR;	
-	finfo.mtime = job->t;
-	finfo.atime = job->t;
-	finfo.ctime = job->t;
-	finfo.uid = nametouid(job->user);
-	finfo.mode = aRONLY;
-	finfo.size = job->size;
-
-	smbw_dir_add(&finfo, NULL, NULL);
-}
-
 
 /***************************************************** 
 open a directory on the server
@@ -221,12 +200,7 @@
 			goto failed;
 		}
 	} else if (strncmp(srv->cli.dev,"LPT",3) == 0) {
-		smbw_share_add(".",0,"",NULL);
-		smbw_share_add("..",0,"",NULL);
-		if (cli_print_queue(&srv->cli, smbw_printjob_add) < 0) {
-			errno = smbw_errno(&srv->cli);
-			goto failed;
-		}
+		goto failed;
 	} else {
 #if 0
 		if (strcmp(path,"\\") == 0) {
diff -Naur samba-2.2.12-orig/source/smbwrapper/smbw_stat.c samba-2.2.12/source/smbwrapper/smbw_stat.c
--- samba-2.2.12-orig/source/smbwrapper/smbw_stat.c	2004-08-12 20:24:19.000000000 +0200
+++ samba-2.2.12/source/smbwrapper/smbw_stat.c	2011-03-04 12:57:18.000000000 +0100
@@ -85,41 +85,9 @@
 }
 
 
-static struct print_job_info printjob;
-
-/***************************************************** 
-gather info from a printjob listing
-*******************************************************/
-static void smbw_printjob_stat(struct print_job_info *job)
-{
-	if (strcmp(job->name, printjob.name) == 0) {
-		printjob = *job;
-	}
-}
-
-/***************************************************** 
-stat a printjob
-*******************************************************/
-int smbw_stat_printjob(struct smbw_server *srv,char *path,
-		       size_t *size, time_t *m_time)
-{
-	if (path[0] == '\\') path++;
-
-	ZERO_STRUCT(printjob);
-
-	fstrcpy(printjob.name, path);
-	cli_print_queue(&srv->cli, smbw_printjob_stat);
-
-	if (size) {
-		*size = printjob.size;
-	}
-	if (m_time) {
-		*m_time = printjob.t;
-	}
-	return printjob.id;
-}
 
 
+/
 /***************************************************** 
 a wrapper for fstat()
 *******************************************************/
diff -Naur samba-2.2.12-orig/source/Makefile.in samba-2.2.12/source/Makefile.in
--- samba-2.2.12-orig/source/Makefile.in	2011-03-04 13:52:41.000000000 +0100
+++ samba-2.2.12/source/Makefile.in	2011-03-04 13:25:22.000000000 +0100
@@ -53,7 +53,6 @@
 LOGFILEBASE = @logfilebase@
 CONFIGFILE = $(CONFIGDIR)/smb.conf
 LMHOSTSFILE = $(CONFIGDIR)/lmhosts
-DRIVERFILE = $(CONFIGDIR)/printers.def
 PASSWD_PROGRAM = @passwd_program@
 # This is where smbpasswd et al go
 PRIVATEDIR = @privatedir@
@@ -61,9 +60,6 @@
 SMB_PASSWD_FILE = $(PRIVATEDIR)/smbpasswd
 TDB_PASSWD_FILE = $(PRIVATEDIR)/smbpasswd.tdb
 
-# This is where SWAT images and help files go
-SWATDIR = @swatdir@
-
 # the directory where lock files go
 LOCKDIR = @lockdir@
 
@@ -85,7 +81,7 @@
 PASSWD_FLAGS = -DPASSWD_PROGRAM=\"$(PASSWD_PROGRAM)\" -DSMB_PASSWD_FILE=\"$(SMB_PASSWD_FILE)\" -DTDB_PASSWD_FILE=\"$(TDB_PASSWD_FILE)\"
 FLAGS1 = $(CFLAGS) @FLAGS1@ -Iinclude -I$(srcdir)/include -I$(srcdir)/ubiqx -I$(srcdir)/smbwrapper $(CPPFLAGS) -DLOGFILEBASE=\"$(LOGFILEBASE)\"
 FLAGS2 = -DCONFIGFILE=\"$(CONFIGFILE)\" -DLMHOSTSFILE=\"$(LMHOSTSFILE)\"  
-FLAGS3 = -DSWATDIR=\"$(SWATDIR)\" -DSBINDIR=\"$(SBINDIR)\" -DLOCKDIR=\"$(LOCKDIR)\" -DCODEPAGEDIR=\"$(CODEPAGEDIR)\"
+FLAGS3 = -DSBINDIR=\"$(SBINDIR)\" -DLOCKDIR=\"$(LOCKDIR)\" -DCODEPAGEDIR=\"$(CODEPAGEDIR)\"
 FLAGS4 = -DDRIVERFILE=\"$(DRIVERFILE)\" -DBINDIR=\"$(BINDIR)\" -DPIDDIR=\"$(PIDDIR)\" -DLIBDIR=\"$(LIBDIR)\"
 FLAGS5 = $(FLAGS1) $(FLAGS2) $(FLAGS3) $(FLAGS4) -DHAVE_INCLUDES_H
 FLAGS  = $(ISA) $(FLAGS5) $(PASSWD_FLAGS)
@@ -96,8 +92,8 @@
 WINBIND_PAM_PROGS = @WINBIND_PAM_TARGETS@
 WINBIND_LPROGS = @WINBIND_LTARGETS@
 
-SPROGS = bin/smbd bin/nmbd bin/swat
-PROGS1 = bin/smbclient bin/smbspool bin/testparm bin/testprns bin/smbstatus bin/smbcontrol bin/tdbbackup bin/make_printerdef @RUNPROG@ 
+SPROGS = bin/smbd bin/nmbd
+PROGS1 = bin/smbclient bin/testparm bin/smbstatus bin/tdbbackup @RUNPROG@ 
 PROGS2 = bin/smbpasswd bin/make_smbcodepage bin/rpcclient bin/make_unicodemap bin/smbcacls @WRAPPROG@ @WRAP@ @WRAP32@ @PAM_MOD@ @PDBEDIT@ @LIBSMBCLIENT@
 MPROGS = @MPROGS@
 LPROGS = $(WINBIND_PAM_PROGS) $(WINBIND_LPROGS)
@@ -138,7 +134,7 @@
 
 LIBSMB_OBJ = libsmb/clientgen.o libsmb/cliconnect.o libsmb/clifile.o \
 		libsmb/clirap.o libsmb/clierror.o libsmb/climessage.o \
-		libsmb/clireadwrite.o libsmb/clilist.o libsmb/cliprint.o \
+		libsmb/clireadwrite.o libsmb/clilist.o \
 		libsmb/clitrans.o libsmb/clisecdesc.o libsmb/clidgram.o \
 		libsmb/namequery.o libsmb/nmblib.o libsmb/clistr.o \
 		libsmb/nterr.o libsmb/smbdes.o libsmb/smbencrypt.o \
@@ -147,7 +143,7 @@
 		libsmb/passchange.o libsmb/unexpected.o $(RPC_PARSE_OBJ1) \
 		libsmb/namecache.o
 
-LIBMSRPC_OBJ = libsmb/cli_lsarpc.o libsmb/cli_samr.o libsmb/cli_spoolss.o \
+LIBMSRPC_OBJ = libsmb/cli_lsarpc.o libsmb/cli_samr.o \
 				libsmb/cli_netlogon.o libsmb/cli_srvsvc.o libsmb/cli_dfs.o \
 				libsmb/cli_reg.o \
 				rpc_client/cli_pipe.o libsmb/cli_pipe_util.o
@@ -157,8 +153,7 @@
                  rpc_server/srv_pipe_hnd.o rpc_server/srv_reg.o rpc_server/srv_reg_nt.o \
                  rpc_server/srv_samr.o rpc_server/srv_samr_nt.o rpc_server/srv_srvsvc.o rpc_server/srv_srvsvc_nt.o \
                  rpc_server/srv_util.o rpc_server/srv_wkssvc.o rpc_server/srv_wkssvc_nt.o \
-                 rpc_server/srv_pipe.o rpc_server/srv_dfs.o rpc_server/srv_dfs_nt.o \
-		 rpc_server/srv_spoolss.o rpc_server/srv_spoolss_nt.o rpc_client/cli_spoolss_notify.o
+                 rpc_server/srv_pipe.o rpc_server/srv_dfs.o rpc_server/srv_dfs_nt.o
 
 # this includes only the low level parse code, not stuff
 # that requires knowledge of security contexts
@@ -169,7 +164,7 @@
                 rpc_parse/parse_reg.o rpc_parse/parse_rpc.o \
                 rpc_parse/parse_samr.o rpc_parse/parse_srv.o \
                 rpc_parse/parse_wks.o \
-		rpc_parse/parse_spoolss.o rpc_parse/parse_dfs.o
+		rpc_parse/parse_dfs.o
 
 RPC_CLIENT_OBJ = rpc_client/cli_netlogon.o rpc_client/cli_pipe.o \
 		rpc_client/cli_login.o \
@@ -200,21 +195,15 @@
 	    smbd/vfs.o smbd/vfs-wrap.o smbd/statcache.o \
             smbd/posix_acls.o lib/sysacls.o \
 	    smbd/process.o smbd/service.o smbd/error.o \
-	    printing/printfsp.o lib/util_seaccess.o \
+	    lib/util_seaccess.o \
 	    libsmb/cli_pipe_util.o
 
-PRINTING_OBJ = printing/pcap.o printing/print_svid.o \
-				 printing/print_cups.o printing/print_generic.o \
-				printing/lpq_parse.o printing/load.o
-
-PRINTBACKEND_OBJ = printing/printing.o printing/nt_printing.o
-
 MSDFS_OBJ = msdfs/msdfs.o 
 
 SMBD_OBJ = $(SMBD_OBJ1) $(MSDFS_OBJ) $(PARAM_OBJ) $(LIBSMB_OBJ) $(UBIQX_OBJ) \
            $(RPC_SERVER_OBJ) $(RPC_PARSE_OBJ) $(RPC_CLIENT_OBJ) \
-           $(LOCKING_OBJ) $(PASSDB_OBJ) $(PRINTING_OBJ) $(PROFILE_OBJ) $(LIB_OBJ) \
-	   $(PRINTBACKEND_OBJ) $(QUOTAOBJS) $(OPLOCK_OBJ) $(NOTIFY_OBJ)
+           $(LOCKING_OBJ) $(PASSDB_OBJ) $(PROFILE_OBJ) $(LIB_OBJ) \
+	   $(QUOTAOBJS) $(OPLOCK_OBJ) $(NOTIFY_OBJ)
 
 
 NMBD_OBJ1 = nmbd/asyncdns.o nmbd/nmbd.o nmbd/nmbd_become_dmb.o \
@@ -233,11 +222,6 @@
 NMBD_OBJ = $(NMBD_OBJ1) $(PARAM_OBJ) $(LIBSMB_OBJ) $(UBIQX_OBJ) \
            $(PROFILE_OBJ) $(LIB_OBJ)
 
-SWAT_OBJ = web/cgi.o web/diagnose.o web/startstop.o web/statuspage.o \
-           web/swat.o $(PRINTING_OBJ) $(LIBSMB_OBJ) $(LOCKING_OBJ) \
-           $(PARAM_OBJ) $(PASSDB_OBJ) $(RPC_PARSE_OBJ) \
-           $(UBIQX_OBJ) $(LIB_OBJ) 
-
 SMBSH_OBJ = smbwrapper/smbsh.o smbwrapper/shared.o \
             $(PARAM_OBJ) $(UBIQX_OBJ) $(LIB_OBJ)
 
@@ -247,21 +231,12 @@
 MAKE_UNICODEMAP_OBJ = utils/make_unicodemap.o $(PARAM_OBJ) \
                        $(UBIQX_OBJ) $(LIB_OBJ)
 
-MAKE_PRINTERDEF_OBJ = utils/make_printerdef.o $(PARAM_OBJ) \
-                      $(UBIQX_OBJ) $(LIB_OBJ)
-
 STATUS_OBJ = utils/status.o $(LOCKING_OBJ) $(PARAM_OBJ) \
              $(UBIQX_OBJ) $(PROFILE_OBJ) $(LIB_OBJ)
 
-SMBCONTROL_OBJ = utils/smbcontrol.o $(LOCKING_OBJ) $(PARAM_OBJ) \
-             $(UBIQX_OBJ) $(PROFILE_OBJ) $(LIB_OBJ)
-
 TESTPARM_OBJ = utils/testparm.o \
                $(PARAM_OBJ) $(UBIQX_OBJ) $(LIB_OBJ)
 
-TESTPRNS_OBJ = utils/testprns.o $(PARAM_OBJ) $(PRINTING_OBJ) $(UBIQX_OBJ) \
-               $(LIB_OBJ)
-
 SMBPASSWD_OBJ = utils/smbpasswd.o $(PARAM_OBJ) \
 				$(LIBSMB_OBJ) $(PASSDB_OBJ) $(GROUPDB_OBJ)\
 				$(UBIQX_OBJ) $(RPC_CLIENT_OBJ) $(RPC_PARSE_OBJ) $(LIB_OBJ) \
@@ -271,7 +246,7 @@
 		$(UBIQX_OBJ) $(LIB_OBJ) $(GROUPDB_OBJ)
 
 RPCCLIENT_OBJ1 = rpcclient/rpcclient.o rpcclient/cmd_lsarpc.o \
-				rpcclient/cmd_samr.o rpcclient/cmd_spoolss.o \
+				rpcclient/cmd_samr.o \
 				rpcclient/cmd_netlogon.o rpcclient/cmd_srvsvc.o \
 				rpcclient/cmd_dfs.o rpcclient/cmd_reg.o \
 				rpc_client/cli_login.o rpc_client/cli_netlogon.o \
@@ -299,8 +274,6 @@
              $(PARAM_OBJ) $(LIBSMB_OBJ) $(UBIQX_OBJ) $(LIB_OBJ) \
              $(READLINE_OBJ)
 
-CUPS_OBJ = client/smbspool.o $(PARAM_OBJ) $(LIBSMB_OBJ) $(UBIQX_OBJ) $(LIB_OBJ)
-
 MOUNT_OBJ = client/smbmount.o \
              $(PARAM_OBJ) $(LIBSMB_OBJ) $(UBIQX_OBJ) $(LIB_OBJ)
 
@@ -355,7 +328,7 @@
 SMBFILTER_OBJ = utils/smbfilter.o $(LIBSMB_OBJ) $(PARAM_OBJ) \
                  $(UBIQX_OBJ) $(LIB_OBJ)
 
-PROTO_OBJ = $(SMBD_OBJ) $(NMBD_OBJ) $(SWAT_OBJ) $(CLIENT_OBJ) \
+PROTO_OBJ = $(SMBD_OBJ) $(NMBD_OBJ) $(CLIENT_OBJ) \
 	    $(SMBWRAPPER_OBJ) $(SMBTORTURE_OBJ) $(RPCCLIENT_OBJ1) \
 	    $(RPC_CLIENT_OBJ) $(LIBMSRPC_OBJ)
 
@@ -520,10 +493,6 @@
 	@echo Linking $@
 	@$(CC) $(FLAGS) -o $@ $(NMBD_OBJ) $(LDFLAGS) $(LIBS)
 
-bin/swat: $(SWAT_OBJ) bin/.dummy
-	@echo Linking $@
-	@$(CC) $(FLAGS) -o $@ $(SWAT_OBJ) $(LDFLAGS) $(DYNEXP) $(LIBS) $(LDAPLIBS) 
-
 bin/rpcclient: $(RPCCLIENT_OBJ) bin/.dummy
 	@echo Linking $@
 	@$(CC) $(FLAGS) -o $@ $(RPCCLIENT_OBJ) $(LDFLAGS) $(DYNEXP) $(TERMLDFLAGS) $(TERMLIBS) $(LIBS) $(LDAPLIBS)
@@ -532,10 +501,6 @@
 	@echo Linking $@
 	@$(CC) $(FLAGS) -o $@ $(CLIENT_OBJ) $(LDFLAGS) $(TERMLDFLAGS) $(TERMLIBS) $(LIBS)
 
-bin/smbspool: $(CUPS_OBJ) bin/.dummy
-	@echo Linking $@
-	@$(CC) $(FLAGS) -o $@ $(CUPS_OBJ) $(LDFLAGS) $(LIBS)
-
 bin/smbmount: $(MOUNT_OBJ) bin/.dummy
 	@echo Linking $@
 	@$(CC) $(FLAGS) -o $@ $(MOUNT_OBJ) $(LDFLAGS) $(LIBS)
@@ -552,18 +517,10 @@
 	@echo Linking $@
 	@$(CC) $(FLAGS) -o $@ $(TESTPARM_OBJ) $(LDFLAGS) $(LIBS)
 
-bin/testprns: $(TESTPRNS_OBJ) bin/.dummy
-	@echo Linking $@
-	@$(CC) $(FLAGS) -o $@ $(TESTPRNS_OBJ) $(LDFLAGS) $(LIBS)
-
 bin/smbstatus: $(STATUS_OBJ) bin/.dummy
 	@echo Linking $@
 	@$(CC) $(FLAGS) -o $@ $(STATUS_OBJ) $(LDFLAGS) $(LIBS)
 
-bin/smbcontrol: $(SMBCONTROL_OBJ) bin/.dummy
-	@echo Linking $@
-	@$(CC) $(FLAGS) -o $@ $(SMBCONTROL_OBJ) $(LDFLAGS) $(LIBS)
-
 bin/smbpasswd: $(SMBPASSWD_OBJ) bin/.dummy
 	@echo Linking $@
 	@$(CC) $(FLAGS) -o $@ $(SMBPASSWD_OBJ) $(LDFLAGS) $(DYNEXP) $(LIBS) $(LDAPLIBS)
@@ -584,10 +541,6 @@
 	@echo Linking $@
 	@$(CC) $(FLAGS) -o $@ $(NMBLOOKUP_OBJ) $(LDFLAGS) $(LIBS)
 
-bin/make_printerdef: $(MAKE_PRINTERDEF_OBJ) bin/.dummy
-	@echo Linking $@
-	@$(CC) $(FLAGS) -o $@ $(MAKE_PRINTERDEF_OBJ) $(LDFLAGS) $(LIBS)
-
 bin/smbtorture: $(SMBTORTURE_OBJ) bin/.dummy
 	@echo Linking $@
 	@$(CC) $(FLAGS) -o $@ $(SMBTORTURE_OBJ) $(LDFLAGS) $(LIBS)
@@ -699,7 +652,7 @@
 	@echo Linking $@
 	@$(CC) $(FLAGS) -o $@ $(TDBDUMP_OBJ)
 
-install: installbin installman installscripts installcp installswat
+install: installbin installman installscripts installcp
 
 installdirs:
 	$(SHELL) $(srcdir)/install-sh -d -m $(INSTALLPERMS) $(BASEDIR)
@@ -723,9 +676,6 @@
 installcp: installdirs installbin
 	@$(SHELL) $(srcdir)/script/installcp.sh $(srcdir) $(LIBDIR) $(CODEPAGEDIR) $(BINDIR) $(CODEPAGELIST)
 
-installswat: installdirs
-	@$(SHELL) $(srcdir)/script/installswat.sh $(SWATDIR) $(srcdir)
-
 installclientlib:
 	-$(INSTALLCLIENTCMD_SH) bin/libsmbclient.@SHLIBEXT@
 	-$(INSTALLCLIENTCMD_A) bin/libsmbclient.a
