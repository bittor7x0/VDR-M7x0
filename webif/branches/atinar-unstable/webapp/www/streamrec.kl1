<%!
/*
* 
* This source-code is licensed under GPL v2.
* See ../../LICENSE for details
* 
* Originally written for http://vdr-m7x0.foroactivo.com.es by:
* atinar <atinar1@hotmail.com>
* 
* You will need the KLONE web application development framework
* from www.koanlogic.com Version 2.
* 
*/

#include <errno.h>
#include <signal.h>
#include <stdio.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>

#include "recording.h"

#ifdef DEBUG
void dbg_streamrec_kl1(void) { 
	dbg("streamrec.kl1");
}
#endif

int cancel=0; //enabled after SIGPIPE has been received

void sig_handler(int sig){
	dbg("Got signal [%s]",sig);
	if( sig==SIGPIPE){
		dbg("Broken pipe");
		cancel=~0;
	}
}

%><%
#ifdef DEBUG
	dbg_streamrec_kl1();
#endif
	vars_t *args = request_get_args(request);
	const char *arg_id;
	int id=-1; 
	if (vars_countn(args,"id")>0) {
		arg_id=vars_get_value(args,"id");
		errno=0;
		id = (int)strtol(arg_id,NULL,10);
		if (errno) {
			warn("%d=strtol(%s,...) errno=%d",id,arg_id,errno);
		}
	}
	info("Recording %d requested",id);
	if (id<0){
		warn("Invalid recording id=%s",arg_id);
		response_set_status(response,HTTP_STATUS_NO_CONTENT);
		response_print_header(response);
		return;
	}
	struct sigaction sa;
	struct sigaction oldsa;
	int fragnum;
	uint64_t total_size;
	uint64_t range_start=0;
	uint64_t range_end=0;
	int use_range=0;

	/* Catch SIGPIPE signals */
	sa.sa_handler=sig_handler;		
	sigemptyset(&sa.sa_mask);
	sigaction(SIGPIPE,&sa,&oldsa);

	recFragment * fragment = parseRecData( getRecData(session, id), &fragnum, &total_size);
	info("Total recording size= %lld bytes", total_size);
	if (fragment==NULL) {
		response_set_status(response,HTTP_STATUS_NO_CONTENT);
		response_print_header(response);
		fragnum=0;
		goto exit;
	}
	field_t * range = request_get_field(request,"Range");
	if (range){
		info("Range requested \"%s\"",range->value);
		if (strncmp(range->value,"bytes=",6)==0){
			char *r = range->value+6;
			use_range=~0;
			errno=0;
			range_start=(uint64_t)strtoll((const char *)r,&r,10);
			if (errno || range_start>total_size){
				warn("Invalid range start %s, range_start=%lld, total_size=%lld, errno=%d",r,range_start,total_size,errno);
				use_range=0;
			}
			else {
				r+=strspn(r,"- ");
				if (strlen(r)>0) {
					errno=0;
					range_end=(uint64_t)strtoll((const char *)r,&r,10);
					if (errno){
						warn("Invalid range end %s, range_end=%lld, total_size=%lld, errno=%d",r,range_end,total_size,errno);
						range_end=0;
					}
				}
			}
		}
		else {
			warn("Invalid range %s",range->value);
			use_range=0;
		}
	}
	
	int i;
	int fragini=0;
	ssize_t result;
	recFragment *f;
	uint64_t position;
	
	fragini=whichFragment(fragment,fragnum,range_start,&position);
	if (fragini<0){
		warn("Error: no fragment found for range_start=%lld",range_start);
		response_set_status(response,HTTP_STATUS_NO_CONTENT);
		response_print_header(response);
		freeRF(fragment,fragnum);
		goto exit;
	}
	
	response_set_field(response, "Accept-Ranges", "bytes");
	if (use_range){
		if (!range_end){
			range_end=total_size-1;
		}
		response_set_status(response,HTTP_PARTIAL_CONTENT); //=206 requires klone-core patched
		char *content_range;		
		if (asprintf(&content_range,"bytes %lld-%lld/%lld",range_start,range_end,total_size)!=-1) {
			response_set_field(response, "Content-Range", content_range);
			free(content_range);
		}
	}
	else {
		response_set_status(response,HTTP_STATUS_OK);
		range_end=total_size-1;
	}
	uint64_t remaining=(range_end-range_start+1);
	if (range_start+remaining-1 != range_end){
		warn( "Error: content_length trucated");
	}
	response_set_content_length(response,remaining);
	response_set_content_type(response,"video/mpeg");

	io_codecs_remove(response_io(rs));
	response_print_header(response);
	io_flush(out);
	
	if (request_get_method(request)==HM_GET){
		cancel=0;
		io_t * pio;
		const int buflen=1024;
		char buffer[buflen];
		for (i=fragini; i<fragnum && remaining>0 && !cancel; i++){
			f=&fragment[i];
			FILE *fi = fopen(f->path,"rb");
			if (f) {
				int b=0;
				errno=0;
				if (fseek(fi,position,SEEK_SET)!=0) {
					warn("Error %d in fseek",errno);
					position=0;
				}
				while(remaining>0 && !cancel && !feof(fi)) {
					int len=(remaining>buflen)?buflen:(int)remaining;
					b=fread(buffer,1,len,fi);
					if (b>0) {
						b=io_write(out,buffer,b);
						if (b<0) {
							cancel=1;
							info("Cancelado");
						}
						else {
							position+=b;
							remaining-=b;
							//dbg("Sent %d bytes, current position: %lld, remaining: %lld", b, position, remaining);
						}
					}
				}
				fclose(fi);
			}
			position=0; //read following files from the start
		}
	}

exit:
	sigaction(SIGPIPE,&oldsa,NULL);
	freeRF(fragment,fragnum);
	info("2 session recid=%p",session_get(session,"recid"));
	info("2 session recdata=%p",session_get(session,"recdata"));
%>
