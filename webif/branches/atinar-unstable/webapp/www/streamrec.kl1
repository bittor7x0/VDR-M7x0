<%!
/*
* 
* This source-code is licensed under GPL v2.
* See ../../LICENSE for details
* 
* Originally written for http://vdr-m7x0.foroactivo.com.es by:
* atinar <atinar1@hotmail.com>
* 
* You will need the KLONE web application development framework
* from www.koanlogic.com Version 2.
* 
*/

#include <errno.h>
#include <fcntl.h>
#include <klone/utils.h>
#include <signal.h>
#include <stdio.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>

#include "recording.h"

#ifdef DEBUG
void dbg_streamrec_kl1(void) { 
	dbg("streamrec.kl1");
}
#endif

boolean_t cancel=BT_FALSE;

void sig_handler(int sig){
	dbg("Got signal [%s]",sig);
	if( sig==SIGPIPE){
		dbg("Broken pipe");
		cancel=BT_TRUE;
	}
}

%><%
#ifdef DEBUG
	dbg_streamrec_kl1();
#endif
	set_server_address(session,NULL,NULL);

	vars_t *args = request_get_args(request);
	int id=-1; 
	const char *path=NULL;
	if (vars_countn(args,"id")>0) {
		id=vars_get_value_i(args,"id");
	}
	if (id<0) {
		if (vars_countn(args,"path")>0) {
			path=vars_get_value(args,"path");
			dbg("Recording %s requested",path);
		}
	} else {
		dbg("Recording %d requested",id);
	}
	if (id<0 && path==NULL) {
		warn("Invalid parameters");
		response_set_status(response,HTTP_STATUS_NO_CONTENT);
		response_print_header(response);
		return;
	}
	struct sigaction sa;
	struct sigaction oldsa;
	uint64_t range_start=0;
	uint64_t range_end=0;
	boolean_t use_range=BT_FALSE;

	/* Catch SIGPIPE signals */
	sa.sa_handler=sig_handler;		
	sigemptyset(&sa.sa_mask);
	sigaction(SIGPIPE,&sa,&oldsa);

	fragmentList_t list;
	if (!getFragmentList(&list,path,id)) {
		response_set_status(response,HTTP_STATUS_NO_CONTENT);
		response_print_header(response);
		goto exit;
	}
	field_t * range = request_get_field(request,"Range");
	if (range){
		dbg("Range requested \"%s\"",range->value);
		if (strncmp(range->value,"bytes=",6)==0){
			char *r = range->value+6;
			use_range=BT_TRUE;
			errno=0;
			range_start=(uint64_t)strtoll(r,&r,10);
			if (errno || range_start>list.totalSize){
				warn("Invalid range start %s, range_start=%lld, total_size=%lld, errno=%d",r,range_start,list.totalSize,errno);
				use_range=BT_FALSE;
			}
			else {
				r+=strspn(r,"- ");
				if (strlen(r)>0) {
					errno=0;
					range_end=(uint64_t)strtoll((const char *)r,&r,10);
					if (errno){
						warn("Invalid range end %s, range_end=%lld, total_size=%lld, errno=%d",r,range_end,list.totalSize,errno);
						range_end=0;
					}
				}
			}
		}
		else {
			warn("Invalid range %s",range->value);
			use_range=0;
		}
	}
	
	if (!seekFragment(&list,range_start)){
		warn("Error: no fragment found for range_start=%lld",range_start);
		response_set_status(response,HTTP_STATUS_NO_CONTENT);
		response_print_header(response);
		goto exit;
	}
	
	response_set_field(response, "Accept-Ranges", "bytes");
	if (use_range){
		if (!range_end){
			range_end=list.totalSize-1;
		}
		response_set_status(response,HTTP_PARTIAL_CONTENT); //=206 requires klone-core patched
		char *content_range;		
		if (asprintf(&content_range,"bytes %lld-%lld/%lld",range_start,range_end,list.totalSize)!=-1) {
			response_set_field(response, "Content-Range", content_range);
			free(content_range);
		}
	}
	else {
		response_set_status(response,HTTP_STATUS_OK);
		range_end=list.totalSize-1;
	}
	uint64_t remaining=(range_end-range_start+1);
	response_set_content_length(response,remaining);
	response_set_content_type(response,"video/mpeg");

	io_codecs_remove(response_io(rs));
	response_print_header(response);
	io_flush(out);
	
	if (request_get_method(request)==HM_GET){
		cancel=BT_FALSE;
//#define USE_IO_PIPE
#ifndef USE_IO_PIPE
		int len,br,bw;
		enum { BUFSZ = 4096 };
		char buffer[BUFSZ];
#endif
		while (list.fragNum<list.length && remaining>0 && !cancel){
			fragmentEntry_t *f=&list.entry[list.fragNum];
			if (f->path!=NULL && f->size>0){
				warn("Fragment[%d] %lld %lld",list.fragNum,f->size,list.fragPos);
#ifndef USE_IO_PIPE
				FILE *fi = fopen(f->path,"rb");
				if (fi) {
					errno=0;
					if (fseek(fi,list.fragPos,SEEK_SET)!=0) {
						warn("Wrong position %lld in fragment[&d].Error:%d",list.fragPos,list.fragNum,errno);
					}

					while(remaining>0 && !cancel && !feof(fi) && !ferror(fi)) {
						len=(remaining>BUFSZ)?BUFSZ:(int)remaining;
						br=fread(buffer,1,len,fi);
						if (br>0) {
							bw=io_write(out,buffer,br);
							if (bw<0) {
								cancel=BT_TRUE; //TODO necesario?
								dbg("Cancelado");
							}
							else {
								if (bw<br){
									warn("bw(%d)!=br(%d)",bw,br);
								}
								remaining-=bw;
							}
						}
					}
					fclose(fi);
				}
#else
				int fd=open(f->path,O_RDONLY);
				if (fd>-1){
					io_t *in;
					int result=0;
					if (io_fd_create(fd,IO_FD_CLOSE,&in)==0){
						if (list.fragPos>0){
							result=io_seek(in,list.fragPos);
						}
						if (result>-1){
							ssize_t piped=io_pipe(out,in);
							if (piped>-1){
								remaining-=piped;
							} else {
								cancel=BT_TRUE;
								warn("Error,piped=%lld",piped);
							}
						}
						io_free(in);
					} else {
						perror("streamrec.kl1:io_fd_create()");
					}
				} else {
					perror("streamrec.kl1:open()");
				}
#endif
			}
			list.fragNum++;
			list.fragPos=0;
		}
	}
	if (remaining>0){
		warn("Remaining %lld, should be 0", remaining);
	}

exit:
	sigaction(SIGPIPE,&oldsa,NULL);
	freeFL(&list);
%>
