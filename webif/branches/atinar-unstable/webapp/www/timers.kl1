<%!
/*
* 
* This source-code is licensed under GPL v2.
* See ../../LICENSE for details
* 
* (c) Christian Kelinski <k@kille.cx>
* Please checkout the README file!
* 
* Originally written for the open7x0.org VDR-FW project:
* www.open7x0.org
* 
* Modified for http://vdr-m7x0.foroactivo.com.es by:
* atinar <atinar1@hotmail.com>
* 
* You will need the KLONE web application development framework
* from www.koanlogic.com Version 2.
* 
*/

#include <klapp_conf.h>
#include <time.h>
#include <locale.h>
#include <u/libu.h>

#include "i18n.h"
#include "misc.h"
#include "timers.h"
#include "channels.h"
#include "svdrp_comm.h"
#include "svdrp_parse.h"


char * parseTimerForm(vars_t *args){
	char * timerStr=NULL;
	timerEntry_t timer;
	boolean_t result=BT_FALSE;		
	initTE(&timer);
	timer.active=(vars_countn(args,"active")>0) ? vars_get_value_i(args,"active") : 0;
	timer.channelNum=(vars_countn(args,"channelNum")>0) ? vars_get_value_i(args,"channelNum") : 0;
	timer.type=(vars_countn(args,"type")>0) ? vars_get_value_i(args,"type") : TT_ONE_TIME;
	char * date=NULL;
	if (timer.type==TT_ONE_TIME && vars_countn(args,"date")>0) {
		date=strdup(vars_get_value(args,"date"));
	} else {
		size_t i;
		for(i=0;i<vars_countn(args,"wday");i++){
			int wday=vars_geti_value_i(args, "wday",i);
			if (wday>6||wday<0){
				//TODO warn
			} else {
				timer.reg_timer[(wday+6)%7]=weekdays[langID][wday][0]; 
			}
		}
	}
	const char * startH= vars_get_value(args,"startHour"); 
	const char * startM= vars_get_value(args,"startMin");
	const char * endH  = vars_get_value(args,"endHour");
	const char * endM  = vars_get_value(args,"endMin");
	timer.lifetime= (vars_countn(args,"lifetime")>0) ? vars_get_value_i(args,"lifetime") : 99;
	timer.priority= (vars_countn(args,"priority")>0) ? vars_get_value_i(args,"priority") : 50;
	timer.title = strdup((vars_countn(args,"title")>0) ? vars_get_value(args,"title") : "");
	boolean_t addMargin= boolean(vars_countn(args,"addMargin")>0);
		
	if	( (timer.type==TT_UNDEFINED) ||
		( (timer.type==TT_ONE_TIME) && (!date) ) ||
		( (timer.type==TT_REGULAR) && (strlen(timer.reg_timer)<7) ) ||
		( (!startH) || (!startM) || (!endH) || (!endM) ) ) 
	{
		io_printf(out,"Fatal Error!\n");
	} else {
		if (timer.type==TT_REGULAR) {
			//El dia no importa, solo las horas
			time_t rawtime=time(NULL);
			struct tm * today;
			today=localtime(&rawtime); 
			date=malloc(12);    
			strftime(date,11,"%Y-%m-%d",today);
		}
		
		if (makeTime(&timer.start,date,startH,startM) && makeTime(&timer.stop,date,endH,endM)){
			if (addMargin){
				timer.start-=marginStart;
				timer.stop+=marginStop;
			}
			if (timer.stop<timer.start) {
				timer.stop+=24*60*60; 
			}
			struct tm t1=*localtime(&timer.start);
			struct tm t2=*localtime(&timer.stop);
			result = (timer.type==TT_REGULAR) 
				? (asprintf(&timerStr,"%d:%d:%s:%02d%02d:%02d%02d:%d:%d:%s:"
					,timer.active
					,timer.channelNum
					,timer.reg_timer
					,t1.tm_hour,t1.tm_min
					,t2.tm_hour,t2.tm_min
					,timer.priority
					,timer.lifetime
					,timer.title		)<1) ? BT_FALSE : BT_TRUE
				: (asprintf(&timerStr,"%d:%d:%d-%02d-%02d:%02d%02d:%02d%02d:%d:%d:%s:"
					,timer.active
					,timer.channelNum
					,1900+t1.tm_year,t1.tm_mon+1,t1.tm_mday
					,t1.tm_hour,t1.tm_min
					,t2.tm_hour,t2.tm_min
					,timer.priority
					,timer.lifetime
					,timer.title		)<1) ? BT_FALSE : BT_TRUE;
		}
		free(date);
	}
	freeTE(&timer);
	return timerStr;
}

#ifdef DEBUG
void dbg_timers_kl1(void) { dbg("timers.kl1"); }
#endif

%><%

	#ifdef DEBUG
	dbg_timers_kl1();
	#endif

	config(session, request);

	int i=0;

	vars_t *args = request_get_args(request);
	int timerID=(vars_countn(args,"timerID")>0) ? vars_get_value_i(args,"timerID") : -1;
	const char * argTimerStr=(vars_countn(args,"timer")>0) ? vars_get_value(args,"timer") : NULL;
	const char * oldTimerStr=(vars_countn(args,"oldTimerStr")>0) ? vars_get_value(args,"oldTimerStr") : NULL;
	sortBy=(vars_countn(args,"sort")>0) ? vars_get_value_i(args,"sort") : SF_START;
	sortDirection=(vars_countn(args,"direction")>0) ? vars_get_value_i(args,"direction") : SD_ASC;
	currentPage=PN_TIMERS;
	currentAction = (vars_countn(args,"a")>0) ? vars_get_value_i(args,"a") : PA_SUMMARY;
	printXhtmlHead(out,tr("timers"),
"		<script type=\"text/javascript\">\n"
"			$(function(){\n"
"				$('#delete').click(function (event){\n"
"					if (!confirm('%s')){\n"
"						event.preventDefault();\n"
"					}\n"
"				});\n"
"			});\n"
"		</script>\n"
		,tr("timerDeleteConfirm")
	);
	printMenu(out);
	io_printf(out,
"		<div id=\"main\" class=\"content\">\n"
"			<h2>%s</h2>\n"
		,tr("timers")
	);

	channelList channels;
	initCL(&channels);

	if (currentAction==PA_DELETE) {
		if ( (timerID>0) && (timerID<1000) && (oldTimerStr) ) {
			char *message=NULL;
			dbg("Trying to delete timer with ID %d (%s)",timerID,oldTimerStr);
			if (deleTimer(timerID,oldTimerStr,&message)) {
				io_printf(out,
"			<div class=\"message\"><p>%s:</p><p class=\"response\">%s</p></div>\n",tr("timerDeleteOk"),message
				);
				currentAction=PA_SUMMARY;
			} else {
				io_printf(out,
"			<div class=\"alert\"><p>%s:</p><p class=\"response\">%s</p></div>\n",tr("timerDeleteErr"),message
				);
				currentAction=PA_EDIT;
			}
			free(message);
		}
	}
	if (currentAction==PA_ADD) {
		char * timerStr = (argTimerStr==NULL) ? parseTimerForm(args) : (char *)argTimerStr;
		char *message=NULL;
		if ( (timerID>0) && (timerStr) && (oldTimerStr) ) {
			if (editTimer(timerID,oldTimerStr,timerStr,&message)) {
				io_printf(out,
"			<div class=\"message\"><p>%s:</p><p class=\"response\">%s</p></div>\n",tr("timerUpdateOk"),message
				);
			} else {
				io_printf(out,
"			<div class=\"alert\"><p>%s:</p><p class=\"response\">%s</p></div>\n",tr("timerUpdateErr"),message
				);
			}
		} else if ( (timerStr) && (addTimer(timerStr,&message))) {
			io_printf(out,
"		<div class=\"message\"><p>%s:</p><p class=\"response\">%s</p></div>\n",tr("timerCreateOk"),message
			);
		} else {  
			io_printf(out,
"		<div class=\"alert\"><p>%s:</p><p class=\"response\">%s</p></div>\n",tr("timerCreateErr"),message
			);
		}
		currentAction=PA_SUMMARY;
		if (timerStr && timerStr!=argTimerStr ){
			free(timerStr);
		}
		free(message);
	} else if (currentAction==PA_EDIT) {

		timerEntry_t timer;
		initTE(&timer);
		
		if (channels.length==0){
			getChannelList(&channels,SF_NONE,SD_NONE);
		}
		
		io_printf(out,
"		<form action=\"/timers.kl1\">\n");
		if (argTimerStr) {
			parseTimer(argTimerStr,&timer);
		}

		if (timerID>0) {
			io_printf(out,
"			<input type=\"hidden\" name=\"timerID\" value=\"%d\" />\n"
"			<input type=\"hidden\" name=\"oldTimerStr\" value=\"%s\" />"
				,timerID
				,(oldTimerStr!=NULL) ? oldTimerStr : argTimerStr
				);
		}
		io_printf(out,
"			<table id=\"timerEdit\" class=\"list1\">\n"
"				<caption>%s</caption>\n"
"				<tr>\n"
"					<th>%s</th>\n"
"					<td><input type=\"checkbox\" name=\"active\" value=\"1\" %s /></td>\n"
"				</tr>\n"
					,tr((timerID>0)?"timerEdit":"timerAdd")
					,tr("active")
					,checked[boolean(timer.active)]
		);
		io_printf(out,
"				<tr>\n"
"					<th>%s</th>\n"
"					<td>\n"
"						<select name=\"channelNum\" size=\"1\">\n",tr("channel"));
		for (i=0;i<channels.length;i++) {
			io_printf(out,
"							<option value=\"%d\" %s>%d - %s</option>\n"
				,channels.entry[i].channelNum
				,selected[boolean(timer.channelNum==channels.entry[i].channelNum)]
				,channels.entry[i].channelNum
				,channels.entry[i].channelName
			);
		}  
		io_printf(out,
"						</select>\n"
"					</td>\n"
"				</tr>\n"
"				<tr>\n"
"					<th><input type=\"radio\" name=\"type\" value=\"%d\" %s>%s</input></th>"
			,TT_ONE_TIME
			,checked[boolean(timer.type==TT_ONE_TIME)]
			,tr("oneTimeRecording")
		);
		io_printf(out,
"					<td>\n"
"						<select name=\"date\" size=\"1\">\n");
		time_t tdate=time(NULL);
		char cdate[11];
		struct tm sdate;
		boolean_t isThatDay=BT_FALSE;
		boolean_t isAfterThatDay=BT_FALSE;
		for(i=0;i<14;i++) {
			sdate=*localtime(&tdate);
			strftime(cdate,11,"%Y-%m-%d",&sdate);
			if (!isAfterThatDay){
				isThatDay=sameDay(tdate,timer.start);
				isAfterThatDay=boolean(isThatDay||tdate>timer.start);
			}
			io_printf(out,
"							<option value=\"%s\" %s>%s, %s</option>\n"
				,cdate,selected[isThatDay],weekdays[langID][sdate.tm_wday],formatDate(&sdate,BT_FALSE));
			if (isThatDay && (timer.type==TT_ONE_TIME)) { 
				//marcar por si se cambia a regular
				timer.reg_timer[(sdate.tm_wday+6)%7]=weekdays[langID][sdate.tm_wday][0]; 
			}
			isThatDay=BT_FALSE;
			tdate+=24*60*60;
		} 
		io_printf(out,
"						</select>\n"
"					</td>\n"
"				</tr>\n"
"				<tr>\n"
"					<th><input type=\"radio\" name=\"type\" value=\"%d\" %s>%s</input></th>\n"
"					<td>"
			,TT_REGULAR
			,checked[boolean(timer.type==TT_REGULAR)]
			,tr("regularRecording")
		); 
		for(i=startOfWeek[langID];i<startOfWeek[langID]+7;i++) {
			io_printf(out,
						"<input type=\"checkbox\" name=\"wday\" value=\"%d\" %s>%s</input>&nbsp;&nbsp;"
				,(i%7)
				,checked[boolean(timer.reg_timer[(i+6)%7]!='-')]
				,weekdays[langID][i%7]
			);
		}

		struct tm start_date=*localtime(&timer.start);
		io_printf(out,
					"</td>\n"
"				</tr>\n"
"				<tr>\n"
"					<th>%s</th>\n"
"					<td>"
						"<input type=\"text\" name=\"startHour\" maxlength=\"2\" size=\"3\" value=\"%02d\"/>&nbsp;:&nbsp;"
						"<input type=\"text\" name=\"startMin\"  maxlength=\"2\" size=\"3\" value=\"%02d\"/>&nbsp;"
					"</td>\n"
"				</tr>\n",tr("start"),start_date.tm_hour,start_date.tm_min);
		struct tm end_date=*localtime(&timer.stop);
		io_printf(out,
"				<tr>\n"
"					<th>%s</th>\n"
"					<td>"
						"<input type=\"text\" name=\"endHour\" maxlength=\"2\" size=\"3\" value=\"%02d\" />&nbsp;:&nbsp;"
						"<input type=\"text\" name=\"endMin\"  maxlength=\"2\" size=\"3\" value=\"%02d\"/>&nbsp;"
					"</td>\n"
"				</tr>\n",tr("end"),end_date.tm_hour,end_date.tm_min);
		io_printf(out,
"				<tr>\n"
"					<th>&nbsp;</th>\n"
"					<td>\n"
"						<input type=\"checkbox\" name=\"addMargin\" value=\"%d\" %s>%s</input></td></tr>\n"
			,boolean(timerID==-1)
			,checked[boolean(timerID<1)]
			,tr("addMargin")
		);

		io_printf(out,
"				<tr>"
					"<th>%s</th>"
					"<td>"
						"<input type=\"text\" name=\"priority\" maxlength=\"2\" size=\"3\" value=\"%d\"/>"
					"</td>"
				"</tr>\n",tr("priority"),timer.priority);
		io_printf(out,
"				<tr>"
					"<th>%s</th>"
					"<td>"
						"<input type=\"text\" name=\"lifetime\" value=\"%d\" maxlength=\"2\" size=\"3\" />"
					"</td>"
				"</tr>\n",tr("lifetime"),timer.lifetime);
		io_printf(out,
"				<tr>"
					"<th>%s</th>"
					"<td>"
						"<input type=\"text\" name=\"title\" size=\"70\" value=\"%s\" />"
					"</td>"
				"</tr>\n",tr("title"),(timer.title)?timer.title:"");
		io_printf(out,
"				<tr class=\"buttons\">"
					"<td colspan=\"2\">"
						"<button id=\"delete\" name=\"a\" type=\"submit\" value=\"%d\" "
							"class=\"delete\">%s</button>"
						"<button id=\"confirm\" name=\"a\" type=\"submit\" value=\"%d\" "
							"class=\"confirm\">%s</button>"
					"</td>"
				"</tr>\n"
				,PA_DELETE,tr("timerDelete")
				,PA_ADD,tr("accept"));
		io_printf(out,
"			</table>\n"
"		</form>\n");
		freeTE(&timer);
		
	} else {
		currentAction=PA_SUMMARY;
	}

	if (currentAction==PA_SUMMARY) {
		if (channels.length==0){
			getChannelList(&channels,SF_NONE,SD_NONE);
		}
		
		if (channels.length>0) {
			timerList_t timers;
			io_printf(out,
"		<table id=\"timers\" class=\"list1\">\n"
"			<col class=\"number\"/>\n"
"			<col class=\"tmDate date\"/>\n"
"			<col class=\"chName\"/>\n"
"			<col class=\"tmStart hour\"/>\n"
"			<col class=\"tmEnd hour\"/>\n"
"			<col class=\"tmName\"/>\n"
"			<col class=\"mxName\"/>\n"
"			<col class=\"ctrls\"/>\n"
"			<thead>\n"
"				<tr>\n"
"					<th><a class=\"%s\" href=\"timers.kl1?sort=%d&direction=%d\">%s</a></th>\n"
"					<th><a class=\"%s\" href=\"timers.kl1?sort=%d&direction=%d\">%s</a></th>\n"
"					<th><a class=\"%s\" href=\"timers.kl1?sort=%d&direction=%d\">%s</a></th>\n"
"					<th><a class=\"%s\" href=\"timers.kl1?sort=%d&direction=%d\">%s</a></th>\n"
"					<th><a class=\"%s\" href=\"timers.kl1?sort=%d&direction=%d\">%s</a></th>\n"
"					<th><a class=\"%s\" href=\"timers.kl1?sort=%d&direction=%d\">%s</a></th>\n"
"					<th><a class=\"%s\" href=\"timers.kl1?sort=%d&direction=%d\">%s</a></th>\n"
"					<th>&nbsp;</th>\n"
"				</tr>\n"
"			</thead>\n"
"			<tbody>\n"
"				<tr>\n"
				,sortClass(SF_TM_NUMBER),SF_TM_NUMBER,newSortDirection(SF_TM_NUMBER),"#"
				,sortClass(SF_START),SF_START,newSortDirection(SF_START),tr("date")
				,sortClass(SF_CH_NUMBER),SF_CH_NUMBER,newSortDirection(SF_CH_NUMBER),tr("channel")
				,sortClass(SF_START),SF_START,newSortDirection(SF_START),tr("start")
				,sortClass(SF_START),SF_START,newSortDirection(SF_START),tr("end")
				,sortClass(SF_TITLE),SF_TITLE,newSortDirection(SF_TITLE),tr("program")
				,sortClass(SF_MUX),SF_MUX,newSortDirection(SF_MUX),tr("channelMux")
			);
			getTimerList(&timers,&channels,sortBy,sortDirection);
			const char *EditTimer=tr("timerEdit");
			for (i=0;i<timers.length;i++) {
				struct tm t1=*localtime(&timers.entry[i].start);
				struct tm t2=*localtime(&timers.entry[i].stop);

				io_printf(out,
"				<tr>\n"
"					<td class=\"number\">%d</td>\n",timers.entry[i].ID
				);
				if (timers.entry[i].type==TT_REGULAR) {
					io_printf(out,
"					<td class=\"date\">%s (%s)</td>\n",formatDate(&t1,0),timers.entry[i].reg_timer);
				} else {
					io_printf(out,
"					<td class=\"date\">%s</td>\n",formatDate(&t1,0));
				}

				io_printf(out,
"					<td><a class=\"strong\" href=\"program.kl1?chan=%d\">%s</a></td>\n"
"					<td class=\"hour\">%02d:%02d</td>\n"
"					<td class=\"hour\">%02d:%02d</td>\n"
"					<td>%s</td>\n"
"					<td>%s</td>\n"
"					<td class=\"ctrls\">"
						"<a class=\"ui-icon ui-icon-edit\" href=\"timers.kl1?a=%d&timer=%s&timerID=%d\">%s</a>"
					"</td>\n"
"				</tr>\n"
					,(timers.entry[i].channel) ? timers.entry[i].channel->channelNum : 1
					,(timers.entry[i].channel) ? timers.entry[i].channel->channelName : ""
					,t1.tm_hour,t1.tm_min
					,t2.tm_hour,t2.tm_min
					,timers.entry[i].title
					,(timers.entry[i].channel) ? timers.entry[i].channel->multiplexName : ""
					,PA_EDIT,timers.entry[i].timerStr,timers.entry[i].ID
					,EditTimer
				);
			}
			io_printf(out,
"			</tbody>\n"
"		</table>\n"
			);
			freeTL(&timers);
		} else {
			//TODO
		}
	}
	freeCL(&channels);
	close_svdrp();
io_printf(out,
"	</div>\n");
printFooter(out);
%>
