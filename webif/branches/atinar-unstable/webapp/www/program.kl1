<%!
/*
* 
* This source-code is licensed under GPL v2.
* See ../../LICENSE for details
* 
* (c) Christian Kelinski <k@kille.cx>
* Please checkout the README file!
* 
* Originally written for the open7x0.org VDR-FW project:
* www.open7x0.org
* 
* Modified for http://vdr-m7x0.foroactivo.com.es by:
* atinar <atinar1@hotmail.com>
* 
* You will need the KLONE web application development framework
* from www.koanlogic.com Version 2.
* 
*/

#include <klapp_conf.h>
#include <time.h>
#include <string.h>
#include <stdlib.h>
#include <u/libu.h>

#include "channels.h"
#include "epg.h"
#include "i18n.h"
#include "timers.h"
#include "svdrp_comm.h"

channelList_t channels;
timerList_t timers;

boolean_t intersects(vdrTimer_t *timer, time_t pstart, time_t pend, int *mstart, int *mend){
	boolean_t result=BT_FALSE;
	*mstart=timer->start-pstart; //margen no cubierto al inicio
	*mend  =pend-timer->stop;    //margen no cubierto al final
	result=boolean( ((*mstart<=0) && (*mend<=0)) || ((*mstart<0) && (timer->stop>pstart)) || ((timer->start<pend) && (*mend<0)) );
	if (timer->type==TT_REGULAR && timer->stop<pstart){
		//Set regular timer to next date and reorder timers
		struct tm sdate=*localtime(&timer->start);
		int wday=(sdate.tm_wday+6)%7;
		for(;;){
			//TODO daylight savings?
			wday=(wday+1)%7;
			timer->start+=24*60*60;
			timer->stop+=24*60*60;
			if (timer->wdays[wday]!='-') {
				sortTimerList(&timers,SF_START,SD_ASC);
				break;
			}
		}
	}
	return result;
}

void printTimers(io_t *out, int ntabs, int channelNum, time_t startTime, int duration,char aux[]) {
	int mstart=0;
	int mend=0;

	time_t endTime=startTime+duration;
	boolean_t isStart, isEnd, anyMatch;
	anyMatch=BT_FALSE;
	if ( (timers.length>0) && (channelNum>0) && (startTime>0) && (duration>0) ) {
		const char *TimerEdit=tr("timerEdit");
		int i;
		vdrTimer_t *timer;
		for (i=0,timer=timers.entry;i<timers.length;i++,timer++) {
			if (timer->channelNum==channelNum && intersects(timer,startTime,endTime,&mstart,&mend)) {
				isStart=boolean(mstart>=0);
				isEnd=boolean(mend>=0);
				anyMatch=BT_TRUE;
				mstart=(mstart<=0) ? 0 : 100 * mstart / duration;
				mend=  (mend<=0)   ? 0 : 100 * mend / duration;
				io_printf(out,"%.*s<div id=\"timer%d_%d\" class=\"timer\" title=\"%s\">\n"
					,ntabs++,tabs,timer->id,++timer->count,timer->title);
				io_printf(out,"%.*s<div class=\"progressbar\">\n",ntabs++,tabs);
				io_printf(out,"%.*s"
					"<div class=\"pb%s%s%s\" style=\"left:%d%%;right:%d%%;\">"
						"&nbsp;"
					"</div>\n",ntabs,tabs
					,(isStart) ? " pbstart":"",(isEnd) ? " pbend":""
					,(isFlagSet(TF_ACTIVE,timer->flags)) ? " pbenabled":" pbdisabled"
					,mstart,mend);
				io_printf(out,"%.*s</div>\n",--ntabs,tabs); //progressbar
				u_urlncpy(aux,timer->timerStr,strlen(timer->timerStr),URLCPY_ENCODE);
				io_printf(out,"%.*s<a class=\"ui-icon ui-icon-edit\" href=\"timers.kl1?a=%d&amp;timerStr=%s&amp;timerId=%d\" title=\"%s\">%s</a>\n"
					,ntabs,tabs,PA_EDIT,aux,timer->id,TimerEdit,TimerEdit
					);
				io_printf(out,"%.*s</div>\n",--ntabs,tabs); //timer
			}
		}
	}
	if (!anyMatch) io_printf(out,"%.*s&nbsp;\n",ntabs,tabs);
}

#ifdef DEBUG
dbg_program_kl1(void) { dbg("program.kl1"); }
#endif

%><%
	#ifdef DEBUG
	dbg_program_kl1();
	#endif

	int i=0;
	int channelNum=0;
	enum {AUXSZ=2048};
	char aux[AUXSZ];


	vars_t *args = request_get_args(request);
	channelNum=vars_get_value_i(args,"chan");

	config(session, request);
	currentPage=PN_PROGRAMS;
	
	int ntabs=initHtmlPage(response,out,tr("schedule"),NULL);
	printMenu(out,ntabs);
	io_printf(out,"%.*s<div id=\"main\" class=\"content\">\n",ntabs++,tabs);
	
	hostConf_t *host=getFirstVdrHost();
	if (!host)
		printMessage(out,ntabs,"alert",tr("errorNoVdrHost"),NULL,NULL);
	else {
		getChannelList(host,&channels,SF_NONE,SD_NONE);
		getTimerList(&timers,&channels,SF_START,SD_ASC);

		boolean_t isTv;
		const char * Schedule=tr("schedule");
		const char * TimerCreate=tr("timerCreate");
		if (channelNum<1) {
			nowNextList_t nnl;
			getNowNextList(host,&nnl,&channels);

			io_printf(out,"%.*s<h2>%s</h2>\n",ntabs,tabs,tr("nowOnTv"));
			if (nnl.length==0) {
				io_printf(out,"%.*s<div class=\"alert\">%s</div>\n",ntabs,tabs,tr("warnNoEPG"));
			} else {
				nowNextEntry_t *nne;
				channel_t *channel;
				eventEntry_t *event;
				struct tm *sdate;
				int pcbegin;
				int pcend;
				const char *LiveStream=tr("liveStream");
				io_printf(out,"%.*s<table id=\"programs\" class=\"list1\" summary=\"%s\">\n",ntabs++,tabs,Schedule);
				
				io_printf(out,"%.*s<col class=\"channel\"/>\n",ntabs,tabs);
				io_printf(out,"%.*s<col class=\"space\"/>\n",ntabs,tabs);
				io_printf(out,"%.*s<colgroup id=\"colNow\" class=\"nowNext\">\n",ntabs++,tabs);
				io_printf(out,"%.*s<col class=\"hour\"/>\n",ntabs,tabs);
				io_printf(out,"%.*s<col class=\"timers\"/>\n",ntabs,tabs);
				io_printf(out,"%.*s<col class=\"pgName\"/>\n",ntabs,tabs);
				io_printf(out,"%.*s</colgroup>\n",--ntabs,tabs);
				io_printf(out,"%.*s<col class=\"space\"/>\n",ntabs,tabs);
				io_printf(out,"%.*s<colgroup id=\"colNext\" class=\"nowNext\">\n",ntabs++,tabs);
				io_printf(out,"%.*s<col class=\"hour\"/>\n",ntabs,tabs);
				io_printf(out,"%.*s<col class=\"timers\"/>\n",ntabs,tabs);
				io_printf(out,"%.*s<col class=\"pgName\"/>\n",ntabs,tabs);
				io_printf(out,"%.*s</colgroup>\n",--ntabs,tabs);
				
				io_printf(out,"%.*s<thead>\n",ntabs++,tabs);
				io_printf(out,"%.*s"
					"<tr>"
						"<th>%s</th>"
						"<td class=\"space\"></td>"
						"<th colspan=\"3\">%s</th>"
						"<td class=\"space\"></td>"
						"<th colspan=\"3\">%s</th>"
					"</tr>\n",ntabs,tabs,tr("channel"),tr("now"),tr("next"));
				io_printf(out,"%.*s</thead>\n",--ntabs,tabs);
				
				io_printf(out,"%.*s<tbody>\n",ntabs++,tabs);
				for (i=0;i<nnl.length;i++) {
					nne=nnl.entry+i;
					channel=channels.channel+i;
					isTv=boolean(channel->vpid>1);
					io_printf(out,"%.*s<tr>\n",ntabs++,tabs);
					io_printf(out,"%.*s<td class=\"channel\">\n",ntabs++,tabs);
					io_printf(out,"%.*s"
						"<div class=\"boxRight\">"
							"<a class=\"ui-icon %s\" href=\"watchit.kl1?channelnum=%d\" title=\"%s\">%s</a>"
						"</div>\n"
						,ntabs,tabs,(isTv)?"ui-icon-tv":"ui-icon-radio",channel->channelNum,LiveStream,LiveStream);
					io_printf(out,"%.*s<a class=\"channel\" href=\"program.kl1?chan=%d\" title=\"%s\">%s</a>\n"
						,ntabs,tabs,channel->channelNum,Schedule,channel->channelName);
					io_printf(out,"%.*s</td>\n",--ntabs,tabs);
						
					int n;
					for (n=0;n<2;n++){
						event=nne->event+n;
						if (event->start>0) {
							long int end_time = event->start+event->duration;
							char *timerStr=NULL;
							timerStr=makeOneTimeTimerStr(TF_ACTIVE,channel->channelNum,event->start,end_time,50,99,event->title,NULL);
							sdate = localtime(&event->start);
							
							io_printf(out,"%.*s<td class=\"space\"></td>\n",ntabs,tabs);
							
							io_printf(out,"%.*s<td class=\"hour\">%02d:%02d</td>\n",ntabs,tabs,sdate->tm_hour,sdate->tm_min);
							
							io_printf(out,"%.*s<td class=\"timers\">\n",ntabs++,tabs);
							printTimers(out,ntabs,channel->channelNum,event->start,event->duration,aux);
							io_printf(out,"%.*s</td>\n",--ntabs,tabs);
							
							u_urlncpy(aux,timerStr,strlen(timerStr),URLCPY_ENCODE);
							io_printf(out,"%.*s<td class=\"title\">\n",ntabs++,tabs);
							io_printf(out,"%.*s<div class=\"boxRight\">\n",ntabs++,tabs);
							io_printf(out,"%.*s<a class=\"ui-icon ui-icon-rec\" href=\"timers.kl1?a=%d&amp;timerStr=%s\" title=\"%s\">%s</a>\n"
								,ntabs,tabs,PA_EDIT,aux,TimerCreate,TimerCreate);
							io_printf(out,"%.*s</div>\n",--ntabs,tabs);
							io_printf(out,"%.*s<div class=\"boxRight infoLeft\">\n",ntabs++,tabs);
							printEventInfobox(out,ntabs,event);
							io_printf(out,"%.*s</div>\n",--ntabs,tabs);
							io_printf(out,"%.*s<div class=\"title\">%s</div>\n",ntabs,tabs,(event->title)?event->title:"&nbsp;");
							io_printf(out,"%.*s</td>\n",--ntabs,tabs);

							free(timerStr);
						} else {
							io_printf(out,"%.*s<td class=\"space\"></td>\n",ntabs,tabs);
							io_printf(out,"%.*s<td>&nbsp;</td>\n",ntabs,tabs);
							io_printf(out,"%.*s<td class=\"timers\">&nbsp;</td>\n",ntabs,tabs);
							io_printf(out,"%.*s<td class=\"title\">%s</td>\n",ntabs,tabs,(event->title)?event->title:"&nbsp;",ntabs,tabs);
						}
					}
					io_printf(out,"%.*s</tr>\n",--ntabs,tabs);
				}
				io_printf(out,"%.*s</tbody>\n",--ntabs,tabs);
				io_printf(out,"%.*s</table>\n",--ntabs,tabs);
			}
			freeNNL(&nnl);
			
		} else {

			// TODO generalizar nowNextList_t a eventList con numero de eventos por canal uno de {1=now,2={now,next},0=todos}
			// TODO chanelNum coincide siempre con idx+1?
			char *cmd;
			char * data;
			char * p;
			eventEntry_t event;
			time_t next_time=0;
			int previous_yday=-1;
			int pcbegin;
			int pcend;

			initEE(&event);
			sprintf(aux,"LSTE %d",channelNum);
			data=execSvdrp(host,aux);

			int retCode;
			int cont=0;
			for(p=strtok(data,"\r\n");p!=0;p=strtok(0,"\r\n")) {
				retCode=strtol(p,&p,10);
				if (retCode==215){
					p++;
					if (p[0]=='e') {
						next_time=event.start+event.duration;
						if (event.start>0) {
							if (cont==0){
								io_printf(out,"%.*s<h2>%s %s &raquo;%s&laquo;</h2>\n"
									,ntabs,tabs,tr("schedule"),tr("for"),channels.channel[channelNum-1].channelName);
								io_printf(out,"%.*s<table id=\"programs\" class=\"list1\" summary=\"%s\">\n",ntabs++,tabs,Schedule);
								io_printf(out,"%.*s<col class=\"hour\"/>\n",ntabs,tabs);
								io_printf(out,"%.*s<col class=\"timers\"/>\n",ntabs,tabs);
								io_printf(out,"%.*s<col class=\"pgName\"/>\n",ntabs,tabs);
								io_printf(out,"%.*s<thead>\n",ntabs++,tabs);
								io_printf(out,"%.*s"
									"<tr>"
										"<th>%s</th>"
										"<th class=\"timers\">%s</th>"
										"<th>%s</th>"
									"</tr>\n"
									,ntabs,tabs,tr("time"),tr("timers."),tr("program"));
								io_printf(out,"%.*s</thead>\n",--ntabs,tabs);
								
								io_printf(out,"%.*s<tbody>\n",ntabs++,tabs);
							}
							cont++;
							struct tm sdate=*localtime(&event.start);
							char *timerStr=makeOneTimeTimerStr(TF_ACTIVE,channelNum,event.start,next_time,50,99,event.title,NULL);
							if (previous_yday!=sdate.tm_yday) {
								previous_yday=sdate.tm_yday;
								io_printf(out,"%.*s"
									"<tr class=\"anotherDay\">"
										"<td colspan=\"3\">%s %s</td>"
									"</tr>\n"
									,ntabs,tabs,weekdays[langId][sdate.tm_wday],formatDate(&sdate,0));
							}
							io_printf(out,"%.*s<tr>\n",ntabs++,tabs);
							io_printf(out,"%.*s<td class=\"hour\">%02d:%02d</td>\n",ntabs,tabs,sdate.tm_hour,sdate.tm_min);
							
							io_printf(out,"%.*s<td class=\"timers\">\n",ntabs++,tabs);
							printTimers(out,ntabs,channelNum,event.start,event.duration,aux);
							io_printf(out,"%.*s</td>\n",--ntabs,tabs);
							
							u_urlncpy(aux,timerStr,strlen(timerStr),URLCPY_ENCODE);
							io_printf(out,"%.*s<td>\n",ntabs++,tabs);
							io_printf(out,"%.*s<div class=\"boxRight\">\n",ntabs++,tabs);
							io_printf(out,"%.*s<a class=\"ui-icon ui-icon-rec\" href=\"timers.kl1?a=%d&amp;timerStr=%s\" title=\"%s\">%s</a>\n"
								,ntabs,tabs,PA_EDIT,aux,TimerCreate,TimerCreate);
							io_printf(out,"%.*s</div>\n",--ntabs,tabs);
							io_printf(out,"%.*s<div class=\"boxRight infoLeft\">\n",ntabs++,tabs);
							printEventInfobox(out,ntabs,&event);
							io_printf(out,"%.*s</div>\n",--ntabs,tabs);
							io_printf(out,"%.*s<div class=\"title\">%s</div>\n",ntabs,tabs,(event.title)?event.title:"");
							io_printf(out,"%.*s</td>\n",--ntabs,tabs);
							
							io_printf(out,"%.*s</tr>\n",--ntabs,tabs);
							free(timerStr);
						} 
						freeEE(&event);
					} else {
						parseLineEvent(p[0],p+2,&event);
					}
				}
			}
			freeEE(&event);
			free(data);
			if (cont>0){
				io_printf(out,"%.*s</tbody>\n",--ntabs,tabs);
				io_printf(out,"%.*s</table>\n",--ntabs,tabs);
			} else {
				io_printf(out,"%.*s<div class=\"alert\">%s</div>",ntabs,tabs,tr("warnNoEPG"));
			}
		}
		freeTimerList(&timers);
		freeChannelList(&channels);
	}
	io_printf(out,"%.*s</div>\n",--ntabs,tabs);
	finishHtmlPage(out,ntabs);
end:
	closeSvdrpAll();
%>

