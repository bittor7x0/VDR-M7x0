<%!
/*
* 
* This source-code is licensed under GPL v2.
* See ../../LICENSE for details
* 
* (c) Christian Kelinski <k@kille.cx>
* Please checkout the README file!
* 
* Originally written for the open7x0.org VDR-FW project:
* www.open7x0.org
* 
* Modified for http://vdr-m7x0.foroactivo.com.es by:
* atinar <atinar1@hotmail.com>
* 
* You will need the KLONE web application development framework
* from www.koanlogic.com Version 2.
* 
*/

#include <klapp_conf.h>
#include <klone/utils.h>
#include <time.h>
#include <dirent.h>
#include <error.h>
#include <stdio.h>
#include <string.h>
#include <u/libu.h>

#include "i18n.h"
#include "misc.h"
#include "svdrp_comm.h"
#include "svdrp_parse.h"
#include "recordings.h"

enum readDirFlags_e {
	DF_ERROR = 0x0001,
	DF_INFO  = 0x0002,
	DF_DELE  = 0x0004,
	DF_SERIE = 0x0008
};

const char *classIsRec[]={""," recFolderRec"};
const char *classIsDel[]={""," recFolderDel"};
const char *classIsEdt[]={""," recFolderEdt"};

short htoi(unsigned char c) {
	return (c>='0' && c<='9') ? c-'0' : (c>='a' && c<='f') ? c-'a'+10 : (c>='A' && c<='F') ? c-'A'+10 : 0;
}

char * decodeName(char *name, boolean_t inplace, boolean_t *isEdt){
	char *dname=(inplace) ? name : strdup(name);
	char *s, *d;
	s=d=dname;
	if (s[0]=='%'){
		if (isEdt) *isEdt=BT_TRUE;
		s++;
	} else {
		if (isEdt) *isEdt=BT_FALSE;
	}
	while (s[0]!=0) {
		if (s[0]=='#' && isxdigit(s[1]) && isxdigit(s[2])) {
			*d= htoi(s[1]) << 4 | htoi(s[2]);
			s+=2;
		} else if (d<=s){
			*d=(*s=='_') ? ' ' : *s;
		}
		s++;
		d++;
	}
	d[0]=0;
	return dname;
}

int printRecDir(char **io_str,const char * path, char * const pathEnc, int level, int * numF, int * numD) {
	int result=0;
	DIR *dir = opendir(path); 
	if (dir == 0) {
		result |= DF_ERROR;
		return result;
	}
	struct dirent* dirE; 
	recInfo_t info;
	while(0 != (dirE = readdir(dir))) { 
		const char* name = dirE->d_name; 
		if (strcmp(name,"info.vdr")==0) {
			result |= DF_INFO;
			char *path2;
			if (asprintf(&path2,"%s/%s",path,name)>0){
				initRI(&info);
	    		if (readRecInfo(&info,path2)) {
					u_urlncpy(pathEnc,path,strlen(path),URLCPY_ENCODE);
					int minutes = (info.stop - info.start)/60;
					io_printf(out,
"							<div class=\"recInfo\">\n"
"								<a class=\"ui-icon ui-icon-play\" href=\"playlistrec.kl1?path=%s\">%s</a>"
								"<div class=\"recDate\">"
									"<span class=\"recStart field\">"
										"<span class=\"label\">%s:</span>&nbsp;<span class=\"value\">%s</span>"
									"</span> "
									"<span class=\"recDuration field\">"
										"<span class=\"label\">%s:</span>&nbsp;<span class=\"value\">%d&#39;</span>"
									"</span>"
								"</div>\n"
						,pathEnc
						,tr("play")
						,tr("date"),formatDate(localtime(&info.start),1)
						,tr("runtime"),minutes
					);
					if (info.desc!=NULL) {
						io_printf(out,
"								<div class=\"recDesc\">"
									"%s"
								"</div>\n"
						,info.desc);
					}
					io_printf(out,
"							</div>");
	    			result |= DF_INFO;
	    		}
				freeRI(&info);
	    		free(path2);
			} else {
				result |= DF_ERROR;
			}
			return result;

		} else if (dirE->d_type==DT_DIR) {
			if ( (name[0]=='.' && (name[1]==0 || (name[1]=='.' && name[2]==0)))  ){
				continue;
			}
			char *path2;
			if (asprintf(&path2,"%s/%s",path,name)<0) {
				result |= DF_ERROR;
				return result;
			}
			if (strcmp(name,"_")==0) {
				result |= DF_SERIE;
				printRecDir(NULL,path2,pathEnc,level,numF,numD);
			} else {
				int isRec=(strcmp(name+(strlen(name)-4),".rec")==0);
				int isDel=(strcmp(name+(strlen(name)-4),".del")==0);
				if (level==0){
					*numF=0; 
					*numD=0;
					boolean_t isEdt;
					char *dname=decodeName((char *)name,BT_FALSE,&isEdt);
					io_printf(out,
"				<div class=\"recFolderWrapper\">\n"
"					<div class=\"recFolder%s%s%s\">\n"
"						<div class=\"recFolderHeader\">\n"
						,classIsRec[isRec],classIsDel[isDel],classIsEdt[isEdt]
					);
					if (isRec || isDel) {
						io_printf(out,dname);
					} else {
						u_urlncpy(pathEnc,path2+16,strlen(path2+16),URLCPY_ENCODE);
						io_printf(out,
							"<a href=\"browse.kl1?path=%s\">%s</a>"
							,pathEnc,dname);
					}
					free(dname);
					io_printf(out,
"						</div>\n"
"						<div class=\"recFolderDetails\">\n"
					);
					printRecDir(NULL,path2,pathEnc,level+1,numF,numD);
					io_printf(out,
"						</div>\n"
"						<div class=\"recFolderFooter\">"
					);
    				if (*numD>0) {
						io_printf(out,
							"<span class=\"field\">"
								"<span class=\"label\">%s:</span> <span class=\"value\">%d</span>"
							"</span>",tr("subfolders"),*numD);
					}
    				if (*numF>0) {
						io_printf(out,
							"<span class=\"field\">"
								"<span class=\"label\">%s:</span> <span class=\"value\">%d</span>"
							"</span>",tr("recordings"),*numF);
					}
					io_printf(out,
						"</div>\n"
"					</div>\n"
"				</div>"
					);
				} else {
					if ( isRec || isDel ) {
						*numF+=1;
						if (isDel) result|=DF_DELE;
						int na, nb;
						printRecDir(NULL,path2,pathEnc,level+1,&na,&nb);
					} else {	
						*numD+=1;
					}
				}
			}
			free(path2);
		}
	}
	return result;
}

#ifdef DEBUG
void dbg_browse_kl1(void) { dbg("browse.kl1"); }
#endif

%><%

	#ifdef DEBUG
	dbg_browse_kl1();
	#endif

	config(session, request);
	currentPage=PN_BROWSE;
	printXhtmlHead(out,tr("browse"),NULL);
	printMenu(out);

	vars_t *args = request_get_args(request);
	char pathEnc[1024];
	char * pathStr=strdup( (vars_countn(args, "path")>0) ? vars_get_value(args,"path") : "" );
	char * p;
	for (p=pathStr+strlen(pathStr)-1;(p>=pathStr) && (*p=='/' || *p=='_');p--) {
		*p=0;
	}
	char * videoPath;
	if (strlen(pathStr)>0) {
		if (asprintf(&videoPath,"/var/vdr/video0/%s",pathStr)<0){
			warn("No hay memoria para videoPath");
			videoPath=NULL;
			//TODO 
		}
	} else {
		videoPath=strdup("/var/vdr/video0");
	}

	io_printf(out,
"		<div id=\"main\" class=\"content\">\n"
"			<h2>%s</h2>\n"
"			<div class=\"section\">\n"
"				<div class=\"recPathWrapper\">\n"
"					<ul class=\"recPath\">\n"
"						<li class=\"recDir\">"
							"<a%s href=\"browse.kl1\">%s</a>"
						"</li>\n"
		,tr("recordings")
		,classCurrent[boolean(strlen(pathStr)==0)],tr("recordings")
	);
				
	if (strlen(pathStr)>0) {
		char * bc;
		char * bcPath=malloc(strlen(pathStr)+2);
		if (bcPath!=NULL) {
			char * s=strdup(pathStr);
			if (s!=NULL){
				bcPath[0]=0;
				char *next=strtok(s,"/");
				for(bc=next;bc!=0;bc=next) {
					next=strtok(0,"/");
					strcat(bcPath,bc);
					if (strcmp(bc,"_")!=0) {
						u_urlncpy(pathEnc,bcPath,strlen(bcPath),URLCPY_ENCODE);
						io_printf(out,
"					<li class=\"recDir\">"
						"<a%s href=\"browse.kl1?path=%s\">%s</a>"
					"</li>\n"
						,classCurrent[boolean(!next)]
						,pathEnc
						,decodeName(bc,BT_TRUE,NULL));
					}
					strcat(bcPath,"/");
				}
				free(s);
			}
			free(bcPath);
		}
	}
	io_printf(out,
"					</ul>\n"
"				</div>\n"
"				<div class=\"recFolders\">\n"
	);
	int numF, numD;
	printRecDir(NULL,videoPath,pathEnc,0,&numF,&numD);
	free(videoPath);
	free(pathStr);
	io_printf(out,
"					<div class=\"clearer\"></div>\n"
"				</div>\n"
"			</div>\n"
"		</div>\n"
	);
	printFooter(out);
%>

