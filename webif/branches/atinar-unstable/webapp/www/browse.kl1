<%!
/*
* 
* This source-code is licensed under GPL v2.
* See ../../LICENSE for details
* 
* (c) Christian Kelinski <k@kille.cx>
* Please checkout the README file!
* 
* Originally written for the open7x0.org VDR-FW project:
* www.open7x0.org
* 
* Modified for http://vdr-m7x0.foroactivo.com.es by:
* atinar <atinar1@hotmail.com>
* 
* You will need the KLONE web application development framework
* from www.koanlogic.com Version 2.
* 
*/

#include <klapp_conf.h>
#include <klone/utils.h>
#include <time.h>
#include <dirent.h>
#include <error.h>
#include <stdio.h>
#include <string.h>
#include <u/libu.h>

#include "epg.h"
#include "i18n.h"
#include "misc.h"
#include "svdrp_comm.h"
#include "svdrp_parse.h"
#include "recordings.h"

enum readDirFlags_e {
	DF_ISREC   = 0x0001,
	DF_HASRECS = 0x0002,
	DF_EDITED  = 0x0004,
	DF_DELETED = 0x0008,
	DF_ISSERIE = 0x0010,
	DF_INFO    = 0x0020,
};

const char *classIsRec[]={""," recRecRec"};
const char *classIsDel[]={""," recRecDel"};
const char *classIsEdt[]={""," recRecEdt"};

typedef struct recDir_s recDir_t;
typedef struct recDirList_s {
	int length;
	recDir_t *entry;
} recDirList_t;
struct recDir_s {
	char *name;
	char *dname;
	int flags;
	int numRecs;
	int numDirs;
	int numDels;
	recDirList_t subdirs;
};

void initRecDir(recDir_t *recDir){
	recDir->name=NULL;
	recDir->dname=NULL;
	recDir->flags=0;
	recDir->numRecs=0;
	recDir->numDirs=0;
	recDir->numDels=0;
	recDir->subdirs.length=0;
	recDir->subdirs.entry=NULL;
}
void freeRecDirList(recDirList_t *recDirList);
void freeRecDir(recDir_t *recDir){
	free(recDir->name);
	free(recDir->dname);
	freeRecDirList(&recDir->subdirs);
	initRecDir(recDir); 
}
void freeRecDirList(recDirList_t *recDirList){
	int i=0;
	recDir_t *recDir;
	for(i=0,recDir=recDirList->entry;i<recDirList->length;i++,recDir++){
		freeRecDir(recDir);
	}
	free(recDirList->entry);
}

int compareRecDir(const void * a, const void * b) {
	const recDir_t * ta=(const recDir_t *)a;
	const recDir_t * tb=(const recDir_t *)b;
	return (ta->flags!=tb->flags)
	? tb->flags-ta->flags
	: strcmp((ta->dname)?ta->dname:ta->name,(tb->dname)?tb->dname:tb->name);
}

char * vdrDecodeName(char *name, boolean_t inPlace, boolean_t *isEdt){
	char *dname=(inPlace) ? name : strdup(name);
	char *s;
	s=name;
	if (s[0]=='%'){
		if (isEdt) *isEdt=BT_TRUE;
		s++;
	} else {
		if (isEdt) *isEdt=BT_FALSE;
	}
	vdrDecode(dname,s);
	return dname;
}

boolean_t printRecInfo(io_t *out,const char * const tabs,const char * path, char * const urlEnc){
	boolean_t result=BT_FALSE;
	recInfo_t info;
	initRI(&info);
	if (readRecInfo(path,&info)) {
		int minutes = (info.stop - info.start)/60;
		io_printf(out,
"%s<div class=\"recInfo\">\n"
"%s	<div class=\"recDate\">"
		"<span class=\"recStart field\">"
			"<span class=\"label\">%s:</span>&nbsp;<span class=\"value\">%s</span>"
		"</span> "
		"<span class=\"recDuration field\">"
			"<span class=\"label\">%s:</span>&nbsp;<span class=\"value\">%d&#39;</span>"
		"</span>\n"
"%s	</div>\n"
		,tabs
		,tabs
		,tr("date"),formatDate(localtime(&info.start),1)
		,tr("runtime"),minutes
		,tabs
		);
		if (info.desc!=NULL) {
			char *tabs2;
			asprintf(&tabs2,
"%s	",tabs);
			printEventDesc(out,tabs2,info.desc);
			free(tabs2);
		}
		io_printf(out,
"%s</div>\n",tabs);
		result=BT_TRUE;
	}
	freeRI(&info);
	return result;
}

void parseRecDir(const char * const path,recDir_t * const recDir) {
	DIR *dir = opendir(path);
	if (dir == 0) {
		return;
	}
	struct dirent* dirE;
	recDir_t *recDir2;
	while(0 != (dirE = readdir(dir))) {
		if (dirE->d_type==DT_DIR) {
			const char* name = dirE->d_name; 
			if ( (name[0]=='.' && (name[1]==0 || (name[1]=='.' && name[2]==0)))  ){
				continue;
			}
			recDir->subdirs.length++;
			recDir->subdirs.entry=(recDir_t *)realloc(recDir->subdirs.entry,recDir->subdirs.length*sizeof(recDir_t));
			crit_goto_if(recDir->subdirs.entry==NULL,outOfMemory);
			recDir2=recDir->subdirs.entry+(recDir->subdirs.length-1);
			initRecDir(recDir2);
			recDir2->name=strdup(name);
			crit_goto_if(recDir2->name==NULL,outOfMemory);
			if (strcmp(name,"_")==0) {
				recDir->flags |= DF_ISSERIE;
			} else {
				boolean_t isRec=boolean(strcmp(name+(strlen(name)-4),".rec")==0);
				boolean_t isDel=boolean(!isRec && strcmp(name+(strlen(name)-4),".del")==0);
				boolean_t isEdt=BT_FALSE;
				if ( isRec || isDel ) {
					recDir2->flags|=DF_ISREC;
					recDir->flags|=DF_HASRECS;
					recDir->numRecs++;
					if (isDel) {
						recDir2->flags|=DF_DELETED;
						recDir->numDels++;
					} 
				} else {
					recDir2->dname=vdrDecodeName((char *)name,BT_FALSE,&isEdt);
					char *path2;
					crit_goto_if(asprintf(&path2,"%s/%s",path,name)<0,outOfMemory);
					parseRecDir(path2,recDir2);
					free(path2);
					recDir->numRecs+=recDir2->numRecs;
					recDir->numDels+=recDir2->numDels;
					if (!isFlagSet(DF_HASRECS,recDir2->flags)){
						recDir->numDirs+=recDir2->numDirs+1;
					}
				}
			}
		}
	}
	if (recDir->subdirs.length>0){
		qsort(recDir->subdirs.entry,recDir->subdirs.length,sizeof(recDir_t),compareRecDir);
		int i;
		boolean_t allDeleted=BT_TRUE;
		for (i=0,recDir2=recDir->subdirs.entry;i<recDir->subdirs.length;i++,recDir2++){
			if (!isFlagSet(DF_DELETED,recDir2->flags)) {
				allDeleted=BT_FALSE;
				break;
			}
		}
		if (allDeleted) {
			recDir->flags|=DF_DELETED;
		}
	}
	return;
outOfMemory:
	crit("parseRecDir:out of memory");
	exit(1);
}

void printRecDirList(io_t *out,const char * const tabs,const char *const path,recDirList_t *recDirList,char *const urlEnc,int level);

void printRecDir(io_t *out,const char * const tabs,const char *const path,recDir_t *recDir,char *const urlEnc,int level) {
	char *tabs2;
	const char * const Play=tr("play");
	const char * const Browse=tr("browse");
	if (level==0){
		io_printf(out,
"%s<li class=\"recFolderWrapper\">\n"
"%s	<div class=\"recFolder%s\">\n"
		,tabs
		,tabs,classIsDel[isFlagSet(DF_DELETED,recDir->flags)]
		);
		io_printf(out,
"%s		<div class=\"recFolderHeader\">\n"
"%s			<ul class=\"controls ui-widget ui-helper-clearfix\">\n"
"%s				<li class=\"control ui-state-default ui-corner-all\">"
			,tabs
			,tabs
			,tabs
		);
		if ( recDir->subdirs.length==0 && isFlagSet(DF_ISREC,recDir->flags)) {
			u_urlncpy(urlEnc,path,strlen(path),URLCPY_ENCODE);
			io_printf(out,
					"<a href=\"playlistrec.kl1?path=%s\" class=\"ui-icon ui-icon-play\" title=\"%s\">%s</a>"
				"</li>\n"
"%s			</ul>\n"
"%s			%s\n"
"%s		</div>\n"
			,urlEnc,Play,Play
			,tabs
			,tabs,recDir->name
			,tabs
			); //TODO formatear fecha
			io_printf(out,
"%s		<div class=\"recFolderDetails\">\n",tabs);
			asprintf(&tabs2,
"%s			",tabs);  
			printRecInfo(out,tabs2,path,urlEnc);
			free(tabs2);
			io_printf(out,
"%s		</div>\n",tabs);
		} else if ( recDir->subdirs.length==1 && isFlagSet(DF_ISREC,recDir->subdirs.entry[0].flags)) {
			char *path2;
			asprintf(&path2,"%s/%s",path,recDir->subdirs.entry[0].name);
			u_urlncpy(urlEnc,path2,strlen(path2),URLCPY_ENCODE);
			io_printf(out,
					"<a href=\"playlistrec.kl1?path=%s\" class=\"ui-icon ui-icon-play\" title=\"%s\">%s</a>"
				"</li>\n"
"%s			</ul>\n"
"%s			%s\n"
"%s		</div>\n"
			,urlEnc,Play,Play
			,tabs
			,tabs,(recDir->dname!=NULL)?recDir->dname:recDir->name
			,tabs
			);
			io_printf(out,
"%s		<div class=\"recFolderDetails\">\n",tabs);
			asprintf(&tabs2,
"%s			",tabs);  
			printRecInfo(out,tabs2,path2,urlEnc);
			free(tabs2);
			io_printf(out,
"%s		</div>\n",tabs);
		} else {
			u_urlncpy(urlEnc,path+16,strlen(path+16),URLCPY_ENCODE);
			io_printf(out,
					"<a href=\"browse.kl1?path=%s\" class=\"ui-icon ui-icon-folder-rec\" title=\"%s\">%s</a>"
				"</li>\n"
"%s			</ul>\n"
"%s			%s\n"
"%s		</div>\n"
			,urlEnc,Browse,Browse
			,tabs
			,tabs,(recDir->dname!=NULL)?recDir->dname:recDir->name
			,tabs
			);
			asprintf(&tabs2,
"%s		",tabs);  
			printRecDirList(out,tabs2,path,&recDir->subdirs,urlEnc,level+1);
			free(tabs2);
			io_printf(out,
"%s		<ul class=\"recFolderFooter\">\n"
			,tabs);
			if (recDir->numDirs>0) {
				io_printf(out,
"%s			<li class=\"field\"><span class=\"label\">%s:</span> <span class=\"value\">%d</span></li>\n"
					,tabs,tr("subfolders"),recDir->numDirs);
				}
				if (recDir->numRecs>0) {
					io_printf(out,
"%s			<li class=\"field\"><span class=\"label\">%s:</span> <span class=\"value\">%d</span></li>\n"
					,tabs,tr("recordings"),recDir->numRecs
					);
				}
				io_printf(out,
"%s		</ul>\n",tabs
				);
		}
		io_printf(out,
"%s	</div>\n"
"%s</li>\n"
		,tabs,tabs,tabs);
	} else { //level>0
		if (recDir->subdirs.length==0 && isFlagSet(DF_ISREC,recDir->flags)) {
			u_urlncpy(urlEnc,path,strlen(path),URLCPY_ENCODE);
			io_printf(out,
"%s<li class=\"recRec%s\">\n"
"%s	<ul class=\"controls ui-widget ui-helper-clearfix\">\n"
"%s		<li class=\"control ui-state-default ui-corner-all\">"
			"<a href=\"playlistrec.kl1?path=%s\" class=\"ui-icon ui-icon-play\" title=\"%s\">%s</a>"
		"</li>\n"
"%s	</ul>\n"
"%s	%s\n"
"%s</li>\n"
			,tabs,classIsDel[isFlagSet(DF_DELETED,recDir->flags)]
			,tabs
			,tabs
			,urlEnc,Play,Play
			,tabs
			,tabs,recDir->name
			,tabs
			); //TODO formatear fecha
		} else if (recDir->subdirs.length==1 && isFlagSet(DF_ISREC,recDir->subdirs.entry[0].flags)) {
			char *path2;
			asprintf(&path2,"%s/%s",path,recDir->subdirs.entry[0].name);
			u_urlncpy(urlEnc,path2,strlen(path2),URLCPY_ENCODE);
			io_printf(out,
"%s<li class=\"recRec%s\">\n"
"%s	<ul class=\"controls ui-widget ui-helper-clearfix\">\n"
"%s		<li class=\"control ui-state-default ui-corner-all\">"
			"<a href=\"playlistrec.kl1?path=%s\" class=\"ui-icon ui-icon-play\" title=\"%s\">%s</a>"
		"</li>\n"
"%s	</ul>\n"
"%s	%s\n"
"%s</li>\n"
			,tabs,classIsDel[isFlagSet(DF_DELETED,recDir->flags)]
			,tabs
			,tabs
			,urlEnc,Play,Play
			,tabs
			,tabs,(recDir->dname!=NULL)?recDir->dname:recDir->name
			,tabs
			);
		} else {
			u_urlncpy(urlEnc,path+16,strlen(path+16),URLCPY_ENCODE);
			io_printf(out,
"%s<li class=\"recFolder\">\n"
"%s	<div class=\"recFolderHeader\">\n"
"%s		<ul class=\"controls ui-widget ui-helper-clearfix\">\n"
"%s			<li class=\"control ui-state-default ui-corner-all\">"
				"<a href=\"browse.kl1?path=%s\" class=\"ui-icon ui-icon-folder-rec\" title=\"%s\">%s</a>"
			"</li>\n"
"%s		</ul>\n"
"%s		%s\n"
"%s	</div>\n"
			,tabs
			,tabs
			,tabs
			,tabs
			,urlEnc,Browse,Browse
			,tabs
			,tabs,(recDir->dname!=NULL)?recDir->dname:recDir->name
			,tabs
			);
			asprintf(&tabs2,
"%s	",tabs);  
			printRecDirList(out,tabs2,path,&recDir->subdirs,urlEnc,level+1);
			free(tabs2);
			io_printf(out,
"%s</li>\n"	,tabs);
		}
	}
	return;
outOfMemory:
	crit("printRecDir:out of memory");
	exit(1);
}

void printRecDirList(io_t *out,const char * const tabs,const char *const path,recDirList_t *recDirList,char *const urlEnc,int level) {
	if (recDirList==NULL || recDirList->length<1) return;
	io_printf(out,
"%s<ul class=\"recFolders\">\n",tabs
	);
	char tabs2[strlen(tabs)+2];
	sprintf(tabs2,"%s	",tabs);
	int i;
	recDir_t *recDir;
	for(i=0,recDir=recDirList->entry;i<recDirList->length;i++,recDir++){
		char *path2;
		crit_goto_if(asprintf(&path2,"%s/%s",path,recDir->name)<0,outOfMemory);
		printRecDir(out,tabs2,path2,recDir,urlEnc,level);
		free(path2);
	}
	io_printf(out,
"%s</ul>\n",tabs
	);
	return;
outOfMemory:
	crit("printRecDirList:out of memory");
	exit(1);
}

#ifdef DEBUG
void dbg_browse_kl1(void) { dbg("browse.kl1"); }
#endif

%><%

	#ifdef DEBUG
	dbg_browse_kl1();
	#endif

	config(session, request);
	currentPage=PN_BROWSE;
	initHtmlPage(response,out,tr("browse"),NULL);
	printMenu(out);

	vars_t *args = request_get_args(request);
	char urlEnc[4096];
	recDir_t recDir;
	initRecDir(&recDir);
	char * pathStr=strdup( (vars_countn(args, "path")>0) ? vars_get_value(args,"path") : "" );
	char * p;
	for (p=pathStr+strlen(pathStr)-1;(p>=pathStr) && (*p=='/' || *p=='_');p--) {
		*p=0;
	}
	char * videoPath;
	if (strlen(pathStr)>0) {
		if (asprintf(&videoPath,"/var/vdr/video0/%s",pathStr)<0) videoPath=NULL;
	} else {
		videoPath=strdup("/var/vdr/video0");
	}
	if (videoPath==NULL){
		crit("browse.kl1: out of memory");
		exit(1);
	}
	io_printf(out,
"		<div id=\"main\" class=\"content\">\n"
"			<h2>%s</h2>\n"
"			<div class=\"section\">\n"
"				<div class=\"recPathWrapper\">\n"
"					<ul class=\"recPath\">\n"
"						<li class=\"recDir\">"
							"<a%s href=\"browse.kl1\">%s</a>"
						"</li>\n"
		,tr("recordings")
		,classCurrent[boolean(strlen(pathStr)==0)],tr("recordings")
	);
				
	if (strlen(pathStr)>0) {
		char * bc;
		char * bcPath=malloc(strlen(pathStr)+2);
		if (bcPath!=NULL) {
			char * s=strdup(pathStr);
			if (s!=NULL){
				bcPath[0]=0;
				char *next=strtok(s,"/");
				for(bc=next;bc!=0;bc=next) {
					next=strtok(0,"/");
					strcat(bcPath,bc);
					if (strcmp(bc,"_")!=0) {
						u_urlncpy(urlEnc,bcPath,strlen(bcPath),URLCPY_ENCODE);
						io_printf(out,
"					<li class=\"recDir\">"
						"<a%s href=\"browse.kl1?path=%s\">%s</a>"
					"</li>\n"
						,classCurrent[boolean(!next)]
						,urlEnc
						,vdrDecodeName(bc,BT_TRUE,NULL));
					}
					strcat(bcPath,"/");
				}
				free(s);
			}
			free(bcPath);
		}
	}
	io_printf(out,
"					</ul>\n"
"				</div>\n"
	);
	recDir.name=strdup(strlen(videoPath)>0?videoPath+16:tr("recordings"));
	parseRecDir(videoPath,&recDir);
	printRecDirList(out,
"				",videoPath,&recDir.subdirs,urlEnc,0);
	free(videoPath);
	free(pathStr);
	io_printf(out,
"			</div>\n"
"		</div>\n"
	);
	freeRecDir(&recDir);
	finishHtmlPage(out);
%>

