diff -Naur VDR-NG-EM-orig/device.c VDR-NG-EM/device.c
--- VDR-NG-EM-orig/device.c	2008-03-23 13:01:54.000000000 +0100
+++ VDR-NG-EM/device.c	2008-03-29 11:41:31.000000000 +0100
@@ -22,120 +22,188 @@
 bool scanning_on_receiving_device = false;
 
 // --- cPesAssembler ---------------------------------------------------------
+//M7X0 BEGIN AK
+#define REPLAY_MAX_UNUSABLE_DATA KILOBYTE(512)
 
 class cPesAssembler {
 private:
-  uchar *data;
-  uint32_t tag;
-  int length;
-  int size;
-  bool Realloc(int Size);
+  uchar fragmentData[6 + 65535];
+  int fragmentLength;
+  const uchar *packetData;
+  int packetLength;
+  int streamId;
+  int skippedBytes;
+  uint32_t scanner;
+  bool initialSync;
+
+  bool ScanForStartCode(const uchar *&Data, int Length);
 public:
   cPesAssembler(void);
-  ~cPesAssembler();
-  int ExpectedLength(void) { return PacketSize(data); }
-  static int PacketSize(const uchar *data);
-  int Length(void) { return length; }
-  const uchar *Data(void) { return data; } // only valid if Length() >= 4
   void Reset(void);
-  void Put(uchar c);
-  void Put(const uchar *Data, int Length);
-  bool IsPes(void);
+  const uchar *Packet(int &Length) const;
+  int Put(const uchar *Data, int Length);
+  // This has not been implemented. What should it do?
+  // bool IsPes(void);
   };
 
 cPesAssembler::cPesAssembler(void)
 {
-  data = NULL;
-  size = 0;
   Reset();
 }
 
-cPesAssembler::~cPesAssembler()
+void cPesAssembler::Reset(void)
 {
-  free(data);
+  packetData = NULL;
+  packetLength = 0;
+  fragmentData[0] = fragmentData[1] = 0;
+  fragmentData[1] = 1;
+  fragmentLength = 0;
+  streamId = 0;
+  scanner = 0xFFFFFFFF;
+  skippedBytes = 0;
+  initialSync = true;
+}
+
+const uchar *cPesAssembler::Packet(int &Length) const
+{
+  if (streamId != 0 & packetLength != 0 &
+        (fragmentLength == 0 | packetLength == fragmentLength)) {
+     Length = packetLength;
+     return (!fragmentLength ? packetData : fragmentData);
+     }
+  return NULL;
 }
 
-void cPesAssembler::Reset(void)
+bool cPesAssembler::ScanForStartCode(const uchar *&Data,int Length)
 {
-  tag = 0xFFFFFFFF;
-  length = 0;
+  register const uchar *data = Data;
+
+  // Normal case - No need to sync
+  // I think this hit in 99% of cases.
+  // If this hit, there cannot be a part startcode in scanner
+  // since data[0] is 0
+  if (Length >= 4 && (!(data[0] | data[1] | (data[2] - 1)) & data[3] >= 0xBA
+         & data[3] <= 0xEF)) {
+     scanner = 0xFFFFFFFF;
+     packetLength = 0;
+     streamId = data[3];
+     fragmentLength = 0;
+     return true;
+     }
+
+  for (int i = 0; i < 3 & i < Length ; i++) {
+      if ((scanner & 0xFFFFFF) == 0x000001 & data[i] >= 0xBA
+            & data[i] <= 0xEF) {
+         scanner = 0xFFFFFFFF;
+         packetLength = 0;
+         streamId = data[i];
+         fragmentLength = 3 - i;
+         skippedBytes -= 3 - i;
+         return true;
+         }
+      scanner = (scanner << 8) | data[i];
+      }
+
+  if (Length <= 3) {
+     skippedBytes += Length;
+     return false;
+     }
+
+  register const uchar *const limit = data + Length - 1;
+  data += 2;
+
+  while (data < limit)
+        if (data[0] > 1)
+           data += 3;
+        else if (!data[0])
+           data++;
+        else {
+           if (!(data[-2] | data[-1])) {
+              register const uchar code = *++data;
+              if (code >= 0xBA && code <= 0xEF) {
+                 scanner = 0xFFFFFFFF;
+                 packetLength = 0;
+                 streamId = code;
+                 fragmentLength = 0;
+                 skippedBytes += data - 3 - Data;
+                 Data = data - 3;
+                 return true;
+                 }
+              }
+           data += 3;
+           }
+
+  scanner = BE2HOST(get_unaligned((uint32_t *)(limit - 3)));
+  skippedBytes += limit + 1 - Data;
+  return false;
 }
 
-bool cPesAssembler::Realloc(int Size)
+int cPesAssembler::Put(const uchar *Data, int Length)
 {
-  if (Size > size) {
-     size = max(Size, 2048);
-     data = (uchar *)realloc(data, size);
-     if (!data) {
-        esyslog("ERROR: can't allocate memory for PES assembler");
-        length = 0;
-        size = 0;
-        return false;
+  const uchar *data = Data;
+
+  if (streamId != 0 & packetLength != 0 &
+        (fragmentLength == 0 | packetLength == fragmentLength)) {
+     streamId = 0;
+     }
+
+  if (!streamId && !ScanForStartCode(data, Length)) {
+     if (skippedBytes >= REPLAY_MAX_UNUSABLE_DATA) {
+        esyslog("ERROR: %d bytes of recoding unusable - giving up!", skippedBytes);
+        errno = EDEADLK; // Any ideas for a better errorcode
+        return -1;
         }
+     return Length;
      }
-  return true;
-}
 
-void cPesAssembler::Put(uchar c)
-{
-  if (length < 4) {
-     tag = (tag << 8) | c;
-     if ((tag & 0xFFFFFF00) == 0x00000100) {
-        if (Realloc(4)) {
-           *(uint32_t *)data = htonl(tag);
-           length = 4;
-           }
+  if (skippedBytes) {
+     if (!initialSync) {
+        esyslog("WARNING: %d bytes of recoding unusable!", skippedBytes);
         }
-     else if (length < 3)
-        length++;
+     skippedBytes = 0;
+     initialSync = false;
      }
-  else if (Realloc(length + 1))
-     data[length++] = c;
-}
 
-void cPesAssembler::Put(const uchar *Data, int Length)
-{
-  while (length < 4 && Length > 0) {
-        Put(*Data++);
-        Length--;
+  Length -= data - Data;
+  if (!packetLength) {
+     if (fragmentLength + Length < 6) {
+        memcpy(fragmentData + fragmentLength, data, Length);
+        fragmentLength += Length;
+        return (data - Data + Length);
+        }
+
+     int b1 = fragmentLength < 5 ? data[4-fragmentLength] : fragmentData[4];
+
+     if (streamId != 0xBA) {
+        int b2 = fragmentLength < 6 ? data[5-fragmentLength] : fragmentData[5];
+        packetLength = 6 + ((b1 << 8) | b2);
+        }
+     else {
+        // Mpeg 1 / 2 Pack Headers have different length
+        if (b1 & 0xC0) { // MPEG2
+           if (fragmentLength + Length < 14) {
+              memcpy(fragmentData + fragmentLength, data, Length);
+              fragmentLength += Length;
+              return (data - Data + Length);
+              }
+           int b2 = fragmentLength < 14 ? data[13-fragmentLength] : fragmentData[13];
+           packetLength = 14 + (b2 & 0x7); // 14 + Stuffing length
+           }
+        else  // MPEG1
+           packetLength = 12;
         }
-  if (Length && Realloc(length + Length)) {
-     memcpy(data + length, Data, Length);
-     length += Length;
      }
-}
 
-int cPesAssembler::PacketSize(const uchar *data)
-{
-  // we need atleast 6 bytes of data here !!!
-  switch (data[3]) {
-    default:
-    case 0x00 ... 0xB8: // video stream start codes
-    case 0xB9: // Program end
-    case 0xBC: // Programm stream map
-    case 0xF0 ... 0xFF: // reserved
-         return 6;
-
-    case 0xBA: // Pack header
-         if ((data[4] & 0xC0) == 0x40) // MPEG2
-            return 14;
-         // to be absolutely correct we would have to add the stuffing bytes
-         // as well, but at this point we only may have 6 bytes of data avail-
-         // able. So it's up to the higher level to resync...
-         //return 14 + (data[13] & 0x07); // add stuffing bytes
-         else // MPEG1
-            return 12;
-
-    case 0xBB: // System header
-    case 0xBD: // Private stream1
-    case 0xBE: // Padding stream
-    case 0xBF: // Private stream2 (navigation data)
-    case 0xC0 ... 0xCF: // all the rest (the real packets)
-    case 0xD0 ... 0xDF:
-    case 0xE0 ... 0xEF:
-         return 6 + data[4] * 256 + data[5];
-    }
+  if (fragmentLength != 0 | Length < packetLength) {
+     int bite = min(packetLength - fragmentLength, Length);
+     memcpy(fragmentData + fragmentLength, data, bite);
+     fragmentLength += bite;
+     return (data - Data + bite);
+     }
+  packetData = data;
+  return (data - Data + packetLength);
 }
+//M7X0 END AK
 
 // --- cDevice ---------------------------------------------------------------
 
@@ -1271,88 +1339,105 @@
 {
   return -1;
 }
-
+// M7X0 BEGIN AK
 int cDevice::PlayPesPacket(const uchar *Data, int Length, bool VideoOnly)
 {
-  cMutexLock MutexLock(&mutexCurrentAudioTrack);
-  bool FirstLoop = true;
-  uchar c = Data[3];
-  const uchar *Start = Data;
-  const uchar *End = Start + Length;
-  while (Start < End) {
-        int d = End - Start;
-        int w = d;
-        switch (c) {
-          case 0xBE:          // padding stream, needed for MPEG1
-          case 0xE0 ... 0xEF: // video
-               w = PlayVideo(Start, d);
-               break;
-          case 0xC0 ... 0xDF: // audio
-               SetAvailableTrack(ttAudio, c - 0xC0, c);
-               if (!VideoOnly && c == availableTracks[currentAudioTrack].id) {
-                  w = PlayAudio(Start, d, c);
-                  if (FirstLoop)
-                     Audios.PlayAudio(Data, Length, c);
-                  }
-               break;
-          case 0xBD: { // private stream 1
-               int PayloadOffset = Data[8] + 9;
-               uchar SubStreamId = Data[PayloadOffset];
-               uchar SubStreamType = SubStreamId & 0xF0;
-               uchar SubStreamIndex = SubStreamId & 0x1F;
-
-               // Compatibility mode for old VDR recordings, where 0xBD was only AC3:
-pre_1_3_19_PrivateStreamDeteced:
-               if (pre_1_3_19_PrivateStream) {
-                  SubStreamId = c;
-                  SubStreamType = 0x80;
-                  SubStreamIndex = 0;
-                  }
-               switch (SubStreamType) {
-                 case 0x20: // SPU
-                 case 0x30: // SPU
-                      break;
-                 case 0x80: // AC3 & DTS
-                      if (Setup.UseDolbyDigital) {
-                         SetAvailableTrack(ttDolby, SubStreamIndex, SubStreamId);
-                         if (!VideoOnly && SubStreamId == availableTracks[currentAudioTrack].id) {
-                            w = PlayAudio(Start, d, SubStreamId);
-                            if (FirstLoop)
-                               Audios.PlayAudio(Data, Length, SubStreamId);
-                            }
-                         }
-                      break;
-                 case 0xA0: // LPCM
-                      SetAvailableTrack(ttAudio, SubStreamIndex, SubStreamId);
-                      if (!VideoOnly && SubStreamId == availableTracks[currentAudioTrack].id) {
-                         w = PlayAudio(Start, d, SubStreamId);
-                         if (FirstLoop)
-                            Audios.PlayAudio(Data, Length, SubStreamId);
-                         }
-                      break;
-                 default:
-                      // Compatibility mode for old VDR recordings, where 0xBD was only AC3:
-                      if (!pre_1_3_19_PrivateStream) {
-                         dsyslog("switching to pre 1.3.19 Dolby Digital compatibility mode");
-                         ClrAvailableTracks();
-                         pre_1_3_19_PrivateStream = true;
-                         goto pre_1_3_19_PrivateStreamDeteced;
-                         }
-                 }
-               }
-               break;
-          default:
-               ;//esyslog("ERROR: unexpected packet id %02X", c);
-          }
-        if (w > 0)
-           Start += w;
-        else {
-           if (Start != Data)
-              esyslog("ERROR: incomplete PES packet write!");
-           return Start == Data ? w : Start - Data;
+  const uchar streamId = Data[3];
+  int written = 0;
+  switch (streamId) {
+    case 0xBE:          // padding stream, needed for MPEG1
+    case 0xE0 ... 0xEF: // video
+         do {
+           int r = PlayVideo(Data + written, Length - written);
+           if (r >= 0)
+              written += r;
+           else
+              break;
+           } while (written < Length);
+         break;
+    case 0xC0 ... 0xDF: { // audio
+         SetAvailableTrack(ttAudio, streamId - 0xC0, streamId);
+         eTrackType caud = currentAudioTrack;
+         if (VideoOnly | streamId != availableTracks[caud].id) {
+            written = Length;
+            break;
+            }
+
+         Audios.PlayAudio(Data, Length, streamId);
+         do {
+           int r = PlayAudio(Data + written, Length - written,streamId);
+           if (r >= 0)
+              written += r;
+           else
+              break;
+           } while (written < Length);
+         break;
+         }
+    case 0xBD: { // private stream 1
+         const int PayloadOffset = Data[8] + 9;
+         uchar SubStreamId = Data[PayloadOffset];
+         uchar SubStreamType = SubStreamId & 0xF0;
+         uchar SubStreamIndex = SubStreamId & 0x1F;
+         eTrackType thisTrack = ttNone;
+
+         if (pre_1_3_19_PrivateStream) {
+            SubStreamId = streamId;
+            SubStreamType = 0x80;
+            SubStreamIndex = 0;
+            }
+
+         switch (SubStreamType) {
+           case 0x20:
+           case 0x30: // SPU
+                break;
+           case 0x80:
+                if (Setup.UseDolbyDigital)
+                   thisTrack = ttDolby;
+                break;
+           case 0xA0:
+                thisTrack = ttAudio;
+                break;
+           default:
+                SubStreamId = streamId;
+                SubStreamType = 0x80;
+                SubStreamIndex = 0;
+                if (Setup.UseDolbyDigital)
+                   thisTrack = ttDolby;
+                dsyslog("switching to pre 1.3.19 Dolby Digital compatibility mode");
+                ClrAvailableTracks();
+                pre_1_3_19_PrivateStream = true;
            }
-        FirstLoop = false;
+         if (thisTrack == ttNone) {
+            written = Length;
+            break;
+            }
+         SetAvailableTrack(thisTrack, SubStreamIndex, SubStreamId);
+         eTrackType caud = currentAudioTrack;
+         if (VideoOnly | SubStreamId != availableTracks[caud].id) {
+            written = Length;
+            break;
+            }
+
+         Audios.PlayAudio(Data, Length, SubStreamId);
+         do {
+           int r = PlayAudio(Data + written, Length - written, SubStreamId);
+           if (r >= 0)
+              written += r;
+           else
+              break;
+           } while (written < Length);
+         break;
+         }
+    default:
+         written = Length;
+    }
+
+  if (written != Length) {
+     if (written) {
+        esyslog("ERROR: incomplete PES packet write!");
         }
+     return -1;
+     }
   return Length;
 }
 
@@ -1362,52 +1447,28 @@
      pesAssembler->Reset();
      return 0;
      }
+
   int Result = 0;
-  if (pesAssembler->Length()) {
-     // Make sure we have a complete PES header:
-     while (pesAssembler->Length() < 6 && Length > 0) {
-           pesAssembler->Put(*Data++);
-           Length--;
-           Result++;
-           }
-     if (pesAssembler->Length() < 6)
-        return Result; // Still no complete PES header - wait for more
-     int l = pesAssembler->ExpectedLength();
-     int Rest = min(l - pesAssembler->Length(), Length);
-     pesAssembler->Put(Data, Rest);
-     Data += Rest;
-     Length -= Rest;
-     Result += Rest;
-     if (pesAssembler->Length() < l)
-        return Result; // Still no complete PES packet - wait for more
-     // Now pesAssembler contains one complete PES packet.
-     int w = PlayPesPacket(pesAssembler->Data(), pesAssembler->Length(), VideoOnly);
-     if (w > 0)
-        pesAssembler->Reset();
-     return Result > 0 ? Result : w < 0 ? w : 0;
-     }
-  int i = 0;
-  while (i <= Length - 6) {
-        if (Data[i] == 0x00 && Data[i + 1] == 0x00 && Data[i + 2] == 0x01) {
-           int l = cPesAssembler::PacketSize(&Data[i]);
-           if (i + l > Length) {
-              // Store incomplete PES packet for later completion:
-              pesAssembler->Put(Data + i, Length - i);
-              return Length;
-              }
-           int w = PlayPesPacket(Data + i, l, VideoOnly);
-           if (w > 0)
-              i += l;
-           else
-              return i == 0 ? w : i;
-           }
-        else
-           i++;
+  while (Length > 0) {
+        int used = pesAssembler->Put(Data,Length);
+        if (used < 0)
+           return used;
+        Length -= used;
+        Result += used;
+        Data += used;
+
+        int pLength;
+        const uchar *pData = pesAssembler->Packet(pLength);
+        if (!pData)
+           continue;
+
+        int w = PlayPesPacket(pData, pLength, VideoOnly);
+        if (w < 0)
+           return w;
         }
-  if (i < Length)
-     pesAssembler->Put(Data + i, Length - i);
-  return Length;
+  return Result;
 }
+// M7X0 END AK
 
 int cDevice::Ca(void) const
 {
diff -Naur VDR-NG-EM-orig/dvbdevice.c VDR-NG-EM/dvbdevice.c
--- VDR-NG-EM-orig/dvbdevice.c	2008-03-23 13:01:54.000000000 +0100
+++ VDR-NG-EM/dvbdevice.c	2008-03-29 11:41:31.000000000 +0100
@@ -431,1254 +431,10 @@
         }
 }
 //M7X0 BEGIN AK
-//
-//#define REPLAY_WRITE_WAITTIME 100
-// #define REPLAY_FASTPLAY_FRAME_WAITTIME 40
-#define PACKHEADERCOUNTERMASK 0x7f
-#define INITIAL_TRICKSPEED_BUFFER_SIZE KILOBYTE(256)
-#define REPLAY_MAX_UNUSABLE_DATA KILOBYTE(512)
-#define REPLAY_TIMEOUT 3
-class c7x0Replayer {
-private:
-  FILE *testWriter;
-  cDvbDevice *dvbDevice;
-  int fd_dvr;
-  int fd_dmx_video;
-  int fd_dmx_audio;
-
-  int videoStreamId;
-  int mpeg;
-  bool initialized;
-
-  eTrackType curAudioTrack;
-  int curAudioStreamId;
-  int privateStreamId;
-  bool pre_1_3_19_PrivStr;
-
-
-  uchar fragmentData[6 + 65536];
-  int fragmentLen;
-
-  int packetLength;
-  int packetSkipBytes;
-  int streamId;
-  uint32_t packetScanner;
-
-  static const uchar packHeaderMpeg1[12];
-  static const uchar packHeaderMpeg2[14];
-  uchar packHeader[14];
-  int packHeaderLen;
-  int packetCounter;
-  bool packHeaderInStream;
-
-  int skippedBytes;
-  int unusableDataCount;
-  time_t lastPlaytime;
-
-  uchar *trickspeedData;
-  int trickspeedLen;
-  int trickspeedSize;
-  bool inTrickspeed;
-  enum {
-       syncing,
-       findFrame,
-       scanFrame
-       } trickspeedState;
-  uint32_t trickspeedScanner;
-
-#ifdef M7X0_PLAY_TS
-  int audio_ccounter;
-  int video_ccounter;
-  uchar tsHeader[188];
-  uchar tsBuffer[188 * ((6 + 65536 + 183) / 184)]; // Maximum ts length for one pes-packet
-#endif
-  bool ReallocTrickspeedBuffer(const int Size);
-  bool ScanDataTrickspeed(const uchar *&Data, const uchar *Limit);
-  void OpenDvr(void);
-  void CloseDvr(void);
-  void CheckAndSetupAudio(void);
-  bool ScanDataForPacketStartCode(const uchar *&Data,const uchar *const Limit);
-  bool HandlePackHeader(const uchar *&Data,const uchar *const Limit);
-  bool Initialize(const uchar *&Data,const uchar *const Limit);
-  int HandleTrickspeed(const uchar *Data, const uchar *packetLimit);
-  bool CheckPrivateStreamHeader(const uchar *Data, const uchar *const Limit);
-  bool CheckTimeout(void);
-#ifdef M7X0_PLAY_TS
-  int WriteOutPacket(const uchar *Data, int Count,int Pid, int *CCounter);
-#else
-  int WriteOutPacket(const uchar *Data, int Count);
-#endif
-
-public:
-  void Reset(void);
-  c7x0Replayer(cDvbDevice *dev);
-  ~c7x0Replayer();
-  int PlayPes(const uchar *Data, int Length, const bool VideoOnly);
-  void TrickSpeed(const int Speed,const bool UseFastForward);
-  void Clear();
-  void Play();
-  void Freeze();
-  bool Poll(cPoller &Poller,const int TimeoutMs);
-  bool Flush(const int TimeoutMs);
-  };
-
-const uchar c7x0Replayer::packHeaderMpeg1[12] =  {
-     0x00, 0x00, 0x01, 0xBA, 0x21, 0x00, 0x01, 0x00, 0x01, 0x81, 0x24, 0xF9
-  };
-const uchar c7x0Replayer::packHeaderMpeg2[14] =  {
-     0x00, 0x00, 0x01, 0xBA, 0x44, 0x00, 0x04, 0x00, 0x04, 0x01, 0x02, 0x49, 0xF3, 0xF8
-  };
-
-void c7x0Replayer::Reset(void)
-{
-  CloseDvr();
-
-  initialized = false;
-  videoStreamId = 0;
-  mpeg = 0;
-
-  curAudioTrack = ttNone;
-  curAudioStreamId = 0;
-  privateStreamId = 0;
-  pre_1_3_19_PrivStr = false;
-
-  fragmentLen = 0;
-  packetScanner = 0xFFFFFFFF;
-  skippedBytes = 0;
-  packetLength = 0;
-  packetSkipBytes = 0;
-  streamId = 0;
-
-  unusableDataCount = 0;
-
-  packHeaderLen = 0;
-  packetCounter = 0;
-  packHeaderInStream = false;
-
-  trickspeedScanner = 0xFFFFFFFF;
-  inTrickspeed = false;
-  trickspeedState = syncing;
-  trickspeedLen = 0;
-  dvbDevice->ClrAvailableTracks();
-}
-
-c7x0Replayer::c7x0Replayer(cDvbDevice *dev)
-{
-  dvbDevice = dev;
-  fd_dvr = -1;
-  Reset();
-  trickspeedSize = 0;
-  trickspeedData = NULL;
-  ReallocTrickspeedBuffer(INITIAL_TRICKSPEED_BUFFER_SIZE);
-#ifdef M7X0_PLAY_TS
-  tsHeader[0] = 0x47;
-  tsHeader[1] = 0;
-  tsHeader[2] = 0;
-  tsHeader[3] = 0;
-  unsigned int *p = (unsigned int *) tsHeader;
-  p++;
-  for (int i = 0; i < 46; i++, p++)
-      *p = 0xFFFFFFFF;
-  tsHeader[4] = 0;
-  tsHeader[5] = 0;
-#endif
-  //testWriter = fopen("/pc2/tests/trickSpeedTest.m2v","w");
-}
-
-c7x0Replayer::~c7x0Replayer()
-{
-  CloseDvr();
-  free(trickspeedData);
-  //fclose(testWriter);
-}
-
-bool c7x0Replayer::ReallocTrickspeedBuffer(const int Size)
-{
-  if (Size <= trickspeedSize)
-     return true;
-
-  uchar *tmp = (uchar *) realloc(trickspeedData,Size);
-  if (!tmp) {
-     esyslog("m7x0 Replayer cannot alloc memory!");
-     return false;
-     }
-
-  trickspeedSize=Size;
-  trickspeedData=tmp;
-  return true;
-}
-
-void c7x0Replayer::OpenDvr(void)
-{
-  if (fd_dvr >= 0 || !initialized)
-     return;
-
-  packetCounter = 0;
-
-  // None-Blocking-Mode not working as expected
-  fd_dvr = DvbOpen(DEV_DVB_ADAPTER DEV_DVB_DVR, 0, O_WRONLY, true);
-
-
-  if (fd_dvr <0 )
-     return;
-#ifndef M7X0_PLAY_TS
-  CHECK(ioctl(fd_dvr,DVR_SET_STREAM_TYPE,mpeg == 2 ? DVR_MPEG2_PS : DVR_MPEG1));
-#else
-  CHECK(ioctl(fd_dvr,DVR_SET_STREAM_TYPE, DVR_MPEG2_TS));
-#endif
-
-  fd_dmx_video = -1;
-  if (dvbDevice->playMode == pmAudioVideo || dvbDevice->playMode == pmVideoOnly) {
-     dmx_pes_filter_params pesFilterParams;
-     memset(&pesFilterParams, 0, sizeof(pesFilterParams));
-     fd_dmx_video = DvbOpen(DEV_DVB_ADAPTER DEV_DVB_DEMUX, 0, O_RDWR | O_NONBLOCK, true);
-
-     if (fd_dmx_video < 0) {
-        close(fd_dvr);
-        fd_dvr = -1;
-        return;
-     }
-
-     // Uglly the driver needs setting exacty this Value
-     // Yet another BUG in m7x0-drivers
-     CHECK(ioctl(fd_dmx_video, DMX_SET_BUFFER_SIZE,0x100000));
-#ifdef M7X0_PLAY_TS
-     pesFilterParams.pid      = 0xE0;
-     video_ccounter           = 0;
-#else
-     pesFilterParams.pid      = videoStreamId;
-#endif
-     pesFilterParams.input    = DMX_IN_DVR;
-     pesFilterParams.output   = DMX_OUT_DECODER0;
-     pesFilterParams.pes_type = DMX_PES_VIDEO;
-     pesFilterParams.flags    = DMX_IMMEDIATE_START;
-
-     int r, i = 0, errnoSave;
-
-     // Is this loop really nessesary any more.
-     // In earllier Versions the driver returns with EBUSY sometimes
-     do {
-#ifdef M7X0_PLAY_TS
-        if ((r = ioctl(fd_dmx_video,DMX_SET_PES_FILTER, &pesFilterParams)) < 0) {
-#else
-        if ((r = ioctl(fd_dmx_video,DMX_SET_PS_MODE_FILTER, &pesFilterParams)) < 0) {
-#endif
-           errnoSave = errno;
-           CHECK(r);
-           cCondWait::SleepMs(3);
-           }
-        else
-           errnoSave = 0;
-        i++;
-        } while (errnoSave == EBUSY && i <= 100);
-
-     if (errnoSave != 0) {
-        close(fd_dmx_video);
-        close(fd_dvr);
-        fd_dvr = -1;
-        return;
-        }
-     }
-
-  CHECK(ioctl(dvbDevice->fd_audio,AUDIO_SET_AV_SYNC,dvbDevice->playMode == pmAudioVideo));
-  // CHECK(ioctl(dvbDevice->fd_audio,AUDIO_SET_AV_SYNC,0));
-  if (dvbDevice->playMode == pmAudioVideo || dvbDevice->playMode == pmVideoOnly)
-     CHECK(ioctl(dvbDevice->fd_video,VIDEO_PLAY,0));
-  fd_dmx_audio = -1;
-  curAudioTrack = ttNone;
-  CheckAndSetupAudio();
-  lastPlaytime = time(NULL);
-}
-
-void c7x0Replayer::CheckAndSetupAudio(void)
-{
-  eTrackType newAudioTrack = dvbDevice->GetCurrentAudioTrack();
-  if (newAudioTrack != curAudioTrack && newAudioTrack != ttNone && initialized && dvbDevice->playMode != pmVideoOnly) {
-     curAudioStreamId = dvbDevice->GetTrack(newAudioTrack)->id;
-     if (fd_dmx_audio >= 0) {
-        CHECK(ioctl(fd_dmx_audio, DMX_STOP,1));
-        CHECK(ioctl(dvbDevice->fd_audio,AUDIO_STOP,0));
-        }
-     else {
-        fd_dmx_audio = DvbOpen(DEV_DVB_ADAPTER DEV_DVB_DEMUX, 0, O_RDWR | O_NONBLOCK, true);
-        if (fd_dmx_audio < 0) {
-           //close(fd_dmx_video);
-           //close(fd_dvr);
-           //fd_dvr = -1;
-           return;
-           }
-        }
-
-     dmx_pes_filter_params pesFilterParams;
-     memset(&pesFilterParams, 0, sizeof(pesFilterParams));
-     CHECK(ioctl(fd_dmx_audio, DMX_SET_BUFFER_SIZE,0x1E000));
-     pesFilterParams.input    = DMX_IN_DVR;
-     pesFilterParams.pes_type = DMX_PES_AUDIO;
-     pesFilterParams.flags    = DMX_IMMEDIATE_START;
-
-#ifdef M7X0_PLAY_TS
-     pesFilterParams.pid = curAudioStreamId;
-     audio_ccounter = 0;
-#endif
-
-     if (IS_DOLBY_TRACK(newAudioTrack)) {
-#ifndef M7X0_PLAY_TS
-        pesFilterParams.pid      = 0xBD;
-#endif
-        pesFilterParams.output   = DMX_OUT_DECODER1;
-        }
-     else {
-#ifndef M7X0_PLAY_TS
-        int audioType = curAudioStreamId & 0xF0;
-        pesFilterParams.pid      = (audioType == 0xC0 || audioType == 0xD0) ? curAudioStreamId : 0xBD;
-#endif
-        pesFilterParams.output   = DMX_OUT_DECODER0;
-        }
-
-      int r, i = 0, errnoSave;
-
-     // Is this loop really nessesary any more.
-     // In earllier Versions the driver returns with EBUSY sometimes
-     do {
-#ifdef M7X0_PLAY_TS
-        if ((r = ioctl(fd_dmx_audio, DMX_SET_PES_FILTER, &pesFilterParams)) < 0) {
-#else
-        if ((r = ioctl(fd_dmx_audio, DMX_SET_PS_MODE_FILTER, &pesFilterParams)) < 0) {
-#endif
-           errnoSave = errno;
-           CHECK(r);
-           cCondWait::SleepMs(3);
-           }
-        else
-           errnoSave = 0;
-        i++;
-        } while (errnoSave == EBUSY && i <= 100);
-
-     if (errnoSave != 0) {
-        close(fd_dmx_audio);
-        //close(fd_dmx_video);
-        //close(fd_dvr);
-        //fd_dvr = -1;
-        return;
-        }
-     CHECK(ioctl(dvbDevice->fd_audio,AUDIO_PLAY,0));
-     curAudioTrack = newAudioTrack;
-     }
-}
-
-void c7x0Replayer::CloseDvr()
-{
-  if (fd_dvr < 0)
-     return;
-
-  if (fd_dmx_audio >= 0) {
-     CHECK(ioctl(fd_dmx_audio, DMX_STOP,1));
-     close(fd_dmx_audio);
-     fd_dmx_audio = -1;
-     curAudioTrack = ttNone;
-     }
-
-  if (fd_dmx_video >= 0) {
-     CHECK(ioctl(fd_dmx_video, DMX_STOP,1));
-     close(fd_dmx_video);
-     fd_dmx_video = -1;
-     }
-  close(fd_dvr);
-  fd_dvr = -1;
-  if (dvbDevice->playMode != pmVideoOnly)
-     CHECK(ioctl(dvbDevice->fd_audio, AUDIO_STOP, 0))
-  if (dvbDevice->playMode == pmAudioVideo || dvbDevice->playMode == pmVideoOnly)
-     CHECK(ioctl(dvbDevice->fd_video, VIDEO_STOP, 0));
-}
-
-bool c7x0Replayer::ScanDataForPacketStartCode(const uchar *&Data,const uchar *const Limit)
-{
-  register const uchar *data = Data;
-  register const uchar *const limit = Limit -1;
-
-  // Normal case - No need to sync
-  // I think this hit in 99% of cases.
-  if (limit - data >= 3 && !(data[0] | data[1]) && data[2] == 1 && data[3] >= 0xBA && data[3] <= 0xEF) {
-     packetScanner = 0xFFFFFFFF;
-     packetLength = 0;
-     streamId = data[3];
-     fragmentLen = 0;
-     return true;
-     }
-
-  if ((packetScanner & 0xFFFFFF) == 0x000001 && data[0] >= 0xBA && data[0] <= 0xEF) {
-     packetScanner = 0xFFFFFFFF;
-     packetLength = 0;
-     streamId = data[0];
-     fragmentLen = 3;
-     fragmentData[0] = 0;
-     fragmentData[1] = 0;
-     fragmentData[2] = 1;
-     skippedBytes -= 3;
-     return true;
-     }
-
-  packetScanner = (packetScanner << 8) | data[0];
-  data++;
-  if (data > limit) {
-     skippedBytes++;
-     return false;
-     }
-
-
-  if ((packetScanner & 0xFFFFFF) == 0x000001 && data[0] >= 0xBA && data[0] <= 0xEF) {
-     packetScanner = 0xFFFFFFFF;
-     packetLength = 0;
-     streamId = data[0];
-     fragmentLen = 2;
-     fragmentData[0] = 0;
-     fragmentData[1] = 0;
-     skippedBytes -= 2;
-     return true;
-     }
-
-  packetScanner = (packetScanner << 8) | data[0];
-  data++;
-  if (data > limit) {
-     skippedBytes += 2;
-     return false;
-     }
-
-
-  if ((packetScanner & 0xFFFFFF) == 0x000001 && data[0] >= 0xBA && data[0] <= 0xEF) {
-     packetScanner = 0xFFFFFFFF;
-     packetLength = 0;
-     streamId = data[0];
-     fragmentLen = 1;
-     fragmentData[0] = 0;
-     skippedBytes --;
-     return true;
-     }
-
-  packetScanner = (packetScanner << 8) | data[0];
-  if (data >= limit) {
-     skippedBytes += 3;
-     return false;
-     }
-
-   while (data < limit)
-        if (data[0] > 1)
-           data += 3;
-        else if (!data[0])
-           data++;
-        else {
-           if (!(data[-2] | data[-1])) {
-              register const uchar code = *++data;
-              if (code >= 0xBA && code <= 0xEF) {
-                 packetScanner = 0xFFFFFFFF;
-                 packetLength = 0;
-                 streamId = code;
-                 fragmentLen = 0;
-                 skippedBytes += data - 3 - Data;
-                 Data = data - 3;
-                 return true;
-                 }
-              }
-           data += 3;
-           }
-
-  packetScanner = getIntUnalignedBE(limit - 3);
-  skippedBytes += limit + 1 - Data;
-  return false;
-}
-
-bool c7x0Replayer::HandlePackHeader(const uchar *&Data,const uchar *const Limit)
-{
-  const uchar *data = Data;
-
-  if (!mpeg) {
-     int offset = 4 - fragmentLen;
-     int marker;
-
-     if (offset < 0)
-        marker = fragmentData[4] & 0xC0;
-     else if (offset < Limit - data)
-        marker = data[offset] & 0xC0;
-     else
-       return false;
-
-     if (marker)
-        mpeg = 2;
-     else
-        mpeg = 1;
-     }
-
-  if (mpeg == 1)
-     packHeaderLen = 12;
-  else
-     packHeaderLen = 14;
-
-  if (packHeaderLen > fragmentLen + (Limit - data))
-     return false;
-
-  if (fragmentLen)
-     memcpy(packHeader, fragmentData, fragmentLen);
-
-  memcpy(packHeader + fragmentLen, data, packHeaderLen - fragmentLen);
-  data += packHeaderLen -fragmentLen;
-  fragmentLen = 0;
-  streamId = 0;
-
-  if (mpeg == 2) {
-     data += packHeader[13] & 0x7; // Stuffing length
-     packHeader[13] = packHeader[13] & 0xF8;
-     }
-
-  Data = data;
-  packHeaderInStream = true;
-  return true;
-}
-
-bool c7x0Replayer::Initialize(const uchar *&Data,const uchar *const Limit)
-{
-  const uchar *data = Data;
-  if ((streamId & 0xF0) == 0xE0) {
-     videoStreamId = streamId;
-     }
-
-  if (fragmentLen + (Limit - data) >= 7) {
-     int offset = 6 - fragmentLen;
-     mpeg = (data[offset] & 0xC0) == 0x80 ? 2 : 1;
-     }
-
-  initialized = (mpeg &&  (videoStreamId ||
-              (dvbDevice->playMode != pmAudioVideo && dvbDevice->playMode != pmVideoOnly)));
-
-  if (!initialized) {
-     if (mpeg) {
-        data += packetLength - fragmentLen;
-        unusableDataCount += packetLength - fragmentLen;
-        fragmentLen = 0;
-        streamId = 0;
-        Data = data;
-        return true;
-        }
-
-     unusableDataCount += Limit - data;
-     return false;
-     }
-
-  if (!packHeaderInStream)
-     if (mpeg == 1) {
-        memcpy(packHeader, packHeaderMpeg1, 12);
-        packHeaderLen = 12;
-        }
-     else {
-        memcpy (packHeader,packHeaderMpeg2,14);
-        packHeaderLen = 14;
-        }
-
-  packetCounter = 0;
-
-  if (!inTrickspeed)
-     OpenDvr();
-  return true;
-}
-
-bool c7x0Replayer::ScanDataTrickspeed(const uchar *&Data, const uchar *Limit)
-{
-  register const uchar *data = Data;
-  register const uchar *limit = Limit - 1;
-
-  while (data < limit)
-        if (data[0] > 1)
-           data += 3;
-        else if (!data[0])
-           data++;
-        else {
-           if (!(data[-2] | data[-1])) {
-              register const uchar code = *++data;
-              if (code == 0 || code == 0xB3 || code == 0xB8) {
-                 Data = data;
-                 return true;
-                 }
-              }
-           data += 3;
-           }
-
-  return false;
-}
-
-int c7x0Replayer::HandleTrickspeed(const uchar *Data, const uchar *packetLimit)
-{
-  // Always a full packet should be present in Data.
-  const uchar *data = Data;
-  const uchar *limit = packetLimit;
-
-  if (mpeg == 2) {
-     data += 8;
-
-     if (data >= limit) {  // This should never happen packet is illegal
-        errno = EINVAL;    // Which error value should be set???
-        return -1;
-        }
-
-     data += data[0] + 1;
-
-     if (data >= limit) {  // Packet with no payload should normaly not happen
-        return 0;          // but allowed
-        }
-     }
-  else { //Mpeg1
-     data += 6;
-     if (data >= limit) {  // This should never happen packet is illegal
-        errno = EINVAL;    // Which error value should be set???
-        return -1;
-        }
-
-     // Stuffing Bytes
-     while (data < limit && data[0] == 0xFF )
-            data++;
-
-     if (data >= limit) {  // This should never happen packet is illegal
-        errno = EINVAL;    // Which error value should be set???
-        return -1;
-        }
-
-     if ((data[0] & 0xC0) == 0x40)
-         data += 2;
-
-     if (data >= limit) {  // This should never happen packet is illegal
-        errno = EINVAL;    // Which error value should be set???
-        return -1;
-        }
-
-     if ((data[0] & 0xF0) == 0x20) {
-        data += 5;
-        }
-     else if ((data[0] & 0xF0) == 0x30) {
-        data += 10;
-        }
-     else {
-        data++;
-        }
-
-     if (data >= limit) {  // Packet with no payload should normaly not happen
-        return 0;          // but allowed
-        }
-     }
-
-  // Driver expects an elementary video stream written to /dev/ost/video0
-  // while in trickspeed.
-  // At this point we would normally sync to a sequence header and
-  // write out the data from data until limit. Pes-header is stripped up
-  // above, the rest is video elementary data.
-  // But hey as always there are a number of bugs in this part of the driver:
-  // 1. Don't like writing startcodes aligned to start of buffer
-  //   (isn't it funny - this is the easiest case)
-  // 2. Don't like startcode a spilted over writes.
-  // There are some others which I not yet was able to trace down.
-  // Some parts of the video get replayed even if we are miles away for that
-  // point. Seems so as if some frames get not played right.
-  // The part below tries to workaround these issues.
-  // As always let me write a hint:
-  // IF YOU ARE IN CHARGE OF THE DRIVER SOURCE FIX THIS HORRIBLE BROKEN THING
-
-  const uchar *data_save = data;
-  const uchar *payload_start = data;
-
-  for (int i = 0; i < 3 && data < limit; i++) {
-      int code = data[0];
-      if ((trickspeedScanner & 0xFFFFFF) == 0x000001) {
-         if (trickspeedState == syncing && code == 0xB3) {
-            putIntUnalignedBE(trickspeedData, 0x00000000); // First two 0: Padding for bug in driver
-            trickspeedData[4] = 1;
-            trickspeedLen = 5;
-            payload_start = data;
-            data += 3 - i;
-            trickspeedState = findFrame;
-            break;
-            }
-         if (trickspeedState == findFrame && !code) {
-            trickspeedState = scanFrame;
-            data += 3 - i;
-            break;
-            }
-         if (trickspeedState == scanFrame && (!code || code == 0xB3 || code == 0xB8)) {
-            trickspeedLen -= 3 - i;
-            int r;
-            if ((r = write(dvbDevice->fd_video, trickspeedData, trickspeedLen)) < 0) {
-               LOG_ERROR;
-               return r;
-               }
-            //fwrite (trickspeedData, trickspeedLen, 1, testWriter);
-            if (r != trickspeedLen) {
-               esyslog("ERROR: Write of trickspeed data stripped off %d bytes",trickspeedLen - r);
-               }
-
-            putIntUnalignedBE(trickspeedData, 0x00000000); // First two 0: Padding for bug in driver
-            trickspeedData[4] = 1;
-            trickspeedLen = 5;
-            payload_start = data;
-            data += 3 - i;
-            if (code) {
-               trickspeedState = findFrame;
-               }
-            break;
-            }
-         }
-      trickspeedScanner = (trickspeedScanner << 8) | code;
-      data++;
-      }
-
-  data--;
-
-  while (ScanDataTrickspeed(data, limit)) {
-        int code = data[0];
-        if (trickspeedState == scanFrame) {
-           int n = data - 3 - payload_start;
-           if (n) {
-              if (!ReallocTrickspeedBuffer(n + trickspeedLen)) {
-                 errno = ENOMEM;
-                 return -1;
-                 }
-              memcpy(trickspeedData + trickspeedLen, payload_start, n);
-              trickspeedLen += n;
-              }
-           int r;
-           if ((r = write(dvbDevice->fd_video, trickspeedData, trickspeedLen)) < 0) {
-              LOG_ERROR;
-              return r;
-              }
-           //fwrite (trickspeedData, trickspeedLen, 1, testWriter);
-           if (r != trickspeedLen) {
-              esyslog("ERROR: Write of trickspeed data stripped off %d bytes",trickspeedLen - r);
-              }
-
-           trickspeedData[0] = 0; // Padding for bug in driver
-           trickspeedData[1] = 0; // Padding for bug in driver
-           trickspeedLen = 2;
-           payload_start = data - 3;
-           data += 3;
-           if (code) {
-              trickspeedState = findFrame;
-              }
-           }
-        else if (trickspeedState == findFrame && !code) {
-           trickspeedState = scanFrame;
-           data += 3;
-           }
-        else if (trickspeedState == syncing && code == 0xB3) {
-           trickspeedData[0] = 0; // Padding for bug in driver
-           trickspeedData[1] = 0; // Padding for bug in driver
-           trickspeedLen = 2;
-           payload_start = data - 3;
-           data += 3;
-           trickspeedState = findFrame;
-           }
-        }
-
-  int n = min (4, limit - data_save);
-  memcpy(&trickspeedScanner, limit - n, n);
-
-  if (trickspeedState == syncing){
-     unusableDataCount += limit - Data;
-     return 0;
-     }
-
-  unusableDataCount = 0;
-  n = limit - payload_start;
-  if (n) {
-     if (!ReallocTrickspeedBuffer(n + trickspeedLen)) {
-        errno = ENOMEM;
-        return -1;
-        }
-     memcpy(trickspeedData + trickspeedLen, payload_start, n);
-     trickspeedLen += n;
-     }
-  return 0;
-}
-
-bool c7x0Replayer::CheckPrivateStreamHeader(const uchar *Data, const uchar *const Limit)
-{
-  if (pre_1_3_19_PrivStr){
-     privateStreamId = 0xBD;
-     return true;
-     }
-
-  if (privateStreamId)
-     return true;
-
-  int offset = 8 - fragmentLen;
-  if (offset >= 0) {
-     Data += offset;
-     if (Data >= Limit)
-        return false;
-     Data += 1 + Data[0];
-     }
-  else
-     Data += offset + fragmentData[8] + 1;
-
-  if (Data >= Limit)
-     return false;
-
-  privateStreamId = Data[0];
-
-
-  switch (privateStreamId&0xF0) {
-    case 0x20: // SPU
-    case 0x30:
-         break;
-    case 0x80: // AC3 & DTS
-         dvbDevice->SetAvailableTrack(ttDolby, privateStreamId & 0x1F , privateStreamId);
-         break;
-    case 0xA0: // LPCM
-         dvbDevice->SetAvailableTrack(ttAudio, privateStreamId & 0x1F, privateStreamId);
-         break;
-    default:
-         dsyslog("switching to pre 1.3.19 Dolby Digital compatibility mode");
-         dvbDevice->ClrAvailableTracks();
-         dvbDevice->SetAvailableTrack(ttDolby, 0, 0xBD);
-         pre_1_3_19_PrivStr = true;
-    }
-  return true;
-}
-
-bool c7x0Replayer::CheckTimeout(void)
-{
-  time_t now = time(NULL);
-
-  struct video_status videoStat;
-  if (ioctl(dvbDevice->fd_video, VIDEO_GET_STATUS, &videoStat) >= 0 && videoStat.play_state == VIDEO_PLAYING)
-     lastPlaytime = now;
-  else if (now - lastPlaytime > REPLAY_TIMEOUT) {
-     esyslog("ERROR: Playing timed out!");
-     dsyslog("DEBUG: MPEG %d Video ID 0x%02X Audio ID 0x%02d", mpeg,  videoStreamId, curAudioStreamId);
-     dsyslog("DEBUG: Current Packet: ID 0x%02X (0x%02X) Length %d (%d) "
-             "Pack Header: Source %d Length %d Count %d", streamId,
-             privateStreamId, packetLength, fragmentLen, packHeaderInStream,
-             packHeaderLen, packetCounter);
-
-     errno = EDEADLK;
-     return true;
-     }
-  return false;
-}
-#ifdef M7X0_PLAY_TS
-int c7x0Replayer::WriteOutPacket(const uchar *Data, int Count, int Pid, int *CCounter)
-{
-  int ccounter = *CCounter;
-  tsHeader[1] = 0x40; // Payload Start Flag
-  tsHeader[2] = (Pid & 0xFF);
-
-  int tsBufferLen = 0;
-
-  while (Count >= 184) {
-        tsHeader[3] = 0x10 | (ccounter & 0xF);
-
-        // n * 188  == tsBufferLen => always 4 byte aligned
-        *((int *) (tsBuffer + tsBufferLen)) = *((int *) tsHeader);
-        memcpy(tsBuffer + tsBufferLen + 4, Data, 184);
-
-        Data += 184;
-        Count -= 184;
-        tsBufferLen += 188;
-        ccounter++;
-
-        tsHeader[1] = 0; // Reset Payload Start Flag
-        }
-
-  if (Count) { // Does last TS-Packet needs padding
-     const int tsHeaderLen = 188 - Count;
-     tsHeader[3] = 0x30 | (ccounter & 0xF);
-     tsHeader[4] = tsHeaderLen - 5;
-
-     memcpy(tsBuffer + tsBufferLen, tsHeader, tsHeaderLen);
-     memcpy(tsBuffer + tsBufferLen + tsHeaderLen, Data, Count);
-
-     tsBufferLen += 188;
-     ccounter++;
-     }
-
-   int i = 0;
-   int r;
-   do {
-      if ((r = write(fd_dvr,tsBuffer + i, tsBufferLen - i)) < 0) {
-         if (FATALERRNO) {
-            LOG_ERROR;
-            return r;
-            }
-         }
-      else
-         i += r;
-      } while (i < tsBufferLen);
-
-  *CCounter = ccounter;
-#ifdef USE_PLAYER_WATCHDOG
-  if (CheckTimeout())
-     return -1;
-#endif
-  return 0;
-
-}
-#else
-int c7x0Replayer::WriteOutPacket(const uchar *Data, int Count)
-{
-
-  int r;
-  int i;
-
-  if ((!packetCounter || packHeaderInStream) && packHeaderLen) {
-     i = 0;
-     while (i < packHeaderLen) {
-            if ((r = write(fd_dvr,packHeader+i,packHeaderLen-i)) < 0) {
-               LOG_ERROR;
-               return r;
-               }
-            i += r;
-            }
-     if (packHeaderInStream)
-        packHeaderLen = 0;
-     }
-
-  i = 0;
-  while (fragmentLen) {
-        if ((r = write(fd_dvr,fragmentData+i,fragmentLen)) < 0) {
-           LOG_ERROR;
-           return r;
-           }
-        fragmentLen -= r;
-        i += r;
-        }
-
-
-  while (Count) {
-        if ((r = write(fd_dvr,Data,Count)) < 0) {
-           LOG_ERROR;
-           return r;
-           }
-        Count -= r;
-        Data += r;
-        }
-
-  packetCounter = (packetCounter + 1) & PACKHEADERCOUNTERMASK;
-#ifdef USE_PLAYER_WATCHDOG
-  if (CheckTimeout())
-     return -1;
-#endif
-  return 0;
-}
-#endif
-int c7x0Replayer::PlayPes(const uchar *Data, int Length, const bool VideoOnly)
-{
-  if (!Data) {
-     dsyslog("m7x0 Replayer: Discarding last PES-Packet");
-     fragmentLen = 0;
-     packetSkipBytes = 0;
-     packetScanner = 0xFFFFFFFF;
-     streamId = 0;
-     privateStreamId = 0;
-     return 0;
-     }
-
-  if (!inTrickspeed)
-     OpenDvr();
-
-  const uchar *data = Data + packetSkipBytes;
-  const uchar *const limit = Data + Length;
-  packetSkipBytes = 0;
-#ifdef M7X0_PLAY_TS
-  int tsPid = 0;
-  int *ccounter = NULL;
-#endif
-  while (data < limit) {
-
-        if (!streamId && !ScanDataForPacketStartCode(data,limit)) {
-           if (skippedBytes > REPLAY_MAX_UNUSABLE_DATA) {
-              esyslog("ERROR: %d bytes of recoding unusable while in initialization - giving up!", unusableDataCount + skippedBytes);
-              errno = EDEADLK; // Any ideas for a better errorcode
-              return -1;
-              }
-           return Length;
-           }
-
-        if (skippedBytes) {
-           esyslog("ERROR: c7x0Replayer skipped %d bytes while syncing on Packet",skippedBytes);
-           unusableDataCount += skippedBytes;
-           skippedBytes = 0;
-           }
-
-        if (streamId == 0xBA) {
-           unusableDataCount = 0;
-           if (HandlePackHeader(data,limit))
-              continue;
-           else
-              break;
-           }
-
-
-        if (!packetLength) {
-           if (fragmentLen + (limit - data)  < 6)
-              break;
-           int offset = 4 - fragmentLen;
-
-           if (offset < 0) {
-              packetLength = fragmentData[4];
-              offset = 0;
-              }
-           else
-              packetLength = data[offset++];
-           packetLength <<= 8;
-           packetLength |= data[offset];
-           packetLength += 6;
-           }
-
-        //dsyslog("Stream %02X Packet-Length %d fragmentLen %d Length %d", streamId, packetLength, fragmentLen, limit - data);
-        if (!initialized) {
-           if (unusableDataCount > REPLAY_MAX_UNUSABLE_DATA) {
-              esyslog("ERROR: %d bytes of recoding unusable while in initialization - giving up!", unusableDataCount);
-              errno = EDEADLK; // Any ideas for a better errorcode
-              return -1;
-              }
-           if (Initialize(data,limit))
-              continue;
-           else
-              break;
-           }
-
-
-        if (inTrickspeed) {
-           if ((streamId&0xF0) == 0xE0) {
-              if (data + packetLength - fragmentLen <= limit) {
-                 int r = 0;
-                 if (!fragmentLen)
-                    r = HandleTrickspeed(data,data + packetLength);
-                 else {
-                    memcpy(fragmentData + fragmentLen, data, packetLength - fragmentLen);
-                    r = HandleTrickspeed(fragmentData,fragmentData + packetLength);
-                    }
-                 data += packetLength - fragmentLen;
-                 fragmentLen = 0;
-                 streamId = 0;
-                 if (r < 0) {
-                    return r;
-                    }
-                 }
-              else
-                 break;
-              }
-           else {
-              unusableDataCount += packetLength - fragmentLen;
-              data += packetLength - fragmentLen;
-              fragmentLen = 0;
-              streamId = 0;
-              }
-           if (unusableDataCount > REPLAY_MAX_UNUSABLE_DATA) {
-              esyslog("ERROR: %d bytes of recoding unusable while in trickspeed - giving up!", unusableDataCount);
-              errno = EDEADLK; // Any ideas for a better errorcode
-              return -1;
-              }
-           continue;
-           }
-
-        switch (streamId) {
-#ifndef M7X0_PLAY_TS
-          case 0xBB:
-          case 0xBC:
-               unusableDataCount = 0;
-               break;
-#endif
-          case 0xBD:
-               unusableDataCount = 0;
-               if (!Setup.UseDolbyDigital || mpeg == 1 || dvbDevice->playMode == pmVideoOnly || VideoOnly) {
-                  data += packetLength - fragmentLen;
-                  fragmentLen = 0;
-                  streamId = 0;
-                  continue;
-                  }
-
-               if (!CheckPrivateStreamHeader(data,limit))
-                  break;
-
-               CheckAndSetupAudio();
-
-               if (privateStreamId != curAudioStreamId) {
-                  data += packetLength - fragmentLen;
-                  fragmentLen = 0;
-                  streamId = 0;
-                  privateStreamId = 0;
-                  continue;
-                  }
-
-#ifdef M7X0_PLAY_TS
-               tsPid = privateStreamId;
-               ccounter = &audio_ccounter;
-#endif
-               break;
-          case 0xC0 ... 0xDF:
-               unusableDataCount = 0;
-               if (dvbDevice->playMode == pmVideoOnly || VideoOnly) {
-                  data += packetLength - fragmentLen;
-                  fragmentLen = 0;
-                  streamId = 0;
-                  continue;
-                  }
-
-               dvbDevice->SetAvailableTrack(ttAudio,streamId - 0xC0, streamId);
-
-               CheckAndSetupAudio();
-
-               if (streamId != curAudioStreamId) {
-                  data += packetLength - fragmentLen;
-                  fragmentLen = 0;
-                  streamId = 0;
-                  continue;
-                  }
-
-#ifdef M7X0_PLAY_TS
-               tsPid = streamId;
-               ccounter = &audio_ccounter;
-#endif
-               break;
-          case 0xBE:
-          case 0xE0 ... 0xEF:
-               unusableDataCount = 0;
-               if (dvbDevice->playMode != pmAudioVideo && dvbDevice->playMode != pmVideoOnly) {
-                  data += packetLength - fragmentLen;
-                  fragmentLen = 0;
-                  streamId = 0;
-                  continue;
-                  }
-#ifdef M7X0_PLAY_TS
-               tsPid = 0xE0;
-               ccounter = &video_ccounter;
-#endif
-               break;
-          default:
-               unusableDataCount += packetLength - fragmentLen;
-               data += packetLength - fragmentLen;
-               fragmentLen = 0;
-               streamId = 0;
-               if (unusableDataCount > REPLAY_MAX_UNUSABLE_DATA) {
-                  esyslog("ERROR: %d bytes of recoding unusable - giving up!", unusableDataCount);
-                  errno = EDEADLK; // Any ideas for a better errorcode
-                  return -1;
-                  }
-               continue;
-          }
-
-        int bite = packetLength - fragmentLen;
-        if (data + bite <= limit) {
-#ifdef M7X0_PLAY_TS
-           int r;
-           if (fragmentLen) {
-              memcpy(fragmentData + fragmentLen, data, bite);
-              fragmentLen += bite;
-              r = WriteOutPacket(fragmentData,fragmentLen,tsPid,ccounter);
-              }
-           else
-              r = WriteOutPacket(data,bite,tsPid,ccounter);
-#else
-           int r = WriteOutPacket(data,bite);
-#endif
-
-           if (r < 0) {
-              return r;
-              }
-           data += bite;
-           streamId = 0;
-           privateStreamId = 0;
-           fragmentLen = 0;
-           }
-        else
-           break;
-        }
-
-  int bite = limit - data;
-  if (bite > 0) {
-     memcpy(fragmentData + fragmentLen, data, bite);
-     fragmentLen += bite;
-     }
-  else
-     packetSkipBytes = -bite;
-
-  return Length;
-}
-
-void c7x0Replayer::TrickSpeed(const int Speed,const bool UseFastForward)
-{
-  dsyslog("TrickSpeed called Speed %d %d!",Speed, UseFastForward);
-  if (dvbDevice->playMode != pmAudioVideo && dvbDevice->playMode != pmVideoOnly)
-     return;
-  // Uglly needed otherwise continue won't work
-  // Yet another bug in driver!?!
-  CHECK(ioctl(dvbDevice->fd_audio, AUDIO_SET_MUTE, true));
-  CHECK(ioctl(dvbDevice->fd_audio, AUDIO_STOP,0));
-  CHECK(ioctl(dvbDevice->fd_video, VIDEO_STOP,0));
-  CloseDvr();
-
-  if (!inTrickspeed || !UseFastForward) {
-     trickspeedState = syncing;
-     trickspeedScanner = 0xFFFFFFFF;
-     trickspeedLen = 0;
-     }
-  if (Speed > 1)
-     CHECK(ioctl(dvbDevice->fd_video, VIDEO_SLOWMOTION, Speed << 1))
-  else
-     CHECK(ioctl(dvbDevice->fd_video, VIDEO_FAST_FORWARD, 1))
-  inTrickspeed = true;
-
-}
-
-void c7x0Replayer::Play(void)
-{
-  dsyslog("Play called!");
-  //CHECK(ioctl(dvbDevice->fd_audio, AUDIO_STOP,0));
-  //CHECK(ioctl(dvbDevice->fd_video, VIDEO_STOP,0));
-  //CloseDvr();
-  inTrickspeed = false;
-  //OpenDvr();
-  CHECK(ioctl(dvbDevice->fd_audio, AUDIO_SET_MUTE, false));
-  if (dvbDevice->playMode != pmAudioVideo && dvbDevice->playMode != pmVideoOnly)
-     CHECK(ioctl(dvbDevice->fd_audio, AUDIO_CONTINUE, 0));
-
-}
-
-void c7x0Replayer::Clear(void)
-{
-  dsyslog("Clear called!");
-  // CHECK(ioctl(dvbDevice->fd_audio, AUDIO_SET_MUTE, true));
-  // CHECK(ioctl(dvbDevice->fd_audio, AUDIO_STOP,0));
-  // CHECK(ioctl(dvbDevice->fd_video, VIDEO_STOP,0));
-  CloseDvr();
-  /* if (!inTrickspeed) {
-     dsyslog("Clear called2!");
-     OpenDvr();
-     CHECK(ioctl(dvbDevice->fd_audio, AUDIO_SET_MUTE, false));
-     }*/
-
-}
-
-void c7x0Replayer::Freeze(void)
-{
-  dsyslog("Freeze called!");
-  if (dvbDevice->playMode == pmAudioVideo || dvbDevice->playMode == pmVideoOnly) {
-     CloseDvr();
-     CHECK(ioctl(dvbDevice->fd_video, VIDEO_STOP,0));
-     CHECK(ioctl(dvbDevice->fd_audio, AUDIO_SET_MUTE, true));
-     if (dvbDevice->playMode == pmAudioVideo)
-        CHECK(ioctl(dvbDevice->fd_audio, AUDIO_STOP,0));
-     }
-  else
-     CHECK(ioctl(dvbDevice->fd_audio, AUDIO_PAUSE, 0));
-}
-
-bool c7x0Replayer::Poll(cPoller &Poller,const int TimeoutMs)
-{
-
-  return true;
-}
 
-bool c7x0Replayer::Flush(const int TimeoutMs)
-{
-  dsyslog("Flush called!");
-  return true;
-}
+#define INITIAL_TRICKSPEED_BUFFER_SIZE KILOBYTE(256)
+#define REPLAY_MAX_UNUSABLE_DATA KILOBYTE(512)
+#define REPLAY_TIMEOUT 3
 
 // -----------------
 // c7x0Ts
@@ -3561,7 +2317,9 @@
 {
 //M7X0 BEGIN AK
   audioChannel = 0;
-  replayer = NULL;
+  fd_playDvr = -1;
+  fd_playDemux[0] = -1;
+  fd_playDemux[1] = -1;
   tsreplayer = NULL;
 //M7X0 END AK
   dvbTuner = NULL;
@@ -3641,8 +2399,6 @@
 cDvbDevice::~cDvbDevice()
 {
 //M7X0 BEGIN AK
-  if (replayer != NULL)
-     delete replayer;
   if (tsreplayer != NULL)
      delete tsreplayer;
 //M7X0 END AK
@@ -4469,37 +3225,104 @@
   bool DoBlank = false;
   switch (PlayMode) {
     case pmNone:
+         if (fd_playDemux[1] >= 0) {
+            CHECK(ioctl(fd_playDemux[1], DMX_STOP,1));
+            close(fd_playDemux[1]);
+            fd_playDemux[1] = -1;
+            playAudioId = 0;
+            }
+         if (fd_playDemux[0] >= 0) {
+            CHECK(ioctl(fd_playDemux[0], DMX_STOP,1));
+            close(fd_playDemux[0]);
+            fd_playDemux[0] = -1;
+            }
+         if (fd_playDvr >= 0) {
+            close(fd_playDvr);
+            fd_playDvr = -1;
+            }
+
          CHECK(ioctl(fd_audio, AUDIO_STOP, 0));
          CHECK(ioctl(fd_video, VIDEO_STOP, 0));
-         if (replayer != NULL) {
-            delete replayer;
-            replayer=NULL;
-         }
          if (tsreplayer != NULL) {
             delete tsreplayer;
             tsreplayer=NULL;
          }
          break;
     case pmAudioVideo:
-    case pmAudioOnlyBlack:
+    case pmVideoOnly: {
          if (tsreplayer != NULL) {
             delete tsreplayer;
             tsreplayer=NULL;
          }
-         DoBlank = !replayer &&
-           (!pidHandles[cDevice::ptVideo].pid && PlayMode == pmAudioVideo ||
-            pidHandles[cDevice::ptVideo].pid && PlayMode != pmAudioVideo);
-         TurnOffLiveMode(true, DoBlank);
+         TurnOffLiveMode(true, !pidHandles[cDevice::ptVideo].pid);
          CHECK(ioctl(fd_audio, AUDIO_STOP,0));
          CHECK(ioctl(fd_video, VIDEO_STOP, 1));
-         if (replayer == NULL){
-            replayer = new c7x0Replayer(this);
+
+         if (fd_playDvr >= 0)
+            close(fd_playDvr);
+         fd_playDvr = DvbOpen(DEV_DVB_ADAPTER DEV_DVB_DVR, 0, O_WRONLY, true);
+         if (fd_playDvr < 0)
+            return false;
+
+         // CHECK(ioctl(fd_playDvr,DVR_SET_STREAM_TYPE, DVR_MPEG2_TS));
+         if (fd_playDemux[0] >= 0)
+            close(fd_playDemux[0]);
+
+         fd_playDemux[0] = DvbOpen(DEV_DVB_ADAPTER DEV_DVB_DEMUX, 0, O_RDWR | O_NONBLOCK, true);
+         if (fd_playDemux[0] < 0) {
+            close(fd_playDvr);
+            fd_playDvr = -1;
+            return false;
+         }
+         dmx_pes_filter_params pesFilterParams;
+         memset(&pesFilterParams, 0, sizeof(pesFilterParams));
+
+         // Uglly the driver needs setting exacty this Value
+         // Yet another BUG in m7x0-drivers
+         CHECK(ioctl(fd_playDemux[0], DMX_SET_BUFFER_SIZE,0x100000));
+         pesFilterParams.pid      = 0xEF;
+         playTsCcounter[0]        = 0;
+
+         pesFilterParams.input    = DMX_IN_DVR;
+         pesFilterParams.output   = DMX_OUT_DECODER0;
+         pesFilterParams.pes_type = DMX_PES_VIDEO;
+         pesFilterParams.flags    = DMX_IMMEDIATE_START;
+
+         int r, i = 0, errnoSave;
+         // Is this loop really nessesary any more.
+         // In earllier Versions the driver returns with EBUSY sometimes
+         do {
+            if ((r = ioctl(fd_playDemux[0],DMX_SET_PES_FILTER, &pesFilterParams)) < 0) {
+               errnoSave = errno;
+               CHECK(r);
+               cCondWait::SleepMs(3);
+               }
+            else
+               errnoSave = 0;
+            i++;
+            } while (errnoSave == EBUSY & i <= 100);
+
+         if (errnoSave) {
+            close(fd_playDemux[0]);
+            fd_playDemux[0] = -1;
+            close(fd_playDvr);
+            fd_playDvr = -1;
+            return false;
             }
-         else
-            replayer->Reset();
-         break;
+
+         if (fd_playDemux[1] >= 0)
+            close(fd_playDemux[1]);
+         fd_playDemux[1] = -1;
+         playAudioId = 0;
+         playTrickSpeed = false;
+         playBufferFill = 0;
+         CHECK(ioctl(fd_audio, AUDIO_SET_AV_SYNC, PlayMode == pmAudioVideo));
+         CHECK(ioctl(fd_video,VIDEO_PLAY,0));
+         CHECK(ioctl(fd_audio,AUDIO_PLAY,0));
+
+         break; }
     case pmAudioOnly:
-    case pmVideoOnly:
+    case pmAudioOnlyBlack:
          if (tsreplayer != NULL) {
             delete tsreplayer;
             tsreplayer=NULL;
@@ -4507,18 +3330,26 @@
 
          CHECK(ioctl(fd_audio, AUDIO_STOP,0));
          CHECK(ioctl(fd_video, VIDEO_STOP, 1));
-         if (replayer == NULL){
-            replayer = new c7x0Replayer(this);
-            }
-         else
-            replayer->Reset();
+         isyslog("Audio only play modes not yet implemented");
+         return false;
          break;
     case pmTsAudioVideo:
     case pmTsAudioOnlyBlack:
-         if (replayer != NULL) {
-            delete replayer;
-            replayer=NULL;
-         }
+         if (fd_playDemux[1] >= 0) {
+            CHECK(ioctl(fd_playDemux[1], DMX_STOP,1));
+            close(fd_playDemux[1]);
+            fd_playDemux[1] = -1;
+            playAudioId = 0;
+            }
+         if (fd_playDemux[0] >= 0) {
+            CHECK(ioctl(fd_playDemux[0], DMX_STOP,1));
+            close(fd_playDemux[0]);
+            fd_playDemux[0] = -1;
+            }
+         if (fd_playDvr >= 0) {
+            close(fd_playDvr);
+            fd_playDvr = -1;
+            }
          DoBlank = !tsreplayer &&
            (!pidHandles[cDevice::ptVideo].pid && PlayMode == pmTsAudioVideo ||
             pidHandles[cDevice::ptVideo].pid && PlayMode != pmTsAudioVideo);
@@ -4533,10 +3364,21 @@
          break;
     case pmTsAudioOnly:
     case pmTsVideoOnly:
-         if (replayer != NULL) {
-            delete replayer;
-            replayer=NULL;
-         }
+         if (fd_playDemux[1] >= 0) {
+            CHECK(ioctl(fd_playDemux[1], DMX_STOP,1));
+            close(fd_playDemux[1]);
+            fd_playDemux[1] = -1;
+            playAudioId = 0;
+            }
+         if (fd_playDemux[0] >= 0) {
+            CHECK(ioctl(fd_playDemux[0], DMX_STOP,1));
+            close(fd_playDemux[0]);
+            fd_playDemux[0] = -1;
+            }
+         if (fd_playDvr >= 0) {
+            close(fd_playDvr);
+            fd_playDvr = -1;
+            }
          CHECK(ioctl(fd_audio, AUDIO_STOP,0));
          CHECK(ioctl(fd_video, VIDEO_STOP, 1));
          if (tsreplayer == NULL){
@@ -4579,16 +3421,39 @@
 
 void cDvbDevice::TrickSpeed(int Speed, bool UseFastForward)
 {
-  if (replayer != NULL)
-     replayer->TrickSpeed(Speed,UseFastForward);
-  else if (tsreplayer != NULL)
+  if (tsreplayer != NULL) {
      tsreplayer->TrickSpeed(Speed,UseFastForward);
+     return;
+     }
+
+  if (playMode != pmAudioVideo & playMode != pmVideoOnly)
+     return;
+  dsyslog("TrickSpeed called Speed %d %d!",Speed, UseFastForward);
+  CHECK(ioctl(fd_audio, AUDIO_SET_MUTE, true));
+  CHECK(ioctl(fd_audio, AUDIO_STOP,0));
+  CHECK(ioctl(fd_video, VIDEO_STOP,0));
+  if (Speed > 1)
+     CHECK(ioctl(fd_video, VIDEO_SLOWMOTION, Speed << 1))
+  else
+     CHECK(ioctl(fd_video, VIDEO_FAST_FORWARD, 1))
+  playTrickSpeed = true;
+  playBufferFill = 0;
 }
 
 void cDvbDevice::Clear(void)
 {
-  if (replayer != NULL)
-     replayer->Clear();
+  if (playMode == pmAudioVideo | playMode == pmVideoOnly) {
+     dsyslog("cDvbDevice::Clear(void) called!");
+     CHECK(ioctl(fd_audio, AUDIO_SET_MUTE, true));
+     CHECK(ioctl(fd_audio, AUDIO_STOP,0));
+     CHECK(ioctl(fd_video, VIDEO_STOP,0));
+     CHECK(ioctl(fd_audio, AUDIO_SET_AV_SYNC, playMode == pmAudioVideo));
+     CHECK(ioctl(fd_video, VIDEO_PLAY,0));
+     CHECK(ioctl(fd_audio, AUDIO_PLAY,0));
+     CHECK(ioctl(fd_audio, AUDIO_SET_MUTE, false));
+     playBufferFill = 0;
+     playAudioId = 0;
+     }
   else if (tsreplayer != NULL)
      tsreplayer->Clear();
   cDevice::Clear();
@@ -4596,56 +3461,33 @@
 
 void cDvbDevice::Play(void)
 {
-  if (replayer != NULL)
-     replayer->Play();
+  if (playMode < pmTsAudioVideo) {
+     dsyslog("cDvbDevice::Play(void) called!");
+     CHECK(ioctl(fd_audio, AUDIO_STOP,0));
+     CHECK(ioctl(fd_video, VIDEO_STOP,0));
+     CHECK(ioctl(fd_audio, AUDIO_SET_AV_SYNC, playMode == pmAudioVideo));
+     CHECK(ioctl(fd_video, VIDEO_PLAY,0));
+     CHECK(ioctl(fd_audio, AUDIO_PLAY,0));
+     CHECK(ioctl(fd_audio, AUDIO_SET_MUTE, false));
+     playTrickSpeed = false;
+     playBufferFill = 0;
+     playAudioId = 0;
+     }
   else if (tsreplayer != NULL)
      tsreplayer->Play();
-#if 0
-  CHECK(ioctl(fd_video, VIDEO_STOP, 0));
-  CHECK(ioctl(fd_audio, AUDIO_STOP, 0));
-  CHECK(ioctl(fd_audio, AUDIO_SET_MUTE, false));
-  if (replayer != NULL)
-     replayer->Play();
-  if (playMode == pmAudioOnly || playMode == pmAudioOnlyBlack) {
-     if (fd_audio >= 0)
-        CHECK(ioctl(fd_audio, AUDIO_CONTINUE));
-     }
-  else {
-     if (fd_audio >= 0) {
-        CHECK(ioctl(fd_audio, AUDIO_SET_AV_SYNC, true));
-        CHECK(ioctl(fd_audio, AUDIO_PLAY,0));
-        }
-     if (fd_video >= 0)
-        CHECK(ioctl(fd_video, VIDEO_PLAY,0));
-     }
-#endif
   cDevice::Play();
 }
 
 void cDvbDevice::Freeze(void)
 {
-  if (replayer != NULL)
-     replayer->Freeze();
-  else if (tsreplayer != NULL)
-     tsreplayer->Freeze();
-#if 0
-  if (playMode == pmAudioOnly || playMode == pmAudioOnlyBlack) {
-     if (fd_audio >= 0)
-        CHECK(ioctl(fd_audio, AUDIO_PAUSE));
-     }
-
-  if (replayer != NULL)
-     replayer->Freeze();
-#ifndef REPLAY_BUFFER_RUNOUT_ON_FREEZE
-  CHECK(ioctl(fd_audio, AUDIO_SET_MUTE, true));
-  if (fd_audio >= 0){
+  if (playMode < pmTsAudioVideo) {
+     dsyslog("cDvbDevice::Freeze(void) called!");
+     CHECK(ioctl(fd_audio, AUDIO_SET_MUTE, true));
      CHECK(ioctl(fd_audio, AUDIO_STOP,0));
-     }
-  if (fd_video >= 0) {
      CHECK(ioctl(fd_video, VIDEO_STOP,0));
      }
-#endif
-#endif
+  else if (tsreplayer != NULL)
+     tsreplayer->Freeze();
   cDevice::Freeze();
 }
 
@@ -4737,33 +3579,20 @@
 
 bool cDvbDevice::Poll(cPoller &Poller, int TimeoutMs)
 {
-  if (replayer!=NULL)
-     return replayer->Poll(Poller, TimeoutMs);
-  else if (tsreplayer!=NULL)
+  if (tsreplayer!=NULL)
      return tsreplayer->Poll(Poller, TimeoutMs);
-  return false;
+  return true;
 }
 
 bool cDvbDevice::Flush(int TimeoutMs)
 {
   //TODO actually this function should wait until all buffered data has been processed by the card, but how?
-  if (replayer!=NULL)
-     return replayer->Flush(TimeoutMs);
-  else if (tsreplayer!=NULL)
+  if (tsreplayer!=NULL)
      return tsreplayer->Flush(TimeoutMs);
+  dsyslog("cDvbDevice::Flush called");
   return true;
 }
 
-int cDvbDevice::PlayPes(const uchar *Data, int Length, bool VideoOnly)
-{
-  // cMutexLock MutexLock(&mutexCurrentAudioTrack);
-  if (replayer!=NULL)
-     return replayer->PlayPes(Data,Length,VideoOnly);
-
-	esyslog("PlayPes called without replayer");
-	return -1;
-}
-
 int cDvbDevice::PlayTs(const uchar *Data, int Length)
 {
   // cMutexLock MutexLock(&mutexCurrentAudioTrack);
@@ -4789,16 +3618,209 @@
   esyslog("GetTsReplayVideoPid called without replayer");
   return 0;
 }
+
+int cDvbDevice::PESPayload(const uchar *Data, int Length,
+  int &TSOffset, int &TSLength)
+{
+  static int mpeg2_pts_dts_offset[4] = { 0, 0, 9, 9 };
+  static int pts_dts_length[4] = { 0, 0, 5, 10 };
+  if ((Data[6] & 0xC0) == 0x80) { // MPEG2
+    int dts_pts_fl = Data[7] >> 6;
+    TSOffset = mpeg2_pts_dts_offset[dts_pts_fl];
+    TSLength = pts_dts_length[dts_pts_fl];
+    return 9 + Data[8];
+  }
+  //MPEG 1
+  int payl = 6;
+  while (payl < Length && Data[payl] == 0xFF)
+        payl++;
+  if (payl < Length && (Data[payl] & 0xC0) == 0x40)
+     payl++;
+
+  if (payl >= Length) {
+     esyslog("ERROR: Invalid MPEG1 PES Header!");
+     return payl;
+     }
+  int dts_pts_fl = (Data[payl] & 0x30) >> 4;
+  TSOffset = payl;
+  TSLength = pts_dts_length[dts_pts_fl];
+  payl += TSLength;
+  if (!TSLength)
+     payl++;
+  return payl;
+}
+
+void cDvbDevice::PESPacket2TS(const uchar *Data, int Length, int Pid, int &CCounter)
+{
+  static uchar dts_pts_fl[11] =
+    { 0, 0, 0, 0, 0, 0x80, 0, 0, 0, 0, 0xC0 };
+  int payload_offset;
+  int ts_offset;
+  int ts_length;
+  const uchar *ts_start;
+  const uchar *data_start;
+  int cc = CCounter;
+  payload_offset = PESPayload(Data,Length,ts_offset,ts_length);
+  playBufferFill = 0;
+  data_start = Data;
+  ts_start = Data + ts_offset;
+  Data += payload_offset;
+  Length -= payload_offset;
+  if (Length <= 0)
+     return;
+  uchar *p = playBuffer;
+  p[0] = 0x47;
+  p[1] = 0x40;
+  p[2] = Pid;
+  p[3] = 0x10 | (cc & 0xf);
+  cc++;
+  int rest = 184 - 9 - ts_length;
+  p+=4;
+  if (Length < rest) {
+     p[-1] = p[-1] | 0x30;
+     p[0] = 183 - (Length + 9 + ts_length);
+     p[1] = 0;
+     memset(p + 2, 0xff, 182);
+     p += 1 + p[0];
+     rest = Length;
+  }
+  put_unaligned(get_unaligned((uint32_t *)data_start),(uint32_t *)p);
+  put_unaligned(HOST2BE(uint16_t(Length + 3 + ts_length)), (uint16_t *)(p + 4));
+  p[6] = 0x80;
+  p[7] = dts_pts_fl[ts_length];
+  p[8] = ts_length;
+  p += 9;
+  memcpy(p, ts_start, ts_length);
+  p += ts_length;
+  memcpy(p,Data,rest);
+  p += rest;
+  Data += rest;
+  Length -= rest;
+  int out_length = 188;
+
+  while (Length >= 184) {
+        p[0] = 0x47;
+        p[1] = 0;
+        p[2] = Pid;
+        p[3] = 0x10 | (cc & 0xf);
+        cc++;
+        memcpy(p + 4 , Data, 184);
+        Length -= 184;
+        Data += 184;
+        p += 188;
+        out_length += 188;
+        }
+
+  if (Length > 0) {
+     p[0] = 0x47;
+     p[1] = 0;
+     p[2] = Pid;
+     p[3] = 0x30 | (cc & 0xf);
+     cc++;
+     p[4] = 183 - Length;
+     p[5] = 0;
+     memset(p + 6, 0xff, 182);
+     p += 5 + p[4];
+     memcpy(p, Data, Length);
+     out_length += 188;
+     }
+  CCounter = cc;
+  playBufferFill = out_length;
+}
+
 int cDvbDevice::PlayVideo(const uchar *Data, int Length)
 {
-	esyslog("PlayVideo should not be called any more");
- 	return -1;
+  if (!playTrickSpeed) {
+     PESPacket2TS(Data, Length, 0xef, playTsCcounter[0]);
+     int r = safe_write(fd_playDvr, playBuffer, playBufferFill);
+     return r >= 0 ? Length : r;
+     }
+
+  int t1, t2;
+  int pay_off = PESPayload(Data,Length,t1,t2);
+  int pay_length = Length - pay_off;
+  const uchar *p = Data + pay_off;
+  if ((p[0] | p[1] | (p[2] - 1)) == 0 &
+        (p[3] == 0x00 | p[3] == 0xB3 | p[3] == 0xB8)) {
+     if (playBufferFill > 0) {
+        int r = safe_write(fd_video, playBuffer, playBufferFill);
+        if (r < 0)
+           return r;
+        }
+     *((uint32_t *) playBuffer) = 0;
+     playBufferFill = 4;
+  }
+
+  if (playBufferFill + pay_length > KILOBYTE(256)) {
+     esyslog("ERROR: Play buffer size exceeded in trick speed play."
+             " Recording corrupt?");
+     int bite = KILOBYTE(256) - playBufferFill;
+     memcpy(playBuffer + playBufferFill, p, bite);
+     int r = safe_write(fd_video, playBuffer, KILOBYTE(256));
+     if (r < 0)
+        return r;
+     p += bite;
+     pay_length -= bite;
+     playBufferFill = 0;
+     }
+
+  memcpy(playBuffer + playBufferFill, p, pay_length);
+  playBufferFill += pay_length;
+  return Length;
 }
 
 int cDvbDevice::PlayAudio(const uchar *Data, int Length, uchar Id)
 {
-  esyslog("PlayAudio should not be called any more");
- return -1;
+  if (playMode == pmAudioVideo) {
+     if (Id != playAudioId) {
+        dsyslog("Setting audio channel");
+        CHECK(ioctl(fd_audio,AUDIO_STOP,0));
+        CHECK(ioctl(fd_video,VIDEO_STOP,0));
+        if (fd_playDemux[1] < 0) {
+           fd_playDemux[1] = DvbOpen(DEV_DVB_ADAPTER DEV_DVB_DEMUX, 0, O_RDWR | O_NONBLOCK, true);
+           if (fd_playDemux[1] < 0)
+              return -1;
+           }
+
+        dmx_pes_filter_params pesFilterParams;
+        memset(&pesFilterParams, 0, sizeof(pesFilterParams));
+
+        // Uglly the driver needs setting exacty this Value
+        // Yet another BUG in m7x0-drivers
+        CHECK(ioctl(fd_playDemux[1], DMX_SET_BUFFER_SIZE,0x1E000));
+        pesFilterParams.pid      = Id;
+        playTsCcounter[1]        = 0;
+        playAudioId              = Id;
+        pesFilterParams.input    = DMX_IN_DVR;
+        pesFilterParams.output   = ((Id & 0xF0) == 0x80 | Id == 0xBD) ?
+                                   DMX_OUT_DECODER1 : DMX_OUT_DECODER0;
+        pesFilterParams.pes_type = DMX_PES_AUDIO;
+        pesFilterParams.flags    = DMX_IMMEDIATE_START;
+
+        int i = 0; int r; int errnoSave;
+        do {
+           if ((r = ioctl(fd_playDemux[1],DMX_SET_PES_FILTER, &pesFilterParams)) < 0) {
+              errnoSave = errno;
+              CHECK(r);
+              cCondWait::SleepMs(3);
+              }
+           else
+              errnoSave = 0;
+           i++;
+           } while (errnoSave == EBUSY & i <= 100);
+
+        if (errnoSave)
+           return -1;
+        CHECK(ioctl(fd_audio, AUDIO_SET_AV_SYNC, playMode == pmAudioVideo));
+        CHECK(ioctl(fd_video, VIDEO_PLAY,0));
+        CHECK(ioctl(fd_audio,AUDIO_PLAY,0));
+        }
+     PESPacket2TS(Data, Length, Id, playTsCcounter[1]);
+     int r = safe_write(fd_playDvr, playBuffer, playBufferFill);
+     return r >= 0 ? Length : r;
+     }
+  esyslog("Audio only play modes not yet implemented");
+  return -1;
 }
 
 
diff -Naur VDR-NG-EM-orig/dvbdevice.h VDR-NG-EM/dvbdevice.h
--- VDR-NG-EM-orig/dvbdevice.h	2008-03-23 12:51:50.000000000 +0100
+++ VDR-NG-EM/dvbdevice.h	2008-03-29 12:06:03.000000000 +0100
@@ -29,7 +29,6 @@
 class cDvbTuner;
 //M7X0 BEGIN AK
 class c7x0TSBuffer;
-class c7x0Replayer;
 class c7x0TsReplayer;
 //M7X0 END AK
 /// The cDvbDevice implements a DVB device which can be accessed through the Linux DVB driver API.
@@ -152,8 +151,17 @@
 // Player facilities
 
 private:
-  friend class c7x0Replayer;
-  c7x0Replayer *replayer;
+  int fd_playDvr;
+  int fd_playDemux[2];
+  int playTsCcounter[2];
+  int playAudioId;
+  bool playTrickSpeed;
+  // On PES packet can at max have 67116 Bytes in MPEG-TS
+  // For Trickspeed limit buffering of _one_ frame to 256KB
+  uchar playBuffer[KILOBYTE(256)];
+  int playBufferFill;
+  int PESPayload(const uchar *Data, int Length, int &TSOffset, int &TSLength);
+  void PESPacket2TS(const uchar *Data, int Length, int Pid, int &CCounter);
   friend class c7x0TsReplayer;
   c7x0TsReplayer *tsreplayer;
 //M7X0 END AK
@@ -166,7 +174,6 @@
 public:
   virtual int64_t GetSTC(void);
 //M7X0 BEGIN AK
-  virtual int PlayPes(const uchar *Data, int Length, bool VideoOnly);
   virtual int PlayTs(const uchar *Data, int Length);
   virtual void SetTsReplayPids(int pmtPid, int videoPid);
   virtual int GetTsReplayVideoPid(void);
